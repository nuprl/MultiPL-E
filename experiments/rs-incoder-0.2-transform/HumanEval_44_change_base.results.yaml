language: rs
name: HumanEval_44_change_base
results:
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut power = 1;\n    let mut i = 0;\n    while i < digits.len() {\n   \
    \     if digits[i] > base {\n            power = power * base;\n            digits.remove(i,\
    \ 1);\n        } else {\n            power = power * digits[i];\n        }\n \
    \       i += 1;\n    }\n    s += power.to_string();\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeup0txf6.rs:17:12\n\
    \   |\n17 |         if digits[i] > base {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: cannot multiply `{integer}` by `String`\n  --> /tmp/tmpeup0txf6.rs:18:27\n\
    \   |\n18 |             power = power * base;\n   |                          \
    \ ^ no implementation for `{integer} * String`\n   |\n   = help: the trait `Mul<String>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0061]: this function takes 1 argument but 2\
    \ arguments were supplied\n    --> /tmp/tmpeup0txf6.rs:19:20\n     |\n19   | \
    \            digits.remove(i, 1);\n     |                    ^^^^^^ -  - supplied\
    \ 2 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeup0txf6.rs:21:29\n\
    \   |\n21 |             power = power * digits[i];\n   |                     \
    \        ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String "
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let digit = quotient % base;\n        remainder = quotient / base;\n\
    \        s = format!(\"{}{}\", s, digit);\n        quotient = remainder;\n   \
    \ }\n    if remainder > 0 {\n        s = format!(\"{}\", s);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpn1zawkeo.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp2_e8gydy.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \    let mut base = base.to_string().chars().collect::<Vec<_>>();\n    while digits.len()\
    \ > 0 {\n        let mut digit = digits.remove(0);\n        remainder += digit\
    \ as isize;\n        if base > 1 {\n            digit *= base;\n        }\n  \
    \      s += digit.to_string();\n    }\n    if remainder > 0 {\n        s += \"\
    0\".to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbj7uc_4n.rs:18:19\n   |\n\
    18 |         if base > 1 {\n   |                   ^ expected struct `Vec`, found\
    \ integer\n   |\n   = note: expected struct `Vec<char>`\n                found\
    \ type `{integer}`\n\nerror[E0368]: binary assignment operation `*=` cannot be\
    \ applied to type `char`\n  --> /tmp/tmpbj7uc_4n.rs:19:13\n   |\n19 |        \
    \     digit *= base;\n   |             -----^^^^^^^^\n   |             |\n   |\
    \             cannot use `*=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbj7uc_4n.rs:21:14\n   |\n21 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbj7uc_4n.rs:24:14\n\
    \   |\n24 |         s += \"0\".to_string();\n   |              ^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&\"0\".to_string()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    s.push_str(&format!(\"{}\", remainder));\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp_0624t1e.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    let mut i = 0;\n    while i < digits.size() {\n        let mut digit = digits[i];\n\
    \        let mut base = base[i];\n        if digit == 0 {\n            digit =\
    \ carry;\n            base = base + 1;\n        }\n        digit = digit - base;\n\
    \        digit = digit / 10;\n        digit = digit + carry + 1;\n        digit\
    \ = digit % 10;\n        carry = digit / 10;\n        digit = digit % 10;\n  \
    \      digits[i] = digit;\n        s[i] = digit.to_string();\n        i += 1;\n\
    \    }\n    if carry > 0 {\n        s.push(carry.to_string());\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp_v9h9k7z.rs:16:22\n   |\n16 |     while i < digits.size()\
    \ {\n   |                      ^^^^ help: there is an associated function with\
    \ a similar name: `resize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_v9h9k7z.rs:19:21\n\
    \   |\n19 |         if digit == 0 {\n   |                     ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_v9h9k7z.rs:20:21\n\
    \   |\n17 |         let mut digit = digits[i];\n   |                         ---------\
    \ expected due to this value\n...\n20 |             digit = carry;\n   |     \
    \                ^^^^^ expected `char`, found integer\n\nerror[E0369]: cannot\
    \ add `{integer}` to `char`\n  --> /tmp/tmp_v9h9k7z.rs:21:25\n   |\n21 |     \
    \        base = base + 1;\n   |                    ---- ^ - {integer}\n   |  \
    \                  |\n   |                    char\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmp_v9h9k7z.rs:23:23\n   |\n23 |         digit\
    \ = digit - base;\n   |                 ----- ^ ---- char\n   |              \
    \   |\n   |                 char\n\nerror[E0369]: cannot divide `char` by `{integer}`\n\
    \  --> /tmp/tmp_v9h9k7z.rs:24:23\n   |\n24 |         digit = digit / 10;\n   |\
    \                 ----- ^ -- {integer}\n   |                 |\n   |         \
    \        char\n\nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmp_v9h9k7z.rs:25:23\n\
    \   |\n25 |         digit = digit + carry + 1;\n   |                 ----- ^ -----\
    \ {integer}\n   |                 |\n   |                 char\n\nerror[E0369]:\
    \ cannot mod `char` by `{integer}`\n  --> /tmp/tmp_v9h9k7z.rs:26:23\n   |\n26\
    \ |         digit = digit % 10;\n   |                 ----- ^ -- {integer}\n \
    \  |                 |\n   |                 char\n\nerror[E0369]: cannot divide\
    \ `char` by `{integer}`\n  --> /tmp/tmp_v9h9k7z.rs:27:23\n   |\n27 |         carry\
    \ = digit / 10;\n   |                 ----- ^ -- {integer}\n   |             \
    \    |\n   |                 char\n\nerror[E0369]: cannot mod `char` by `{integer}`\n\
    \  --> /tmp/tmp_v9h9k7z.rs:28:23\n   |\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x.to_digits();\n    let mut base = base.to_digits();\n    while\
    \ x.len() > 0 {\n        let mut digit = x.pop().unwrap();\n        if digit >\
    \ base {\n            digit -= base;\n            s.push('0');\n        }\n  \
    \      s.push((digit as char).to_string());\n    }\n    String::from(s)\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpo2ohrr3j.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpo2ohrr3j.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo2ohrr3j.rs:20:16\n   |\n20 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder *= base;\n        remainder %= base;\n        quotient\
    \ /= base;\n        s.push((quotient as u32).to_string());\n    }\n    s.push((remainder\
    \ as u32).to_string());\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp91jh_zz7.rs:18:16\n   |\n\
    18 |         s.push((quotient as u32).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp91jh_zz7.rs:20:12\n   |\n20 |     s.push((remainder as u32).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ base = base;\n    while remainder > 0 {\n        remainder %= base;\n      \
    \  digits.push(char::from_u32(base).unwrap());\n        base /= base;\n    }\n\
    \    digits.push(char::from_u32(base).unwrap());\n    s += digits.into_owned();\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc3uf3e3s.rs:17:36\n   |\n\
    17 |         digits.push(char::from_u32(base).unwrap());\n   |               \
    \                     ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `u32` and panic if the converted value doesn't fit\n\
    \   |\n17 |         digits.push(char::from_u32(base.try_into().unwrap()).unwrap());\n\
    \   |                                        ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc3uf3e3s.rs:20:32\n   |\n20 |     digits.push(char::from_u32(base).unwrap());\n\
    \   |                                ^^^^ expected `u32`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `u32` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     digits.push(char::from_u32(base.try_into().unwrap()).unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpc3uf3e3s.rs:21:17\n   |\n21 |     s += digits.into_owned();\n \
    \  |                 ^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s.push(remainder);\n    }\n    s.push(remainder);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:17:16\n   |\n\
    17 |         s.push(remainder);\n   |                ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:19:12\n\
    \   |\n19 |     s.push(remainder);\n   |            ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x.to_digits();\n    let mut base = base.to_digits();\n    while\
    \ x.len() > 0 {\n        let mut digit = x.remove(0);\n        let mut base =\
    \ base.remove(0);\n        if base > 10 {\n            digit = digit.to_digits()\
    \ + 1;\n            base = base.to_digits() + 1;\n        }\n        s += digit.to_string()\
    \ + base.to_string();\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpg9ty38e1.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpg9ty38e1.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; base];\n    let mut carry = 0;\n    while x >=\
    \ base {\n        let digit = x % base;\n        digits[digit] += 1;\n       \
    \ x /= base;\n        carry += 1;\n    }\n    if carry > 0 {\n        digits[digit]\
    \ += 1;\n    }\n    for digit in digits.iter().rev() {\n        s += char::from_u32(digit\
    \ as u32).unwrap();\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpbw7kp2_u.rs:21:16\n\
    \   |\n21 |         digits[digit] += 1;\n   |                ^^^^^ help: a local\
    \ variable with a similar name exists: `digits`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbw7kp2_u.rs:12:32\n   |\n12 |     let mut digits = vec![0u8; base];\n\
    \   |                                ^^^^ expected `usize`, found `isize`\n  \
    \ |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n12 |     let mut digits = vec![0u8; base.try_into().unwrap()];\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0277]:\
    \ the type `[u8]` cannot be indexed by `isize`\n  --> /tmp/tmpbw7kp2_u.rs:16:9\n\
    \   |\n16 |         digits[digit] += 1;\n   |         ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<u8>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbw7kp2_u.rs:24:14\n\
    \   |\n24 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error[E0606]: casting `&u8` as `u32` is invalid\n  --> /tmp/tmpbw7kp2_u.rs:24:29\n\
    \   |\n24 |         s += char::from_u32(digit as u32).unwrap();\n   |        \
    \                     -----^^^^^^^\n   |                             |\n   | \
    \                            cannot cast `&u8` as `u32`\n   |                \
    \             help: dereference the expression: `*digit`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0425, E0606.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder /= base;\n        result.push(remainder.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder /= base;\n        result.push(remainder.to_string());\n\
    \    }\n    if remainder > 0 {\n        result.push(remainder.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5smp5qdy.rs:16:21\n   |\n\
    16 |         result.push(remainder.to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp5smp5qdy.rs:20:21\n   |\n20 |         result.push(remainder.to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5smp5qdy.rs:23:21\n\
    \   |\n23 |         result.push(remainder.to_string());\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    while digits_len > base_len {\n        digits = digits.chars().nth(digits_len\
    \ - base_len + 1).collect();\n        base = base.chars().nth(base_len).collect();\n\
    \        base_len += 1;\n    }\n    while base_len > digits_len {\n        digits\
    \ = digits.chars().nth(digits_len - base_len + 1).collect();\n        base = base.chars().nth(base_len).collect();\n\
    \        base_len -= 1;\n    }\n    while digits_len > 0 {\n        if digits[digits_len\
    \ - 1] == '0' {\n            digits = digits.chars().nth(digits_len - 1).collect();\n\
    \            digits_len -= 1;\n        } else {\n            break;\n        }\n\
    \    }\n    while base_len > 0 {\n        if base[base_len - 1] == '0' {\n   \
    \         base = base.chars().nth(base_len - 1).collect();\n            base_len\
    \ -= 1;\n        } else {\n            break;\n        }\n    }\n    while digits_len\
    \ > 0 {\n        if digits[digits_len - 1] == '0' {\n            digits = digits.chars().nth(digits_len\
    \ - 1).collect();\n            digits_len -= 1;\n        } else {\n          \
    \  break;\n        }\n    }\n    while base_len > 0 {\n        if base[base_len\
    \ - 1] == '0' {\n            base = base.chars().nth(base_len - 1).collect();\n\
    \            base_len -= 1;\n        } else {\n            break;\n        }\n\
    \    }\n    while digits_len > 0 {\n        if digits[digits_len - 1] == '0' {\n\
    \            digits = digits.chars().nth(digits_len - 1).collect();\n        \
    \    digits_len -= 1;\n        } else {\n            break;\n        }\n    }\n\
    \    while base_len > 0 {\n        if base[base_len - 1] == '0' {\n          \
    \  base = base.chars().nth(base_len - 1).collect();\n            base_len -= 1;\n\
    \        } else {\n            break;\n        }\n    }\n    while digits_len\
    \ > 0 {\n        if digits[digits_len - 1] == '0' {\n            digits = digits.chars().nth(digits_len\
    \ - 1).collect();\n            digits_len -= 1;\n        } else {\n          \
    \  break;\n        }\n    }\n    while base_len > 0 {\n        if base[base_len\
    \ - 1] == '0' {\n            base = base.chars().nth(base_len - 1).collect();\n\
    \            base_len -= 1;\n        } else {\n            break;\n        }\n\
    \    }\n    while digits_len > 0 {\n        if digit\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpoecan5lq.rs:108:3\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n90  |  \
    \   while digits_len > 0 {\n    |                          - this delimiter might\
    \ not be properly closed...\n91  |         if digit\n92  | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n108 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n  --> /tmp/tmpoecan5lq.rs:92:1\n   |\n91 |        \
    \ if digit\n   |         -- this `if` expression has a condition, but no block\n\
    92 | }\n   | ^ expected `{`\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpoecan5lq.rs:14:33\n   |\n\
    14 |     let mut digits_len = digits.length();\n   |                         \
    \        ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpoecan5lq.rs:15:29\n   |\n15 |     let mut base_len = base.length();\n\
    \   |                             ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: `Option<char>` is not an iterator\n\
    \   --> /tmp/tmpoecan5lq.rs:17:64\n    |\n17  |           digits = digits.chars().nth(digits_len\
    \ - base_len + 1).collect();\n    |                                          \
    \                        ^^^^^^^ `Option<char>` is not an iterator\n    |\n  \
    \  = note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ Iterator`\n            which is required by `&mut Option<char>: Iterator`\n\n\
    error[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmpoecan5lq.rs:18:43\n\
    \    |\n18  |           base = base.chars().nth(base_len).collect();\n    |  \
    \                                           ^^^^^^^ `Option<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<char>: Iterator`\n            which is required by `&mut Option<char>:\
    \ Iterator`\n\nerror["
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        if base < 10 {\n   \
    \         s.push_str(&digits[i..i + 1]);\n            i += 1;\n        } else\
    \ {\n            s.push_str(&digits[i..i + base.len()]);\n            i += base.len();\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphcnvu7cr.rs:16:19\n   |\n\
    16 |         if base < 10 {\n   |                   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found integer\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    while bases.len() > 0 {\n        let mut digit = digits.chars().nth(bases.len()\
    \ - 1);\n        let mut base = bases.chars().nth(bases.len() - 1);\n        if\
    \ base == b'0' {\n            digit = digit.chars().nth(digit.len() - 1);\n  \
    \          base = base.chars().nth(base.len() - 1);\n        }\n        if digit\
    \ == b'0' {\n            digit = digit.chars().nth(digit.len() - 1);\n       \
    \     base = base.chars().nth(base.len() - 1);\n        }\n        if digit ==\
    \ b'1' {\n            digit = digit.chars().nth(digit.len() - 1);\n          \
    \  base = base.chars().nth(base.len() - 1);\n        }\n        if digit == b'2'\
    \ {\n            digit = digit.chars().nth(digit.len() - 1);\n            base\
    \ = base.chars().nth(base.len() - 1);\n        }\n        if digit == b'3' {\n\
    \            digit = digit.chars().nth(digit.len() - 1);\n            base = base.chars().nth(base.len()\
    \ - 1);\n        }\n        if digit == b'4' {\n            digit = digit.chars().nth(digit.len()\
    \ - 1);\n            base = base.chars().nth(base.len() - 1);\n        }\n   \
    \     if digit == b'5' {\n            digit = digit.chars().nth(digit.len() -\
    \ 1);\n            base = base.chars().nth(base.len() - 1);\n        }\n     \
    \   if digit == b'6' {\n            digit = digit.chars().nth(digit.len() - 1);\n\
    \            base = base.chars().nth(base.len() - 1);\n        }\n        if digit\
    \ == b'7' {\n            digit = digit.chars().nth(digit.len() - 1);\n       \
    \     base = base.chars().nth(base.len() - 1);\n        }\n        if digit ==\
    \ b'8' {\n            digit = digit.chars().nth(digit.len() - 1);\n          \
    \  base = base.chars().nth(base.len() - 1);\n        }\n        if digit == b'9'\
    \ {\n            digit = digit.chars().nth(digit.len() - 1);\n            base\
    \ = base.chars().nth(base.len() - 1);\n        }\n        if base == b'0' {\n\
    \            digit = digit.chars().nth(digit.len() - 1);\n            base = base.chars().nth(base.len()\
    \ - 1);\n        }\n        if base == b'1' {\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmj7qea84.rs:82:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ bases.len() > 0 {\n   |                           - unclosed delimiter\n...\n\
    65 |         if base == b'1' {\n   |                         - this delimiter\
    \ might not be properly closed...\n66 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n82 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmj7qea84.rs:17:20\n   |\n17 |         if base == b'0' {\n\
    \   |                    ^^^^ expected enum `Option`, found `u8`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found type `u8`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpmj7qea84.rs:18:27\n   |\n18 |             digit = digit.chars().nth(digit.len()\
    \ - 1);\n   |                           ^^^^^ method not found in `Option<char>`\n\
    \nerror[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpmj7qea84.rs:18:45\n   |\n18 |             digit = digit.chars().nth(digit.len()\
    \ - 1);\n   |                                             ^^^ method not found\
    \ in `Option<char>`\n\nerror[E0599]: no method named `chars` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpmj7qea84.rs:19:25\n   |\n19 |          \
    \   base = base.chars().nth(base.len() - 1);\n   |                         ^^^^^\
    \ method not found in `Option<char>`\n\nerror[E0599]: no method named `len` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpmj7qea84.rs:19:42\n  \
    \ |\n19 |             base = base.chars().nth(base.len() - 1);\n   |         \
    \                                 ^^^ method not found in `Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmj7qea84.rs:21:21\n   |\n21 |         if digit\
    \ == b'0' {\n   |                     ^^^^ expected enum `Option`, found `u8`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `u8`\n\
    \nerror[E0599]: no method named "
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ base.to_string());\n    }\n    s += digits;\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_qzimvw2.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ base.to_string());\n   |                          ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:22:10\n\
    \   |\n22 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base);\n    }\n\
    \    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ 1);\n    }\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfhq9n5ne.rs:16:26\n   |\n\
    16 |         digits.insert(0, base);\n   |                          ^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfhq9n5ne.rs:20:26\n\
    \   |\n20 |         digits.insert(0, 1);\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.remove(0);\n   \
    \     let mut new_digit = digit;\n        if base == 2 {\n            if carry\
    \ > 0 {\n                new_digit += &'0';\n            }\n            new_digit\
    \ += &'1';\n        }\n        if base == 8 {\n            if carry > 0 {\n  \
    \              new_digit += &'0';\n            }\n            new_digit += &'7';\n\
    \        }\n        if base == 16 {\n            if carry > 0 {\n            \
    \    new_digit += &'0';\n            }\n            new_digit += &'7';\n     \
    \       new_digit += &'1';\n        }\n        if base == 10 {\n            if\
    \ carry > 0 {\n                new_digit += &'0';\n            }\n           \
    \ new_digit += &'9';\n        }\n        if base == 16 {\n            if carry\
    \ > 0 {\n                new_digit += &'0';\n            }\n            new_digit\
    \ += &'9';\n            new_digit += &'1';\n        }\n        if base == 10 {\n\
    \            if carry > 0 {\n                new_digit += &'0';\n            }\n\
    \            new_digit += &'9';\n        }\n        if base == 8 {\n         \
    \   if carry > 0 {\n                new_digit += &'0';\n            }\n      \
    \      new_digit += &'7';\n        }\n        if base == 2 {\n            if carry\
    \ > 0 {\n                new_digit += &'0';\n            }\n            new_digit\
    \ += &'1';\n        }\n        if base == 10 {\n            if carry > 0 {\n \
    \               new_digit += &'0';\n            }\n            new_digit += &'9';\n\
    \        }\n        if base == 16 {\n            if carry > 0 {\n            \
    \    new_digit += &'0';\n            }\n            new_digit += &'9';\n     \
    \       new_digit += &'1';\n        }\n        if base == 8 {\n            if\
    \ carry > 0 {\n                new_digit += &'0';\n            }\n           \
    \ new_digit += &'7';\n        }\n        if base == 2 {\n            if carry\
    \ > 0 {\n                new_digit += &'0';\n            }\n            new_digit\
    \ += &'1';\n        }\n        if base == 10 {\n            if carry > 0 {\n \
    \               new_digit += &'0';\n            }\n            new_digit += &'9';\n\
    \        }\n        if \n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpaa5exvnn.rs:116:3\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n15  |  \
    \   while digits.len() > 0 {\n    |                            - this delimiter\
    \ might not be properly closed...\n...\n100 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n116 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpaa5exvnn.rs:100:1\n    |\n100 | }\n  \
    \  | ^ expected expression\n\nerror[E0277]: can't compare `Vec<char>` with `{integer}`\n\
    \  --> /tmp/tmpaa5exvnn.rs:18:17\n   |\n18 |         if base == 2 {\n   |    \
    \             ^^ no implementation for `Vec<char> == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `Vec<char>`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpaa5exvnn.rs:20:17\n   |\n20 |     \
    \            new_digit += &'0';\n   |                 ---------^^^^^^^^\n   |\
    \                 |\n   |                 cannot use `+=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpaa5exvnn.rs:22:13\n\
    \   |\n22 |             new_digit += &'1';\n   |             ---------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpaa5exvnn.rs:24:17\n\
    \   |\n24 |         if base == 8 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        if digit == '0' {\n            digit = digits.chars().nth(base.len()\
    \ - 2).unwrap();\n        }\n        base.truncate(base.len() - 1);\n        s\
    \ += digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1_eo_eo3.rs:20:14\n   |\n\
    20 |         s += digit;\n   |              ^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.remove(0);\n   \
    \     if base == 2 {\n            if carry > 0 {\n                digit += carry;\n\
    \                carry = 0;\n            }\n        }\n        if digit < base\
    \ {\n            digit += carry;\n            carry = 0;\n        }\n        if\
    \ digit > base {\n            digit -= base;\n            carry = 0;\n       \
    \ }\n        s += digit.to_string();\n    }\n    if carry > 0 {\n        s +=\
    \ &format!(\"{}\", carry).to_string();\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpdmvafsbj.rs:17:17\n\
    \   |\n17 |         if base == 2 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpdmvafsbj.rs:19:17\n\
    \   |\n19 |                 digit += carry;\n   |                 -----^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdmvafsbj.rs:23:20\n   |\n23 |\
    \         if digit < base {\n   |                    ^^^^ expected `char`, found\
    \ struct `Vec`\n   |\n   = note: expected type `char`\n            found struct\
    \ `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpdmvafsbj.rs:24:13\n   |\n24 |             digit\
    \ += carry;\n   |             -----^^^^^^^^^\n   |             |\n   |       \
    \      cannot use `+=` on type `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdmvafsbj.rs:27:20\n   |\n27 |         if digit > base {\n   |      \
    \              ^^^^ expected `char`, found struct `Vec`\n   |\n   = note: expected\
    \ type `char`\n            found struct `Vec<char>`\n\nerror[E0368]: binary assignment\
    \ operation `-=` cannot be applied to type `char`\n  --> /tmp/tmpdmvafsbj.rs:28:13\n\
    \   |\n28 |             digit -= base;\n   |             -----^^^^^^^^\n   | \
    \            |\n   |             cannot use `-=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdmvafsbj.rs:31:14\n   |\n31 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |             "
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while digits.len() > 0 {\n        let mut digit = digits.pop().unwrap();\n\
    \        if base == 10 {\n            s.push_str(&digit);\n        } else {\n\
    \            s.push_str(&digit + &base);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpr3ekbyab.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr3ekbyab.rs:17:24\n\
    \   |\n17 |             s.push_str(&digit);\n   |                        ^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0369]: cannot add `&String` to\
    \ `&char`\n  --> /tmp/tmpr3ekbyab.rs:19:31\n   |\n19 |             s.push_str(&digit\
    \ + &base);\n   |                        ------ ^ ----- &String\n   |        \
    \                |\n   |                        &char\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.pop().unwrap();\n \
    \       if base > 10 {\n            digit *= base;\n            digit = digit.to_string();\n\
    \        }\n        s += digit;\n        base /= 10;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6uihihpl.rs:16:19\n   |\n\
    16 |         if base > 10 {\n   |                   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found integer\n\nerror[E0368]: binary assignment operation\
    \ `*=` cannot be applied to type `char`\n  --> /tmp/tmp6uihihpl.rs:17:13\n   |\n\
    17 |             digit *= base;\n   |             -----^^^^^^^^\n   |        \
    \     |\n   |             cannot use `*=` on type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6uihihpl.rs:18:21\n   |\n15 |         let mut digit = digits.pop().unwrap();\n\
    \   |                         --------------------- expected due to this value\n\
    ...\n18 |             digit = digit.to_string();\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6uihihpl.rs:20:14\n   |\n20 |         s += digit;\n   |        \
    \      ^^^^^ expected `&str`, found `char`\n\nerror[E0368]: binary assignment\
    \ operation `/=` cannot be applied to type `String`\n  --> /tmp/tmp6uihihpl.rs:21:9\n\
    \   |\n21 |         base /= 10;\n   |         ----^^^^^^\n   |         |\n   |\
    \         cannot use `/=` on type `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        result = format!(\"{}{}\", digits, digit);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmpjtgabvuz.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        result = format!(\"{}{}\", digit, result);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let digit = digits.remove(0).unwrap();\n\
    \        let mut new_digit = digit as isize;\n        if carry > 0 {\n       \
    \     new_digit += carry;\n        }\n        base = base.iter().map(|&x| x as\
    \ isize).collect::<Vec<_>>();\n        digits = digits.iter().map(|&x| x as isize).collect::<Vec<_>>();\n\
    \        let mut new_base = base.iter().map(|&x| x as isize).collect::<Vec<_>>();\n\
    \        new_digit = new_digit as isize;\n        if new_digit > 9 {\n       \
    \     new_digit -= 10;\n            new_base += 1;\n        }\n        carry =\
    \ new_digit as isize - new_base;\n        s = s.push_str(&new_base.to_string());\n\
    \    }\n    if carry > 0 {\n        s = s.push_str(&carry.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprpkgkx3a.rs:16:38\n   |\n16 |         let digit = digits.remove(0).unwrap();\n\
    \   |                                      ^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprpkgkx3a.rs:21:16\n   |\n13 |\
    \     let mut base = base.to_string().chars().collect::<Vec<_>>();\n   |     \
    \               -------------------------------------------- expected due to this\
    \ value\n...\n21 |         base = base.iter().map(|&x| x as isize).collect::<Vec<_>>();\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `isize`\n   |\n   = note: expected struct `Vec<char>`\n      \
    \        found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpkgkx3a.rs:22:18\n\
    \   |\n12 |     let mut digits = x.to_string().chars().collect::<Vec<_>>();\n\
    \   |                      ----------------------------------------- expected\
    \ due to this value\n...\n22 |         digits = digits.iter().map(|&x| x as isize).collect::<Vec<_>>();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `isize`\n   |\n   = note: expected struct `Vec<char>`\n\
    \              found struct `Vec<isize>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `Vec<isize>`\n  --> /tmp/tmprpkgkx3a.rs:27:13\n\
    \   |\n27 |             new_base += 1;\n   |             --------^^^^^\n   | \
    \            |\n   |             cannot use `+=` on type `Vec<isize>`\n\nerror[E0277]:\
    \ cannot subtract `Vec<isize>` from `isize`\n  --> /tmp/tmprpkgkx3a.rs:29:36\n\
    \   |\n29 |         carry = new_digit as isize - new_base;\n   |             \
    \                       ^ no implementation for `isize - Vec<isize>`\n   |\n \
    \  = help: the trait `Sub<Vec<isize>>` is not implemented for `isize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i3"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient /= base;\n   \
    \     s.push((remainder as char).to_string());\n    }\n    s.push((quotient as\
    \ char).to_string());\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcjopq55r.rs:17:16\n   |\n\
    17 |         s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpcjopq55r.rs:19:12\n   |\n19 |     s.push((quotient as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  -->\
    \ /tmp/tmpcjopq55r.rs:17:16\n   |\n17 |         s.push((remainder as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpcjopq55r.rs:17:16\n   |\n17 |         s.push((remainder\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpcjopq55r.rs:19:12\n\
    \   |\n19 |     s.push((quotient as char).to_string());\n   |            ^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpcjopq55r.rs:19:12\n   |\n19 |     s.push((quotient as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.len() - 1);\n        let\
    \ digit = digit.to_digit(base);\n        remainder = digit * remainder;\n    \
    \    s = format!(\"{}{}\", s, digit);\n        digits = digits.chars().nth(digits.len()\
    \ - 1);\n    }\n    if remainder != 0 {\n        s = format!(\"{}\", remainder)\
    \ + s;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmp4wkryzas.rs:16:27\n   |\n16 |         let digit\
    \ = digit.to_digit(base);\n   |                           ^^^^^^^^ method not\
    \ found in `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4wkryzas.rs:19:18\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n19 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp4wkryzas.rs:22:40\n   |\n22 |         s = format!(\"{}\", remainder)\
    \ + s;\n   |                                        ^\n   |                  \
    \                      |\n   |                                        expected\
    \ `&str`, found struct `String`\n   |                                        help:\
    \ consider borrowing here: `&s`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i..].parse::<usize>().unwrap();\n\
    \        digit = digit.checked_mul(base).unwrap();\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        digit = digit.checked_add(&mut\
    \ i);\n        digit = digit.checked_add(&mut i);\n        \n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpllnylnno.rs:69:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ i < digits.len() {\n   |                            - this delimiter might not\
    \ be properly closed...\n...\n53 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n69 | }\n   |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllnylnno.rs:17:35\n   |\n17 |         digit = digit.checked_mul(base).unwrap();\n\
    \   |                                   ^^^^ expected `usize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpllnylnno.rs:18:35\n   |\n18 |\
    \         digit = digit.checked_add(&mut i);\n   |                           \
    \        ^^^^^^ expected `usize`, found `&mut usize`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n18 -         digit = digit.checked_add(&mut i);\n18 +    \
    \     digit = digit.checked_add(i);\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllnylnno.rs:18:17\n   |\n16 |         let mut digit = digits[i..].parse::<usize>().unwrap();\n\
    \   |                         ------------------------------------- expected due\
    \ to this value\n17 |         digit = digit.checked_mul(base).unwrap();\n18 |\
    \         digit = digit.checked_add(&mut i);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpllnylnno.rs:19:35\n   |\n19 |         digit = digit.checked_add(&mut\
    \ i);\n   |                                   ^^^^^^ expected `usize`, found `&mut\
    \ usize`\n   |\nhelp: consider removing the borrow\n   |\n19 -         digit =\
    \ digit.checked_add(&mut i);\n19 +         digit = digit.checked_add(i);\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpllnylnno.rs:19:17\n   |\n\
    16 |         let mut digit = digits[i..].parse::<usize>().unwrap();\n   |    \
    \                     ------------------------------------- expected due to this\
    \ value\n.."
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp56ely50k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s.push((base as char).to_string());\n\
    \        base /= 10;\n    }\n    s.push((base as char).to_string());\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppaw0fqt2.rs:16:16\n   |\n\
    16 |         s.push((base as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppaw0fqt2.rs:19:12\n   |\n19 |     s.push((base as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmppaw0fqt2.rs:16:16\n\
    \   |\n16 |         s.push((base as char).to_string());\n   |                ^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmppaw0fqt2.rs:16:16\n   |\n16 |         s.push((base as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `isize`\n  --> /tmp/tmppaw0fqt2.rs:19:12\n   |\n19 |     s.push((base\
    \ as char).to_string());\n   |            ^^^^^^^^^^^^^^ invalid cast\n   |\n\
    help: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmppaw0fqt2.rs:19:12\n\
    \   |\n19 |     s.push((base as char).to_string());\n   |            ^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpwbbte1wg.rs:17:32\n\
    \   |\n17 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as isize;\n    let mut base = base as isize;\n    while x >=\
    \ base {\n        s +=\n            format!(\"{:0{}b}\", x % base, base).to_string()\n\
    \                .chars()\n                .map(|c| match c {\n              \
    \      '0' => 0,\n                    '1' => 1,\n                    '2' => 2,\n\
    \                    '3' => 3,\n                    '4' => 4,\n              \
    \      '5' => 5,\n                    '6' => 6,\n                    '7' => 7,\n\
    \                    '8' => 8,\n                    '9' => 9,\n              \
    \      'a' => 10,\n                    'b' => 11,\n                    'c' =>\
    \ 12,\n                    'd' => 13,\n                    'e' => 14,\n      \
    \              'f' => 15,\n                    _ => unreachable!(),\n        \
    \        })\n                .collect::<Vec<_>>()\n                .join();\n\
    \        x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string()\n\
    \            .chars()\n            .map(|c| match c {\n                '0' =>\
    \ 0,\n                '1' => 1,\n                '2' => 2,\n                '3'\
    \ => 3,\n                '4' => 4,\n                '5' => 5,\n              \
    \  '6' => 6,\n                '7' => 7,\n                '8' => 8,\n         \
    \       '9' => 9,\n                'a' => 10,\n                'b' => 11,\n  \
    \              'c' => 12,\n                'd' => 13,\n                'e' =>\
    \ 14,\n                'f' => 15,\n                _ => unreachable!(),\n    \
    \        })\n            .collect::<Vec<_>>()\n            .join();\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpq8919feh.rs:16:25\n\
    \   |\n16 |             format!(\"{:0{}b}\", x % base, base).to_string()\n   |\
    \                      -  ^ expected `}` in format string\n   |              \
    \        |\n   |                      because of this opening brace\n   |\n  \
    \ = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpq8919feh.rs:42:21\n\
    \   |\n42 |         format!(\"{:0{}b}\", x, base).to_string()\n   |          \
    \        -  ^ expected `}` in format string\n   |                  |\n   |   \
    \               because of this opening brace\n   |\n   = note: if you intended\
    \ to print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    if quotient > 0 {\n\
    \        s = format!(\"{}\", s);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp5keu7rh4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        if digit == '0' {\n            digit = digits.chars().nth(base.len()\
    \ - 2);\n        }\n        base.truncate(base.len() - 1);\n        s += digit;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdui09fhj.rs:16:21\n   |\n\
    16 |         if digit == '0' {\n   |                     ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the expression in `Some`\n   |\n16 |       \
    \  if digit == Some('0') {\n   |                     +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdui09fhj.rs:20:14\n   |\n20 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found enum `Option`\n   |\n   = note:\
    \ expected reference `&str`\n                   found enum `Option<char>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s.push(remainder);\n    }\n    s.push(remainder);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:17:16\n   |\n\
    17 |         s.push(remainder);\n   |                ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:19:12\n\
    \   |\n19 |     s.push(remainder);\n   |            ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let digit = quotient % base;\n        remainder = remainder / base;\n\
    \        s = format!(\"{}{}\", digit, s);\n        quotient = quotient / base;\n\
    \    }\n    if remainder > 0 {\n        s = format!(\"{}\", s);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits = digit.to_string().to_string() + digits;\n    }\n \
    \   s = digits.to_string() + s;\n    s\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpag1_wedx.rs:17:50\n   |\n\
    17 |         digits = digit.to_string().to_string() + digits;\n   |          \
    \                                        ^^^^^^\n   |                        \
    \                          |\n   |                                           \
    \       expected `&str`, found struct `String`\n   |                         \
    \                         help: consider borrowing here: `&digits`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpag1_wedx.rs:19:30\n   |\n19 |     s = digits.to_string()\
    \ + s;\n   |                              ^\n   |                            \
    \  |\n   |                              expected `&str`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&s`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = base;\n    while remainder >\
    \ 0 {\n        if remainder >= digits {\n            s.push((remainder % digits).to_string());\n\
    \            remainder = remainder / digits;\n        } else {\n            s.push((digits).to_string());\n\
    \            remainder = remainder % digits;\n        }\n        digits /= base;\n\
    \    }\n    s.push((remainder).to_string());\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5i3l6jjf.rs:16:20\n   |\n\
    16 |             s.push((remainder % digits).to_string());\n   |             \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5i3l6jjf.rs:19:20\n   |\n19 |\
    \             s.push((digits).to_string());\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp5i3l6jjf.rs:24:12\n   |\n24 |     s.push((remainder).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpr09z52ob.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ basedigits = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry\
    \ = 0;\n    while basedigits.len() > 0 {\n        let mut digit = basedigits.pop().unwrap();\n\
    \        if carry > 0 {\n            digit += 1;\n        }\n        digits.push(digit);\n\
    \        carry = digit as isize - 1;\n    }\n    while digits.len() > 0 {\n  \
    \      let mut digit = digits.pop().unwrap();\n        if carry > 0 {\n      \
    \      digit += 1;\n        }\n        s += digit.to_string();\n        carry\
    \ = digit as isize - 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpapb3r3d2.rs:18:13\n   |\n18 |             digit += 1;\n\
    \   |             -----^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpapb3r3d2.rs:26:13\n   |\n26 |     \
    \        digit += 1;\n   |             -----^^^^^\n   |             |\n   |  \
    \           cannot use `+=` on type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpapb3r3d2.rs:28:14\n   |\n28 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut carry = 0;\n    while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.len()\
    \ - 1).unwrap();\n        let digit = digit.to_digit(base).unwrap();\n       \
    \ let digit = digit + carry;\n        carry = digit / 10;\n        digits = digits.chars().nth(digits.len()\
    \ - 1).unwrap();\n        s = format!(\"{}{}\", s, digit);\n    }\n    if carry\
    \ > 0 {\n        s = format!(\"{}{}\", s, carry);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppobrbr1k.rs:17:36\n   |\n\
    17 |         let digit = digit.to_digit(base).unwrap();\n   |                \
    \                    ^^^^ expected `u32`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppobrbr1k.rs:20:18\n   |\n12 |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n20 |         digits = digits.chars().nth(digits.len() - 1).unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                  |\n   |   \
    \               expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as isize;\n    let mut base = base as isize;\n    while x >=\
    \ base {\n        s += &format!(\"{}\", x % base);\n        x /= base;\n    }\n\
    \    s += &format!(\"{}\", x);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpv5_9zvfv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s += char::from_u32(base).unwrap();\n\
    \        base /= base;\n    }\n    s += char::from_u32(base).unwrap();\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppotnf6sz.rs:16:29\n   |\n\
    16 |         s += char::from_u32(base).unwrap();\n   |                       \
    \      ^^^^ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n16 |        \
    \ s += char::from_u32(base.try_into().unwrap()).unwrap();\n   |              \
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppotnf6sz.rs:16:14\n   |\n16 |         s += char::from_u32(base).unwrap();\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppotnf6sz.rs:19:25\n   |\n19 |\
    \     s += char::from_u32(base).unwrap();\n   |                         ^^^^ expected\
    \ `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32` and\
    \ panic if the converted value doesn't fit\n   |\n19 |     s += char::from_u32(base.try_into().unwrap()).unwrap();\n\
    \   |                             ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppotnf6sz.rs:19:10\n   |\n19 |     s += char::from_u32(base).unwrap();\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = base.to_string();\n\
    \    let mut i = 0;\n    while i < digits.length() {\n        let mut j = i;\n\
    \        while j < digits.length() && digits[j] == basedigits[j] {\n         \
    \   j += 1; // skip past this digit\n        }\n        if j == digits.length()\
    \ {\n            break; // no more digits to process\n        }\n        let mut\
    \ digit = digits[j];\n        digits[j] = digit;\n        i += 1;\n    }\n   \
    \ while i < digits.length() {\n        s += digits[i];\n        i += 1; // skip\
    \ past this digit\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpmgux2tpq.rs:15:22\n   |\n15 |     while i < digits.length()\
    \ {\n   |                      ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpmgux2tpq.rs:17:26\n   |\n17 | \
    \        while j < digits.length() && digits[j] == basedigits[j] {\n   |     \
    \                     ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpmgux2tpq.rs:17:38\n   |\n17 |         while j < digits.length()\
    \ && digits[j] == basedigits[j] {\n   |                                      ^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpmgux2tpq.rs:17:51\n   |\n17 |         while j < digits.length()\
    \ && digits[j] == basedigits[j] {\n   |                                      \
    \             ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <s"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = base;\n    while remainder >\
    \ 0 {\n        remainder, remainder = remainder % base, remainder / base;\n  \
    \      digits = digits - 1;\n    }\n    while digits > 0 {\n        s.push((digits).to_string());\n\
    \        digits = digits - 1;\n    }\n    String::from(s)\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpj8tx164w.rs:15:18\n   |\n15 |         remainder, remainder\
    \ = remainder % base, remainder / base;\n   |                  ^ expected one\
    \ of 8 possible tokens\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj8tx164w.rs:19:16\n\
    \   |\n19 |         s.push((digits).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        if base.len() == 1 {\n            s.push_str(&digits[digits.len()\
    \ - 1]);\n            break;\n        }\n        let mut index = digits.len()\
    \ - 1;\n        let mut digit = digits[index];\n        while base.len() > 1 &&\
    \ digit >= base.len() {\n            digits.swap(index, digits.len() - 1);\n \
    \           digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.swap(digits.len() - 1, digits.len() - 2);\n            digits.swap(digits.len()\
    \ - 2, digits.len() - 1);\n            digits.swap(digits.len() - 1, digits.len()\
    \ - 2);\n            digits.swap(digits.len() - 2, digits.len() - 1);\n      \
    \      digits.\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpwj4btjjv.rs:72:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ base.len() > 0 {\n   |                          - unclosed delimiter\n...\n\
    21 |         while base.len() > 1 && digit >= base.len() {\n   |             \
    \                                        - this delimiter might not be properly\
    \ closed...\n...\n56 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n72 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpwj4btjjv.rs:56:1\n\
    \   |\n56 | }\n   | ^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpwj4btjjv.rs:16:25\n   |\n16 |             s.push_str(&digits[digits.len()\
    \ - 1]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwj4btjjv.rs:20:25\n   |\n20 |         let mut digit = digits[index];\n\
    \   |                         ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str "
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.len() - 1).unwrap();\n\
    \        remainder = digit as isize - remainder;\n        if remainder < base\
    \ {\n            s.push_str(&digits[..digits.len() - 1]);\n            break;\n\
    \        }\n        digits.push_str(&digits[digits.len() - 1]);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpms2_t39v.rs:21:26\n\
    \   |\n21 |         digits.push_str(&digits[digits.len() - 1]);\n   |        \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.len()\
    \ - 1);\n        if base == 10 {\n            s.push_str(digit);\n           \
    \ digits.clear();\n            base = base.to_string();\n        } else {\n  \
    \          s.push_str(&digit + &base);\n            digits.clear();\n        \
    \    base = base.to_string();\n        }\n    }\n    s\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmp4z4qawdp.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4z4qawdp.rs:17:24\n\
    \   |\n17 |             s.push_str(digit);\n   |                        ^^^^^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<char>`\n\nerror[E0369]: cannot add `&String`\
    \ to `&Option<char>`\n  --> /tmp/tmp4z4qawdp.rs:21:31\n   |\n21 |            \
    \ s.push_str(&digit + &base);\n   |                        ------ ^ ----- &String\n\
    \   |                        |\n   |                        &Option<char>\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0369.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder /= base;\n        quotient /= base;\n        s.push((remainder\
    \ % base) as char);\n    }\n    s.push((quotient % base) as char);\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpauwdrk8r.rs:17:16\n\
    \   |\n17 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpauwdrk8r.rs:17:16\n   |\n17 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can\
    \ be cast as `char`, not `isize`\n  --> /tmp/tmpauwdrk8r.rs:19:12\n   |\n19 |\
    \     s.push((quotient % base) as char);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpauwdrk8r.rs:19:12\n   |\n19 |     s.push((quotient % base) as char);\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpwbbte1wg.rs:17:32\n\
    \   |\n17 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , digit, s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i..].parse::<usize>().unwrap();\n\
    \        if digit < base {\n            digit = digit * base + 10;\n        }\n\
    \        digit = digit as usize;\n        i += 1;\n        s += digit.to_string();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvfweqlu.rs:17:20\n   |\n\
    17 |         if digit < base {\n   |                    ^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0277]: cannot multiply `usize` by `String`\n\
    \  --> /tmp/tmpgvfweqlu.rs:18:27\n   |\n18 |             digit = digit * base\
    \ + 10;\n   |                           ^ no implementation for `usize * String`\n\
    \   |\n   = help: the trait `Mul<String>` is not implemented for `usize`\n   =\
    \ help: the following other types implement trait `Mul<Rhs>`:\n             <&'a\
    \ f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a i128\
    \ as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32 as\
    \ Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgvfweqlu.rs:22:14\n   |\n22 |         s += digit.to_string();\n\
    \   |              ^^^^^^^^^^^^^^^^^\n   |              |\n   |              expected\
    \ `&str`, found struct `String`\n   |              help: consider borrowing here:\
    \ `&digit.to_string()`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = String::new();\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    if remainder >\
    \ 0 {\n        digits.push(remainder.to_string());\n    }\n    s += digits.reverse();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2pbzcd0.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpb2pbzcd0.rs:20:21\n   |\n20 |         digits.push(remainder.to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0599]: no method named `reverse` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpb2pbzcd0.rs:22:17\n   |\n22 |     s += digits.reverse();\n\
    \   |                 ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reserve`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s.push((remainder as char).to_string());\n\
    \        remainder /= base;\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq1yj115j.rs:16:16\n   |\n\
    16 |         s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpq1yj115j.rs:16:16\n   |\n16 |        \
    \ s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpq1yj115j.rs:16:16\n   |\n16 |         s.push((remainder as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut basedigits_len = basedigits.length;\n\
    \    let mut i = 0;\n    while i < basedigits_len {\n        if basedigits[i]\
    \ >= base {\n            basedigits[i] -= base;\n        } else {\n          \
    \  basedigits[i] += base;\n        }\n        i += 1;\n    }\n    s += basedigits.to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `length` on type `Vec<char>`\n  --> /tmp/tmp00g9sxly.rs:14:41\n\
    \   |\n14 |     let mut basedigits_len = basedigits.length;\n   |            \
    \                             ^^^^^^ unknown field\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp00g9sxly.rs:17:29\n   |\n17 |         if basedigits[i]\
    \ >= base {\n   |                             ^^^^ expected `char`, found `isize`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `char`\n\
    \  --> /tmp/tmp00g9sxly.rs:18:13\n   |\n18 |             basedigits[i] -= base;\n\
    \   |             -------------^^^^^^^^\n   |             |\n   |            \
    \ cannot use `-=` on type `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmp00g9sxly.rs:20:13\n   |\n\
    20 |             basedigits[i] += base;\n   |             -------------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0599]:\
    \ `Vec<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmp00g9sxly.rs:24:21\n\
    \    |\n24  |       s += basedigits.to_string();\n    |                      \
    \ ^^^^^^^^^ `Vec<char>` cannot be formatted with the default formatter\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<char>:\
    \ std::fmt::Display`\n            which is required by `Vec<char>: ToString`\n\
    \            `[char]: std::fmt::Display`\n            which is required by `[char]:\
    \ ToString`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368, E0599, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    digits.insert(0, remainder.to_string());\n    s += &digits;\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm4gc16si.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm4gc16si.rs:18:22\n   |\n18 |     digits.insert(0, remainder.to_string());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n    let mut basedigits_len = basedigits.len();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        if basedigits_len == 0 {\n            s.push_str(&digits[..i]);\n\
    \            break;\n        }\n        let mut digit = digits[..i].chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n        let mut basedigit = basedigits[..basedigits_len].chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n        let mut basedigits_len =\
    \ basedigit.len();\n        let mut digits_len = digits.len();\n        while\
    \ i < digits_len {\n            if basedigits_len == 0 {\n                s.push_str(&digits[..i]);\n\
    \                break;\n            }\n            let mut digit = digits[..i].chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n            let mut basedigit =\
    \ basedigits[..basedigits_len].chars().filter(|c| c >= '0' && c <= '9').collect::<Vec<_>>();\n\
    \            let mut basedigits_len = basedigit.len();\n            if basedigits_len\
    \ > 0 {\n                let mut basedigit = basedigits[..basedigits_len].chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n                let mut basedigits_len\
    \ = basedigit.len();\n                let mut digits_len = digits.len();\n   \
    \             while i < digits_len {\n                    if basedigits_len ==\
    \ 0 {\n                        s.push_str(&digits[..i]);\n                   \
    \     break;\n                    }\n                    let mut digit = digits[..i].chars().filter(|c|\
    \ c >= '0' && c <= '9').collect::<Vec<_>>();\n                    let mut basedigit\
    \ = basedigits[..basedigits_len].chars().filter(|c| c >= '0' && c <= '9').collect::<Vec<_>>();\n\
    \                    let mut basedigits_len = basedigit.len();\n             \
    \       \n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpn30zpze8.rs:63:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n17 |     while\
    \ i < digits_len {\n   |                          - unclosed delimiter\n...\n\
    26 |         while i < digits_len {\n   |                              - unclosed\
    \ delimiter\n...\n34 |             if basedigits_len > 0 {\n   |             \
    \                      - unclosed delimiter\n...\n38 |                 while i\
    \ < digits_len {\n   |                                      - this delimiter might\
    \ not be properly closed...\n...\n47 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n63 | }\n   |   ^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn30zpze8.rs:13:57\n   |\n13 |     let mut basedigits =\
    \ digits.chars().filter(|c| c >= '0' && c <= '9').collect::<Vec<_>>();\n   | \
    \                                                        ^^^\n   |           \
    \                                              |\n   |                       \
    \                                  expected `&char`, found `char`\n   |      \
    \                                                   help: consider borrowing here:\
    \ `&'0'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn30zpze8.rs:13:69\n\
    \   |\n13 |     let mut basedigits = digits.chars().filter(|c| c >= '0' && c <=\
    \ '9').collect::<Vec<_>>();\n   |                                            \
    \                         ^^^\n   |                                          \
    \                           |\n   |                                          \
    \                           expected `&char`, found `char`\n   |             \
    \                                                        help: consider borrowing\
    \ here: `&'9'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn30zpze8.rs:22:61\n\
    \   |\n22 |         let mut digit = digits[..i].chars().filter(|c| c >= '0' &&\
    \ c <= '9').collect::<Vec<_>>();\n   |                                       \
    \                      ^^^\n   |                                             \
    \    "
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ power = 1;\n    let mut i = 0;\n    while i < digits.len() {\n        if digits[i]\
    \ > base {\n            digits[i] -= base;\n            power = 1;\n        }\
    \ else {\n            digits[i] += power;\n            power += 1;\n        }\n\
    \        i += 1;\n    }\n    s += digits.into_iter().map(|x| x.to_string()).collect::<String>();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7j_qoat4.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmp7j_qoat4.rs:17:13\n   |\n17 |     \
    \        digits[i] -= base;\n   |             ---------^^^^^^^^\n   |        \
    \     |\n   |             cannot use `-=` on type `char`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp7j_qoat4.rs:20:13\n\
    \   |\n20 |             digits[i] += power;\n   |             ---------^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7j_qoat4.rs:25:10\n   |\n25 |     s += digits.into_iter().map(|x|\
    \ x.to_string()).collect::<String>();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits.into_iter().map(|x| x.to_string()).collect::<String>()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if digits[i] > base {\n            s.push_str(&digits[i\
    \ .. (i + 1)]);\n            i += 1;\n        } else {\n            s.push_str(&base[digits[i]\
    \ - base]);\n            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6xizmzbx.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6xizmzbx.rs:17:24\n\
    \   |\n17 |             s.push_str(&digits[i .. (i + 1)]);\n   |             \
    \           ^^^^^^^^^^^^^^^^^^^^^ expected `str`, found slice `[char]`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&[char]`\n\
    \nerror[E0369]: cannot subtract `Vec<char>` from `char`\n  --> /tmp/tmp6xizmzbx.rs:20:40\n\
    \   |\n20 |             s.push_str(&base[digits[i] - base]);\n   |           \
    \                   --------- ^ ---- Vec<char>\n   |                         \
    \     |\n   |                              char\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = s.push_str(&digits[digit]);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpvs3opbb9.rs:17:25\n\
    \   |\n17 |         s = s.push_str(&digits[digit]);\n   |                    \
    \     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n   |\n   = help: the\
    \ trait `Index<isize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvs3opbb9.rs:17:13\n\
    \   |\n11 |     let mut s = String::new();\n   |                 -------------\
    \ expected due to this value\n...\n17 |         s = s.push_str(&digits[digit]);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpvs3opbb9.rs:17:15\n\
    \   |\n17 |         s = s.push_str(&digits[digit]);\n   |             - ^^^^^^^^\
    \ this call modifies `s` in-place\n   |             |\n   |             you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push_str`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    let mut digits_len = digits.length();\n    let mut bases_len = bases.length();\n\
    \    let mut i = 0;\n    while i < digits_len {\n        if digits[i] > bases.chars().nth(digits_len\
    \ - i - 1) {\n            digits = digits.chars().nth(digits_len - i - 1).to_string();\n\
    \            digits_len = digits.length();\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    while i < bases_len {\n        if bases[i] > digits.chars().nth(bases_len\
    \ - i - 1) {\n            bases = bases.chars().nth(bases_len - i - 1).to_string();\n\
    \            bases_len = bases.length();\n        } else {\n            i += 1;\n\
    \        }\n    }\n    for i in 0..digits_len {\n        if digits[i] != bases.chars().nth(digits_len\
    \ - i - 1) {\n            s.push_str(&digits.chars().nth(i).unwrap());\n     \
    \   }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3rvfu9bn.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmp3rvfu9bn.rs:15:31\n\
    \   |\n15 |     let mut bases_len = bases.length();\n   |                    \
    \           ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp3rvfu9bn.rs:18:12\n   |\n18 |         if digits[i] > bases.chars().nth(digits_len\
    \ - i - 1) {\n   |            ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `Option<char>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp3rvfu9bn.rs:19:61\n    |\n19  |               digits = digits.chars().nth(digits_len\
    \ - i - 1).to_string();\n    |                                               \
    \                ^^^^^^^^^ `Option<char>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3rvfu9bn.rs:20:33\n\
    \   |\n20 |             digits_len = digits.length();\n   |                  \
    \               ^^^^^^ help: there is an associated function with a similar name:\
    \ `len`"
  stdout: ''
  timestamp: 1660011298
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        result =\
    \ format!(\"{}{}\", digit, result);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = 0;\n    while digits.len()\
    \ > 0 {\n        let digit = digits.chars().nth(digits.len() - 1);\n        let\
    \ mut new_digit = digit;\n        let mut new_remainder = 0;\n        while new_digit\
    \ != 0 {\n            let mut new_digit = digit % base;\n            new_remainder\
    \ = new_remainder + (new_digit as isize);\n            digit = digit / base;\n\
    \        }\n        s = format!(\"{}{}\", s, new_remainder);\n        remainder\
    \ = remainder + new_remainder;\n        digits = digits.chars().nth(digits.len()\
    \ - 1);\n    }\n    if remainder != 0 {\n        s = format!(\"{}\", remainder);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgfdv4_my.rs:18:28\n   |\n\
    18 |         while new_digit != 0 {\n   |                            ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `{integer}`\n\nerror[E0369]: cannot mod `Option<char>`\
    \ by `isize`\n  --> /tmp/tmpgfdv4_my.rs:19:39\n   |\n19 |             let mut\
    \ new_digit = digit % base;\n   |                                 ----- ^ ----\
    \ isize\n   |                                 |\n   |                        \
    \         Option<char>\n\nerror[E0369]: cannot divide `Option<char>` by `isize`\n\
    \  --> /tmp/tmpgfdv4_my.rs:21:27\n   |\n21 |             digit = digit / base;\n\
    \   |                     ----- ^ ---- isize\n   |                     |\n   |\
    \                     Option<char>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgfdv4_my.rs:25:18\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n25 |         digits = digits.chars().nth(digits.len()\
    \ - 1);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmplejqmi5s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    let mut\
    \ base = base;\n    while remainder > base {\n        remainder -= base;\n   \
    \     s += &digits[..base];\n    }\n    s += &digits[..remainder];\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmp69rijz_7.rs:17:15\n   |\n17 |         s += &digits[..base];\n \
    \  |               ^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `RangeTo<isize>`\n\
    \  --> /tmp/tmp69rijz_7.rs:19:11\n   |\n19 |     s += &digits[..remainder];\n\
    \   |           ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<isize>`\n\
    \   |\n   = help: the trait `Index<RangeTo<isize>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if digits[i] > base {\n            s.push_str(&base[digits[i]\
    \ - base]);\n            i += 1;\n        } else {\n            s.push_str(&digits[i]);\n\
    \        }\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0h3ibi0m.rs:16:24\n   |\n\
    16 |         if digits[i] > base {\n   |                        ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0369]: cannot subtract `Vec<char>` from\
    \ `char`\n  --> /tmp/tmp0h3ibi0m.rs:17:40\n   |\n17 |             s.push_str(&base[digits[i]\
    \ - base]);\n   |                              --------- ^ ---- Vec<char>\n  \
    \ |                              |\n   |                              char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0h3ibi0m.rs:20:24\n   |\n20 |  \
    \           s.push_str(&digits[i]);\n   |                        ^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        let mut digit = digits[i..].parse::<usize>().unwrap();\n\
    \        if digit < base {\n            digit = digit * base + 10;\n        }\n\
    \        digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpj2ux0mhi.rs:91:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ i < digits.len() {\n   |                            - this delimiter might not\
    \ be properly closed...\n...\n75 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n91 | }\n   |   ^\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj2ux0mhi.rs:17:20\n   |\n17 |         if digit < base {\n   | \
    \                   ^^^^ expected `usize`, found struct `String`\n\nerror[E0277]:\
    \ cannot multiply `usize` by `String`\n  --> /tmp/tmpj2ux0mhi.rs:18:27\n   |\n\
    18 |             digit = digit * base + 10;\n   |                           ^\
    \ no implementation for `usize * String`\n   |\n   = help: the trait `Mul<String>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n             <&'a f64\
    \ as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n             <&'a i16 as\
    \ Mul<i16>>\n             <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n\
    \             <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n  \
    \         and 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj2ux0mhi.rs:10:42\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |    -----------\
    \                           ^^^^^^ expected struct `String`, found `()`\n   |\
    \    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0; base];\n    let mut carry = 0;\n    for digit in\
    \ x.to_string().chars().cloned() {\n        digits[digit.digit() - '0'] +=\n \
    \           digit.digit() >= '0' && digit.digit() <= '9' ? digit.digit() - '0'\
    \ : digit.digit() - 'a' + 10;\n        carry = (digits[digit.digit() - '0'] +\
    \ carry) % base;\n        digits[digit.digit() - '0'] = carry / base;\n      \
    \  carry %= base;\n    }\n    for digit in digits.iter_mut() {\n        *digit\
    \ = digit.digit() >= '0' && digit.digit() <= '9' ? digit.digit() - '0' : digit.digit()\
    \ - 'a' + 10;\n    }\n    if carry > 0 {\n        s += &format!(\"{}{}\", digits[digits.len()\
    \ - 1], &'0' + &carry);\n    }\n    String::from(s)\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `digit`\n\
    \  --> /tmp/tmpw1xiosnr.rs:16:60\n   |\n16 |             digit.digit() >= '0'\
    \ && digit.digit() <= '9' ? digit.digit() - '0' : digit.digit() - 'a' + 10;\n\
    \   |                                                            ^^^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected one of `.`, `;`,\
    \ `?`, `else`, `}`, or an operator, found `digit`\n  --> /tmp/tmpw1xiosnr.rs:22:65\n\
    \   |\n22 |         *digit = digit.digit() >= '0' && digit.digit() <= '9' ? digit.digit()\
    \ - '0' : digit.digit() - 'a' + 10;\n   |                                    \
    \                             ^^^^^ expected one of `.`, `;`, `?`, `else`, `}`,\
    \ or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1xiosnr.rs:12:30\n\
    \   |\n12 |     let mut digits = vec![0; base];\n   |                        \
    \      ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0; base.try_into().unwrap()];\n   |                      \
    \            ++++++++++++++++++++\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpw1xiosnr.rs:14:40\n     |\n14   |\
    \     for digit in x.to_string().chars().cloned() {\n     |                  \
    \                      ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpw1xiosnr.rs:14:18\n   |\n14 |     for\
    \ digit in x.to_string().chars().cloned() {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type misma"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder *= base;\n        remainder %= base;\n        quotient\
    \ /= base;\n        result.push((quotient as char).to_string());\n    }\n    if\
    \ remainder > 0 {\n        result.push((remainder as char).to_string());\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7x_a0vc5.rs:18:21\n   |\n\
    18 |         result.push((quotient as char).to_string());\n   |              \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7x_a0vc5.rs:21:21\n   |\n21 |\
    \         result.push((remainder as char).to_string());\n   |                \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp7x_a0vc5.rs:18:21\n\
    \   |\n18 |         result.push((quotient as char).to_string());\n   |       \
    \              ^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp7x_a0vc5.rs:18:21\n   |\n18 |         result.push((quotient\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp7x_a0vc5.rs:21:21\n\
    \   |\n21 |         result.push((remainder as char).to_string());\n   |      \
    \               ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmp7x_a0vc5.rs:21:21\n   |\n21 |         result.push((remainder\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as u64;\n    let mut base = base as u64;\n    while x >= base\
    \ {\n        s +=\n            format!(\"{:0{}b}\", x % base, base).to_string()\n\
    \                .chars().collect::<Vec<_>>()\n                .join('');\n  \
    \      x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string().chars().collect::<Vec<_>>()\n\
    \            .join('');\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmptiu7kk32.rs:18:24\n   |\n\
    18 |                 .join('');\n   |                        ^ empty character\
    \ literal\n\nerror: empty character literal\n  --> /tmp/tmptiu7kk32.rs:23:20\n\
    \   |\n23 |             .join('');\n   |                    ^ empty character\
    \ literal\n\nerror: invalid format string: expected `'}'`, found `'{'`\n  -->\
    \ /tmp/tmptiu7kk32.rs:16:25\n   |\n16 |             format!(\"{:0{}b}\", x % base,\
    \ base).to_string()\n   |                      -  ^ expected `}` in format string\n\
    \   |                      |\n   |                      because of this opening\
    \ brace\n   |\n   = note: if you intended to print `{`, you can escape it using\
    \ `{{`\n\nerror: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmptiu7kk32.rs:22:21\n\
    \   |\n22 |         format!(\"{:0{}b}\", x, base).to_string().chars().collect::<Vec<_>>()\n\
    \   |                  -  ^ expected `}` in format string\n   |              \
    \    |\n   |                  because of this opening brace\n   |\n   = note:\
    \ if you intended to print `{`, you can escape it using `{{`\n\nerror: aborting\
    \ due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x;\n    while x >= base {\n        s +=\n            format!(\"\
    {:0{}b}\", x % base, base).to_string()\n                .chars()\n           \
    \     .map(|c| match c {\n                    '0' => 0,\n                    '1'\
    \ => 1,\n                    '2' => 2,\n                    '3' => 3,\n      \
    \              '4' => 4,\n                    '5' => 5,\n                    '6'\
    \ => 6,\n                    '7' => 7,\n                    '8' => 8,\n      \
    \              '9' => 9,\n                    _ => panic!(\"Invalid base\"),\n\
    \                })\n                .collect::<Vec<_>>()\n                .join();\n\
    \        x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string()\n\
    \            .chars()\n            .map(|c| match c {\n                '0' =>\
    \ 0,\n                '1' => 1,\n                '2' => 2,\n                '3'\
    \ => 3,\n                '4' => 4,\n                '5' => 5,\n              \
    \  '6' => 6,\n                '7' => 7,\n                '8' => 8,\n         \
    \       '9' => 9,\n                _ => panic!(\"Invalid base\"),\n          \
    \  })\n            .collect::<Vec<_>>()\n            .join();\n    s\n}\n\nfn\
    \ main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmply7jt5go.rs:15:25\n\
    \   |\n15 |             format!(\"{:0{}b}\", x % base, base).to_string()\n   |\
    \                      -  ^ expected `}` in format string\n   |              \
    \        |\n   |                      because of this opening brace\n   |\n  \
    \ = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmply7jt5go.rs:35:21\n\
    \   |\n35 |         format!(\"{:0{}b}\", x, base).to_string()\n   |          \
    \        -  ^ expected `}` in format string\n   |                  |\n   |   \
    \               because of this opening brace\n   |\n   = note: if you intended\
    \ to print `{`, you can escape it using `{{`\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.len()\
    \ - 1).unwrap();\n        let mut new_digit = digit;\n        if base == 2 {\n\
    \            if digit == '0' {\n                new_digit = '1';\n           \
    \ } else {\n                new_digit = '0';\n            }\n        }\n     \
    \   if base == 8 {\n            if digit == '0' {\n                new_digit =\
    \ '7';\n            } else {\n                new_digit = '8';\n            }\n\
    \        }\n        if base == 10 {\n            if digit == '0' {\n         \
    \       new_digit = '9';\n            } else {\n                new_digit = '0';\n\
    \            }\n        }\n        s.push((new_digit as char).to_string());\n\
    \        digits = digits.chars().nth(digits.len() - 1).unwrap();\n        base\
    \ = base.to_string();\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpz7gz9hqp.rs:17:17\n\
    \   |\n17 |         if base == 2 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `{integer}`\n\
    \  --> /tmp/tmpz7gz9hqp.rs:24:17\n   |\n24 |         if base == 8 {\n   |    \
    \             ^^ no implementation for `String == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `{integer}`\n  --> /tmp/tmpz7gz9hqp.rs:31:17\n   |\n31 |     \
    \    if base == 10 {\n   |                 ^^ no implementation for `String ==\
    \ {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>"
  stdout: ''
  timestamp: 1660011298
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        result =\
    \ format!(\"{}{}\", digit, result);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; base];\n    let mut carry = 0;\n    for digit\
    \ in x.to_digits().iter() {\n        let digit = digit as usize;\n        digits[digit]\
    \ += carry;\n        carry = 0;\n        if digits[digit] > base {\n         \
    \   digits[digit] -= base;\n            carry = 1;\n        }\n    }\n    for\
    \ digit in digits.iter_mut() {\n        *digit = *digit as u8;\n    }\n    if\
    \ carry != 0 {\n        s += String::from(\"1\");\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9c3ar90m.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp9c3ar90m.rs:14:20\n\
    \   |\n14 |     for digit in x.to_digits().iter() {\n   |                    ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c3ar90m.rs:18:28\n\
    \   |\n18 |         if digits[digit] > base {\n   |                          \
    \  ^^^^ expected `u8`, found `isize`\n   |\nhelp: you can convert `digits[digit]`\
    \ from `u8` to `isize`, matching the type of `base`\n   |\n18 |         if isize::from(digits[digit])\
    \ > base {\n   |            ++++++++++++             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9c3ar90m.rs:19:30\n   |\n19 |             digits[digit]\
    \ -= base;\n   |                              ^^^^ expected `u8`, found `isize`\n\
    \nerror[E0277]: cannot subtract-assign `isize` from `u8`\n  --> /tmp/tmp9c3ar90m.rs:19:27\n\
    \   |\n19 |             digits[digit] -= base;\n   |                         \
    \  ^^ no implementation for `u8 -= isize`\n   |\n   = help: the trait `SubAssign<isize>`\
    \ is not implemented for `u8`\n   = help: the following other types implement\
    \ trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n           \
    \  <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64\
    \ as SubAssign>\n             <i128 as SubAssign<&i128>>\n             <i128 as\
    \ SubAssign>\n             <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c3ar90m.rs:27:14\n\
    \   |\n27 |         s += String::from(\"1\");\n   |              ^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpwbbte1wg.rs:17:32\n\
    \   |\n17 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    digits.insert(0, remainder.to_string());\n    s.push_str(&digits);\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagip4u54.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpagip4u54.rs:18:22\n   |\n18 |     digits.insert(0, remainder.to_string());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    basedigits[base] = '.';\n    s += basedigits.join(\"\
    \");\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[char]` cannot be indexed by `isize`\n  --> /tmp/tmpv_7omkcg.rs:14:5\n\
    \   |\n14 |     basedigits[base] = '.';\n   |     ^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<char>`\n\nerror[E0599]: the method `join` exists for\
    \ struct `Vec<char>`, but its trait bounds were not satisfied\n  --> /tmp/tmpv_7omkcg.rs:15:21\n\
    \   |\n15 |     s += basedigits.join(\"\");\n   |                     ^^^^ method\
    \ cannot be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        if base == 10 {\n  \
    \          s.push_str(&digits[i..i + 1]);\n            break;\n        }\n   \
    \     let mut digit = digits[i..i + 1];\n        let mut power = 1;\n        while\
    \ i < digits.len() && base > 10 {\n            power = power * base;\n       \
    \     i += 1;\n        }\n        if base == 10 {\n            s.push_str(&digit);\n\
    \        } else {\n            s.push_str(&digit.to_string().powf(power));\n \
    \       }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpnf_xrovc.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n  --> /tmp/tmpnf_xrovc.rs:20:13\n   |\n20 |  \
    \       let mut digit = digits[i..i + 1];\n   |             ^^^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\nhelp:\
    \ consider borrowing here\n   |\n20 |         let mut digit = &digits[i..i + 1];\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnf_xrovc.rs:22:42\n\
    \   |\n22 |         while i < digits.len() && base > 10 {\n   |              \
    \                            ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                          |\n   |                       \
    \                   expected struct `String`, found integer\n\nerror[E0277]: cannot\
    \ multiply `{integer}` by `String`\n  --> /tmp/tmpnf_xrovc.rs:23:27\n   |\n23\
    \ |             power = power * base;\n   |                           ^ no implementation\
    \ for `{integer} * String`\n   |\n   = help: the trait `Mul<String>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a "
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.remove(0);\n   \
    \     if digit < base {\n            digit += carry;\n            carry = 1;\n\
    \        }\n        let mut digit = digit - base;\n        if digit < 0 {\n  \
    \          digit += 10;\n            carry = 0;\n        }\n        s.push((digit\
    \ as char).to_string());\n    }\n    if carry != 0 {\n        s.push((carry as\
    \ char).to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgo4ynbyu.rs:17:20\n   |\n\
    17 |         if digit < base {\n   |                    ^^^^ expected `char`,\
    \ found struct `Vec`\n   |\n   = note: expected type `char`\n            found\
    \ struct `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpgo4ynbyu.rs:18:13\n   |\n18 |     \
    \        digit += carry;\n   |             -----^^^^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0369]: cannot subtract\
    \ `Vec<char>` from `char`\n  --> /tmp/tmpgo4ynbyu.rs:21:31\n   |\n21 |       \
    \  let mut digit = digit - base;\n   |                         ----- ^ ---- Vec<char>\n\
    \   |                         |\n   |                         char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgo4ynbyu.rs:26:16\n   |\n26 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgo4ynbyu.rs:29:16\n\
    \   |\n29 |         s.push((carry as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `{integer}`\n  --> /tmp/tmpgo4ynbyu.rs:29:16\n\
    \   |\n29 |         s.push((carry as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead (via\
    \ a `u32`)\n  --> /tmp/tmpgo4ynbyu.rs:29:16\n   |\n29 |         s.push((carry\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0368,\
    \ E0369, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as isize;\n    let mut base = base as isize;\n    while x >=\
    \ base {\n        s +=\n            format!(\"{:0{}b}\", x % base, base).to_string()[..base];\n\
    \        x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string()[..base];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmp4aogcsf5.rs:16:25\n\
    \   |\n16 |             format!(\"{:0{}b}\", x % base, base).to_string()[..base];\n\
    \   |                      -  ^ expected `}` in format string\n   |          \
    \            |\n   |                      because of this opening brace\n   |\n\
    \   = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmp4aogcsf5.rs:20:21\n\
    \   |\n20 |         format!(\"{:0{}b}\", x, base).to_string()[..base];\n   | \
    \                 -  ^ expected `}` in format string\n   |                  |\n\
    \   |                  because of this opening brace\n   |\n   = note: if you\
    \ intended to print `{`, you can escape it using `{{`\n\nerror: aborting due to\
    \ 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let digit = quotient % base;\n        remainder = quotient / base;\n\
    \        s = format!(\"{}{}\", s, digit);\n        quotient = remainder;\n   \
    \ }\n    if remainder > 0 {\n        s = format!(\"{}\", remainder) + s;\n   \
    \ }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xpbb59f.rs:21:40\n   |\n\
    21 |         s = format!(\"{}\", remainder) + s;\n   |                       \
    \                 ^\n   |                                        |\n   |     \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                        help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        digit = digit.to_string();\n        base.truncate(base.len()\
    \ - 1);\n        s += digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1spyvgqt.rs:16:17\n   |\n\
    15 |         let mut digit = digits.chars().nth(base.len() - 1).unwrap();\n  \
    \ |                         ------------------------------------------- expected\
    \ due to this value\n16 |         digit = digit.to_string();\n   |           \
    \      ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1spyvgqt.rs:18:14\n   |\n18 |         s += digit;\n\
    \   |              ^^^^^ expected `&str`, found `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    result.push_str(&format!(\"{}\", remainder));\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmp7wjpujxx.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        let mut digit = digits.chars().nth(i).unwrap();\n\
    \        if base == 10 {\n            digit += &\"0\";\n        }\n        i +=\
    \ 1;\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit -= &'0';\n\
    \        }\n        if digit >= '\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpyn5ok2am.rs:78:21\n\
    \   |\n78 |         if digit >= '\n   |                     ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x = x / base;\n    }\n    digits.push(format!(\"{}\",\
    \ x));\n    s += &digits;\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr9v7r1to.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpr9v7r1to.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    while base10.len() > 0 {\n        let mut digit = digits.pop().unwrap();\n\
    \        if digit < '0' || digit > '9' {\n            digit = digit.to_string();\n\
    \        }\n        s += digit;\n        base10 -= digit;\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptjp3un1a.rs:17:21\n   |\n\
    15 |         let mut digit = digits.pop().unwrap();\n   |                    \
    \     --------------------- expected due to this value\n16 |         if digit\
    \ < '0' || digit > '9' {\n17 |             digit = digit.to_string();\n   |  \
    \                   ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptjp3un1a.rs:19:14\n   |\n19 |\
    \         s += digit;\n   |              ^^^^^ expected `&str`, found `char`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `String`\n\
    \  --> /tmp/tmptjp3un1a.rs:20:9\n   |\n20 |         base10 -= digit;\n   |   \
    \      ------^^^^^^^^^\n   |         |\n   |         cannot use `-=` on type `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    let mut\
    \ base = base.to_string();\n    while remainder > 0 {\n        let mut digit =\
    \ remainder.to_string();\n        if base < 10 {\n            digit = digit.parse::<usize>().unwrap();\n\
    \        }\n        base = base.parse::<usize>().unwrap();\n        if digit <\
    \ base {\n            digit = digit.to_string();\n        }\n        s += digit;\n\
    \        remainder -= digit;\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3d4_j2rs.rs:17:19\n   |\n\
    17 |         if base < 10 {\n   |                   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3d4_j2rs.rs:18:21\n\
    \   |\n16 |         let mut digit = remainder.to_string();\n   |             \
    \            --------------------- expected due to this value\n17 |         if\
    \ base < 10 {\n18 |             digit = digit.parse::<usize>().unwrap();\n   |\
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                     |\n   |                   \
    \  expected struct `String`, found `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3d4_j2rs.rs:20:16\n   |\n14 |     let mut base = base.to_string();\n\
    \   |                    ---------------- expected due to this value\n...\n20\
    \ |         base = base.parse::<usize>().unwrap();\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                |\n\
    \   |                expected struct `String`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3d4_j2rs.rs:24:14\n   |\n24 |         s += digit;\n\
    \   |              ^^^^^\n   |              |\n   |              expected `&str`,\
    \ found struct `String`\n   |              help: consider borrowing here: `&digit`\n\
    \nerror[E0277]: cannot subtract-assign `String` from `isize`\n  --> /tmp/tmp3d4_j2rs.rs:25:19\n\
    \   |\n25 |         remainder -= digit;\n   |                   ^^ no implementation\
    \ for `isize -= String`\n   |\n   = help: the trait `SubAssign<String>` is not\
    \ implemented for `isize`\n   = help: the following other types implement trait\
    \ `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n             <f32\
    \ as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n\
    \             <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n \
    \            <i16 as SubAssign<&i16>>\n             <i16 as SubAssig"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        s.push((&mut digits[..]).to_digits(base).unwrap().to_string());\n\
    \    }\n    s.push((&mut digits[..]).to_digits(base).unwrap().to_string());\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n   \
    \ assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpxg61evfv.rs:16:34\n   |\n16 |     \
    \    s.push((&mut digits[..]).to_digits(base).unwrap().to_string());\n   |   \
    \                               ^^^^^^^^^ method not found in `&mut str`\n\nerror[E0599]:\
    \ no method named `to_digits` found for mutable reference `&mut str` in the current\
    \ scope\n  --> /tmp/tmpxg61evfv.rs:18:30\n   |\n18 |     s.push((&mut digits[..]).to_digits(base).unwrap().to_string());\n\
    \   |                              ^^^^^^^^^ method not found in `&mut str`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let mut digit = digits.chars().nth(base.len()\
    \ - 1);\n        if digit == Some('0') {\n            digit = digits.chars().nth(base.len()\
    \ - 2);\n        }\n        base.truncate(base.len() - 1);\n        s += digit;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsyeqs5s1.rs:20:14\n   |\n\
    20 |         s += digit;\n   |              ^^^^^ expected `&str`, found enum\
    \ `Option`\n   |\n   = note: expected reference `&str`\n                   found\
    \ enum `Option<char>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, '0');\n    }\n\
    \    while remainder < base {\n        remainder += base;\n        digits.insert(0,\
    \ '0');\n    }\n    s += &digits;\n    String::from(s)\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"0008\"`,\n right: `\"22\"`', /tmp/tmpne7jajp2.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s.push(remainder);\n    }\n    s.push(remainder);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:17:16\n   |\n\
    17 |         s.push(remainder);\n   |                ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3rmydma.rs:19:12\n\
    \   |\n19 |     s.push(remainder);\n   |            ^^^^^^^^^ expected `char`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        let mut digit = digits[i];\n        if base\
    \ == 10 {\n            digit = digit.to_string().chars().collect::<Vec<_>>()[0];\n\
    \        }\n        if digit >= '0' && digit <= '9' {\n            digit = digit\
    \ - '0';\n        }\n        if digit >= base {\n            digit = digit - base;\n\
    \        }\n        if digit < base {\n            digit = digit + '0';\n    \
    \    }\n        digits[i] = digit.to_string().chars().collect::<Vec<_>>()[0];\n\
    \        i += 1;\n    }\n    s += digits.join(\"\");\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmpfn16ca4s.rs:17:17\n\
    \   |\n17 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0369]: cannot subtract\
    \ `char` from `char`\n  --> /tmp/tmpfn16ca4s.rs:21:27\n   |\n21 |            \
    \ digit = digit - '0';\n   |                     ----- ^ --- char\n   |      \
    \               |\n   |                     char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpfn16ca4s.rs:23:21\n   |\n23 |         if digit >= base {\n   |\
    \                     ^^^^ expected `char`, found struct `Vec`\n   |\n   = note:\
    \ expected type `char`\n            found struct `Vec<char>`\n\nerror[E0369]:\
    \ cannot subtract `Vec<char>` from `char`\n  --> /tmp/tmpfn16ca4s.rs:24:27\n \
    \  |\n24 |             digit = digit - base;\n   |                     ----- ^\
    \ ---- Vec<char>\n   |                     |\n   |                     char\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfn16ca4s.rs:26:20\n   |\n26 |  \
    \       if digit < base {\n   |                    ^^^^ expected `char`, found\
    \ struct `Vec`\n   |\n   = note: expected type `char`\n            found struct\
    \ `Vec<char>`\n\nerror[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpfn16ca4s.rs:27:27\n\
    \   |\n27 |             digit = digit + '0';\n   |                     ----- ^\
    \ --- char\n   |                     |\n   |                     char\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<char>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpfn16ca4s.rs:32:17\n   |\n32 |     s += digits.join(\"\
    \");\n   |                 ^^^^ method cannot be called on `Vec<char>` due to\
    \ unsatisfied trait b"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp75h09n4q.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0; base];\n    let mut carry = 0;\n    while x >= base\
    \ {\n        digits[base - 1] += x;\n        x -= base;\n        carry = 0;\n\
    \        for &d in &digits[base] {\n            carry += d;\n            s +=\
    \ if carry > 9 { String::from(\"0\".to_string()) } else { String::from(\"0123456789ABCDEF\"\
    .to_string()) };\n            carry -= 10;\n        }\n    }\n    s += if carry\
    \ > 9 { String::from(\"0\".to_string()) } else { String::from(\"0123456789ABCDEF\"\
    .to_string()) };\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7g3d4bfn.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmp7g3d4bfn.rs:15:9\n   |\n15 |         digits[base\
    \ - 1] += x;\n   |         ^^^^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is\
    \ not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmp7g3d4bfn.rs:18:20\n   |\n18 |  \
    \       for &d in &digits[base] {\n   |                    ^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<isize>` for `Vec<{integer}>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7g3d4bfn.rs:20:33\n   |\n20 |             s\
    \ += if carry > 9 { String::from(\"0\".to_string()) } else { String::from(\"0123456789ABCDEF\"\
    .to_string()) };\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                 |\n   |                                \
    \ expected `&str`, found struct `String`\n   |                               \
    \  help: consider borrowing here: `&String::from(\"0\".to_string())`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7g3d4bfn.rs:20:72\n   |\n20 |             s\
    \ += if carry > 9 { String::from(\"0\".to_string()) } else { String::from(\"0123456789ABCDEF\"\
    .to_string()) };\n   |                   "
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    if quotient > 0 {\n\
    \        s = format!(\"{}\", s);\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp5keu7rh4.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x /= base;\n    }\n    digits.push(format!(\"{}\", x));\n\
    \    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3arrybwz.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp3arrybwz.rs:19:17\n   |\n19 |     digits.push(format!(\"{}\", x));\n\
    \   |                 ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3arrybwz.rs:20:10\n   |\n20 |     s += digits.clone();\n   |  \
    \        ^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found\
    \ struct `String`\n   |          help: consider borrowing here: `&digits`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut power = 1;\n    let mut i = 0;\n    while i < digits.len() {\n   \
    \     if digits[i] == base[0] {\n            power = power.to_biguint().unwrap();\n\
    \            i += 1;\n        } else {\n            if power > 0 {\n         \
    \       s.push_str(&format!(\"{}{}\", digits[i - power.unwrap()], base));\n  \
    \          } else {\n                s.push_str(&digits[i - power.unwrap()]);\n\
    \            }\n            power = power.to_biguint().unwrap();\n           \
    \ i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp81q24il2.rs:17:12\n\
    \   |\n17 |         if digits[i] == base[0] {\n   |            ^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp81q24il2.rs:17:25\n   |\n17 |         if digits[i] == base[0] {\n\
    \   |                         ^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `to_biguint` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmp81q24il2.rs:18:27\n   |\n18 |          \
    \   power = power.to_biguint().unwrap();\n   |                           ^^^^^^^^^^\
    \ method not found in `{integer}`\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `{integer}` in the current scope\n  --> /tmp/tmp81q24il2.rs:22:62\n\
    \   |\n22 |                 s.push_str(&format!(\"{}{}\", digits[i - power.unwrap()],\
    \ base));\n   |                                                              ^^^^^^\
    \ method not found in `{integer}`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp81q24il2.rs:22:45\n   |\n22 "
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient /= base;\n   \
    \     result.push(remainder);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qh40nvi.rs:17:21\n   |\n\
    17 |         result.push(remainder);\n   |                     ^^^^^^^^^ expected\
    \ `char`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder *= base;\n        remainder %= base;\n        quotient\
    \ /= base;\n        s.push((remainder % base) as char);\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpvt4p2j2n.rs:18:16\n\
    \   |\n18 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpvt4p2j2n.rs:18:16\n   |\n18 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = String::new();\n    while remainder\
    \ > 0 {\n        remainder %= base;\n        digits.push(format!(\"{}\", remainder));\n\
    \    }\n    result.push_str(&digits);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpih17pr29.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x.to_digits();\n    let mut base = base.to_digits();\n    while\
    \ x.len() > 0 {\n        let mut digit = x.remove(0);\n        if digit > base\
    \ {\n            digit -= base;\n            s += digit.to_digits().to_string();\n\
    \        } else {\n            s += digit.to_digits().to_string();\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpnc7hfxj0.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpnc7hfxj0.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        if base == 10 {\n  \
    \          s.push_str(&digits[i..i + 1]);\n            break;\n        }\n   \
    \     let digit = digits[i..i + 1].chars().nth(base).unwrap();\n        s.push_str(&digit);\n\
    \        i += 1;\n        base /= 10;\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmp5wvu7czl.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wvu7czl.rs:20:50\n\
    \   |\n20 |         let digit = digits[i..i + 1].chars().nth(base).unwrap();\n\
    \   |                                                  ^^^^ expected `usize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5wvu7czl.rs:21:20\n\
    \   |\n21 |         s.push_str(&digit);\n   |                    ^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0368]: binary assignment operation `/=`\
    \ cannot be applied to type `String`\n  --> /tmp/tmp5wvu7czl.rs:23:9\n   |\n23\
    \ |         base /= 10;\n   |         ----^^^^^^\n   |         |\n   |       \
    \  cannot use `/=` on type `String`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ bases = base.to_string().chars().collect::<Vec<_>>();\n    let mut bases_len\
    \ = bases.len();\n    let mut digits_len = digits.len();\n    let mut i = 0;\n\
    \    while i < digits_len {\n        if bases_len == 0 {\n            s.push_str(&digits[i\
    \ as usize]);\n            i += 1;\n        } else {\n            let mut base\
    \ = bases[i as usize];\n            let mut digit = digits[i as usize];\n    \
    \        while base > 0 {\n                s.push_str(&digits[i as usize]);\n\
    \                i += 1;\n                base /= bases[i as usize];\n       \
    \     }\n            s.push_str(&digit);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph1k3uutm.rs:19:24\n   |\n\
    19 |             s.push_str(&digits[i as usize]);\n   |                      \
    \  ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph1k3uutm.rs:24:26\n   |\n24 |             while base >\
    \ 0 {\n   |                          ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph1k3uutm.rs:25:28\n   |\n25 |              \
    \   s.push_str(&digits[i as usize]);\n   |                            ^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0368]: binary assignment operation\
    \ `/=` cannot be applied to type `char`\n  --> /tmp/tmph1k3uutm.rs:27:17\n   |\n\
    27 |                 base /= bases[i as usize];\n   |                 ----^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                 |\n   |                 cannot use `/=` on type `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph1k3uutm.rs:29:24\n   |\n29 |\
    \             s.push_str(&digit);\n   |                        ^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    while digits_len > base_len {\n        digits = &digits[digits_len..];\n\
    \        digits_len -= base_len;\n        base_len += base_len;\n    }\n    while\
    \ base_len > digits_len {\n        base = &base[base_len..];\n        base_len\
    \ -= digits_len;\n        digits_len += digits_len;\n    }\n    while digits_len\
    \ > 0 {\n        digits = &digits[digits_len..];\n        digits_len -= base_len;\n\
    \        base_len += base_len;\n    }\n    while base_len > 0 {\n        base\
    \ = &base[base_len..];\n        base_len -= digits_len;\n        digits_len +=\
    \ digits_len;\n    }\n    s += &base;\n    s += &digits;\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpe4vdwjev.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpe4vdwjev.rs:15:29\n\
    \   |\n15 |     let mut base_len = base.length();\n   |                      \
    \       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpe4vdwjev.rs:17:18\n   |\n12 |\
    \     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n17 |         digits = &digits[digits_len..];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n17 |         digits = (&digits[digits_len..]).to_string();\n\
    \   |                  +                     +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe4vdwjev.rs:22:16\n   |\n13 |     let mut base = base.to_string();\n\
    \   |                    ---------------- expected due to this value\n...\n22\
    \ |         base = &base[base_len..];\n   |                ^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n22 |         base = (&base[base_len..]).to_string();\n   |             \
    \   +                 +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe4vdwjev.rs:27:18\n\
    \   |\n12 |     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n27 |         digits = &digits[digits_len..];\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n27 |         digits = (&digits[digits_len..]).to_string();\n\
    \   |                  +                     +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe4vdwjev.rs:32:16\n   |\n13 |     let mut base = base.to_st"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0; base];\n    let mut carry = 0;\n    while x >= base\
    \ {\n        let digit = x % base;\n        digits[digit] += 1;\n        x /=\
    \ base;\n    }\n    while x != 0 {\n        let digit = x % base;\n        digits[digit]\
    \ += 1;\n        x /= base;\n    }\n    for &digit in &digits {\n        if digit\
    \ > 0 {\n            s.push_str(&format!(\"{}\", digit));\n        } else {\n\
    \            s.push_str(&format!(\"{}\", digit - 1));\n        }\n    }\n    if\
    \ carry > 0 {\n        s.push_str(&format!(\"{}\", carry));\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe8aud_ie.rs:12:30\n   |\n\
    12 |     let mut digits = vec![0; base];\n   |                              ^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n12 |     let mut\
    \ digits = vec![0; base.try_into().unwrap()];\n   |                          \
    \        ++++++++++++++++++++\n\nerror[E0277]: the type `[{integer}]` cannot be\
    \ indexed by `isize`\n  --> /tmp/tmpe8aud_ie.rs:16:9\n   |\n16 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror[E0277]: the type `[{integer}]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpe8aud_ie.rs:21:9\n   |\n21 |         digits[digit]\
    \ += 1;\n   |         ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        if base == 10 {\n\
    \            s.push_str(&digits[i..i + 1]);\n            break;\n        }\n \
    \       if base == 8 {\n            s.push_str(&digits[i..i + 1].to_string().rev());\n\
    \            break;\n        }\n        let mut digit = digits[i..i + 1];\n  \
    \      if base == 2 {\n            digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        }\n        let mut digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String>().reverse().collect();\n    \
    \    digit = digit.chars().collect::<String>().reverse().collect();\n        digit\
    \ = digit.chars().collect::<String>().reverse().collect();\n        digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String>().reverse().collect();\n    \
    \    digit = digit.chars().collect::<String>().reverse().collect();\n        digit\
    \ = digit.chars().collect::<String>().reverse().collect();\n        digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String>().reverse().collect();\n    \
    \    digit = digit.chars().collect::<String>().reverse().collect();\n        digit\
    \ = digit.chars().collect::<String>().reverse().collect();\n        digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String>().reverse().collect();\n    \
    \    digit = digit.chars().collect::<String>().reverse().collect();\n        digit\
    \ = digit.chars().collect::<String>().reverse().collect();\n        digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String>().reverse().collect();\n    \
    \    digit = digit.chars().collect::<String>().reverse().collect();\n        digit\
    \ = digit.chars().collect::<String>().reverse().collect();\n        digit = digit.chars().collect::<String>().reverse().collect();\n\
    \        digit = digit.chars().collect::<String\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpus2wfxno.rs:66:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ i < digits.length() {\n   |                               - this delimiter might\
    \ not be properly closed...\n...\n50 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n66 | }\n   |   ^\n\nerror: expected one of `!`,\
    \ `(`, `+`, `,`, `::`, `:`, `<`, `=`, or `>`, found `}`\n  --> /tmp/tmpus2wfxno.rs:50:1\n\
    \   |\n49 |         digit = digit.chars().collect::<String\n   |             \
    \                                  - expected one of 9 possible tokens\n50 | }\n\
    \   | ^ unexpected token\n   |\nhelp: you might have meant to end the type parameters\
    \ here\n   |\n49 |         digit = digit.chars().collect::<String>\n   |     \
    \                                          +\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmpus2wfxno.rs:15:22\n\
    \   |\n15 |     while i < digits.length() {\n   |                      ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ can't compare `String` with `{integer}`\n  --> /tmp/tmpus2wfxno.rs:16:17\n \
    \  |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `{integer}`\n\
    \  --> /tmp/tmpus2wfxno.rs:20:17\n   |\n20 |         if base == 8 {\n   |    \
    \             ^^ no implementation for `String ="
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        result = digit.to_string() + result;\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1mrnd5lj.rs:17:38\n   |\n\
    17 |         result = digit.to_string() + result;\n   |                      \
    \                ^^^^^^\n   |                                      |\n   |   \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                      help: consider borrowing here: `&result`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut basedigits_len = basedigits.len();\n\
    \    let mut basedigits_pow = basedigits_len as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_min = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_min = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_max = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_max = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_max = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_max = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n    let mut basedigits_pow_max = basedigits_pow as isize;\n    let\
    \ mut basedigits_pow_max = basedigits_pow as isize;\n    let mut basedigits_pow_max\
    \ = basedigits_pow as isize;\n    let mut basedigits_pow_max = basedigits_pow\
    \ as isize;\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmraf0okk.rs:10:42\n   |\n\
    10 | fn change_base(x: isize, base: isize) -> String {\n   |    -----------  \
    \                         ^^^^^^ expected struct `String`, found `()`\n   |  \
    \  |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", digit, s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x.to_digits();\n    let mut base = base.to_digits();\n    let\
    \ mut carry = 0;\n    while x.len() > 0 {\n        let digit = x.pop().unwrap();\n\
    \        let mut digit = digit + carry.to_digits().last().unwrap();\n        carry\
    \ = digit / base.last().unwrap();\n        digit = digit % base.last().unwrap();\n\
    \        s.push((digit as char).to_string());\n    }\n    if carry > 0 {\n   \
    \     s.push((carry as char).to_string());\n    }\n    String::from(s)\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpk714spwi.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpk714spwi.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `{integer}` in the current scope\n\
    \  --> /tmp/tmpk714spwi.rs:17:39\n   |\n17 |         let mut digit = digit + carry.to_digits().last().unwrap();\n\
    \   |                                       ^^^^^^^^^ method not found in `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpk714spwi.rs:20:16\n   |\n20 |\
    \         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpk714spwi.rs:23:16\n   |\n23 |         s.push((carry as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0604]: only `u8` can be cast as `char`, not `{integer}`\n\
    \  --> /tmp/tmpk714spwi.rs:23:16\n   |\n23 |         s.push((carry as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpk714spwi.rs:23:16\n   |\n23 |         s.push((carry\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ bases = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < digits.len() {\n        if digits[i] > bases.len() {\n        \
    \    i += 1;\n            continue;\n        }\n        let mut j = i;\n     \
    \   while j < digits.len() && digits[j] == bases.len() {\n            i += 1;\n\
    \            j += 1;\n        }\n        if j > i {\n            s.push_str(&digits[i..j]);\n\
    \            i += j - i;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp3n9hwx0.rs:16:24\n   |\n\
    16 |         if digits[i] > bases.len() {\n   |                        ^^^^^^^^^^^\
    \ expected `char`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3n9hwx0.rs:21:48\n\
    \   |\n21 |         while j < digits.len() && digits[j] == bases.len() {\n   |\
    \                                                ^^^^^^^^^^^ expected `char`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp3n9hwx0.rs:26:24\n\
    \   |\n26 |             s.push_str(&digits[i..j]);\n   |                     \
    \   ^^^^^^^^^^^^^ expected `str`, found slice `[char]`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&[char]`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let digit = digits.remove(0);\n       \
    \ let mut new_digit = digit as isize;\n        if carry > 0 {\n            new_digit\
    \ += carry;\n        }\n        carry = new_digit as isize;\n        if base >\
    \ 10 {\n            base = base.checked_add(1).unwrap();\n        }\n        if\
    \ new_digit > 9 {\n            s.push_str(&base[new_digit as usize].to_string());\n\
    \            base = base.checked_add(1).unwrap();\n        } else {\n        \
    \    s.push_str(&base[new_digit as usize].to_string());\n        }\n    }\n  \
    \  if carry > 0 {\n        s.push_str(&base[carry.checked_add(1).unwrap() as usize].to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpngs4gbx7.rs:22:19\n   |\n\
    22 |         if base > 10 {\n   |                   ^^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<char>`\n              \
    \  found type `{integer}`\n\nerror[E0599]: no method named `checked_add` found\
    \ for struct `Vec<char>` in the current scope\n  --> /tmp/tmpngs4gbx7.rs:23:25\n\
    \   |\n23 |             base = base.checked_add(1).unwrap();\n   |           \
    \              ^^^^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no\
    \ method named `checked_add` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpngs4gbx7.rs:27:25\n   |\n27 |             base = base.checked_add(1).unwrap();\n\
    \   |                         ^^^^^^^^^^^ method not found in `Vec<char>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmplejqmi5s.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x = x / base;\n    }\n    s += String::from(remainder);\n    s += String::from(x);\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmplnmllr7d.rs:17:10\n   |\n17 |     s += String::from(remainder);\n\
    \   |          ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplnmllr7d.rs:17:10\n   |\n17 |\
    \     s += String::from(remainder);\n   |          ^^^^^^^^^^^^^^^^^^^^^^^\n \
    \  |          |\n   |          expected `&str`, found struct `String`\n   |  \
    \        help: consider borrowing here: `&String::from(remainder)`\n\nerror[E0277]:\
    \ the trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmplnmllr7d.rs:18:10\n\
    \   |\n18 |     s += String::from(x);\n   |          ^^^^^^^^^^^^ the trait `From<isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplnmllr7d.rs:18:10\n   |\n18 |     s += String::from(x);\n   |      \
    \    ^^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`, found struct\
    \ `String`\n   |          help: consider borrowing here: `&String::from(x)`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.remove(0).unwrap();\n\
    \        if digit > base {\n            digit -= base;\n            carry += 1;\n\
    \        }\n        s += digit.to_string();\n        if carry > 0 {\n        \
    \    s += &format!(\"{}\", base);\n            carry = 0;\n        }\n    }\n\
    \    if carry > 0 {\n        s += &format!(\"{}\", base);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpoatf2o0w.rs:16:42\n   |\n16 |         let mut digit = digits.remove(0).unwrap();\n\
    \   |                                          ^^^^^^ method not found in `char`\n\
    \nerror[E0277]: `Vec<char>` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpoatf2o0w.rs:23:33\n\
    \   |\n23 |             s += &format!(\"{}\", base);\n   |                   \
    \              ^^^^ `Vec<char>` cannot be formatted with the default formatter\n\
    \   |\n   = help: the trait `std::fmt::Display` is not implemented for `Vec<char>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]:\
    \ `Vec<char>` doesn't implement `std::fmt::Display`\n  --> /tmp/tmpoatf2o0w.rs:28:29\n\
    \   |\n28 |         s += &format!(\"{}\", base);\n   |                       \
    \      ^^^^ `Vec<char>` cannot be formatted with the default formatter\n   |\n\
    \   = help: the trait `std::fmt::Display` is not implemented for `Vec<char>`\n\
    \   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print)\
    \ instead\n   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp56ely50k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient /= base;\n   \
    \     result.push(remainder);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qh40nvi.rs:17:21\n   |\n\
    17 |         result.push(remainder);\n   |                     ^^^^^^^^^ expected\
    \ `char`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpfx5baqsv.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    while power.is_positive()\
    \ {\n        if power % base == 0 {\n            s.push_str(&digits);\n      \
    \      s.push_str(&format!(\"{}\", power));\n            return s;\n        }\n\
    \        power = power.pow(base);\n        digits.push_str(&format!(\"{}\", power));\n\
    \    }\n    s.push_str(&digits);\n    s.push_str(&format!(\"{}\", power));\n \
    \   s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `is_positive` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmpgyxurjd_.rs:14:17\n   |\n14 |     while power.is_positive()\
    \ {\n   |                 ^^^^^^^^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n13 |     let mut power: i32 = 1;\n   |     \
    \    ~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgyxurjd_.rs:20:27\n\
    \   |\n20 |         power = power.pow(base);\n   |                           ^^^^\
    \ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n20 |         power = power.pow(base.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0689.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder *= base;\n        quotient /= base;\n    }\n    while remainder\
    \ > 0 {\n        s.push((remainder % base) as char);\n        remainder /= base;\n\
    \    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpc414wgx9.rs:19:16\n\
    \   |\n19 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpc414wgx9.rs:19:16\n   |\n19 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    while x\
    \ >= base {\n        remainder = x % base;\n        digits.push(format!(\"{}\"\
    , remainder));\n        x /= base;\n    }\n    if x != 0 {\n        digits.push(format!(\"\
    {}\", x));\n    }\n    s += digits.into_owned();\n    s\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsnrb0pph.rs:16:21\n   |\n\
    16 |         digits.push(format!(\"{}\", remainder));\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n   |\n  \
    \ = note: this error originates in the macro `format` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpsnrb0pph.rs:20:21\n   |\n20 |         digits.push(format!(\"{}\"\
    , x));\n   |                     ^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n   |\n   = note: this error originates in the macro `format` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method\
    \ named `into_owned` found for struct `String` in the current scope\n  --> /tmp/tmpsnrb0pph.rs:22:17\n\
    \   |\n22 |     s += digits.into_owned();\n   |                 ^^^^^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        s.push((&mut digits[..]).to_ascii_lowercase()[..]);\n\
    \    }\n    s.push((&mut digits[..]).to_ascii_lowercase()[..]);\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7td688t2.rs:16:16\n   |\n\
    16 |         s.push((&mut digits[..]).to_ascii_lowercase()[..]);\n   |       \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found `str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7td688t2.rs:18:12\n   |\n18 |\
    \     s.push((&mut digits[..]).to_ascii_lowercase()[..]);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = vec![];\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit);\n    }\n    for digit in digits {\n   \
    \     s.push((digit as char).to_string());\n    }\n    String::from(s)\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4k015_ka.rs:20:16\n   |\n\
    20 |         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmp4k015_ka.rs:20:16\n   |\n20 |        \
    \ s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp4k015_ka.rs:20:16\n\
    \   |\n20 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0604.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut base_size = base.len();\n    let mut digits_size = digits.len();\n\
    \    while base_size.abs() > 0 {\n        if digits.len() < base_size.abs() {\n\
    \            result.push_str(&digits[digits_size..]);\n            digits_size\
    \ += base_size.abs();\n        } else {\n            result.push_str(&digits[digits_size..digits_size\
    \ + base_size]);\n            digits_size += base_size;\n        }\n        digits\
    \ = &digits[digits_size..];\n        base_size -= base_size.abs();\n    }\n  \
    \  result.push_str(&digits[digits_size..]);\n    result\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp0jpzrhzp.rs:16:21\n   |\n16 |     while base_size.abs()\
    \ > 0 {\n   |                     ^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `abs` found for type `usize` in the current scope\n  --> /tmp/tmp0jpzrhzp.rs:17:37\n\
    \   |\n17 |         if digits.len() < base_size.abs() {\n   |                \
    \                     ^^^ method not found in `usize`\n\nerror[E0599]: no method\
    \ named `abs` found for type `usize` in the current scope\n  --> /tmp/tmp0jpzrhzp.rs:19:38\n\
    \   |\n19 |             digits_size += base_size.abs();\n   |                \
    \                      ^^^ method not found in `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0jpzrhzp.rs:24:18\n   |\n12 |     let mut digits = x.to_string();\n\
    \   |                      ------------- expected due to this value\n...\n24 |\
    \         digits = &digits[digits_size..];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n24 |         digits = (&digits[digits_size..]).to_string();\n   |     \
    \             +                      +++++++++++++\n\nerror[E0599]: no method\
    \ named `abs` found for type `usize` in the current scope\n  --> /tmp/tmp0jpzrhzp.rs:25:32\n\
    \   |\n25 |         base_size -= base_size.abs();\n   |                      \
    \          ^^^ method not found in `usize`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s.push((remainder as char).to_string());\n\
    \        remainder /= base;\n    }\n    String::from(s)\n}\n\nfn main() {\n  \
    \  let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq1yj115j.rs:16:16\n   |\n\
    16 |         s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpq1yj115j.rs:16:16\n   |\n16 |        \
    \ s.push((remainder as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpq1yj115j.rs:16:16\n   |\n16 |         s.push((remainder as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let digit = quotient % base;\n        remainder = remainder / base;\n\
    \        s = format!(\"{}{}\", digit, s);\n        quotient = quotient / base;\n\
    \    }\n    if remainder > 0 {\n        s = format!(\"{}\", remainder) + s;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyuqh__kz.rs:21:40\n   |\n\
    21 |         s = format!(\"{}\", remainder) + s;\n   |                       \
    \                 ^\n   |                                        |\n   |     \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                        help: consider borrowing here: `&s`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut power = 1;\n    let mut i = 0;\n    while i < digits.len() {\n   \
    \     if digits.chars().nth(i).unwrap() == '0' {\n            power = power.powf(base);\n\
    \        }\n        i += 1;\n    }\n    while power > 1 {\n        power = power.powf(base);\n\
    \        s += digits[digits.len() - 1];\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `powf` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpw_nhzeuz.rs:18:27\n   |\n18 |             power = power.powf(base);\n\
    \   |                           ^^^^\n   |\nhelp: you must specify a type for\
    \ this binding, like `i32`\n   |\n14 |     let mut power: i32 = 1;\n   |     \
    \    ~~~~~~~~~~~~~~\n\nerror[E0689]: can't call method `powf` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmpw_nhzeuz.rs:23:23\n   |\n23 |         power\
    \ = power.powf(base);\n   |                       ^^^^\n   |\nhelp: you must specify\
    \ a type for this binding, like `i32`\n   |\n14 |     let mut power: i32 = 1;\n\
    \   |         ~~~~~~~~~~~~~~\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpw_nhzeuz.rs:24:14\n   |\n24 |         s += digits[digits.len()\
    \ - 1];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0689.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut power = 1;\n    let mut digits_len\
    \ = digits.length();\n    while digits_len > 0 {\n        if digits_len % 2 ==\
    \ 0 {\n            s.push_str(&digits[digits_len / 2]);\n        }\n        let\
    \ mut digits_len = digits_len / 2;\n        if digits_len > 0 {\n            power\
    \ = power / base;\n        }\n        if power > 10 {\n            s.push_str(&format!(\"\
    {}\", power));\n            power = 1;\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmppti4fpg6.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        s.push((&digits[..]).to_string()\
    \ + &base);\n    }\n    s.push((&digits[..]).to_string() + &remainder);\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:16:44\n   |\n\
    16 |         s.push((&digits[..]).to_string() + &base);\n   |                \
    \                            ^^^^^ expected `str`, found `isize`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmponx6v5st.rs:16:16\n   |\n16 |         s.push((&digits[..]).to_string()\
    \ + &base);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:18:40\n\
    \   |\n18 |     s.push((&digits[..]).to_string() + &remainder);\n   |        \
    \                                ^^^^^^^^^^ expected `str`, found `isize`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:18:12\n   |\n18 |\
    \     s.push((&digits[..]).to_string() + &remainder);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as usize;\n    let mut base = base as usize;\n    while x >\
    \ 0 {\n        s += char::from_u32(x as u32).unwrap();\n        x /= base;\n \
    \   }\n    while base > 0 {\n        s += char::from_u32(base as u32).unwrap();\n\
    \        base /= base;\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ydwqg5m.rs:15:14\n   |\n\
    15 |         s += char::from_u32(x as u32).unwrap();\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1ydwqg5m.rs:19:14\n\
    \   |\n19 |         s += char::from_u32(base as u32).unwrap();\n   |         \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let digit = quotient % base;\n        remainder = quotient / base;\n\
    \        result = format!(\"{}{}\", result, digit);\n        quotient = remainder;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmposithcu6.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if base == 0 {\n            s.push_str(&digits[i\
    \ as usize]);\n            break;\n        }\n        if base < 10 {\n       \
    \     s.push_str(&digits[i as usize]);\n            i += 1;\n        } else {\n\
    \            let mut carry = 0;\n            let mut digit = digits[i as usize];\n\
    \            while digit != '0' {\n                let mut digit = digit as usize;\n\
    \                let mut new_digit = digit + carry + 1;\n                if new_digit\
    \ > 9 {\n                    new_digit -= 10;\n                    carry = 1;\n\
    \                } else {\n                    carry = 0;\n                }\n\
    \                s.push_str(&new_digit.to_string());\n                i += 1;\n\
    \            }\n            if carry != 0 {\n                s.push_str(&carry.to_string());\n\
    \            }\n        }\n        base = base.checked_add(1).unwrap();\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<char>` with `{integer}`\n  --> /tmp/tmp_hpuxn1r.rs:16:17\n\
    \   |\n16 |         if base == 0 {\n   |                 ^^ no implementation\
    \ for `Vec<char> == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_hpuxn1r.rs:17:24\n   |\n17 |             s.push_str(&digits[i\
    \ as usize]);\n   |                        ^^^^^^^^^^^^^^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_hpuxn1r.rs:20:19\n\
    \   |\n20 |         if base < 10 {\n   |                   ^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<char>`\n       \
    \         found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_hpuxn1r.rs:21:24\n\
    \   |\n21 |             s.push_str(&digits[i as usize]);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror[E0599]: no\
    \ method named `checked_add` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmp_hpuxn1r.rs:42:21\n   |\n42 |         base = base.checked_add(1).unwrap();\n\
    \   |                     ^^^^^^^^^^^ method not found in `Vec<char>`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ remainder.to_string());\n    }\n    s += digits;\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4xw52qcl.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4xw52qcl.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ remainder.to_string());\n   |                          ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp4xw52qcl.rs:22:10\n   |\n22 |     s += digits;\n   |          ^^^^^^\n\
    \   |          |\n   |          expected `&str`, found struct `String`\n   | \
    \         help: consider borrowing here: `&digits`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        result =\
    \ format!(\"{}{}\", digit, result);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ base.to_string());\n    }\n    s += digits;\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_qzimvw2.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ base.to_string());\n   |                          ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:22:10\n\
    \   |\n22 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        s.push((&digits[..]).to_string()\
    \ + &base);\n    }\n    s.push((&digits[..]).to_string() + &remainder);\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:16:44\n   |\n\
    16 |         s.push((&digits[..]).to_string() + &base);\n   |                \
    \                            ^^^^^ expected `str`, found `isize`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmponx6v5st.rs:16:16\n   |\n16 |         s.push((&digits[..]).to_string()\
    \ + &base);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:18:40\n\
    \   |\n18 |     s.push((&digits[..]).to_string() + &remainder);\n   |        \
    \                                ^^^^^^^^^^ expected `str`, found `isize`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmponx6v5st.rs:18:12\n   |\n18 |\
    \     s.push((&digits[..]).to_string() + &remainder);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ base10_digits = base;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base10_digits;\n        remainder = remainder / base10_digits;\n        digits.push(digit.to_string());\n\
    \    }\n    while base10_digits > 0 {\n        let digit = remainder % base10_digits;\n\
    \        remainder = remainder / base10_digits;\n        digits.push(digit.to_string());\n\
    \        base10_digits -= 1;\n    }\n    for digit in digits {\n        s += digit;\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbd75byi9.rs:18:21\n   |\n\
    18 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpbd75byi9.rs:23:21\n   |\n23 |         digits.push(digit.to_string());\n\
    \   |                     ^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpbd75byi9.rs:26:18\n\
    \   |\n26 |     for digit in digits {\n   |                  ^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = String::new();\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    s += digits.reverse();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyuh_4scz.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `reverse`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpyuh_4scz.rs:19:17\n\
    \   |\n19 |     s += digits.reverse();\n   |                 ^^^^^^^ help: there\
    \ is an associated function with a similar name: `reserve`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut basedigits = digits.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut basedigits_len = basedigits.len();\n\
    \    let mut i = 0;\n    while i < basedigits_len {\n        if basedigits[i]\
    \ > base {\n            basedigits[i] -= base;\n        } else {\n           \
    \ basedigits[i] += base;\n        }\n        i += 1;\n    }\n    s += basedigits.to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptqlmhzu2.rs:17:28\n   |\n\
    17 |         if basedigits[i] > base {\n   |                            ^^^^ expected\
    \ `char`, found `isize`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmptqlmhzu2.rs:18:13\n   |\n18 |     \
    \        basedigits[i] -= base;\n   |             -------------^^^^^^^^\n   |\
    \             |\n   |             cannot use `-=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmptqlmhzu2.rs:20:13\n\
    \   |\n20 |             basedigits[i] += base;\n   |             -------------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `char`\n\nerror[E0599]:\
    \ `Vec<char>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmptqlmhzu2.rs:24:21\n\
    \    |\n24  |       s += basedigits.to_string();\n    |                      \
    \ ^^^^^^^^^ `Vec<char>` cannot be formatted with the default formatter\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<char>:\
    \ std::fmt::Display`\n            which is required by `Vec<char>: ToString`\n\
    \            `[char]: std::fmt::Display`\n            which is required by `[char]:\
    \ ToString`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0368, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        if base < 10 {\n\
    \            s.push_str(&digits[i..i + 1]);\n            i += 1;\n        } else\
    \ {\n            s.push_str(&digits[i..i + base.len()]);\n            i += base.len();\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpha3dvzqf.rs:15:22\n   |\n15 |     while i < digits.length()\
    \ {\n   |                      ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpha3dvzqf.rs:16:19\n\
    \   |\n16 |         if base < 10 {\n   |                   ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                   |\n   |        \
    \           expected struct `String`, found integer\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        result.push((&digits[..]).to_string()\
    \ + &\"0\".to_string());\n    }\n    result.push((&digits[..]).to_string() + &\"\
    0\".to_string());\n    result\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4mkr67ac.rs:16:21\n   |\n\
    16 |         result.push((&digits[..]).to_string() + &\"0\".to_string());\n  \
    \ |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4mkr67ac.rs:18:17\n\
    \   |\n18 |     result.push((&digits[..]).to_string() + &\"0\".to_string());\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = x;\n    let mut\
    \ digits_len = base;\n    while remainder > 0 {\n        remainder %= base;\n\
    \        digits.push((remainder as char).to_string());\n    }\n    while digits_len\
    \ > 0 {\n        digits.push((digits_len as char).to_string());\n        digits_len\
    \ -= 1;\n    }\n    s += digits.clone();\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwh2uqpkg.rs:17:21\n   |\n\
    17 |         digits.push((remainder as char).to_string());\n   |             \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwh2uqpkg.rs:20:21\n   |\n20 |\
    \         digits.push((digits_len as char).to_string());\n   |               \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwh2uqpkg.rs:23:10\n   |\n23 |\
    \     s += digits.clone();\n   |          ^^^^^^^^^^^^^^\n   |          |\n  \
    \ |          expected `&str`, found struct `String`\n   |          help: consider\
    \ borrowing here: `&digits`\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `isize`\n  --> /tmp/tmpwh2uqpkg.rs:17:21\n   |\n17 |         digits.push((remainder\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpwh2uqpkg.rs:17:21\n\
    \   |\n17 |         digits.push((remainder as char).to_string());\n   |      \
    \               ^^^^^^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `isize`\n  --> /tmp/tmpwh2uqpkg.rs:20:21\n   |\n20 |         digits.push((digits_len\
    \ as char).to_string());\n   |                     ^^^^^^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpwh2uqpkg.rs:20:21\n\
    \   |\n20 |         digits.push((digits_len as char).to_string());\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit].to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmps1pohzuh.rs:17:32\n\
    \   |\n17 |         s = format!(\"{}{}\", s, digits[digit].to_string());\n   |\
    \                                ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n\
    \   |\n   = help: the trait `Index<isize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s = format!(\"{}{}\", s, remainder);\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpbjp9y1kn.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remain = x;\n    while remain > 0 {\n        let mut digit = remain;\n\
    \        remain -= digit.pow(base);\n        digit = digit.div(base);\n      \
    \  s += digit.to_string();\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsoktkgw_.rs:15:29\n   |\n\
    15 |         remain -= digit.pow(base);\n   |                             ^^^^\
    \ expected `u32`, found `isize`\n   |\nhelp: you can convert an `isize` to a `u32`\
    \ and panic if the converted value doesn't fit\n   |\n15 |         remain -= digit.pow(base.try_into().unwrap());\n\
    \   |                                 ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `div` found for type `isize` in the current scope\n   --> /tmp/tmpsoktkgw_.rs:16:23\n\
    \    |\n16  |         digit = digit.div(base);\n    |                       ^^^\
    \ method not found in `isize`\n    |\n    = help: items from traits can only be\
    \ used if the trait is in scope\nhelp: the following trait is implemented but\
    \ not in scope; perhaps add a `use` for it:\n    |\n1   | use std::ops::Div;\n\
    \    |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsoktkgw_.rs:17:14\n  \
    \ |\n17 |         s += digit.to_string();\n   |              ^^^^^^^^^^^^^^^^^\n\
    \   |              |\n   |              expected `&str`, found struct `String`\n\
    \   |              help: consider borrowing here: `&digit.to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ base.to_string());\n    }\n    s += digits;\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_qzimvw2.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ base.to_string());\n   |                          ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:22:10\n\
    \   |\n22 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remain = x;\n    while remain > 0 {\n        let mut digit = remain;\n\
    \        remain %= base;\n        digit = digit.to_digit(base);\n        s.push((digit\
    \ as char).to_string());\n    }\n    String::from(s)\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp2qqqywrj.rs:16:23\n   |\n16 |         digit = digit.to_digit(base);\n\
    \   |                       ^^^^^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2qqqywrj.rs:17:16\n   |\n17 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast as `char`,\
    \ not `isize`\n  --> /tmp/tmp2qqqywrj.rs:17:16\n   |\n17 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^ invalid cast\n \
    \  |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmp2qqqywrj.rs:17:16\n\
    \   |\n17 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0604.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    if x > 0 {\n        remainder += x;\n    }\n \
    \   s += &format!(\"{}\", remainder);\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpg3mbwjxy.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_base = digits.chars().nth(digits.len() - base.len());\n   \
    \ let mut digits_base_len = digits_base.len();\n    let mut i = 0;\n    while\
    \ i < digits_base_len {\n        let mut digit = digits_base[i];\n        if digit\
    \ >= '0' && digit <= '9' {\n            digit -= '0';\n        }\n        i +=\
    \ 1;\n        if i >= base.len() {\n            break;\n        }\n        digit\
    \ += base[i] - '0';\n        digits_base[i] = digit;\n    }\n    s += digits;\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpj_ls27jt.rs:15:43\n   |\n15 |     let mut digits_base_len\
    \ = digits_base.len();\n   |                                           ^^^ method\
    \ not found in `Option<char>`\n\nerror[E0608]: cannot index into a value of type\
    \ `Option<char>`\n  --> /tmp/tmpj_ls27jt.rs:18:25\n   |\n18 |         let mut\
    \ digit = digits_base[i];\n   |                         ^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj_ls27jt.rs:26:18\n\
    \   |\n26 |         digit += base[i] - '0';\n   |                  ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `Option<char>`\n\
    \  --> /tmp/tmpj_ls27jt.rs:27:9\n   |\n27 |         digits_base[i] = digit;\n\
    \   |         ^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj_ls27jt.rs:29:10\n\
    \   |\n29 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308, E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let digit = remainder\
    \ % base;\n        remainder = remainder / base;\n        s = format!(\"{}{}\"\
    , s, digit);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp75h09n4q.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        if digits[i] >= base {\n            result.push_str(&digits[i\
    \ .. i + base.len()]);\n            i += base.len();\n        } else {\n     \
    \       result.push_str(&digits[i]);\n            i += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0wpye0_s.rs:16:25\n   |\n\
    16 |         if digits[i] >= base {\n   |                         ^^^^ expected\
    \ `char`, found struct `Vec`\n   |\n   = note: expected type `char`\n        \
    \    found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0wpye0_s.rs:17:29\n\
    \   |\n17 |             result.push_str(&digits[i .. i + base.len()]);\n   | \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ slice `[char]`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&[char]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0wpye0_s.rs:20:29\n\
    \   |\n20 |             result.push_str(&digits[i]);\n   |                   \
    \          ^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note: expected\
    \ reference `&str`\n              found reference `&char`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as u64;\n    let mut base = base as u64;\n    while x >= base\
    \ {\n        s +=\n            format!(\"{:0{}b}\", x % base, base).to_string()[..base];\n\
    \        x /= base;\n    }\n    s +=\n        format!(\"{:0{}b}\", x, base).to_string()[..base];\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpw7qy_xnf.rs:16:25\n\
    \   |\n16 |             format!(\"{:0{}b}\", x % base, base).to_string()[..base];\n\
    \   |                      -  ^ expected `}` in format string\n   |          \
    \            |\n   |                      because of this opening brace\n   |\n\
    \   = note: if you intended to print `{`, you can escape it using `{{`\n\nerror:\
    \ invalid format string: expected `'}'`, found `'{'`\n  --> /tmp/tmpw7qy_xnf.rs:20:21\n\
    \   |\n20 |         format!(\"{:0{}b}\", x, base).to_string()[..base];\n   | \
    \                 -  ^ expected `}` in format string\n   |                  |\n\
    \   |                  because of this opening brace\n   |\n   = note: if you\
    \ intended to print `{`, you can escape it using `{{`\n\nerror: aborting due to\
    \ 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x.to_digits();\n    let mut base = base.to_digits();\n    while\
    \ x.len() > 0 {\n        let mut digit = x.remove(0);\n        if base > 10 {\n\
    \            digit *= base;\n            digit = digit.to_digits();\n        }\n\
    \        s += digit.to_string();\n    }\n    String::from(s)\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpjq132gxu.rs:12:19\n   |\n12 |     let mut x = x.to_digits();\n\
    \   |                   ^^^^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpjq132gxu.rs:13:25\n   |\n13 |     let mut base = base.to_digits();\n\
    \   |                         ^^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.length() {\n        let mut digit = digits[i..].parse::<usize>().unwrap();\n\
    \        if digit < base {\n            digit = digit * base + digit;\n      \
    \  }\n        digit = digit as usize;\n        digit = digit as usize;\n     \
    \   digit = digit as usize;\n        digit = digit as usize;\n        digit =\
    \ digit as usize;\n        digit = digit as usize;\n        digit = digit as usize;\n\
    \        digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as usize;\n        digit = digit as usize;\n \
    \       digit = digit as usize;\n        digit = digit as usize;\n        digit\
    \ = digit as usize;\n        digit = digit as usize;\n        digit = digit as\
    \ usize;\n        digit = digit as u\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpue2aqymv.rs:91:3\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \                                       - unclosed delimiter\n...\n15 |     while\
    \ i < digits.length() {\n   |                               - this delimiter might\
    \ not be properly closed...\n...\n75 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n91 | }\n   |   ^\n\nerror[E0412]: cannot find\
    \ type `u` in this scope\n  --> /tmp/tmpue2aqymv.rs:74:26\n   |\n74 |        \
    \ digit = digit as u\n   |                          ^ help: a builtin type with\
    \ a similar name exists: `u8`\n\nerror[E0599]: no method named `length` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpue2aqymv.rs:15:22\n\
    \   |\n15 |     while i < digits.length() {\n   |                      ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpue2aqymv.rs:17:20\n   |\n17 |         if digit\
    \ < base {\n   |                    ^^^^ expected `usize`, found struct `String`\n\
    \nerror[E0277]: cannot multiply `usize` by `String`\n  --> /tmp/tmpue2aqymv.rs:18:27\n\
    \   |\n18 |             digit = digit * base + digit;\n   |                  \
    \         ^ no implementation for `usize * String`\n   |\n   = help: the trait\
    \ `Mul<String>` is not implemented for `usize`\n   = help: the following other\
    \ types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n    \
    \         <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n      \
    \       <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n          \
    \   <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n             <&'a\
    \ isize as Mul<isize>>\n           and 49 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpue2aqymv.rs:10:42\n   |\n10 | fn change_base(x: isize, base: isize)\
    \ -> String {\n   |    -----------                           ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 6 pre"
  stdout: ''
  timestamp: 1660011299
- exit_code: -1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remain = x;\n    while remain > 0 {\n        let mut digit = remain;\n\
    \        remain %= base;\n        digit += base;\n        s.push_str(&format!(\"\
    {:0>2}\", digit));\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011304
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    let mut i = 0;\n    while i < digits.len() {\n        let digit = digits[i]\
    \ - '0';\n        let mut new_digit = digit;\n        if base > 2 {\n        \
    \    if carry == 0 {\n                new_digit += 1;\n                carry =\
    \ 0;\n            } else {\n                new_digit += carry;\n            \
    \    carry = 0;\n            }\n        }\n        if new_digit > 9 {\n      \
    \      new_digit -= 10;\n            base += 1;\n        }\n        s += base.to_string()\
    \ + &new_digit.to_string();\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpqpevorm4.rs:17:31\n\
    \   |\n17 |         let digit = digits[i] - '0';\n   |                     ---------\
    \ ^ --- char\n   |                     |\n   |                     char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqpevorm4.rs:19:19\n   |\n19 |         if base\
    \ > 2 {\n   |                   ^ expected struct `Vec`, found integer\n   |\n\
    \   = note: expected struct `Vec<char>`\n                found type `{integer}`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Vec<char>`\n\
    \  --> /tmp/tmpqpevorm4.rs:30:13\n   |\n30 |             base += 1;\n   |    \
    \         ----^^^^^\n   |             |\n   |             cannot use `+=` on type\
    \ `Vec<char>`\n\nerror[E0599]: `Vec<char>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmpqpevorm4.rs:32:19\n    |\n32  |           s += base.to_string()\
    \ + &new_digit.to_string();\n    |                     ^^^^^^^^^ `Vec<char>` cannot\
    \ be formatted with the default formatter\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<char>: std::fmt::Display`\n   \
    \         which is required by `Vec<char>: ToString`\n            `[char]: std::fmt::Display`\n\
    \            which is required by `[char]: ToString`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut carry = 0;\n\
    \    while digits.len() > 0 {\n        let mut digit = digits.remove(0);\n   \
    \     if digit < base {\n            carry = 1;\n            digit += 1;\n   \
    \     }\n        if carry != 0 {\n            digit += 1;\n        }\n       \
    \ digits.push(digit);\n    }\n    if carry != 0 {\n        digits.push(carry);\n\
    \    }\n    s += digits.iter().cloned().collect::<String>().to_string();\n   \
    \ s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjx3unmfr.rs:17:20\n   |\n\
    17 |         if digit < base {\n   |                    ^^^^ expected `char`,\
    \ found struct `Vec`\n   |\n   = note: expected type `char`\n            found\
    \ struct `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpjx3unmfr.rs:19:13\n   |\n19 |     \
    \        digit += 1;\n   |             -----^^^^^\n   |             |\n   |  \
    \           cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpjx3unmfr.rs:22:13\n\
    \   |\n22 |             digit += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjx3unmfr.rs:27:21\n   |\n27 |         digits.push(carry);\n\
    \   |                     ^^^^^ expected `char`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjx3unmfr.rs:29:10\n   |\n29 |     s += digits.iter().cloned().collect::<String>().to_string();\n\
    \   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |  \
    \        |\n   |          expected `&str`, found struct `String`\n   |       \
    \   help: consider borrowing here: `&digits.iter().cloned().collect::<String>().to_string()`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base10 = base.to_string();\n\
    \    let mut power = 1;\n    while base10.len() > 0 {\n        if base10.len()\
    \ > 4 {\n            base10 = base10.split_off(4);\n        }\n        if base10.len()\
    \ > 0 {\n            power = power.pow(base10.len());\n        }\n        if base10.len()\
    \ < 4 {\n            base10 = base10.pad(4);\n        }\n        if base10.len()\
    \ == 0 {\n            base10 = \"0\";\n        }\n        if base10.len() == 1\
    \ {\n            base10 = \"1\";\n        }\n        if base10.len() == 2 {\n\
    \            base10 = \"10\";\n        }\n        if base10.len() == 3 {\n   \
    \         base10 = \"100\";\n        }\n        if base10.len() == 4 {\n     \
    \       base10 = \"1000\";\n        }\n        if base10.len() == 5 {\n      \
    \      base10 = \"10000\";\n        }\n        if base10.len() == 6 {\n      \
    \      base10 = \"100000\";\n        }\n        if base10.len() == 7 {\n     \
    \       base10 = \"1000000\";\n        }\n        if base10.len() == 8 {\n   \
    \         base10 = \"10000000\";\n        }\n        if base10.len() == 9 {\n\
    \            base10 = \"100000000\";\n        }\n        if base10.len() == 10\
    \ {\n            base10 = \"1000000000\";\n        }\n        if base10.len()\
    \ == 11 {\n            base10 = \"10000000000\";\n        }\n        if base10.len()\
    \ == 12 {\n            base10 = \"100000000000\";\n        }\n        if base10.len()\
    \ == 13 {\n            base10 = \"1000000000000\";\n        }\n        if base10.len()\
    \ == 14 {\n            base10 = \"10000000000000\";\n        }\n        if base10.len()\
    \ == 15 {\n            base10 = \"100000000000000\";\n        }\n        if base10.len()\
    \ == 16 {\n            base10 = \"1000000000000000\";\n        }\n        if base10.len()\
    \ == 17 {\n            base10 = \"10000000000000000\";\n        }\n        if\
    \ base10.len() == 18 {\n            base10 = \"100000000000000000\";\n       \
    \ }\n        if base10.len() == 19 {\n            base10 = \"1000000000000000000\"\
    ;\n        }\n        if base10.len() == 20 {\n            base10 = \"10000000000000000000\"\
    ;\n        }\n        if base10.len() == 21 {\n            base10 = \"100000000000000000000\"\
    ;\n        }\n        if base10.len() == 22 {\n            base10 = \"1000000000000000000000\"\
    ;\n        }\n        if base10.len() == 23 {\n            base10 = \"10000000000000000000000\"\
    ;\n        }\n        if base10.len() == 24 {\n            base10\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8yhc1l7a.rs:115:3\n\
    \    |\n10  | fn change_base(x: isize, base: isize) -> String {\n    |       \
    \                                          - unclosed delimiter\n...\n15  |  \
    \   while base10.len() > 0 {\n    |                            - unclosed delimiter\n\
    ...\n97  |         if base10.len() == 24 {\n    |                            \
    \   - this delimiter might not be properly closed...\n98  |             base10\n\
    99  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    115 | }\n    |   ^\n\nerror[E0689]: can't call method `pow` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmp8yhc1l7a.rs:20:27\n   |\n20 |             power\
    \ = power.pow(base10.len());\n   |                           ^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n14 |     let mut\
    \ power: i32 = 1;\n   |         ~~~~~~~~~~~~~~\n\nerror[E0599]: no method named\
    \ `pad` found for struct `String` in the current scope\n  --> /tmp/tmp8yhc1l7a.rs:23:29\n\
    \   |\n23 |             base10 = base10.pad(4);\n   |                        \
    \     ^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp8yhc1l7a.rs:26:22\n   |\n13 |     let mut base10 = base.to_string();\n\
    \   |                      ---------------- expected due to this value\n...\n\
    26 |             base10 = \"0\";\n   |                      ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                      |\n   |     \
    \                 expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8yhc1l7a.rs:29:22\n   |\n13 |     let mut base10 = base.to_string();\n\
    \   |                      ---------------- expected due to this value\n...\n\
    29 |             base10 = \"1\";\n   |                      ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                      |\n   |     \
    \                 expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8yhc1l7a.rs:32:22\n   |\n13 |     let mut base10 = base.to_string();\n\
    \   |                      --------"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x as isize;\n    let mut base = base as isize;\n    while x >=\
    \ base {\n        s += &format!(\"{}\", x / base);\n        x %= base;\n    }\n\
    \    s += &format!(\"{}\", x);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"30\"`,\n right: `\"100\"`', /tmp/tmprfcwbtyp.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = vec![0u8; base];\n    let mut carry = 0;\n    for digit\
    \ in x.to_digits().iter() {\n        let digit = digit as usize;\n        digits[digit]\
    \ += carry;\n        carry = 0;\n        if digits[digit] > base {\n         \
    \   digits[digit] -= base;\n            carry = 1;\n        }\n    }\n    for\
    \ digit in digits.iter_mut() {\n        *digit = *digit as usize;\n    }\n   \
    \ s += if carry == 0 {\n        String::from_utf8(digits.iter().cloned().collect())\n\
    \    } else {\n        String::from_utf8(digits.iter().cloned().collect()).into_owned()\n\
    \    };\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpahcwnd8t.rs:12:32\n   |\n\
    12 |     let mut digits = vec![0u8; base];\n   |                             \
    \   ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |     let\
    \ mut digits = vec![0u8; base.try_into().unwrap()];\n   |                    \
    \                ++++++++++++++++++++\n\nerror[E0599]: no method named `to_digits`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmpahcwnd8t.rs:14:20\n\
    \   |\n14 |     for digit in x.to_digits().iter() {\n   |                    ^^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpahcwnd8t.rs:18:28\n\
    \   |\n18 |         if digits[digit] > base {\n   |                          \
    \  ^^^^ expected `u8`, found `isize`\n   |\nhelp: you can convert `digits[digit]`\
    \ from `u8` to `isize`, matching the type of `base`\n   |\n18 |         if isize::from(digits[digit])\
    \ > base {\n   |            ++++++++++++             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpahcwnd8t.rs:19:30\n   |\n19 |             digits[digit]\
    \ -= base;\n   |                              ^^^^ expected `u8`, found `isize`\n\
    \nerror[E0277]: cannot subtract-assign `isize` from `u8`\n  --> /tmp/tmpahcwnd8t.rs:19:27\n\
    \   |\n19 |             digits[digit] -= base;\n   |                         \
    \  ^^ no implementation for `u8 -= isize`\n   |\n   = help: the trait `SubAssign<isize>`\
    \ is not implemented for `u8`\n   = help: the following other types implement\
    \ trait `SubAssign<Rhs>`:\n             <f32 as SubAssign<&f32>>\n           \
    \  <f32 as SubAssign>\n             <f64 as SubAssign<&f64>>\n             <f64\
    \ as SubAssign>\n             <i128 as SubAssign<&i128>>\n             <i128 as\
    \ SubAssign>\n             <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpahcwnd8t.rs:24:18\n\
    \   |\n24 |         *digit = *digit as usize;\n   |         ------   ^^^^^^^^^^^^^^^\
    \ expected `u8`, found `usize`\n   |         |\n   |         expect"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = base;\n    while remainder >\
    \ 0 {\n        if remainder >= digits {\n            s.push_str(&format!(\"{}\"\
    , remainder % digits));\n            remainder /= digits;\n        } else {\n\
    \            s.push_str(&format!(\"0{}\", digits));\n            digits *= base;\n\
    \        }\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate =\
    \ change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to multiply with overflow'', /tmp/tmpppx7a92i.rs:20:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while base.len() > 0 {\n        let digit = digits.chars().nth(base.len()\
    \ - 1).unwrap();\n        s += digit;\n        base.truncate(0);\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0yqajklc.rs:16:14\n   |\n\
    16 |         s += digit;\n   |              ^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s.push((char::from_u32(base).unwrap()).to_string());\n\
    \        base /= base;\n    }\n    s.push((char::from_u32(base).unwrap()).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzyr7on7m.rs:16:32\n   |\n\
    16 |         s.push((char::from_u32(base).unwrap()).to_string());\n   |      \
    \                          ^^^^ expected `u32`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `u32` and panic if the converted value doesn't fit\n\
    \   |\n16 |         s.push((char::from_u32(base.try_into().unwrap()).unwrap()).to_string());\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzyr7on7m.rs:16:16\n   |\n16 |         s.push((char::from_u32(base).unwrap()).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzyr7on7m.rs:19:28\n\
    \   |\n19 |     s.push((char::from_u32(base).unwrap()).to_string());\n   |   \
    \                         ^^^^ expected `u32`, found `isize`\n   |\nhelp: you\
    \ can convert an `isize` to a `u32` and panic if the converted value doesn't fit\n\
    \   |\n19 |     s.push((char::from_u32(base.try_into().unwrap()).unwrap()).to_string());\n\
    \   |                                ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzyr7on7m.rs:19:12\n   |\n19 |     s.push((char::from_u32(base).unwrap()).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    s += &format!(\"{}\", remainder);\n    s += &format!(\"\
    {}\", x);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpjxhtvb4y.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        digits.insert(0, base.to_string());\n\
    \    }\n    while remainder > 0 {\n        remainder -= 1;\n        digits.insert(0,\
    \ base.to_string());\n    }\n    s += digits;\n    s\n}\n\nfn main() {\n    let\
    \ candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"\
    ));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:16:26\n   |\n\
    16 |         digits.insert(0, base.to_string());\n   |                       \
    \   ^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_qzimvw2.rs:20:26\n   |\n20 |         digits.insert(0,\
    \ base.to_string());\n   |                          ^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_qzimvw2.rs:22:10\n\
    \   |\n22 |     s += digits;\n   |          ^^^^^^\n   |          |\n   |    \
    \      expected `&str`, found struct `String`\n   |          help: consider borrowing\
    \ here: `&digits`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = String::new();\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        digits.push(digit.to_string());\n    }\n    digits.push(digits.as_str().unwrap());\n\
    \    s += digits.to_string();\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoi48vnmf.rs:17:21\n   |\n\
    17 |         digits.push(digit.to_string());\n   |                     ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0599]: no method named `unwrap`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpoi48vnmf.rs:19:33\n\
    \   |\n19 |     digits.push(digits.as_str().unwrap());\n   |                 \
    \                ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpoi48vnmf.rs:20:10\n   |\n20 |     s += digits.to_string();\n\
    \   |          ^^^^^^^^^^^^^^^^^^\n   |          |\n   |          expected `&str`,\
    \ found struct `String`\n   |          help: consider borrowing here: `&digits.to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s.push((digit\
    \ as char).to_string());\n    }\n    s.push((remainder as char).to_string());\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpunxmd23o.rs:16:16\n   |\n\
    16 |         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpunxmd23o.rs:18:12\n   |\n18 |     s.push((remainder as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  -->\
    \ /tmp/tmpunxmd23o.rs:16:16\n   |\n16 |         s.push((digit as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32`\
    \ instead (via a `u32`)\n  --> /tmp/tmpunxmd23o.rs:16:16\n   |\n16 |         s.push((digit\
    \ as char).to_string());\n   |                ^^^^^^^^^^^^^^^\n\nerror[E0604]:\
    \ only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmpunxmd23o.rs:18:12\n\
    \   |\n18 |     s.push((remainder as char).to_string());\n   |            ^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmpunxmd23o.rs:18:12\n   |\n18 |     s.push((remainder as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0604.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut digits_len = digits.length();\n    let mut base_len = base.length();\n\
    \    while digits_len > base_len {\n        digits = &digits[digits_len - base_len..digits_len];\n\
    \        base = &base[base_len..base_len + digits_len];\n        digits_len -=\
    \ base_len;\n        base_len += digits_len;\n    }\n    while base_len > digits_len\
    \ {\n        base = &base[base_len - digits_len..base_len];\n        digits_len\
    \ += base_len - digits_len;\n        base_len -= digits_len;\n    }\n    let mut\
    \ digits_len = digits.length();\n    let mut base_len = base.length();\n    while\
    \ digits_len > base_len {\n        digits = &digits[digits_len - base_len..digits_len];\n\
    \        base = &base[base_len..base_len + digits_len];\n        digits_len -=\
    \ base_len;\n        base_len += digits_len;\n    }\n    while base_len > digits_len\
    \ {\n        base = &base[base_len - digits_len..base_len];\n        digits_len\
    \ += base_len - digits_len;\n        base_len -= digits_len;\n    }\n    s +=\
    \ &digits[0..digits_len];\n    s += &base[0..base_len];\n    s\n}\n\nfn main()\
    \ {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpbf0ihxnj.rs:14:33\n   |\n14 |     let mut digits_len\
    \ = digits.length();\n   |                                 ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpbf0ihxnj.rs:15:29\n\
    \   |\n15 |     let mut base_len = base.length();\n   |                      \
    \       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbf0ihxnj.rs:17:18\n   |\n12 |\
    \     let mut digits = x.to_string();\n   |                      -------------\
    \ expected due to this value\n...\n17 |         digits = &digits[digits_len -\
    \ base_len..digits_len];\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n17 |         digits = (&digits[digits_len - base_len..digits_len]).to_string();\n\
    \   |                  +                                          +++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbf0ihxnj.rs:18:16\n   |\n13 |\
    \     let mut base = base.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n18 |         base = &base[base_len..base_len\
    \ + digits_len];\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n18 |         base = (&base[base_len..base_len + digits_len]).to_string();\n\
    \   |                +                                      +++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbf0ihxnj.rs:23:16\n   |\n13 |  \
    \   let mut base = base.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n23 |         base = &base[base_len - digits_len..base_len];\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n23 |        \
    \ base = "
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", s, digit.to_string());\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmpr09z52ob.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remain = x;\n    while remain > 0 {\n        let mut digit = remain;\n\
    \        remain %= base;\n        digit += base;\n        s.push((digit as char).to_string());\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy6rwzvhl.rs:17:16\n   |\n\
    17 |         s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `isize`\n  --> /tmp/tmpy6rwzvhl.rs:17:16\n   |\n17 |        \
    \ s.push((digit as char).to_string());\n   |                ^^^^^^^^^^^^^^^ invalid\
    \ cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmpy6rwzvhl.rs:17:16\n\
    \   |\n17 |         s.push((digit as char).to_string());\n   |               \
    \ ^^^^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0604.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > base {\n        remainder -= base;\n        s.push((&mut digits[..]).to_digit(base).unwrap());\n\
    \    }\n    s.push((&mut digits[..]).to_digit(base).unwrap());\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for mutable reference `&mut\
    \ str` in the current scope\n  --> /tmp/tmpj2wbqr67.rs:16:34\n   |\n16 |     \
    \    s.push((&mut digits[..]).to_digit(base).unwrap());\n   |                \
    \                  ^^^^^^^^ method not found in `&mut str`\n\nerror[E0599]: no\
    \ method named `to_digit` found for mutable reference `&mut str` in the current\
    \ scope\n  --> /tmp/tmpj2wbqr67.rs:18:30\n   |\n18 |     s.push((&mut digits[..]).to_digit(base).unwrap());\n\
    \   |                              ^^^^^^^^ method not found in `&mut str`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut x = x;\n    while x >= base {\n        s +=\n            format!(\"\
    {}\", x % base).to_string().into_owned().to_string();\n        x /= base;\n  \
    \  }\n    s +=\n        format!(\"{}\", x).to_string().into_owned().to_string();\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpsxajjek_.rs:15:49\n   |\n15 |             format!(\"\
    {}\", x % base).to_string().into_owned().to_string();\n   |                  \
    \                               ^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `into_owned` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpsxajjek_.rs:19:38\n   |\n19 |         format!(\"{}\", x).to_string().into_owned().to_string();\n\
    \   |                                      ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = String::new();\n    let mut remainder = 0;\n    let mut\
    \ quotient = 0;\n    let mut remainder_digits = 0;\n    let mut quotient_digits\
    \ = 0;\n    let mut carry = 0;\n\n    while x >= base {\n        remainder = x\
    \ % base;\n        quotient = x / base;\n        digits = quotient.to_string();\n\
    \        remainder_digits = remainder.to_string();\n        quotient_digits =\
    \ digits.len();\n        carry = 1;\n        if quotient_digits > remainder_digits\
    \ {\n            s.push_str(&digits[quotient_digits - remainder_digits]);\n  \
    \          s.push_str(&\"0\");\n        } else {\n            s.push_str(&digits[remainder_digits]);\n\
    \        }\n        x /= base;\n    }\n    if carry != 0 {\n        s.push_str(&\"\
    1\");\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvd481mjr.rs:23:28\n   |\n\
    15 |     let mut remainder_digits = 0;\n   |                                -\
    \ expected due to this value\n...\n23 |         remainder_digits = remainder.to_string();\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^ expected integer, found\
    \ struct `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvd481mjr.rs:27:25\n   |\n27 |             s.push_str(&digits[quotient_digits\
    \ - remainder_digits]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvd481mjr.rs:30:25\n   |\n30 |             s.push_str(&digits[remainder_digits]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut result = String::new();\n\
    \    let mut remainder = 0;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        let remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        result = format!(\"{}{}\", result, remainder);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"001\"`,\n right: `\"100\"`', /tmp/tmp_bskp8en.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = 0;\n    while x >= base {\n        remainder += x % base;\n\
    \        x /= base;\n    }\n    s += &format!(\"{}\", remainder);\n    s += &format!(\"\
    {}\", x);\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `x`\n  --> /tmp/tmpjxhtvb4y.rs:15:9\n\
    \   |\n10 | fn change_base(x: isize, base: isize) -> String {\n   |          \
    \      - help: consider making this binding mutable: `mut x`\n...\n15 |      \
    \   x /= base;\n   |         ^^^^^^^^^ cannot assign to immutable argument\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string().chars().collect::<Vec<_>>();\n    let mut\
    \ base = base.to_string().chars().collect::<Vec<_>>();\n    let mut i = 0;\n \
    \   while i < digits.len() {\n        let mut j = i;\n        while j + 1 < digits.len()\
    \ && digits[j] == digits[j + 1] {\n            j += 1;\n        }\n        if\
    \ j + 1 < digits.len() {\n            digits[j] = digits[j + 1];\n        }\n\
    \        let mut carry = 0;\n        while j + 1 < digits.len() {\n          \
    \  let mut tmp = digits[j] + carry;\n            digits[j] = tmp % base;\n   \
    \         carry = tmp / base;\n            j += 1;\n        }\n        if carry\
    \ > 0 {\n            digits.push(carry);\n        }\n        i += 1;\n    }\n\
    \    digits.reverse();\n    for &d in digits {\n        s += String::from(&d);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpabne0s0l.rs:25:37\n\
    \   |\n25 |             let mut tmp = digits[j] + carry;\n   |               \
    \            --------- ^ ----- {integer}\n   |                           |\n \
    \  |                           char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpabne0s0l.rs:31:25\n\
    \   |\n31 |             digits.push(carry);\n   |                         ^^^^^\
    \ expected `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpabne0s0l.rs:36:9\n\
    \   |\n36 |     for &d in digits {\n   |         ^^    ------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `d`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpabne0s0l.rs:37:14\n   |\n37 |  \
    \       s += String::from(&d);\n   |              ^^^^^^^^^^^^^^^^\n   |     \
    \         |\n   |              expected `&str`, found struct `String`\n   |  \
    \            help: consider borrowing here: `&String::from(&d)`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut base = base;\n    while remainder > 0\
    \ {\n        remainder %= base;\n        s.push((base as char).to_string());\n\
    \        base /= 10;\n    }\n    s.push((base as char).to_string());\n    s\n\
    }\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppaw0fqt2.rs:16:16\n   |\n\
    16 |         s.push((base as char).to_string());\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppaw0fqt2.rs:19:12\n   |\n19 |     s.push((base as char).to_string());\n\
    \   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmppaw0fqt2.rs:16:16\n\
    \   |\n16 |         s.push((base as char).to_string());\n   |                ^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmppaw0fqt2.rs:16:16\n   |\n16 |         s.push((base as char).to_string());\n\
    \   |                ^^^^^^^^^^^^^^\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `isize`\n  --> /tmp/tmppaw0fqt2.rs:19:12\n   |\n19 |     s.push((base\
    \ as char).to_string());\n   |            ^^^^^^^^^^^^^^ invalid cast\n   |\n\
    help: try `char::from_u32` instead (via a `u32`)\n  --> /tmp/tmppaw0fqt2.rs:19:12\n\
    \   |\n19 |     s.push((base as char).to_string());\n   |            ^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut i = 0;\n    while i < digits.len() {\n        if base == 10 {\n  \
    \          s.push_str(&digits[i .. i + 1]);\n            i += 1;\n        } else\
    \ {\n            let mut j = i;\n            while j + 1 < digits.len() && digits[j]\
    \ == digits[j + 1] {\n                j += 1;\n            }\n            s.push_str(&digits[i\
    \ .. j]);\n            i += j - i;\n        }\n        base = base.to_digit(10);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `{integer}`\n  --> /tmp/tmpjltv9li9.rs:16:17\n\
    \   |\n16 |         if base == 10 {\n   |                 ^^ no implementation\
    \ for `String == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjltv9li9.rs:21:43\n   |\n21 |             while j + 1\
    \ < digits.len() && digits[j] == digits[j + 1] {\n   |                       \
    \                    ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjltv9li9.rs:21:56\n\
    \   |\n21 |             while j + 1 < digits.len() && digits[j] == digits[j +\
    \ 1] {\n   |                                                        ^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.len()\
    \ - 1).unwrap();\n        if base < 10 {\n            s.push_str(&digit + &base);\n\
    \        } else {\n            s.push_str(&digit);\n        }\n        digits\
    \ = digits.chars().nth(digits.len() - 1);\n        base = base.chars().nth(base.len()\
    \ - 1);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n  \
    \  assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzix_wbue.rs:16:19\n   |\n\
    16 |         if base < 10 {\n   |                   ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                   |\n   |                   expected\
    \ struct `String`, found integer\n\nerror[E0369]: cannot add `&String` to `&char`\n\
    \  --> /tmp/tmpzix_wbue.rs:17:31\n   |\n17 |             s.push_str(&digit + &base);\n\
    \   |                        ------ ^ ----- &String\n   |                    \
    \    |\n   |                        &char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzix_wbue.rs:19:24\n   |\n19 |             s.push_str(&digit);\n\
    \   |                        ^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzix_wbue.rs:21:18\n   |\n12 |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n21 |         digits = digits.chars().nth(digits.len() - 1);\n  \
    \ |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzix_wbue.rs:22:16\n\
    \   |\n13 |     let mut base = base.to_string();\n   |                    ----------------\
    \ expected due to this value\n...\n22 |         base = base.chars().nth(base.len()\
    \ - 1);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n \
    \               found enum `Option<char>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut base_size = base.len();\n    let mut digits_size = digits.len();\n\
    \    let mut i = 0;\n    while i < digits_size {\n        if digits_size % base\
    \ == 0 {\n            s += &digits[i as usize];\n            i += 1;\n       \
    \ } else {\n            s += &base[digits_size % base_size as usize];\n      \
    \      digits_size /= base_size;\n        }\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"\
    22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot mod `usize` by `String`\n  --> /tmp/tmp0exz4zwl.rs:18:24\n\
    \   |\n18 |         if digits_size % base == 0 {\n   |                       \
    \ ^ no implementation for `usize % String`\n   |\n   = help: the trait `Rem<String>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp0exz4zwl.rs:19:19\n   |\n19 |             s += &digits[i\
    \ as usize];\n   |                   ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0exz4zwl.rs:22:19\n   |\n22 |             s += &base[digits_size\
    \ % base_size as usize];\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n         "
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut bases = base.to_string();\n\
    \    let mut i = 0;\n    while i < digits.size() {\n        let mut digit = digits[i];\n\
    \        if digit >= '0' && digit <= '9' {\n            digit -= '0';\n      \
    \      bases += &base;\n        }\n        s += digit.to_string();\n        i\
    \ += 1;\n    }\n    bases\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp0h9enu8m.rs:15:22\n   |\n15 |     while i < digits.size()\
    \ {\n   |                      ^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmp0h9enu8m.rs:16:25\n\
    \   |\n16 |         let mut digit = digits[i];\n   |                         ^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0h9enu8m.rs:19:22\n\
    \   |\n19 |             bases += &base;\n   |                      ^^^^^ expected\
    \ `str`, found `isize`\n   |\n   = note: expected reference `&str`\n         \
    \     found reference `&isize`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut quotient = x;\n    while quotient > 0\
    \ {\n        remainder = quotient % base;\n        quotient = quotient / base;\n\
    \        s.push((remainder + '0') as char);\n    }\n    String::from(s)\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `char` to `isize`\n  --> /tmp/tmpee4iny9_.rs:17:27\n\
    \   |\n17 |         s.push((remainder + '0') as char);\n   |                 \
    \          ^ no implementation for `isize + char`\n   |\n   = help: the trait\
    \ `Add<char>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n          \
    \   <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n            \
    \ <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a\
    \ i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize\
    \ as Add<isize>>\n           and 48 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 0
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    while remainder > 0 {\n        let mut digit\
    \ = remainder % base;\n        remainder = remainder / base;\n        s = format!(\"\
    {}{}\", digit, s);\n    }\n    s\n}\n\nfn main() {\n    let candidate = change_base;\n\
    \    assert_eq!(candidate(8, 3), String::from(\"22\"));\n    assert_eq!(candidate(9,\
    \ 3), String::from(\"100\"));\n    assert_eq!(candidate(234, 2), String::from(\"\
    11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"10000\"));\n  \
    \  assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660011299
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut remainder = x;\n    let mut digits = base;\n    while remainder >\
    \ 0 {\n        remainder %= base;\n        digits += 1;\n    }\n    while digits\
    \ > 0 {\n        s.push((remainder % base) as char);\n        remainder /= base;\n\
    \        digits -= 1;\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = change_base;\n    assert_eq!(candidate(8, 3), String::from(\"22\"));\n   \
    \ assert_eq!(candidate(9, 3), String::from(\"100\"));\n    assert_eq!(candidate(234,\
    \ 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16, 2), String::from(\"\
    10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"1000\"));\n    assert_eq!(candidate(7,\
    \ 2), String::from(\"111\"));\n    assert_eq!(candidate(2, 3), String::from(\"\
    2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"));\n    assert_eq!(candidate(4,\
    \ 5), String::from(\"4\"));\n    assert_eq!(candidate(5, 6), String::from(\"5\"\
    ));\n    assert_eq!(candidate(6, 7), String::from(\"6\"));\n    assert_eq!(candidate(7,\
    \ 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp8sd9xeit.rs:19:16\n\
    \   |\n19 |         s.push((remainder % base) as char);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmp8sd9xeit.rs:19:16\n   |\n19 |         s.push((remainder % base) as char);\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0604`.\n"
  stdout: ''
  timestamp: 1660011299
- exit_code: 101
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let mut digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", digits, digit.to_string());\n    }\n\
    \    s\n}\n\nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8,\
    \ 3), String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"\
    100\"));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n   \
    \ assert_eq!(candidate(16, 2), String::from(\"10000\"));\n    assert_eq!(candidate(8,\
    \ 2), String::from(\"1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"\
    111\"));\n    assert_eq!(candidate(2, 3), String::from(\"2\"));\n    assert_eq!(candidate(3,\
    \ 4), String::from(\"3\"));\n    assert_eq!(candidate(4, 5), String::from(\"4\"\
    ));\n    assert_eq!(candidate(5, 6), String::from(\"5\"));\n    assert_eq!(candidate(6,\
    \ 7), String::from(\"6\"));\n    assert_eq!(candidate(7, 8), String::from(\"7\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"82\"`,\n right: `\"22\"`', /tmp/tmp56ely50k.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut remainder = x;\n    while remainder\
    \ > 0 {\n        let digit = remainder % base;\n        remainder = remainder\
    \ / base;\n        s = format!(\"{}{}\", s, digits[digit]);\n    }\n    s\n}\n\
    \nfn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `isize`\n  --> /tmp/tmpwbbte1wg.rs:17:32\n\
    \   |\n17 |         s = format!(\"{}{}\", s, digits[digit]);\n   |           \
    \                     ^^^^^^^^^^^^^ `String` cannot be indexed by `isize`\n  \
    \ |\n   = help: the trait `Index<isize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011298
- exit_code: 1
  program: "/// Change numerical base of input number x to base.\n/// return string\
    \ representation after the conversion.\n/// base numbers are less than 10.\n///\
    \ >>> change_base(8, 3)\n/// String::from(\"22\")\n/// >>> change_base(8, 2)\n\
    /// String::from(\"1000\")\n/// >>> change_base(7, 2)\n/// String::from(\"111\"\
    )\nfn change_base(x: isize, base: isize) -> String {\n    let mut s = String::new();\n\
    \    let mut digits = x.to_string();\n    let mut base = base.to_string();\n \
    \   let mut carry = 0;\n    while digits.len() > 0 {\n        let digit = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n        let digit = match digit {\n            '1' => 1,\n \
    \           '0' => 0,\n            _ => panic!(\"Invalid digit {}\", digit),\n\
    \        };\n        let digit = digit * base;\n        let digit = digit + carry;\n\
    \        carry = digit / 10;\n        s = format!(\"{}{}\", s, digit);\n     \
    \   digits = digits.chars().nth(digits.length() - 1).unwrap();\n    }\n    if\
    \ carry != 0 {\n        s = format!(\"{}{}\", s, carry);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = change_base;\n    assert_eq!(candidate(8, 3),\
    \ String::from(\"22\"));\n    assert_eq!(candidate(9, 3), String::from(\"100\"\
    ));\n    assert_eq!(candidate(234, 2), String::from(\"11101010\"));\n    assert_eq!(candidate(16,\
    \ 2), String::from(\"10000\"));\n    assert_eq!(candidate(8, 2), String::from(\"\
    1000\"));\n    assert_eq!(candidate(7, 2), String::from(\"111\"));\n    assert_eq!(candidate(2,\
    \ 3), String::from(\"2\"));\n    assert_eq!(candidate(3, 4), String::from(\"3\"\
    ));\n    assert_eq!(candidate(4, 5), String::from(\"4\"));\n    assert_eq!(candidate(5,\
    \ 6), String::from(\"5\"));\n    assert_eq!(candidate(6, 7), String::from(\"6\"\
    ));\n    assert_eq!(candidate(7, 8), String::from(\"7\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpc8q5idng.rs:16:47\n   |\n16 |         let digit\
    \ = digits.chars().nth(digits.length() - 1).unwrap();\n   |                  \
    \                             ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: cannot multiply `{integer}` by `String`\n\
    \  --> /tmp/tmpc8q5idng.rs:22:27\n   |\n22 |         let digit = digit * base;\n\
    \   |                           ^ no implementation for `{integer} * String`\n\
    \   |\n   = help: the trait `Mul<String>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc8q5idng.rs:26:44\n   |\n26 |         digits = digits.chars().nth(digits.length()\
    \ - 1).unwrap();\n   |                                            ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc8q5idng.rs:26:18\n   |\n12 |     let mut digits\
    \ = x.to_string();\n   |                      ------------- expected due to this\
    \ value\n...\n26 |         digits = digits.chars().nth(digits.length() - 1).unwrap();\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |\n   |\
    \                  expected struct `String`, found `char`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011299
