language: rs
name: HumanEval_40_triples_sum_to_zero
results:
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        sum += i;\n        if sum == 0 {\n            found\
    \ = true;\n            break;\n        }\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn21q5x76.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &x in l {\n        if x == 0 {\n            found = true;\n        } else\
    \ {\n            sum += x;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz3dhy_gq.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |a, b| a || b && (b == 0 ||\
    \ b == -3))\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppyxa5yon.rs:15:38\n   |\n\
    15 |     l.iter().fold(false, |a, b| a || b && (b == 0 || b == -3))\n   |    \
    \                                  ^ expected `bool`, found `&isize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `{integer}`\n  --> /tmp/tmppyxa5yon.rs:15:46\n \
    \  |\n15 |     l.iter().fold(false, |a, b| a || b && (b == 0 || b == -3))\n  \
    \ |                                              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n\
    \  --> /tmp/tmppyxa5yon.rs:15:56\n   |\n15 |     l.iter().fold(false, |a, b| a\
    \ || b && (b == 0 || b == -3))\n   |                                         \
    \               ^^ no implementation for `&isize == {integer}`\n   |\n   = help:\
    \ the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &x in l {\n        sum += x;\n        if sum == 0 {\n            triple\
    \ = true;\n            break;\n        }\n    }\n    triple\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn4r2b73c.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        sum += i;\n        if sum == 0 {\n            triple\
    \ = true;\n            break;\n        }\n    }\n    triple\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiarnt_55.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        sum += i;\n        if sum == 0 {\n            triple\
    \ = true;\n            break;\n        }\n    }\n    triple\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiarnt_55.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            sum += x;\n        } else {\n\
    \            if sum == x {\n                triple = true;\n            } else\
    \ {\n                sum = 0;\n            }\n        }\n    }\n    triple\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2qx119z4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for x in l {\n        sum += x;\n        if sum == 0 {\n            has_three\
    \ = true;\n            break;\n        }\n    }\n    has_three\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpss5m4fqo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| {\n        acc && x.iter().fold(false,\
    \ |acc, y| {\n            acc && y.iter().fold(false, |acc, z| {\n           \
    \     acc + z == 0;\n            })\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmptl3mwj_2.rs:16:18\n   |\n16 |         acc && x.iter().fold(false,\
    \ |acc, y| {\n   |                  ^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for x in l {\n        sum += x;\n        if sum == 0 {\n            has_three\
    \ = true;\n        }\n    }\n    has_three\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpe5bsagmi.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpi6xdul8m.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |sum, el| {\n        match sum\
    \ {\n            true => el > 0,\n            false => el > 0,\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpelf1w4ug.rs:17:26\n   |\n\
    17 |             true => el > 0,\n   |                          ^\n   |      \
    \                    |\n   |                          expected `&isize`, found\
    \ integer\n   |                          help: consider borrowing here: `&0`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpelf1w4ug.rs:18:27\n   |\n18 |\
    \             false => el > 0,\n   |                           ^\n   |       \
    \                    |\n   |                           expected `&isize`, found\
    \ integer\n   |                           help: consider borrowing here: `&0`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        if i != 0 {\n            sum += i;\n            if\
    \ sum == 0 {\n                triple = true;\n            }\n        }\n    }\n\
    \    triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8eytj1j.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    while i\
    \ < l.len() {\n        sum += l[i];\n        if sum == 0 {\n            return\
    \ true;\n        }\n        i += 1;\n    }\n    false\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuzzvbcc8.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpi6xdul8m.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        if l[i] + l[j] + l[k] == 0 {\n            sum += l[i];\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else {\n   \
    \         i += 1;\n            j += 1;\n            k += 1;\n        }\n    }\n\
    \    sum == 0 && k == l.len() - 1\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpv2ph8yih.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        if i == 0 {\n            found = true;\n        } else\
    \ {\n            sum += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdte3lsar.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for i in l.iter() {\n        sum += i;\n        if sum == 0 {\n          \
    \  triple = true;\n            break;\n        }\n    }\n    triple\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkfinr04y.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        if i == 0 {\n            found = true;\n        } else\
    \ {\n            sum += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdte3lsar.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4ymou19r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() {\n        sum += l[i];\n\
    \        if sum == 0 {\n            if j == i {\n                return true;\n\
    \            }\n            i += 1;\n        } else {\n            sum += l[j];\n\
    \            if sum == 0 {\n                if k == j {\n                    return\
    \ true;\n                }\n                j += 1;\n            } else {\n  \
    \              sum += l[k];\n                if sum == 0 {\n                 \
    \   k += 1;\n                } else {\n                    return false;\n   \
    \             }\n            }\n        }\n    }\n    false\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp2q43gd7w.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for el in l {\n        if el > 0 {\n            sum += el;\n        } else\
    \ {\n            if sum == 0 {\n                found = true;\n            }\n\
    \            sum = 0;\n        }\n    }\n    found\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp38c38ub9.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpyus4kalq.rs:15:40\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n   |    \
    \                                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpyus4kalq.rs:15:50\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n   |    \
    \                                              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &x in l {\n        if x == 0 {\n            found = true;\n        } else\
    \ {\n            sum += x;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz3dhy_gq.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    for i in l {\n        if i == 0 {\n            triples_sum_to_zero\
    \ = true;\n            break;\n        }\n        sum += i;\n    }\n    if sum\
    \ == 0 {\n        triples_sum_to_zero = false;\n    }\n    triples_sum_to_zero\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmdi8eg_h.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        sum += l[i];\n        i += 1;\n        j += 1;\n        k += 1;\n\
    \    }\n    sum == 0 && i == l.len() && j == l.len() && k == l.len()\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpg2s54s_u.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum < 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnzevn2vp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for x in l {\n        sum += x;\n        if sum == 0 {\n            has_three\
    \ = true;\n            break;\n        }\n    }\n    has_three\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpss5m4fqo.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        if l[i] + l[j] + l[k] == 0 {\n            sum += l[i];\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else if l[i]\
    \ + l[j] + l[k] > 0 {\n            sum += l[i];\n            i += 1;\n       \
    \ } else {\n            sum += l[j];\n            j += 1;\n        }\n    }\n\
    \    sum == 0 && i == l.len() && j == l.len() && k == l.len()\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpdqnnv38c.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum < 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnzevn2vp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4ymou19r.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| acc && triples_sum_to_zero(vec![x..x+3]))\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeseymhsq.rs:15:70\n   |\n\
    15 |     l.iter().fold(false, |acc, x| acc && triples_sum_to_zero(vec![x..x+3]))\n\
    \   |                                                                      ^^^\n\
    \   |                                                                      |\n\
    \   |                                                                      expected\
    \ `&isize`, found `isize`\n   |                                              \
    \                        help: consider borrowing here: `&(x+3)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeseymhsq.rs:15:67\n   |\n15 |     l.iter().fold(false,\
    \ |acc, x| acc && triples_sum_to_zero(vec![x..x+3]))\n   |                   \
    \                                                ^^^^^^ expected `isize`, found\
    \ struct `std::ops::Range`\n   |\n   = note: expected type `isize`\n         \
    \   found struct `std::ops::Range<&isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        sum += l[i];\n        sum += l[j];\n        sum += l[k];\n      \
    \  i += 1;\n        j += 1;\n        k += 1;\n    }\n    sum == 0 && i != l.len()\
    \ && j != l.len() && k != l.len()\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0nss_s0v.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for i in l {\n        if i == 0 {\n            found = true;\n        } else\
    \ {\n            sum += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpwuav2rw2.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| {\n        acc && x.iter().fold(false,\
    \ |acc, y| {\n            acc && y.iter().fold(false, |acc, z| {\n           \
    \     acc + z == 0;\n            })\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmptl3mwj_2.rs:16:18\n   |\n16 |         acc && x.iter().fold(false,\
    \ |acc, y| {\n   |                  ^^^^ method not found in `&isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        if i == 0 {\n            triple = true;\n        }\
    \ else {\n            sum += i;\n            if sum == 0 {\n                triple\
    \ = true;\n            }\n        }\n    }\n    triple\n}\n\nfn main() {\n   \
    \ let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppdtgj_8z.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for x in l {\n        if x == 0 {\n            found = true;\n        } else\
    \ {\n            sum += x;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxycrze4g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_triple = false;\n\
    \    for x in l {\n        sum += x;\n        if sum == 0 {\n            has_triple\
    \ = true;\n            break;\n        }\n    }\n    has_triple\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp9rmlwyob.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    for &i in l {\n        sum += i;\n        if sum == 0 {\n    \
    \        triples_sum_to_zero = true;\n            break;\n        }\n    }\n \
    \   triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvwcglbm8.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    for i in l {\n        sum += i;\n        if sum == 0 {\n     \
    \       triples_sum_to_zero = true;\n            break;\n        }\n    }\n  \
    \  triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp09m15p4f.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum < 0 {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpnzevn2vp.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbobg1hum.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        sum += l[i];\n        i += 1;\n        sum += l[j];\n        j +=\
    \ 1;\n        sum += l[k];\n        k += 1;\n    }\n    sum == 0 && k == l.len()\
    \ - 1\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpelzb8l4f.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for i in l.iter() {\n        if i != 0 {\n            sum += i;\n        \
    \    if sum == 0 {\n                triple = true;\n            }\n        }\n\
    \    }\n    triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp7uotrcfd.rs:18:14\n\
    \   |\n18 |         if i != 0 {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for i in l {\n        if i == 0 {\n            sum += i;\n        } else {\n\
    \            if sum == 0 {\n                triple = true;\n            } else\
    \ {\n                sum += i;\n            }\n        }\n    }\n    triple\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpcw35pf1t.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        sum += i;\n        if sum == 0 {\n            found\
    \ = true;\n            break;\n        }\n    }\n    found\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn21q5x76.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 3 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmpi6xdul8m.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 3 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples = vec![];\n    let mut triples_sum_to_zero\
    \ = false;\n    for i in l {\n        if triples.contains(&i) {\n            triples.push(i);\n\
    \        } else {\n            triples.push(i);\n            triples_sum_to_zero\
    \ = true;\n        }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmptcvb1072.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    for x in l {\n        sum += x;\n        if sum == 0 {\n     \
    \       triples_sum_to_zero = true;\n            break;\n        }\n    }\n  \
    \  triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpthp_8c6f.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpyus4kalq.rs:15:40\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n   |    \
    \                                    ^^ no implementation for `&isize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpyus4kalq.rs:15:50\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b && x == 0 || x == -x)\n   |    \
    \                                              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for i in l {\n        if i == 0 {\n            sum += i;\n        } else {\n\
    \            if sum == i {\n                triple = true;\n            } else\
    \ {\n                sum = 0;\n            }\n        }\n    }\n    triple\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbo2j9_rb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for &i in l {\n        sum += i;\n        if sum == 0 {\n            has_three\
    \ = true;\n            break;\n        }\n    }\n    has_three\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsu9005qh.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triples_sum_to_zero\
    \ = false;\n    for i in l {\n        sum += i;\n        if sum == 0 {\n     \
    \       triples_sum_to_zero = true;\n            break;\n        }\n    }\n  \
    \  triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpl1di2yna.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut found = false;\n  \
    \  for &i in l {\n        if i == 0 {\n            found = true;\n        } else\
    \ {\n            sum += i;\n        }\n    }\n    found && sum == 0\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdte3lsar.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |acc, x| {\n        if acc {\n\
    \            acc && x.is_zero()\n        } else {\n            acc || x.is_zero()\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpq12tmct0.rs:17:22\n   |\n17 |             acc\
    \ && x.is_zero()\n   |                      ^^^^^^^ method not found in `&isize`\n\
    \nerror[E0599]: no method named `is_zero` found for reference `&isize` in the\
    \ current scope\n  --> /tmp/tmpq12tmct0.rs:19:22\n   |\n19 |             acc ||\
    \ x.is_zero()\n   |                      ^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |a, b| a || b && (a + b == 0))\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_u2vhw7k.rs:15:38\n   |\n\
    15 |     l.iter().fold(false, |a, b| a || b && (a + b == 0))\n   |           \
    \                           ^ expected `bool`, found `&isize`\n\nerror[E0369]:\
    \ cannot add `&isize` to `bool`\n  --> /tmp/tmp_u2vhw7k.rs:15:46\n   |\n15 | \
    \    l.iter().fold(false, |a, b| a || b && (a + b == 0))\n   |               \
    \                             - ^ - &isize\n   |                             \
    \               |\n   |                                            bool\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    for i in\
    \ l.iter() {\n        for j in l.iter() {\n            for k in l.iter() {\n \
    \               if i + j + k == 0 {\n                    triples_sum_to_zero =\
    \ true;\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpxvws2nth.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        sum += l[i];\n        i += 1;\n        j += 1;\n        k += 1;\n\
    \    }\n    sum == 0 && k == l.len() && j == l.len() && i == l.len()\n}\n\nfn\
    \ main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpn81atds_.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &x in l {\n        sum\
    \ += x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08fgcg32.rs:16:9\n   |\n\
    16 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    let mut i = 0;\n    while i < l.len() {\n        sum += l[i];\n\
    \        if sum == 0 {\n            triples_sum_to_zero = true;\n            break;\n\
    \        }\n        i += 1;\n    }\n    triples_sum_to_zero\n}\n\nfn main() {\n\
    \    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3,\
    \ 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpkcef9gxf.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |sum, el| {\n        sum &&\
    \ el == l.iter().fold(0, |sum, el| sum + el)\n    })\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpz_b09fjb.rs:16:19\n\
    \   |\n16 |         sum && el == l.iter().fold(0, |sum, el| sum + el)\n   |  \
    \                 ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &x in l {\n        if x == 0 {\n            triple = true;\n        }\
    \ else {\n            sum += x;\n        }\n    }\n    sum == 0 && triple\n}\n\
    \nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxi9i6v3a.rs:17:9\n   |\n\
    17 |     for &x in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbobg1hum.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 3 && sum == 0\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpk_p71w9_.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |b, x| b && b == x.checked_add(1,\
    \ &b).is_zero())\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \   --> /tmp/tmp8onslzs8.rs:15:45\n    |\n15  |     l.iter().fold(false, |b, x|\
    \ b && b == x.checked_add(1, &b).is_zero())\n    |                           \
    \                  ^^^^^^^^^^^ -  -- supplied 2 arguments\n    |             \
    \                                |\n    |                                    \
    \         expected 1 argument\n    |\nnote: associated function defined here\n\
    \    = note: this error originates in the macro `int_impl` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0599]: no method named\
    \ `is_zero` found for enum `Option` in the current scope\n  --> /tmp/tmp8onslzs8.rs:15:64\n\
    \   |\n15 |     l.iter().fold(false, |b, x| b && b == x.checked_add(1, &b).is_zero())\n\
    \   |                                                                ^^^^^^^ method\
    \ not found in `Option<isize>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for x in l {\n        if x == 0 {\n            triple = true;\n        } else\
    \ {\n            sum += x;\n        }\n        if sum == 3 {\n            return\
    \ true;\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpb2prmwdo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ sum = 0;\n    for i in l {\n        sum += i;\n        if sum == 0 {\n     \
    \       triples_sum_to_zero = true;\n            break;\n        }\n    }\n  \
    \  triples_sum_to_zero\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp09m15p4f.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        if i == 0 {\n            triple = true;\n        }\
    \ else {\n            sum += i;\n            if sum == 3 {\n                triple\
    \ = true;\n            }\n        }\n    }\n    !triple\n}\n\nfn main() {\n  \
    \  let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5,\
    \ 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hx7zbi0.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut has_three = false;\n\
    \    for &i in l {\n        sum += i;\n        if sum == 0 {\n            has_three\
    \ = true;\n            break;\n        }\n    }\n    has_three\n}\n\nfn main()\
    \ {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsu9005qh.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut triples_sum_to_zero = false;\n    let mut\
    \ triples_sum_to_zero_counter = 0;\n    let mut triples_sum_to_zero_counter2 =\
    \ 0;\n    let mut triples_sum_to_zero_counter3 = 0;\n    let mut triples_sum_to_zero_counter4\
    \ = 0;\n    let mut triples_sum_to_zero_counter5 = 0;\n    let mut triples_sum_to_zero_counter6\
    \ = 0;\n    let mut triples_sum_to_zero_counter7 = 0;\n    let mut triples_sum_to_zero_counter8\
    \ = 0;\n    let mut triples_sum_to_zero_counter9 = 0;\n    let mut triples_sum_to_zero_counter10\
    \ = 0;\n    let mut triples_sum_to_zero_counter11 = 0;\n    let mut triples_sum_to_zero_counter12\
    \ = 0;\n    let mut triples_sum_to_zero_counter13 = 0;\n    let mut triples_sum_to_zero_counter14\
    \ = 0;\n    let mut triples_sum_to_zero_counter15 = 0;\n    let mut triples_sum_to_zero_counter16\
    \ = 0;\n    let mut triples_sum_to_zero_counter17 = 0;\n    let mut triples_sum_to_zero_counter18\
    \ = 0;\n    let mut triples_sum_to_zero_counter19 = 0;\n    let mut triples_sum_to_zero_counter20\
    \ = 0;\n    let mut triples_sum_to_zero_counter21 = 0;\n    let mut triples_sum_to_zero_counter22\
    \ = 0;\n    let mut triples_sum_to_zero_counter23 = 0;\n    let mut triples_sum_to_zero_counter24\
    \ = 0;\n    let mut triples_sum_to_zero_counter25 = 0;\n    let mut triples_sum_to_zero_counter26\
    \ = 0;\n    let mut triples_sum_to_zero_counter27 = 0;\n    let mut triples_sum_to_zero_counter28\
    \ = 0;\n    let mut triples_sum_to_zero_counter29 = 0;\n    let mut triples_sum_to_zero_counter30\
    \ = 0;\n    let mut triples_sum_to_zero_counter31 = 0;\n    let mut triples_sum_to_zero_counter32\
    \ = 0;\n    let mut triples_sum_to_zero_counter33 = 0;\n    let mut triples_sum_to_zero_counter34\
    \ = 0;\n    let mut triples_sum_to_zero_counter35 = 0;\n    let mut triples_sum_to_zero_counter36\
    \ = 0;\n    let mut triples_sum_to_zero_counter37 = 0;\n    let mut triples_sum_to_zero_counter38\
    \ = 0;\n    let mut triples_sum_to_zero_counter39 = 0;\n    let mut triples_sum_to_zero_counter40\
    \ = 0;\n    let mut triples_sum_to_zero_counter41 = 0;\n    let mut triples_sum_to_zero_counter42\
    \ = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmplzn3j7k8.rs:59:1\n\
    \   |\n59 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        sum += i;\n        if sum == 0 {\n            triple\
    \ = true;\n        }\n    }\n    triple\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd7bhwooa.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        if i != 0 {\n            sum += i;\n            if\
    \ sum == 0 {\n                triple = true;\n            }\n        }\n    }\n\
    \    triple\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb8eytj1j.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n        if sum == 0 {\n            return true;\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpbobg1hum.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut triple = false;\n \
    \   for &i in l {\n        sum += i;\n        if sum == 0 {\n            triple\
    \ = true;\n        }\n    }\n    triple\n}\n\nfn main() {\n    let candidate =\
    \ triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd7bhwooa.rs:17:9\n   |\n\
    17 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    l.iter().fold(false, |a, b| a && b && (a + b == 0))\n\
    }\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n \
    \   assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n  \
    \  assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100,\
    \ 3, 5, -100]), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3g16x_mg.rs:15:38\n   |\n\
    15 |     l.iter().fold(false, |a, b| a && b && (a + b == 0))\n   |           \
    \                           ^ expected `bool`, found `&isize`\n\nerror[E0369]:\
    \ cannot add `&isize` to `bool`\n  --> /tmp/tmp3g16x_mg.rs:15:46\n   |\n15 | \
    \    l.iter().fold(false, |a, b| a && b && (a + b == 0))\n   |               \
    \                             - ^ - &isize\n   |                             \
    \               |\n   |                                            bool\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() {\n        sum += l[i];\n\
    \        if sum < 0 {\n            i += 1;\n            continue;\n        }\n\
    \        if sum > 0 {\n            j += 1;\n            sum += l[j];\n       \
    \     if sum < 0 {\n                j += 1;\n                sum += l[j];\n  \
    \              if sum < 0 {\n                    k += 1;\n                   \
    \ sum += l[k];\n                }\n            }\n        }\n        i += 1;\n\
    \    }\n    sum == 0 && j == l.len() && k == l.len()\n}\n\nfn main() {\n    let\
    \ candidate = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]),\
    \ false);\n    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 4 but the
    index is 4'', /tmp/tmpfoqrxgj8.rs:27:20

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for &i in l {\n        sum\
    \ += i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppqnoawa0.rs:16:9\n   |\n\
    16 |     for &i in l {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for x in l {\n        sum +=\
    \ x;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp05qdlcgv.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for x in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for x in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        sum += l[i];\n        i += 1;\n        sum += l[j];\n        j +=\
    \ 1;\n        sum += l[k];\n        k += 1;\n    }\n    sum == 0 && i == l.len()\
    \ && j == l.len() && k == l.len()\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzxfkcsc8.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 101
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    while i < l.len() && j < l.len() && k < l.len()\
    \ {\n        if l[i] + l[j] + l[k] == 0 {\n            sum += l[i];\n        \
    \    i += 1;\n            j += 1;\n            k += 1;\n        } else {\n   \
    \         i += 1;\n            j += 1;\n            k += 1;\n        }\n    }\n\
    \    sum == 0 && k == l.len()\n}\n\nfn main() {\n    let candidate = triples_sum_to_zero;\n\
    \    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), true);\n \
    \   assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 9, 7]), true);\n\
    \    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpmrsqitn5.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011546
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
- exit_code: 1
  program: "/// triples_sum_to_zero takes a list of integers as an input.\n/// it\
    \ returns True if there are three distinct elements in the list that\n/// sum\
    \ to zero, and False otherwise.\n/// >>> triples_sum_to_zero(vec![1, 3, 5, 0])\n\
    /// false\n/// >>> triples_sum_to_zero(vec![1, 3, -2, 1])\n/// true\n/// >>> triples_sum_to_zero(vec![1,\
    \ 2, 3, 7])\n/// false\n/// >>> triples_sum_to_zero(vec![2, 4, -5, 3, 9, 7])\n\
    /// true\n/// >>> triples_sum_to_zero(vec![1])\n/// false\nfn triples_sum_to_zero(l:\
    \ Vec<isize>) -> bool {\n    let mut sum = 0;\n    for i in l {\n        sum +=\
    \ i;\n    }\n    sum == 0 && l.len() == 3\n}\n\nfn main() {\n    let candidate\
    \ = triples_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n\
    \    assert_eq!(candidate(vec![1, 3, 5, -1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, -2, 1]), true);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n  \
    \  assert_eq!(candidate(vec![1, 2, 5, 7]), false);\n    assert_eq!(candidate(vec![2,\
    \ 4, -5, 3, 9, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![1,\
    \ 3, 5, -100]), false);\n    assert_eq!(candidate(vec![100, 3, 5, -100]), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `l`\n   --> /tmp/tmp85dxjiqz.rs:19:17\n\
    \    |\n14  | fn triples_sum_to_zero(l: Vec<isize>) -> bool {\n    |         \
    \               - move occurs because `l` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n15  |     let mut sum = 0;\n16  |     for i in l\
    \ {\n    |              - `l` moved due to this implicit call to `.into_iter()`\n\
    ...\n19  |     sum == 0 && l.len() == 3\n    |                 ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n16  |     for i in &l {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011545
