language: rs
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX as isize);\n\
    \    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p <= std::i32::MAX\
    \ as i\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpyg1574zq.rs:50:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n50 |     debug_assert!(p\
    \ <= std::i32::MAX as i\n   |                  ^ unclosed delimiter\n51 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0412]: cannot find type `i` in\
    \ this scope\n  --> /tmp/tmpyg1574zq.rs:50:41\n   |\n50 |     debug_assert!(p\
    \ <= std::i32::MAX as i\n   |                                         ^ help:\
    \ a builtin type with a similar name exists: `i8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyg1574zq.rs:50:5\n   |\n50 | /     debug_assert!(p <= std::i32::MAX\
    \ as i\n51 | | }\n   | |_^ expected `isize`, found `()`\n   |\n   = note: this\
    \ error originates in the macro `debug_assert` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0412.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow2(n);\n    let mut nmod = pow2(p);\n    while nmod\
    \ < npow {\n        nmod += p;\n    }\n    nmod\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmpiqq8xtrd.rs:13:20\n\
    \   |\n13 |     let mut npow = pow2(n);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow2` in this scope\n \
    \ --> /tmp/tmpiqq8xtrd.rs:14:20\n   |\n14 |     let mut nmod = pow2(p);\n   |\
    \                    ^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n\
    \    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX\
    \ as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i16::MAX as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n\
    \    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as isize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u16::MAX as isize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as isize);\n    debug_assert!(p <= std::i16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as isize);\n    debug_assert!(p\
    \ <= std::u32::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as isize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    \n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0bcvw6zk.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n   \
    \ n + (p - 1) * (n - p) % p\n}\n\nfn main() {\n    let candidate = modp;\n   \
    \ assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p <= n'', /tmp/tmpe5fjtkpd.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:16:24\n   |\n16 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:18:24\n   |\n18 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:20:24\n   |\n20 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:22:24\n   |\n22 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:24:24\n   |\n24 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptkop2dtn.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p < std::i32::MAX as isize);\n    debug_assert!(p\
    \ < std::i64::MAX as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n\
    \    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX\
    \ as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p\
    \ < std::isize::MAX as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n\
    \    debug_assert!(p < std::i16::MAX as isize);\n    debug_assert!(p < std::i32::MAX\
    \ as isize);\n    debug_assert!(p < std::i64::MAX as isize);\n    debug_assert!(p\
    \ < std::usize::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::i16::MAX as isize);\n\
    \    debug_assert!(p < std::i32::MAX as isize);\n    debug_assert!(p < std::i64::MAX\
    \ as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p\
    \ < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX as isize);\n\
    \    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p < std::isize::MAX\
    \ as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n    debug_assert!(p\
    \ < std::i16::MAX as isize);\n    debug_assert!(p < std::i32::MAX as isize);\n\
    \    debug_assert!(p < std::i64::MAX as isize);\n    debug_assert!(p < std::usize::MAX\
    \ as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p\
    \ < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n\
    \    debug_assert!(p < std::isize::MAX as \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpz22keriz.rs:49:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n49 |     debug_assert!(p\
    \ < std::isize::MAX as \n   |                  ^ unclosed delimiter\n50 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: expected type, found `<eof>`\n\
    \  --> /tmp/tmpz22keriz.rs:49:39\n   |\n49 |     debug_assert!(p < std::isize::MAX\
    \ as \n   |                                       ^^ expected type\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz22keriz.rs:49:5\n   |\n49 | /     debug_assert!(p\
    \ < std::isize::MAX as \n50 | | }\n   | |_^ expected `isize`, found `()`\n   |\n\
    \   = note: this error originates in the macro `debug_assert` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    let mut result = n;\n    while result > p {\n        result -= p;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmpdvcn6u4t.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if p < 0 {\n        p *= -1;\n    }\n    if p < 2 {\n       \
    \ return n;\n    }\n    if p < 3 {\n        return n;\n    }\n    if p < 4 {\n\
    \        return n;\n    }\n    if p < 5 {\n        return n;\n    }\n    if p\
    \ < 6 {\n        return n;\n    }\n    if p < 7 {\n        return n;\n    }\n\
    \    if p < 8 {\n        return n;\n    }\n    if p < 9 {\n        return n;\n\
    \    }\n    if p < 10 {\n        return n;\n    }\n    if p < 11 {\n        return\
    \ n;\n    }\n    if p < 12 {\n        return n;\n    }\n    if p < 13 {\n    \
    \    return n;\n    }\n    if p < 14 {\n        return n;\n    }\n    if p < 15\
    \ {\n        return n;\n    }\n    if p < 16 {\n        return n;\n    }\n   \
    \ if p < 17 {\n        return n;\n    }\n    if p < 18 {\n        return n;\n\
    \    }\n    if p < 19 {\n        return n;\n    }\n    if p < 20 {\n        return\
    \ n;\n    }\n    if p < 21 {\n        return n;\n    }\n    if p < 22 {\n    \
    \    return n;\n    }\n    if p < 23 {\n        return n;\n    }\n    if p < 24\
    \ {\n        return n;\n    }\n    if p < 25 {\n        return n;\n    }\n   \
    \ if p < 26 {\n        return n;\n    }\n    if p < 27 {\n        return n;\n\
    \    }\n    if p < 28 {\n        return n;\n    }\n    if p < 29 {\n        return\
    \ n;\n    }\n    if p < 30 {\n        return n;\n    }\n    if p < 31 {\n    \
    \    return n;\n    }\n    if p < 32 {\n        return n;\n    }\n    if p < 33\
    \ {\n        return n;\n    }\n    if p < 34 {\n        return n;\n    }\n   \
    \ if p < 35 {\n        return n;\n    }\n    if p < 36 {\n        return n;\n\
    \    }\n    if p < 37 {\n        return n;\n    }\n    if p < 38 {\n        return\
    \ n;\n    }\n    if p < 39 {\n        return n;\n    }\n    if p < 40 {\n    \
    \    return n;\n    }\n    if p < 41 {\n        return n;\n    }\n    if p < 42\
    \ {\n        return n;\n    }\n    if p < 43 {\n        return n;\n    }\n   \
    \ if p < 44 {\n        return n;\n    }\n    if p < 45 {\n        return n;\n\
    \    }\n    if p \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmp30ziib7m.rs:155:1\n    |\n\
    154 |     if p \n    |     -- this `if` expression has a condition, but no block\n\
    155 | }\n    | ^ expected `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n   \
    \ n + (n - p) % n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p <= n'', /tmp/tmpan1iyf70.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    (p / n) as isize\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmpno0__akv.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpo7p7bore.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if p % n == 0 {\n        return p / n;\n    }\n    if p % n ==\
    \ 1 {\n        return modp(n - 1, p) + 1;\n    }\n    if p % n == 2 {\n      \
    \  return modp(n - 2, p) + 1;\n    }\n    if p % n == 3 {\n        return modp(n\
    \ - 3, p) + 1;\n    }\n    if p % n == 4 {\n        return modp(n - 4, p) + 1;\n\
    \    }\n    if p % n == 5 {\n        return modp(n - 5, p) + 1;\n    }\n    if\
    \ p % n == 6 {\n        return modp(n - 6, p) + 1;\n    }\n    if p % n == 7 {\n\
    \        return modp(n - 7, p) + 1;\n    }\n    if p % n == 8 {\n        return\
    \ modp(n - 8, p) + 1;\n    }\n    if p % n == 9 {\n        return modp(n - 9,\
    \ p) + 1;\n    }\n    if p % n == 10 {\n        return modp(n - 10, p) + 1;\n\
    \    }\n    if p % n == 11 {\n        return modp(n - 11, p) + 1;\n    }\n   \
    \ if p % n == 12 {\n        return modp(n - 12, p) + 1;\n    }\n    if p % n ==\
    \ 13 {\n        return modp(n - 13, p) + 1;\n    }\n    if p % n == 14 {\n   \
    \     return modp(n - 14, p) + 1;\n    }\n    if p % n == 15 {\n        return\
    \ modp(n - 15, p) + 1;\n    }\n    if p % n == 16 {\n        return modp(n - 16,\
    \ p) + 1;\n    }\n    if p % n == 17 {\n        return modp(n - 17, p) + 1;\n\
    \    }\n    if p % n == 18 {\n        return modp(n - 18, p) + 1;\n    }\n   \
    \ if p % n == 19 {\n        return modp(n - 19, p) + 1;\n    }\n    if p % n ==\
    \ 20 {\n        return modp(n - 20, p) + 1;\n    }\n    if p % n == 21 {\n   \
    \     return modp(n - 21, p) + 1;\n    }\n    if p % n == 22 {\n        return\
    \ modp(n - 22, p) + 1;\n    }\n    if p % n == 23 {\n        return modp(n - 23,\
    \ p) + 1;\n    }\n    if p % n == 24 {\n        return modp(n - 24, p) + 1;\n\
    \    }\n    if p % n == 25 {\n        return modp(n - 25, p) + 1;\n    }\n   \
    \ if p % n == 26 {\n        return modp(n - 26, p) + 1;\n    }\n    if p % n ==\
    \ 27 {\n        return modp(n - 27, p) + 1;\n    }\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0317]: `if` may be missing an `else` clause\n   --> /tmp/tmpqep0a5bd.rs:100:5\n\
    \    |\n12  |   fn modp(n: isize, p: isize) -> isize {\n    |                \
    \                  ----- expected `isize` because of this return type\n...\n100\
    \ | /     if p % n == 27 {\n101 | |         return modp(n - 27, p) + 1;\n102 |\
    \ |     }\n    | |_____^ expected `isize`, found `()`\n    |\n    = note: `if`\
    \ expressions without `else` evaluate to `()`\n    = help: consider adding an\
    \ `else` block that evaluates to the expected type\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n1 = n;\n    let mut n2 = n;\n    while n2 > p {\n        n1\
    \ -= 1;\n        n2 -= 1;\n    }\n    n1 %= p;\n    n2 %= p;\n    n1\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpdscl7o5y.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p < 64);\n    debug_assert!(p > 0);\n    let mut result\
    \ = n;\n    while result > p {\n        result -= p;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p <= n'', /tmp/tmpo_7k0oh4.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p ==\
    \ 0 || n % p == 0);\n    debug_assert!(p > 0);\n    debug_assert!(p <= std::i32::MAX);\n\
    \    debug_assert!(p <= std::i64::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i16::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::i64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::i16::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= \n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpoku7qubh.rs:55:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n55 |     debug_assert!(p\
    \ <= \n   |                  ^ unclosed delimiter\n56 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected expression, found end of macro arguments\n  -->\
    \ /tmp/tmpoku7qubh.rs:55:23\n   |\n55 |     debug_assert!(p <= \n   |        \
    \               ^ expected expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoku7qubh.rs:14:5\n   |\n14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n   |\n   = note: this error originates in the\
    \ macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoku7qubh.rs:17:24\n \
    \  |\n17 |     debug_assert!(p <= std::i32::MAX);\n   |                      \
    \  ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\nhelp: you can convert an\
    \ `i32` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |\
    \     debug_assert!(p <= std::i32::MAX.try_into().unwrap());\n   |           \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoku7qubh.rs:18:24\n   |\n18 |     debug_assert!(p <= std::i64::MAX);\n\
    \   |                        ^^^^^^^^^^^^^ expected `isize`, found `i64`\n   |\n\
    help: you can convert an `i64` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoku7qubh.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::usize::MAX);\n   |                        ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n19 |     debug_assert!(p <= std::usize::MAX.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatch"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::i64::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::usize::\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpaa6naake.rs:53:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n53 |     debug_assert!(p\
    \ <= std::usize::\n   |                  ^ unclosed delimiter\n54 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror: expected identifier, found `<eof>`\n\
    \  --> /tmp/tmpaa6naake.rs:53:34\n   |\n53 |     debug_assert!(p <= std::usize::\n\
    \   |                                  ^^ expected identifier\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa6naake.rs:16:24\n   |\n16 |     debug_assert!(p\
    \ <= std::i32::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n16 |     debug_assert!(p <= std::i32::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa6naake.rs:17:24\n   |\n17 |     debug_assert!(p\
    \ <= std::u32::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u32`\n   |\nhelp: you can convert a `u32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |     debug_assert!(p <= std::u32::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa6naake.rs:18:24\n   |\n18 |     debug_assert!(p\
    \ <= std::i64::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n18 |     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpaa6naake.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::u64::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u64`\n   |\nhelp: you can convert a `u64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     de"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p < std::i32::MAX as isize);\n    debug_assert!(p <\
    \ std::i64::MAX as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n\
    \    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX\
    \ as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p\
    \ < std::isize::MAX as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n\
    \    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p < std::u16::MAX\
    \ as isize);\n    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p\
    \ < std::u64::MAX as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n\
    \    debug_assert!(p < std::i8::MAX as isize);\n    debug_assert!(p < std::usize::MAX\
    \ as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p\
    \ < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n\
    \    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p < std::i8::MAX\
    \ as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p\
    \ < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX as isize);\n\
    \    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p < std::isize::MAX\
    \ as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n    debug_assert!(p\
    \ < std::usize::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n\
    \    debug_assert!(p < std::u16::MAX as isize);\n\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqph8d8k5.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n % p\n \
    \   }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpo7p7bore.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p <= n);\n    debug_assert!(n == 0 || n == 1);\n  \
    \  debug_assert!(n == 0 || n == 2);\n    debug_assert!(n == 0 || n == 3);\n  \
    \  debug_assert!(n == 0 || n == 4);\n    debug_assert!(n == 0 || n == 5);\n  \
    \  debug_assert!(n == 0 || n == 6);\n    debug_assert!(n == 0 || n == 7);\n  \
    \  debug_assert!(n == 0 || n == 8);\n    debug_assert!(n == 0 || n == 9);\n  \
    \  debug_assert!(n == 0 || n == 10);\n    debug_assert!(n == 0 || n == 11);\n\
    \    debug_assert!(n == 0 || n == 12);\n    debug_assert!(n == 0 || n == 13);\n\
    \    debug_assert!(n == 0 || n == 14);\n    debug_assert!(n == 0 || n == 15);\n\
    \    debug_assert!(n == 0 || n == 16);\n    debug_assert!(n == 0 || n == 17);\n\
    \    debug_assert!(n == 0 || n == 18);\n    debug_assert!(n == 0 || n == 19);\n\
    \    debug_assert!(n == 0 || n == 20);\n    debug_assert!(n == 0 || n == 21);\n\
    \    debug_assert!(n == 0 || n == 22);\n    debug_assert!(n == 0 || n == 23);\n\
    \    debug_assert!(n == 0 || n == 24);\n    debug_assert!(n == 0 || n == 25);\n\
    \    debug_assert!(n == 0 || n == 26);\n    debug_assert!(n == 0 || n == 27);\n\
    \    debug_assert!(n == 0 || n == 28);\n    debug_assert!(n == 0 || n == 29);\n\
    \    debug_assert!(n == 0 || n == 31);\n    debug_assert!(n == 0 || n == 32);\n\
    \    debug_assert!(n == 0 || n == 33);\n    debug_assert!(n == 0 || n == 34);\n\
    \    debug_assert!(n == 0 || n == 35);\n    debug_assert!(n == 0 || n == 36);\n\
    \    debug_assert!(n == 0 || n == 37);\n    debug_assert!(n == 0 || n == 38);\n\
    \    debug_assert!(n == 0 || n == 39);\n    debug_assert!(n == 0 || n == 41);\n\
    \    debug_assert!(n == 0 || n == 42);\n    debug_assert!(n == 0 || n == 43);\n\
    \    debug_assert!(n == 0 || n == 44);\n    debug_assert!(n == 0 || n == 45);\n\
    \    debug_assert!(n == 0 || n == 46);\n    debug_assert!(n == 0 || n == 47);\n\
    \    debug_assert!\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmplb5w0m7e.rs:63:1\n\
    \   |\n62 |     debug_assert!\n   |                  - expected one of `(`, `[`,\
    \ or `{`\n63 | }\n   | ^ unexpected token\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow(n);\n    npow %= p;\n    if npow == 0 {\n        npow\n\
    \    } else {\n        modpow(npow, p)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow` in this scope\n  --> /tmp/tmpgjhxva71.rs:13:20\n\
    \   |\n13 |     let mut npow = pow(n);\n   |                    ^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `modpow` in this scope\n\
    \  --> /tmp/tmpgjhxva71.rs:18:9\n   |\n18 |         modpow(npow, p)\n   |    \
    \     ^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % 2 == 0);\n   \
    \ debug_assert!(n <= p / 2);\n    debug_assert!(n >= p / 2);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n\
    \    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n\
    \    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n\
    \    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n\
    \    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n\
    \    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n\
    \    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n\
    \    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n\
    \    debug_assert!(n % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n\
    \    debug_assert!(n / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ / p == 1);\n    debug_assert!(n % p == 0);\n    debug_assert!(n \n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpfpbjwrnz.rs:67:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n67 |     debug_assert!(n\
    \ \n   |                  ^ unclosed delimiter\n68 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfpbjwrnz.rs:67:5\n\
    \   |\n67 | /     debug_assert!(n \n68 | | }\n   | |_^ expected `bool`, found\
    \ `isize`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfpbjwrnz.rs:67:5\n   |\n67 | /     debug_assert!(n\
    \ \n68 | | }\n   | |_^ expected `isize`, found `()`\n   |\n   = note: this error\
    \ originates in the macro `debug_assert` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut n2 = n * n;\n    while n2 > p {\n        n2 -= p;\n    }\n  \
    \  n2\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `4`,\n right: `3`', /tmp/tmpb2fmxjwv.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmppwb4opi6.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmppwb4opi6.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = n;\n    while res > p {\n        res -= p;\n    }\n   \
    \ res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmphvjw2odk.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(n <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:16:24\n   |\n16 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:18:24\n   |\n18 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:20:24\n   |\n20 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:22:24\n   |\n22 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp90s_acsk.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp90s_acsk.rs:24:24\n   |\n24 |     debug_assert!(n <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpx0erezbp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n == 0 {\n        return 1;\n    }\n    if n == 1 {\n        return\
    \ p;\n    }\n    if p == 1 {\n        return n;\n    }\n    if p == 0 {\n    \
    \    return 0;\n    }\n    if p < n {\n        return modp(n - 1, p) % p;\n  \
    \  }\n    return modp(n, p - 1);\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpplqwt5i_.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n != 0 {\n        if n % p == 0 {\n     \
    \       res += p;\n            n /= p;\n        } else {\n            res += 1;\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpmrq0ya8v.rs:17:13\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n17 |             n /= p;\n   |  \
    \           ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0384`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n - p\n    } else {\n        (p + n) % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1000`,\n right: `2`', /tmp/tmpjzqfui_q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = n;\n    while npow < p {\n        npow *= 2;\n    }\n\
    \    npow % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `3`', /tmp/tmp0eyyuy3a.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p >\
    \ 0);\n    debug_assert!(p < n);\n    debug_assert!(p < std::i32::MAX as isize);\n\
    \    debug_assert!(p < std::i32::MAX as usize);\n    debug_assert!(p < std::i64::MAX\
    \ as isize);\n    debug_assert!(p < std::i64::MAX as usize);\n    debug_assert!(p\
    \ < std::u64::MAX as isize);\n    debug_assert!(p < std::u64::MAX as usize);\n\
    \    debug_assert!(p < std::u128::MAX as isize);\n    debug_assert!(p < std::u128::MAX\
    \ as usize);\n    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p\
    \ < std::usize::MAX as usize);\n    debug_assert!(p < std::i8::MAX as isize);\n\
    \    debug_assert!(p < std::i8::MAX as usize);\n    debug_assert!(p < std::i16::MAX\
    \ as isize);\n    debug_assert!(p < std::i16::MAX as usize);\n    debug_assert!(p\
    \ < std::u16::MAX as isize);\n    debug_assert!(p < std::u16::MAX as usize);\n\
    \    debug_assert!(p < std::i64::MAX as isize);\n    debug_assert!(p < std::i64::MAX\
    \ as usize);\n    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p\
    \ < std::u64::MAX as usize);\n    debug_assert!(p < std::u128::MAX as isize);\n\
    \    debug_assert!(p < std::u128::MAX as usize);\n    debug_assert!(p < std::usize::MAX\
    \ as isize);\n    debug_assert!(p < std::usize::MAX as usize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::i8::MAX as usize);\n \
    \   debug_assert!(p < std::i16::MAX as isize);\n    debug_assert!(p < std::i16::MAX\
    \ as usize);\n    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p\
    \ < std::u16::MAX as usize);\n    debug_assert!(p < std::i64::MAX as isize);\n\
    \    debug_assert!(p < std::i64::MAX as usize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    \n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpspgk45zy.rs:14:5\n   |\n\
    14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \   |\n   = note: this error originates in the macro `debug_assert` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpspgk45zy.rs:18:23\n   |\n18 |     debug_assert!(p < std::i32::MAX\
    \ as usize);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     debug_assert!(p < (std::i32::MAX\
    \ as usize).try_into().unwrap());\n   |                       +              \
    \        +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpspgk45zy.rs:20:23\n\
    \   |\n20 |     debug_assert!(p < std::i64::MAX as usize);\n   |             \
    \          ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n20 |     debug_assert!(p < (std::i64::MAX as usize).try_into().unwrap());\n\
    \   |                       +                      +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpspgk45zy.rs:22:23\n   |\n22 |     debug_assert!(p\
    \ < std::u64::MAX as usize);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |     debug_assert!(p\
    \ < (std::u64::MAX as usize).try_into().unwrap());\n   |                     \
    \  +                      +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpspgk45zy.rs:24:23\n   |\n24 |     debug_assert!(p < std::u128::MAX\
    \ as usize);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n24 |     debug_assert!(p < (std::u128::MAX\
    \ as usize).try_into().unwrap());\n   |                       +         "
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n - p\n    } else {\n        p + n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `8`,\n right: `3`', /tmp/tmp2d65y9of.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p < std::i32::MAX as isize);\n    debug_assert!(p <\
    \ std::i64::MAX as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n\
    \    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX\
    \ as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p\
    \ < std::isize::MAX as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n\
    \    debug_assert!(p < std::i16::MAX as isize);\n    debug_assert!(p < std::i64::MAX\
    \ as isize);\n    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p\
    \ < std::u8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::i16::MAX as isize);\n\
    \    debug_assert!(p < std::i64::MAX as isize);\n    debug_assert!(p < std::usize::MAX\
    \ as isize);\n    debug_assert!(p < std::u8::MAX as isize);\n    debug_assert!(p\
    \ < std::u16::MAX as isize);\n    debug_assert!(p < std::u32::MAX as isize);\n\
    \    debug_assert!(p < std::u64::MAX as isize);\n    debug_assert!(p < std::isize::MAX\
    \ as isize);\n    debug_assert!(p < std::i8::MAX as isize);\n    debug_assert!(p\
    \ < std::i16::MAX as isize);\n    debug_assert!(p < std::i64::MAX as isize);\n\
    \    debug_assert!(p < std::usize::MAX as isize);\n    debug_assert!(p < std::u8::MAX\
    \ as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n    debug_assert!(p\
    \ < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX as isize);\n\
    \    debug_assert!(p < std::isize::MAX as \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpue2s3gw8.rs:49:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n49 |     debug_assert!(p\
    \ < std::isize::MAX as \n   |                  ^ unclosed delimiter\n50 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror: expected type, found `<eof>`\n\
    \  --> /tmp/tmpue2s3gw8.rs:49:39\n   |\n49 |     debug_assert!(p < std::isize::MAX\
    \ as \n   |                                       ^^ expected type\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpue2s3gw8.rs:49:5\n   |\n49 | /     debug_assert!(p\
    \ < std::isize::MAX as \n50 | | }\n   | |_^ expected `isize`, found `()`\n   |\n\
    \   = note: this error originates in the macro `debug_assert` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpx0erezbp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpdqro1atr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!((n % p) == 0);\n    (n / p) as isize\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p <= n'', /tmp/tmpvvh2765f.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpdqro1atr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = p;\n    while npow < n {\n        npow *= p;\n    }\n\
    \    npow % n\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmplmkrz2in.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpdqro1atr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p as isize)\n    } else {\n        n - (p as\
    \ isize)\n    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `-2`,\n right: `3`', /tmp/tmppullkf88.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p >\
    \ 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p\
    \ < 256);\n    debug_assert!(p != 0);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p < 256);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpstqn70y3.rs:14:5\n   |\n\
    14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \   |\n   = note: this error originates in the macro `debug_assert` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpstqn70y3.rs:12:32\n   |\n12 | fn modp(n: isize, p: isize)\
    \ -> isize {\n   |    ----                        ^^^^^ expected `isize`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptkop2dtn.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p ==\
    \ 0 || n % p == 0);\n    debug_assert!(p > 0);\n    debug_assert!(p <= 64);\n\
    \    debug_assert!(p < 64);\n    debug_assert!(p != 1);\n    debug_assert!(p !=\
    \ 2);\n    debug_assert!(p != 4);\n    debug_assert!(p != 8);\n    debug_assert!(p\
    \ != 16);\n    debug_assert!(p != 32);\n    debug_assert!(p != 64);\n    debug_assert!(p\
    \ != 128);\n    debug_assert!(p != 256);\n    debug_assert!(p != 512);\n    debug_assert!(p\
    \ != 1024);\n    debug_assert!(p != 2048);\n    debug_assert!(p != 4096);\n  \
    \  debug_assert!(p != 8192);\n    debug_assert!(p != 16384);\n    debug_assert!(p\
    \ != 32768);\n    debug_assert!(p != 65536);\n    debug_assert!(p != 131072);\n\
    \    debug_assert!(p != 262144);\n    debug_assert!(p != 524288);\n    debug_assert!(p\
    \ != 1048576);\n    debug_assert!(p != 2097152);\n    debug_assert!(p != 4194304);\n\
    \    debug_assert!(p != 8388608);\n    debug_assert!(p != 16777216);\n    debug_assert!(p\
    \ != 33554432);\n    debug_assert!(p != 67108864);\n    debug_assert!(p != 134217728);\n\
    \    debug_assert!(p != 268435456);\n    debug_assert!(p != 536870912);\n    debug_assert!(p\
    \ != 1073741824);\n    debug_assert!(p != -2147483648);\n    debug_assert!(p !=\
    \ -2147483649);\n    debug_assert!(p != -1);\n    debug_assert!(p != -2);\n  \
    \  debug_assert!(p != -4);\n    debug_assert!(p != -8);\n    debug_assert!(p !=\
    \ -16);\n    debug_assert!(p != -32);\n    debug_assert!(p != -64);\n    debug_assert!(p\
    \ != -128);\n    debug_assert!(p != -256);\n    debug_assert!(p != -512);\n  \
    \  debug_assert!(p != -1024);\n    debug_assert!(p != -2048);\n    debug_assert!(p\
    \ != -4096);\n    debug_assert!(p != -8\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpn8bngmcy.rs:65:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n65 |     debug_assert!(p\
    \ != -8\n   |                  ^ unclosed delimiter\n66 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn8bngmcy.rs:14:5\n\
    \   |\n14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `isize`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn8bngmcy.rs:65:5\n   |\n65 | /     debug_assert!(p\
    \ != -8\n66 | | }\n   | |_^ expected `isize`, found `()`\n   |\n   = note: this\
    \ error originates in the macro `debug_assert` (in Nightly builds, run with -Z\
    \ macro-backtrace for more info)\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7ng7798.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmpja952oof.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 1);\n    debug_assert!(n % p == 0);\n    n\
    \ / p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmp1r1vm0oc.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmp7eocbfsw.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(p < std::i32::MAX as\
    \ isize);\n    debug_assert!(p < std::i64::MAX as isize);\n    debug_assert!(p\
    \ < std::usize::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::MAX as isize);\n\
    \    debug_assert!(p < std::u32::MAX as isize);\n    debug_assert!(p < std::u64::MAX\
    \ as isize);\n    debug_assert!(p < std::isize::MAX as isize);\n    debug_assert!(p\
    \ < std::i8::MAX as isize);\n    debug_assert!(p < std::u16::\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpfrh_vnvh.rs:50:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n50 |     debug_assert!(p\
    \ < std::u16::\n   |                  ^ unclosed delimiter\n51 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror: expected identifier, found `<eof>`\n  --> /tmp/tmpfrh_vnvh.rs:50:31\n\
    \   |\n50 |     debug_assert!(p < std::u16::\n   |                           \
    \    ^^ expected identifier\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfrh_vnvh.rs:50:5\n\
    \   |\n50 | /     debug_assert!(p < std::u16::\n51 | | }\n   | |_^ expected `isize`,\
    \ found `()`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    if result > p {\n        result %= p;\n    }\n\
    \    if result < 0 {\n        result += p;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpzp6fn84z.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    n / p\n}\n\nfn main() {\n    let\
    \ candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmppwb4opi6.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p < std::i32::MAX);\n    debug_assert!(p < std::i64::MAX);\n\
    \    debug_assert!(p < std::usize::MAX);\n    debug_assert!(p < std::u16::MAX);\n\
    \    debug_assert!(p < std::u32::MAX);\n    debug_assert!(p < std::u64::MAX);\n\
    \    debug_assert!(p < std::isize::MAX);\n    debug_assert!(p < std::i8::MAX);\n\
    \    debug_assert!(p < std::u16::MAX);\n    debug_assert!(p < std::u32::MAX);\n\
    \    debug_assert!(p < std::u64::MAX);\n    debug_assert!(p < std::isize::MAX);\n\
    \    debug_assert!(p < std::i8::MAX);\n    debug_assert!(p < std::u16::MAX);\n\
    \    debug_assert!(p < std::u32::MAX);\n    debug_assert!(p < std::u64::MAX);\n\
    \    debug_assert!(p < std::isize::MAX);\n    debug_assert!(p < std::i8::MAX);\n\
    \    debug_assert!(p < std::u16::MAX);\n    debug_assert!(p < std::u32::MAX);\n\
    \    debug_assert!(p < std::u64::MAX);\n    debug_assert!(p < std::isize::MAX);\n\
    \    debug_assert!(p < std::i8::MAX);\n    debug_assert!(p < std::u16::MAX);\n\
    \    debug_assert!(p < std::u32::MAX);\n    debug_assert!(p < std::u64::MAX);\n\
    \    debug_assert!(p < std::isize::MAX);\n    debug_assert!(p < std::i8::MAX);\n\
    \    debug_assert!(p < std::u16::MAX);\n    debug_assert!(p < std::u32::MAX);\n\
    \    debug_assert!(p < std::u64::MAX);\n    debug_assert!(p < std::isize::MAX);\n\
    \    debug_assert!(p < std::i8::MAX);\n    debug_assert!(p < std::u16::MAX);\n\
    \    debug_assert!(p < std::u32::MAX);\n    debug_assert!(p < std::u64::MAX);\n\
    \    debug_assert!(p < std::isize::MAX);\n    debug_assert!(p < std::i8::MAX);\n\
    \    debug_assert!(p < std::u16::MAX);\n    debug_assert!(p < std::u32::MAX);\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqoeqc5fu.rs:16:23\n   |\n\
    16 |     debug_assert!(p < std::i32::MAX);\n   |                       ^^^^^^^^^^^^^\
    \ expected `isize`, found `i32`\n   |\nhelp: you can convert an `i32` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |     debug_assert!(p\
    \ < std::i32::MAX.try_into().unwrap());\n   |                                \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqoeqc5fu.rs:17:23\n\
    \   |\n17 |     debug_assert!(p < std::i64::MAX);\n   |                      \
    \ ^^^^^^^^^^^^^ expected `isize`, found `i64`\n   |\nhelp: you can convert an\
    \ `i64` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |\
    \     debug_assert!(p < std::i64::MAX.try_into().unwrap());\n   |            \
    \                        ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqoeqc5fu.rs:18:23\n   |\n18 |     debug_assert!(p < std::usize::MAX);\n\
    \   |                       ^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     debug_assert!(p < std::usize::MAX.try_into().unwrap());\n\
    \   |                                      ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqoeqc5fu.rs:19:23\n   |\n19 |     debug_assert!(p\
    \ < std::u16::MAX);\n   |                       ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |     debug_assert!(p < std::u16::MAX.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqoeqc5fu.rs:20:23\n   |\n20 |     debug_assert!(p\
    \ < std::u32::MAX);\n   |                       ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u32`\n   |\nhelp: you can convert a `u32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n20 |     debug_assert!(p < std::u32::MAX.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerro"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut npow = pow2(n);\n    let mut nmod = pow2(p);\n    while nmod\
    \ < npow {\n        nmod += p;\n        npow *= p;\n    }\n    nmod %= p;\n  \
    \  npow\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `pow2` in this scope\n  --> /tmp/tmpat_cf8xk.rs:13:20\n\
    \   |\n13 |     let mut npow = pow2(n);\n   |                    ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `pow2` in this scope\n \
    \ --> /tmp/tmpat_cf8xk.rs:14:20\n   |\n14 |     let mut nmod = pow2(p);\n   |\
    \                    ^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7ng7798.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(n % p == 0);\n    debug_assert!(n / p >= 1);\n    debug_assert!(n\
    \ / p <= n);\n    debug_assert!(p / n >= 1);\n    debug_assert!(p / n <= p);\n\
    \    debug_assert!(p / n >= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p\
    \ / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n\
    \    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p\
    \ / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n\
    \    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p\
    \ / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n\
    \    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p\
    \ / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n\
    \    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p\
    \ / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n\
    \    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p\
    \ / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n\
    \    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p\
    \ / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n\
    \    debug_assert!(p / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p\
    \ / n <= n);\n    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n\
    \    debug_assert!(p / n <= p);\n    debug_assert!(p / n <= n);\n    debug_assert!(p\
    \ / n <= p);\n    debug_assert!(p / n <= n);\n\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbgt5l5jd.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n % p == 0);\n    n\
    \ + (p - 1) % p\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''assertion failed: p < n'', /tmp/tmp3hlv_ck0.rs:15:5

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p < 64);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 1024);\n    debug_assert!(p < 2048);\n    debug_assert!(p < 4096);\n    debug_assert!(p\
    \ < 8192);\n    debug_assert!(p < 16384);\n    debug_assert!(p < 32768);\n   \
    \ debug_assert!(p < 65536);\n    debug_assert!(p < 131072);\n    debug_assert!(p\
    \ < 262144);\n    debug_assert!(p < 524288);\n    debug_assert!(p < 1048576);\n\
    \    debug_assert!(p < 2097152);\n    debug_assert!(p < 4194304);\n    debug_assert!(p\
    \ < 8388608);\n    debug_assert!(p < 16777216);\n    debug_assert!(p < 33554432);\n\
    \    debug_assert!(p < 67108864);\n    debug_assert!(p < 134217728);\n    debug_assert!(p\
    \ < 268435456);\n    debug_assert!(p < 536870912);\n    debug_assert!(p < 1073741824);\n\
    \    debug_assert!(p < 2147483648);\n    debug_assert!(p < 4294967296);\n    debug_assert!(p\
    \ < 8589934592);\n    debug_assert!(p < 17179869184);\n    debug_assert!(p < 34359738368);\n\
    \    debug_assert!(p < 68719476736);\n    debug_assert!(p < 137438953472);\n \
    \   debug_assert!(p < 274877906944);\n    debug_assert!(p < 549755813888);\n \
    \   debug_assert!(p < 1099511627776);\n    debug_assert!(p < 2199023255552);\n\
    \    debug_assert!(p < 4398046511104);\n    debug_assert!(p < 8796093022208);\n\
    \    debug_assert!(p < 17592186044416);\n    debug_assert!(p < 35184372088832);\n\
    \    debug_assert!(p < 70368744177664);\n    debug_assert!(p < 140737488355328);\n\
    \    debug_assert!(p < 281474976710656);\n    debug_assert!(p < 56294\n}\n\nfn\
    \ main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n \
    \   assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmp_3git72c.rs:57:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n57 |     debug_assert!(p\
    \ < 56294\n   |                  ^ unclosed delimiter\n58 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3git72c.rs:57:5\n\
    \   |\n57 | /     debug_assert!(p < 56294\n58 | | }\n   | |_^ expected `isize`,\
    \ found `()`\n   |\n   = note: this error originates in the macro `debug_assert`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result -= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpk3vu2s5k.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n ^ (p - 1)\n    } else {\n        n & (p - 1)\n\
    \    }\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpdqro1atr.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0cc8vt6.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n > 0);\n    debug_assert!(p > 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    debug_assert!(p < n);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p >= 0);\n    \n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl0cc8vt6.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n - (n % p)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3_xdwhhp.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX as isize);\n    debug_assert!(p\
    \ <= std::i32::MAX as usize);\n    debug_assert!(p <= std::u32::MAX as isize);\n\
    \    debug_assert!(p <= std::u32::MAX as usize);\n    debug_assert!(p <= std::i64::MAX\
    \ as isize);\n    debug_assert!(p <= std::i64::MAX as usize);\n    debug_assert!(p\
    \ <= std::u64::MAX as isize);\n    debug_assert!(p <= std::u64::MAX as usize);\n\
    \    debug_assert!(p <= std::isize::MAX as isize);\n    debug_assert!(p <= std::isize::MAX\
    \ as usize);\n    debug_assert!(p <= std::usize::MAX as isize);\n    debug_assert!(p\
    \ <= std::usize::MAX as usize);\n    debug_assert!(p <= std::i16::MAX as isize);\n\
    \    debug_assert!(p <= std::i16::MAX as usize);\n    debug_assert!(p <= std::u16::MAX\
    \ as isize);\n    debug_assert!(p <= std::u16::MAX as usize);\n    debug_assert!(p\
    \ <= std::i8::MAX as isize);\n    debug_assert!(p <= std::i8::MAX as usize);\n\
    \    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p <= std::u8::MAX\
    \ as usize);\n    debug_assert!(p <= std::i64::MAX as isize);\n    debug_assert!(p\
    \ <= std::i64::MAX as usize);\n    debug_assert!(p <= std::u64::MAX as isize);\n\
    \    debug_assert!(p <= std::u64::MAX as usize);\n    debug_assert!(p <= std::isize::MAX\
    \ as isize);\n    debug_assert!(p <= std::isize::MAX as usize);\n    debug_assert!(p\
    \ <= std::usize::MAX as isize);\n    debug_assert!(p <= std::usize::MAX as usize);\n\
    \    debug_assert!(p <= std::i8::MAX as isize);\n    debug_assert!(p <= std::i8::MAX\
    \ as usize);\n    debug_assert!(p <= std::u8::MAX as isize);\n    debug_assert!(p\
    \ <= std::u8::MAX as usize);\n    debug_assert!(p <= std::i16::MAX as isize);\n\
    \    debug_assert!(p <= std::i16::MAX\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpnndutiqd.rs:49:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n49 |     debug_assert!(p\
    \ <= std::i16::MAX\n   |                  ^ unclosed delimiter\n50 | }\n   | ^\
    \ mismatched closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnndutiqd.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= std::i32::MAX as usize);\n   |            \
    \            ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n17 |     debug_assert!(p <= (std::i32::MAX as usize).try_into().unwrap());\n\
    \   |                        +                      +++++++++++++++++++++\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnndutiqd.rs:19:24\n   |\n19 |  \
    \   debug_assert!(p <= std::u32::MAX as usize);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     debug_assert!(p\
    \ <= (std::u32::MAX as usize).try_into().unwrap());\n   |                    \
    \    +                      +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnndutiqd.rs:21:24\n   |\n21 |     debug_assert!(p <= std::i64::MAX\
    \ as usize);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     debug_assert!(p <= (std::i64::MAX\
    \ as usize).try_into().unwrap());\n   |                        +             \
    \         +++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnndutiqd.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= std::u64::MAX as usize);\n   |            \
    \            ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n23 |     debug_assert!(p <= (std::u64::M"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p\
    \ <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <=\
    \ MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n\
    \    debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n  \
    \  debug_assert!(p <= MAX_DIGITS);\n    debug_assert!(p <= MAX_DIGITS);\n    \n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:15:24\n\
    \   |\n15 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:16:24\n   |\n16 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:17:24\n\
    \   |\n17 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:18:24\n   |\n18 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:19:24\n\
    \   |\n19 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:20:24\n   |\n20 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:21:24\n\
    \   |\n21 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:22:24\n   |\n22 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_DIGITS` in this scope\n  --> /tmp/tmp6ebmt0g_.rs:23:24\n\
    \   |\n23 |     debug_assert!(p <= MAX_DIGITS);\n   |                        ^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_DIGITS` in this\
    \ scope\n  --> /tmp/tmp6ebmt0g_.rs:24:24\n   |\n24 |     debug_assert!(p <= MAX_DIGITS);\n\
    \   |                        ^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `MAX_D"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n\n    } else {\n        n % p\n    }\n}\n\nfn main()\
    \ {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmpf98xlwfz.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n >= p {\n        n - p\n    } else {\n        (p + n) % p\n    }\n\
    }\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1000`,\n right: `2`', /tmp/tmpjzqfui_q.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p && result % p != 0 {\n    \
    \    result /= p;\n    }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `2`', /tmp/tmp9f9t_5i5.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        n + (p - 1)\n    } else {\n        n\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1101`,\n right: `2`', /tmp/tmp79lsam6s.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut result = n;\n    while result > p {\n        result -= p;\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `91`,\n right: `2`', /tmp/tmpx0erezbp.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    if n < 0 {\n        p\n    } else {\n        n & (p - 1)\n    }\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmpbg8h8ln0.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p <= std::i32::MAX);\n    debug_assert!(p <= std::i64::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::u8::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32::MAX);\n\
    \    debug_assert!(p <= std::u64::MAX);\n    debug_assert!(p <= std::isize::MAX);\n\
    \    debug_assert!(p <= std::usize::MAX);\n    debug_assert!(p <= std::i8::MAX);\n\
    \    debug_assert!(p <= std::u8::MAX);\n    debug_assert!(p <= std::u16::MAX);\n\
    \    debug_assert!(p <= std::u32::MAX);\n    debug_assert!(p <= std::u64::MAX);\n\
    \    debug_assert!(p <= std::isize::MAX);\n    debug_assert!(p <= std::usize::MAX);\n\
    \    debug_assert!(p <= std::i8::MAX);\n    debug_assert!(p <= std::u8::MAX);\n\
    \    debug_assert!(p <= std::u16::MAX);\n    debug_assert!(p <= std::u32\n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpgat1uvh9.rs:55:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n55 |     debug_assert!(p\
    \ <= std::u32\n   |                  ^ unclosed delimiter\n56 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0423]: expected value, found module `std::u32`\n\
    \  --> /tmp/tmpgat1uvh9.rs:55:24\n   |\n55 |     debug_assert!(p <= std::u32\n\
    \   |                        ^^^^^^^^ not a value\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgat1uvh9.rs:16:24\n   |\n16 |     debug_assert!(p <= std::i32::MAX);\n\
    \   |                        ^^^^^^^^^^^^^ expected `isize`, found `i32`\n   |\n\
    help: you can convert an `i32` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n16 |     debug_assert!(p <= std::i32::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgat1uvh9.rs:17:24\n   |\n17 |     debug_assert!(p\
    \ <= std::i64::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `i64`\n   |\nhelp: you can convert an `i64` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n17 |     debug_assert!(p <= std::i64::MAX.try_into().unwrap());\n\
    \   |                                     ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgat1uvh9.rs:18:24\n   |\n18 |     debug_assert!(p\
    \ <= std::usize::MAX);\n   |                        ^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n18 |     debug_assert!(p <= std::usize::MAX.try_into().unwrap());\n\
    \   |                                       ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgat1uvh9.rs:19:24\n   |\n19 |     debug_assert!(p\
    \ <= std::u16::MAX);\n   |                        ^^^^^^^^^^^^^ expected `isize`,\
    \ found `u16`\n   |\nhelp: you can convert a `u16` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n19 |   "
  stdout: ''
  timestamp: 1660011665
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p % 2 == 0);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n\
    \ >= p);\n    debug_assert!(n % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n\
    \ % p == 0);\n    debug_assert!(n >= p);\n    debug_assert!(n % p == 0);\n   \
    \ debug_assert!(n >= p);\n    debug_assert\n}\n\nfn main() {\n    let candidate\
    \ = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found macro `debug_assert`\n  --> /tmp/tmplm1vgn3q.rs:73:5\n\
    \   |\n73 |     debug_assert\n   |     ^^^^^^^^^^^^ not a value\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0423`.\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ < n);\n    debug_assert!(p < 64);\n    debug_assert!(p < 256);\n    debug_assert!(p\
    \ < 65536);\n    debug_assert!(p < 16777216);\n    debug_assert!(p < 4294967296);\n\
    \    debug_assert!(p < 18446744073709551616);\n    debug_assert!(p < 4294967296u);\n\
    \    debug_assert!(p < 18446744073709551616u);\n    debug_assert!(p < 4294967296u8);\n\
    \    debug_assert!(p < 18446744073709551616u8);\n    debug_assert!(p < 4294967296u16);\n\
    \    debug_assert!(p < 18446744073709551616u16);\n    debug_assert!(p < 4294967296u32);\n\
    \    debug_assert!(p < 18446744073709551616u32);\n    debug_assert!(p < 4294967296u64);\n\
    \    debug_assert!(p < 18446744073709551616u64);\n    debug_assert!(p < 4294967296usize);\n\
    \    debug_assert!(p < 18446744073709551616usize);\n    debug_assert!(p < 4294967296u8);\n\
    \    debug_assert!(p < 18446744073709551616u8);\n    debug_assert!(p < 4294967296u16);\n\
    \    debug_assert!(p < 18446744073709551616u16);\n    debug_assert!(p < 4294967296u32);\n\
    \    debug_assert!(p < 18446744073709551616u32);\n    debug_assert!(p < 4294967296u64);\n\
    \    debug_assert!(p < 18446744073709551616u64);\n    debug_assert!(p < 4294967296usize);\n\
    \    debug_assert!(p < 18446744073709551616usize);\n    debug_assert!(p < 4294967296u8);\n\
    \    debug_assert!(p < 18446744073709551616u8);\n    debug_assert!(p < 4294967296u16);\n\
    \    debug_assert!(p < 18446744073709551616u16);\n    debug_assert!(p \n}\n\n\
    fn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n\
    \    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n\
    \    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n\
    \    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpgqybvkqa.rs:48:18\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n48 |     debug_assert!(p\
    \ \n   |                  ^ unclosed delimiter\n49 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: invalid suffix `u` for number literal\n  --> /tmp/tmpgqybvkqa.rs:22:23\n\
    \   |\n22 |     debug_assert!(p < 4294967296u);\n   |                       ^^^^^^^^^^^\
    \ invalid suffix `u`\n   |\n   = help: the suffix must be one of the numeric types\
    \ (`u32`, `isize`, `f32`, etc.)\n\nerror: invalid suffix `u` for number literal\n\
    \  --> /tmp/tmpgqybvkqa.rs:23:23\n   |\n23 |     debug_assert!(p < 18446744073709551616u);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^ invalid suffix `u`\n   |\n \
    \  = help: the suffix must be one of the numeric types (`u32`, `isize`, `f32`,\
    \ etc.)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqybvkqa.rs:24:23\n \
    \  |\n24 |     debug_assert!(p < 4294967296u8);\n   |                       ^^^^^^^^^^^^\
    \ expected `isize`, found `u8`\n   |\nhelp: change the type of the numeric literal\
    \ from `u8` to `isize`\n   |\n24 |     debug_assert!(p < 4294967296isize);\n \
    \  |                                 ~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgqybvkqa.rs:25:23\n   |\n25 |     debug_assert!(p < 18446744073709551616u8);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `u8`\n\
    \   |\nhelp: change the type of the numeric literal from `u8` to `isize`\n   |\n\
    25 |     debug_assert!(p < 18446744073709551616isize);\n   |                 \
    \                          ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgqybvkqa.rs:26:23\n\
    \   |\n26 |     debug_assert!(p < 4294967296u16);\n   |                      \
    \ ^^^^^^^^^^^^^ expected `isize`, found `u16`\n   |\nhelp: change the type of\
    \ the numeric literal from `u16` to `isize`\n   |\n26 |     debug_assert!(p <\
    \ 4294967296isize);\n   |                                 ~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqybvkqa.rs:27:23\n   |\n27 |     debug_"
  stdout: ''
  timestamp: 1660011665
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += 1;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmpamqanomh.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011665
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p >= 0);\n    debug_assert!(p\
    \ <= n);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n    debug_assert!(p != n);\n    debug_assert!(p\
    \ != 0);\n    debug_assert!(p != 1);\n\n}\n\nfn main() {\n    let candidate =\
    \ modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101),\
    \ 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11),\
    \ 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5),\
    \ 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa7ng7798.rs:12:32\n   |\n\
    12 | fn modp(n: isize, p: isize) -> isize {\n   |    ----                    \
    \    ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    let mut res = 0;\n    while n > 0 {\n        if n % p == 0 {\n      \
    \      res += p;\n        }\n        n /= p;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = modp;\n    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101,\
    \ 101), 2);\n    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3,\
    \ 11), 8);\n    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30,\
    \ 5), 4);\n    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign to immutable argument `n`\n  --> /tmp/tmptkop2dtn.rs:18:9\n\
    \   |\n12 | fn modp(n: isize, p: isize) -> isize {\n   |         - help: consider\
    \ making this binding mutable: `mut n`\n...\n18 |         n /= p;\n   |      \
    \   ^^^^^^ cannot assign to immutable argument\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 101
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    n & (p - 1)\n}\n\nfn main() {\n    let candidate = modp;\n    assert_eq!(candidate(3,\
    \ 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n    assert_eq!(candidate(0,\
    \ 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n    assert_eq!(candidate(100,\
    \ 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n    assert_eq!(candidate(31,\
    \ 5), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `3`', /tmp/tmp3bakbduf.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011664
- exit_code: 1
  program: "/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfn modp(n: isize, p: isize) -> isize\
    \ {\n    debug_assert!(n >= 0);\n    debug_assert!(p);\n    debug_assert!(p >\
    \ 0);\n    debug_assert!(p < n);\n    debug_assert!(p % n == 0);\n    debug_assert!(n\
    \ % p == 0);\n    n + (n - p) % n\n}\n\nfn main() {\n    let candidate = modp;\n\
    \    assert_eq!(candidate(3, 5), 3);\n    assert_eq!(candidate(1101, 101), 2);\n\
    \    assert_eq!(candidate(0, 101), 1);\n    assert_eq!(candidate(3, 11), 8);\n\
    \    assert_eq!(candidate(100, 101), 1);\n    assert_eq!(candidate(30, 5), 4);\n\
    \    assert_eq!(candidate(31, 5), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe3nboxko.rs:14:5\n   |\n\
    14 |     debug_assert!(p);\n   |     ^^^^^^^^^^^^^^^^ expected `bool`, found `isize`\n\
    \   |\n   = note: this error originates in the macro `debug_assert` (in Nightly\
    \ builds, run with -Z macro-backtrace for more info)\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011665
