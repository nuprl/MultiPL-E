language: rs
name: HumanEval_0_has_close_elements
results:
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 101
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| f64::abs(n - threshold) < threshold)\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphdxl2zia.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n - min_number < min_distance {\n            min_distance\
    \ = n - min_number;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitova3ei.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n    \
    \    if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n     \
    \       min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmput1294dn.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmput1294dn.rs:14:23\n   |\n14 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmput1294dn.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (idx, number) in numbers.iter().enumerate() {\n        let dist = number.abs()\
    \ - min_dist;\n        if dist < 0.0 {\n            min_dist = dist;\n       \
    \     min_idx = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmptjmodo7n.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmptjmodo7n.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < threshold {\n            min_dist = dist;\n            min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpds3z0k3s.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpds3z0k3s.rs:14:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n14 | \
    \            min_idx = Some(numbers.iter().position(|&n| n == n).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        if min_dist > n.abs() {\n            min_dist\
    \ = n.abs();\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpnigup375.rs:13:23\n\
    \   |\n13 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnigup375.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgl_jbuz.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < threshold {\n            min_dist = dist;\n            min_idx\
    \ = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpw5b9f024.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpw5b9f024.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut i = 0;\n    let mut j = 1;\n\
    \    while i < numbers_sorted.len() && j < numbers_sorted.len() {\n        if\
    \ numbers_sorted[i] < numbers_sorted[j] {\n            i += 1;\n        } else\
    \ {\n            j += 1;\n        }\n        if j == numbers_sorted.len() {\n\
    \            return true;\n        }\n    }\n    false\n}\n\nfn main() {\n   \
    \ let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmplww7ay9u.rs:9:20\n\
    \     |\n9    |     numbers_sorted.sort_unstable();\n     |                  \
    \  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmply82l3ml.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_element =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_element.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzssaisuo.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = std::f64::abs(n - min_number);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpqavv4obs.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_number);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqavv4obs.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut min_distance = threshold;\n    let mut\
    \ min_number = numbers_iter.next();\n    while let Some(number) = numbers_iter.next()\
    \ {\n        let distance = number.abs_sub(&min_number).abs();\n        if distance\
    \ < threshold {\n            min_distance = distance;\n            min_number\
    \ = number;\n        }\n    }\n    min_number != numbers_iter.next()\n}\n\nfn\
    \ main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmp0ml5p5hq.rs:13:31\n \
    \  |\n13 |         let distance = number.abs_sub(&min_number).abs();\n   |   \
    \                            ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0ml5p5hq.rs:13:39\n\
    \   |\n13 |         let distance = number.abs_sub(&min_number).abs();\n   |  \
    \                                     ^^^^^^^^^^^ expected `f64`, found `&Option<&f64>`\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&Option<&f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0ml5p5hq.rs:16:26\n   |\n11 |\
    \     let mut min_number = numbers_iter.next();\n   |                        \
    \  ------------------- expected due to this value\n...\n16 |             min_number\
    \ = number;\n   |                          ^^^^^^ expected enum `Option`, found\
    \ `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n           found reference\
    \ `&f64`\nhelp: try wrapping the expression in `Some`\n   |\n16 |            \
    \ min_number = Some(number);\n   |                          +++++      +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        if n == min_number\
    \ {\n            continue;\n        }\n        let distance = n - min_number;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_number != numbers[0]\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_guh0x0.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm_guh0x0.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt6hr2l9h.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n == min_number\
    \ {\n            min_distance = std::f64::MAX;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = std::f64::MAX;\n\
    \        }\n    }\n    min_number < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph4e33n6m.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort_unstable();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            break;\n \
    \       }\n        if numbers_copy[i] < threshold {\n            i += 1;\n   \
    \     } else {\n            j += 1;\n        }\n    }\n    i != numbers_copy.len()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpajqvzidv.rs:9:18\n\
    \     |\n9    |     numbers_copy.sort_unstable();\n     |                  ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &n2) in numbers.iter().enumerate()\
    \ {\n            let dist = abs(n - n2);\n            if dist < min_dist {\n \
    \               min_dist = dist;\n                min_idx = i;\n            }\n\
    \        }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpe_55irwt.rs:12:24\n\
    \   |\n12 |             let dist = abs(n - n2);\n   |                        ^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpe_55irwt.rs:10:27\n   |\n10 |         let mut min_idx\
    \ = -1;\n   |                           ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpe_55irwt.rs:18:20\n   |\n18 |         min_idx != -1\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n    \
    \    if dist < threshold {\n            min_dist = n;\n            min_idx = -1;\n\
    \        }\n        if min_idx < 0 || dist < min_dist {\n            min_dist\
    \ = dist;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpcjdhsdg0.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpcjdhsdg0.rs:18:23\n   |\n18 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjdhsdg0.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_number\
    \ = numbers_iter.next().unwrap();\n    let mut max_number = numbers_iter.next().unwrap();\n\
    \    let mut min_threshold = threshold;\n    let mut max_threshold = threshold;\n\
    \    while numbers_iter.next() {\n        let number = numbers_iter.next().unwrap();\n\
    \        if number < min_number {\n            min_number = number;\n        }\n\
    \        if number > max_number {\n            max_number = number;\n        }\n\
    \        if number < min_threshold {\n            min_threshold = number;\n  \
    \      }\n        if number > max_threshold {\n            max_threshold = number;\n\
    \        }\n    }\n    min_number < max_threshold && min_threshold < max_number\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzf5w2ibm.rs:13:11\n   |\n\
    13 |     while numbers_iter.next() {\n   |           ^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<&f64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf5w2ibm.rs:21:21\n\
    \   |\n21 |         if number < min_threshold {\n   |                     ^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&f64`, found `f64`\n\
    \   |                     help: consider borrowing here: `&min_threshold`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzf5w2ibm.rs:22:29\n   |\n11 |  \
    \   let mut min_threshold = threshold;\n   |                             ---------\
    \ expected due to this value\n...\n22 |             min_threshold = number;\n\
    \   |                             ^^^^^^ expected `f64`, found `&f64`\n   |\n\
    help: consider dereferencing the borrow\n   |\n22 |             min_threshold\
    \ = *number;\n   |                             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzf5w2ibm.rs:24:21\n   |\n24 |         if number > max_threshold\
    \ {\n   |                     ^^^^^^^^^^^^^\n   |                     |\n   |\
    \                     expected `&f64`, found `f64`\n   |                     help:\
    \ consider borrowing here: `&max_threshold`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzf5w2ibm.rs:25:29\n   |\n12 |     let mut max_threshold = threshold;\n\
    \   |                             --------- expected due to this value\n...\n\
    25 |             max_threshold = number;\n   |                             ^^^^^^\
    \ expected `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |             max_threshold = *number;\n   |                       \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzf5w2ibm.rs:28:18\n\
    \   |\n28 |     min_number < max_threshold && min_threshold < max_number\n   |\
    \                  ^^^^^^^^^^^^^\n   |                  |\n   |              \
    \    expected `&f64`, found `f64`\n   |                  help: consider borrowing\
    \ here: `&max_threshold`\n\nerror[E0308]: mismatche"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_element =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_element.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzssaisuo.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 101
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| f64::abs(x - threshold) < threshold)\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpizq13rx4.rs:13:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            if *x - x < min_dist {\n                min_dist = *x - x;\n\
    \                min_idx = i;\n            }\n        }\n        min_idx != -1\n\
    \    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpu_aiap0x.rs:12:16\n\
    \   |\n12 |             if *x - x < min_dist {\n   |                ^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpu_aiap0x.rs:13:28\n   |\n13\
    \ |                 min_dist = *x - x;\n   |                            ^^\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpu_aiap0x.rs:10:27\n\
    \   |\n10 |         let mut min_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpu_aiap0x.rs:17:20\n\
    \   |\n17 |         min_idx != -1\n   |                    ^^\n   |          \
    \          |\n   |                    cannot apply unary operator `-`\n   |  \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0600, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpxgylctpy.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpxgylctpy.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpxgylctpy.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (idx, number) in numbers.iter().enumerate() {\n        let dist = number.abs()\
    \ - min_dist;\n        if dist < 0.0 {\n            min_dist = dist;\n       \
    \     min_idx = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmptjmodo7n.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmptjmodo7n.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n - min_number < min_diff {\n            min_diff\
    \ = n - min_number;\n            min_number = n;\n        }\n    }\n    min_diff\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3fhtd_x.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if *n < min_number {\n            min_number\
    \ = *n;\n            min_dist = threshold;\n        }\n        if *n > min_number\
    \ {\n            let dist = *n - min_number;\n            if dist < min_dist {\n\
    \                min_number = *n;\n                min_dist = dist;\n        \
    \    }\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptgqr2k2c.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            return false;\n\
    \        }\n    }\n    numbers_copy[i] < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpg0sacy7b.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpxgylctpy.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpxgylctpy.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpxgylctpy.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n - min_number\
    \ < min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_number < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfsjwea6o.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = n.abs() - min_number.abs();\n   \
    \     if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo4si4q.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7fijpcli.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort_unstable();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            return false;\n\
    \        }\n    }\n    numbers_copy[i] == numbers_copy[j] && numbers_copy[i] <\
    \ threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpafgkmhes.rs:9:18\n\
    \     |\n9    |     numbers_copy.sort_unstable();\n     |                  ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n\
    \            abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv1625rzs.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        if min_dist > n.abs() {\n            min_dist\
    \ = n.abs();\n            min_idx = -1;\n        }\n        if min_dist == n.abs()\
    \ {\n            min_idx = numbers.iter().position(|&n| n == n);\n        }\n\
    \    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9iwik9be.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9iwik9be.rs:16:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n16 | \
    \            min_idx = numbers.iter().position(|&n| n == n);\n   |           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0\
    \ {\n            min_diff = n;\n            min_idx = -1;\n        }\n       \
    \ if diff < min_diff {\n            min_diff = diff;\n            min_idx = Some(numbers.iter().position(|&x|\
    \ x == n));\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdxh2dxw8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpdxh2dxw8.rs:12:17\n   |\n\
    12 |         if diff < 0 {\n   |                 ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if diff < 0.0 {\n   |  \
    \                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdxh2dxw8.rs:18:23\n\
    \   |\n9  |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n18 |             min_idx = Some(numbers.iter().position(|&x|\
    \ x == n));\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<Option<usize>>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = std::f64::MAX;\n    for &n in numbers {\n        let distance = n.abs() -\
    \ threshold;\n        if distance < min_distance {\n            min_distance =\
    \ distance;\n            min_number = n;\n        }\n    }\n    min_number < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsdrdnsjg.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n  \
    \  for (i, &number) in numbers.iter().enumerate() {\n        let diff = &number\
    \ - &numbers[min_idx];\n        if diff < min_diff {\n            min_diff = diff;\n\
    \            min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp9l_iaowx.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp9l_iaowx.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = n.abs() - min_number.abs();\n   \
    \     if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo4si4q.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n    \
    \    if dist < threshold {\n            min_dist = n;\n            min_idx = -1;\n\
    \        }\n        if min_idx < 0 || dist < min_dist {\n            min_dist\
    \ = dist;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpcjdhsdg0.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpcjdhsdg0.rs:18:23\n   |\n18 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjdhsdg0.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_num = numbers[0];\n\
    \    for num in numbers {\n        let dist = std::f64::abs(num - min_num);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_num\
    \ = num;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpgu5gesqr.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(num - min_num);\n   |           \
    \                   ^^^ not found in `std::f64`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmp_tf9zbyo.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmp_tf9zbyo.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpxgylctpy.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpxgylctpy.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpxgylctpy.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            return false;\n\
    \        }\n        if numbers_copy[i] < threshold {\n            i += 1;\n  \
    \      } else {\n            j += 1;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmppehyg7wz.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = n\
    \ - min_number;\n        }\n    }\n    min_number < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwdibew01.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            return false;\n\
    \        }\n    }\n    numbers_copy[i] < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpg0sacy7b.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpn_ozr8sq.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpn_ozr8sq.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if min_distance > abs(n - min_number) {\n         \
    \   min_distance = abs(n - min_number);\n            min_number = n;\n       \
    \ }\n    }\n    min_distance < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpqkl2q9gf.rs:14:27\n\
    \   |\n14 |         if min_distance > abs(n - min_number) {\n   |            \
    \               ^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `abs` in this scope\n  --> /tmp/tmpqkl2q9gf.rs:15:28\n   |\n15 |           \
    \  min_distance = abs(n - min_number);\n   |                            ^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqkl2q9gf.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs_sub(&min_number).abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmp2sqmujby.rs:12:31\n \
    \  |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |   \
    \                            ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sqmujby.rs:12:39\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |  \
    \                                     ^^^^^^^^^^^ expected `f64`, found `&Option<&f64>`\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&Option<&f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2sqmujby.rs:15:26\n   |\n10 |\
    \     let mut min_number = numbers_iter.next();\n   |                        \
    \  ------------------- expected due to this value\n...\n15 |             min_number\
    \ = number;\n   |                          ^^^^^^ expected enum `Option`, found\
    \ `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n           found reference\
    \ `&f64`\nhelp: try wrapping the expression in `Some`\n   |\n15 |            \
    \ min_number = Some(number);\n   |                          +++++      +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        if number - min_number < min_distance {\n \
    \           min_distance = number - min_number;\n            min_number = number;\n\
    \        }\n    }\n    min_number != numbers_iter.next()\n}\n\nfn main() {\n \
    \   let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `Option<&f64>` from `&f64`\n  --> /tmp/tmpbgv7z34s.rs:12:19\n\
    \   |\n12 |         if number - min_number < min_distance {\n   |            \
    \       ^ no implementation for `&f64 - Option<&f64>`\n   |\n   = help: the trait\
    \ `Sub<Option<&f64>>` is not implemented for `&f64`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]: cannot\
    \ subtract `Option<&f64>` from `&f64`\n  --> /tmp/tmpbgv7z34s.rs:13:35\n   |\n\
    13 |             min_distance = number - min_number;\n   |                   \
    \                ^ no implementation for `&f64 - Option<&f64>`\n   |\n   = help:\
    \ the trait `Sub<Option<&f64>>` is not implemented for `&f64`\n   = help: the\
    \ following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as\
    \ Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n\
    \             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n    \
    \         <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n          \
    \   <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbgv7z34s.rs:14:26\n   |\n10 |     let mut min_number =\
    \ numbers_iter.next();\n   |                          ------------------- expected\
    \ due to this value\n...\n14 |             min_number = number;\n   |        \
    \                  ^^^^^^ expected enum `Option`, found `&f64`\n   |\n   = note:\
    \   expected enum `Option<&f64>`\n           found reference `&f64`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n14 |             min_number = Some(number);\n\
    \   |                          +++++      +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| x < threshold)\n}\n\nfn main() {\n   \
    \ let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp6h87xqwx.rs:8:32\n  |\n8 |\
    \     numbers.iter().any(|x| x < threshold)\n  |                             \
    \   ^^^^^^^^^\n  |                                |\n  |                     \
    \           expected `&f64`, found `f64`\n  |                                help:\
    \ consider borrowing here: `&threshold`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n - min_number < min_distance {\n            min_distance\
    \ = n - min_number;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitova3ei.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 1;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            break;\n \
    \       }\n        if numbers_copy[i] < threshold {\n            i += 1;\n   \
    \     } else {\n            j += 1;\n        }\n    }\n    i != numbers_copy.len()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmpt3icl9n0.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs_sub(&min_number).abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmp2sqmujby.rs:12:31\n \
    \  |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |   \
    \                            ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sqmujby.rs:12:39\n\
    \   |\n12 |         let distance = number.abs_sub(&min_number).abs();\n   |  \
    \                                     ^^^^^^^^^^^ expected `f64`, found `&Option<&f64>`\n\
    \   |\n   = note:   expected type `f64`\n           found reference `&Option<&f64>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp2sqmujby.rs:15:26\n   |\n10 |\
    \     let mut min_number = numbers_iter.next();\n   |                        \
    \  ------------------- expected due to this value\n...\n15 |             min_number\
    \ = number;\n   |                          ^^^^^^ expected enum `Option`, found\
    \ `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n           found reference\
    \ `&f64`\nhelp: try wrapping the expression in `Some`\n   |\n15 |            \
    \ min_number = Some(number);\n   |                          +++++      +\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if min_idx < 0 || dist < min_dist {\n            min_dist = dist;\n \
    \           min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp91yc10j1.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp91yc10j1.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut close = false;\n    let mut current_number\
    \ = numbers_iter.next();\n    while !close.load(Ordering::Relaxed) && current_number.is_some()\
    \ {\n        if current_number.unwrap() < threshold {\n            close = true;\n\
    \        }\n        current_number = numbers_iter.next();\n    }\n    close\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpbvps5893.rs:12:23\n   |\n12 |     while !close.load(Ordering::Relaxed)\
    \ && current_number.is_some() {\n   |                       ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0599]: no method named `load` found for type `bool`\
    \ in the current scope\n  --> /tmp/tmpbvps5893.rs:12:18\n   |\n12 |     while\
    \ !close.load(Ordering::Relaxed) && current_number.is_some() {\n   |         \
    \         ^^^^ method not found in `bool`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbvps5893.rs:13:38\n   |\n13 |         if current_number.unwrap()\
    \ < threshold {\n   |                                      ^^^^^^^^^\n   |   \
    \                                   |\n   |                                  \
    \    expected `&f64`, found `f64`\n   |                                      help:\
    \ consider borrowing here: `&threshold`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpf2sr2qsf.rs:12:50\n   |\n12 |         let distance = number.abs()\
    \ - min_number.abs();\n   |                                                  ^^^\
    \ method not found in `Option<&f64>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf2sr2qsf.rs:15:26\n   |\n10 |     let mut min_number = numbers_iter.next();\n\
    \   |                          ------------------- expected due to this value\n\
    ...\n15 |             min_number = number;\n   |                          ^^^^^^\
    \ expected enum `Option`, found `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n\
    \           found reference `&f64`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             min_number = Some(number);\n   |                     \
    \     +++++      +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = n.abs() - min_number.abs();\n   \
    \     if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8jo4si4q.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    let mut numbers_set_size = numbers_set.len();\n\
    \    let mut close_count = 0;\n    let mut closed_numbers = vec![];\n    while\
    \ numbers_set_size > 1 {\n        let mut min_number = numbers_set.iter().min_by_key(|&x|\
    \ x).unwrap();\n        let mut max_number = numbers_set.iter().max_by_key(|&x|\
    \ x).unwrap();\n        if min_number == max_number {\n            break;\n  \
    \      }\n        if min_number - threshold < max_number + threshold {\n     \
    \       close_count += 1;\n            closed_numbers.push(min_number);\n    \
    \        numbers_set.insert(max_number);\n            numbers_set.insert(min_number);\n\
    \        } else {\n            numbers_set.insert(min_number);\n            numbers_set.insert(max_number);\n\
    \        }\n        numbers_set_size -= 1;\n    }\n    close_count > 0\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmpx45je60j.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (idx, num) in numbers.iter().enumerate() {\n        let dist = std::f64::abs(num\
    \ - min_dist);\n        if dist < threshold {\n            min_dist = num;\n \
    \           min_idx = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpxwfo4ybv.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(num - min_dist);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwfo4ybv.rs:13:24\n   |\n8  |     let mut min_dist = threshold;\n\
    \   |                        --------- expected due to this value\n...\n13 | \
    \            min_dist = num;\n   |                        ^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |    \
    \         min_dist = *num;\n   |                        +\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpxwfo4ybv.rs:9:23\n \
    \ |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpxwfo4ybv.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < threshold {\n            min_dist = dist;\n            min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpds3z0k3s.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpds3z0k3s.rs:14:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n14 | \
    \            min_idx = Some(numbers.iter().position(|&n| n == n).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        }\n    }\n    min_number < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphigcdpts.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_element =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_element;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxem14ya8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        if n == min_dist {\n            continue;\n  \
    \      }\n        let mut min_dist_idx = -1;\n        for &i in numbers {\n  \
    \          if i == min_dist {\n                continue;\n            }\n    \
    \        let dist = n.abs() - i.abs();\n            if dist < min_dist {\n   \
    \             min_dist = dist;\n                min_dist_idx = i;\n          \
    \  }\n        }\n        if min_dist_idx != min_idx {\n            min_idx = min_dist_idx;\n\
    \        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpve65tg4j.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpve65tg4j.rs:15:13\n   |\n15 |         for &i\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `i`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if *n >= *min_number {\n            continue;\n\
    \        }\n        let distance = *n - min_number;\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            min_number = *n;\n    \
    \    }\n    }\n    min_number != numbers[0]\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsy5xnf5w.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpsy5xnf5w.rs:11:18\n   |\n11\
    \ |         if *n >= *min_number {\n   |                  ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            if *x - x < min_dist {\n                min_dist = *x - x;\n\
    \                min_idx = i;\n            }\n        }\n        min_idx != -1\n\
    \    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `f64` cannot be dereferenced\n  --> /tmp/tmpu_aiap0x.rs:12:16\n\
    \   |\n12 |             if *x - x < min_dist {\n   |                ^^\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpu_aiap0x.rs:13:28\n   |\n13\
    \ |                 min_dist = *x - x;\n   |                            ^^\n\n\
    error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpu_aiap0x.rs:10:27\n\
    \   |\n10 |         let mut min_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpu_aiap0x.rs:17:20\n\
    \   |\n17 |         min_idx != -1\n   |                    ^^\n   |          \
    \          |\n   |                    cannot apply unary operator `-`\n   |  \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0600, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if *n >= *min_number {\n            continue;\n\
    \        }\n        let dist = *n - min_number;\n        if dist < min_dist {\n\
    \            min_dist = dist;\n            min_number = n;\n        }\n    }\n\
    \    min_number != numbers[0]\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf9lqekxo.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0614]:\
    \ type `f64` cannot be dereferenced\n  --> /tmp/tmpf9lqekxo.rs:11:18\n   |\n11\
    \ |         if *n >= *min_number {\n   |                  ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                distance = n.abs() - m.abs();\n     \
    \       }\n        }\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsmjybegz.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsmjybegz.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        } else if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        } else {\n            min_distance = threshold - min_number;\n\
    \        }\n    }\n    min_distance < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1a3iegk7.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpxgylctpy.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpxgylctpy.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpxgylctpy.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_element =\
    \ numbers[0];\n    for &n in numbers {\n        if n < min_element {\n       \
    \     min_element = n;\n        }\n    }\n    for &n in numbers {\n        if\
    \ n < min_element {\n            min_distance = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk9l0ypo6.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpk9l0ypo6.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter().cloned();\n    let mut\
    \ min_distance = threshold;\n    let mut min_element = numbers_iter.next().unwrap();\n\
    \    for element in numbers_iter {\n        let distance = element.abs_sub(&min_element).abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = element;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmp47wqvsbi.rs:12:32\n \
    \  |\n12 |         let distance = element.abs_sub(&min_element).abs();\n   | \
    \                               ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp47wqvsbi.rs:12:40\n\
    \   |\n12 |         let distance = element.abs_sub(&min_element).abs();\n   |\
    \                                        ^^^^^^^^^^^^ expected `f64`, found `&f64`\n\
    \   |\nhelp: consider removing the borrow\n   |\n12 -         let distance = element.abs_sub(&min_element).abs();\n\
    12 +         let distance = element.abs_sub(min_element).abs();\n   | \n\nerror:\
    \ aborting due to previous error; 1 warning emitted\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        }\n    }\n    min_number == numbers[0]\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb_nb5j1n.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_num = x;\n        for num in numbers {\n            let dist\
    \ = abs(num - min_num);\n            if dist < min_dist {\n                min_dist\
    \ = dist;\n                min_num = num;\n            }\n        }\n        min_dist\
    \ < threshold\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpft8impwj.rs:12:24\n\
    \   |\n12 |             let dist = abs(num - min_num);\n   |                 \
    \       ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpft8impwj.rs:15:27\n\
    \   |\n10 |         let mut min_num = x;\n   |                           - expected\
    \ due to this value\n...\n15 |                 min_num = num;\n   |          \
    \                 ^^^\n   |                           |\n   |                \
    \           expected `&f64`, found `f64`\n   |                           help:\
    \ consider borrowing here: `&num`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = None;\n    for &n in numbers {\n        let distance = std::f64::abs(n - threshold);\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = Some(n);\n        }\n    }\n    min_number.is_some()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpzc94wtgz.rs:11:34\n\
    \   |\n11 |         let distance = std::f64::abs(n - threshold);\n   |       \
    \                           ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzc94wtgz.rs:10:9\n   |\n10 |     for &n in numbers {\n\
    \   |         ^^    ------- this expression has type `Option<f64>`\n   |     \
    \    |\n   |         expected `f64`, found reference\n   |         help: you can\
    \ probably remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n\
    \           found reference `&_`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n - min_number < min_distance {\n            min_distance\
    \ = n - min_number;\n            min_number = n;\n        }\n    }\n    min_distance\
    \ < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1,\
    \ 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpitova3ei.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_sorted = numbers.iter().cloned().collect::<Vec<_>>();\n\
    \    numbers_sorted.sort_unstable();\n    let mut min_distance = threshold;\n\
    \    for &n in numbers_sorted {\n        if *n < min_distance {\n            min_distance\
    \ = *n;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5m7alpu4.rs:9:20\n\
    \     |\n9    |     numbers_sorted.sort_unstable();\n     |                  \
    \  ^^^^^^^^^^^^^ the trait `Ord` is not implemented for `f64`\n     |\n     =\
    \ help: the following other types implement trait `Ord`:\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n               u128\n               u16\n             and\
    \ 4 others\nnote: required by a bound in `core::slice::<impl [T]>::sort_unstable`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5m7alpu4.rs:11:9\n   |\n11 | \
    \    for &n in numbers_sorted {\n   |         ^^    -------------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_value\
    \ = numbers_iter.next().unwrap();\n    let mut max_value = numbers_iter.next().unwrap();\n\
    \    let mut min_distance = threshold;\n    let mut max_distance = threshold;\n\
    \    while numbers_iter.next() {\n        let value = numbers_iter.next().unwrap();\n\
    \        let distance = value - min_value;\n        if distance < min_distance\
    \ {\n            min_distance = distance;\n            min_value = value;\n  \
    \      }\n        if distance > max_distance {\n            max_distance = distance;\n\
    \            max_value = value;\n        }\n    }\n    min_distance < max_distance\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphqb022op.rs:13:11\n   |\n\
    13 |     while numbers_iter.next() {\n   |           ^^^^^^^^^^^^^^^^^^^ expected\
    \ `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n       \
    \       found enum `Option<&f64>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let diff = n - min_diff;\n        if diff < 0\
    \ {\n            min_diff = diff;\n            min_idx = numbers.iter().position(|&n|\
    \ n == n);\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpim6gwd_d.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0277]:\
    \ can't compare `f64` with `{integer}`\n  --> /tmp/tmpim6gwd_d.rs:12:17\n   |\n\
    12 |         if diff < 0 {\n   |                 ^ no implementation for `f64\
    \ < {integer}` and `f64 > {integer}`\n   |\n   = help: the trait `PartialOrd<{integer}>`\
    \ is not implemented for `f64`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\nhelp: consider using a floating-point\
    \ literal by writing it with `.0`\n   |\n12 |         if diff < 0.0 {\n   |  \
    \                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpim6gwd_d.rs:14:23\n\
    \   |\n9  |     let mut min_idx = -1;\n   |                       -- expected\
    \ due to this value\n...\n14 |             min_idx = numbers.iter().position(|&n|\
    \ n == n);\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut found = false;\n    while\
    \ i < numbers_copy.len() && j < numbers_copy.len() {\n        if numbers_copy[i]\
    \ < numbers_copy[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n        if i == numbers_copy.len() || j == numbers_copy.len()\
    \ {\n            found = true;\n            break;\n        }\n        if numbers_copy[i]\
    \ < threshold && numbers_copy[j] > threshold {\n            i += 1;\n        \
    \    j += 1;\n        } else {\n            i += 1;\n        }\n    }\n    found\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n   --> /tmp/tmp1_5r0r4j.rs:9:18\n\
    \    |\n9   |     numbers_copy.sort();\n    |                  ^^^^ the trait\
    \ `Ord` is not implemented for `f64`\n    |\n    = help: the following other types\
    \ implement trait `Ord`:\n              i128\n              i16\n            \
    \  i32\n              i64\n              i8\n              isize\n           \
    \   u128\n              u16\n            and 4 others\nnote: required by a bound\
    \ in `slice::<impl [T]>::sort`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < threshold {\n            min_dist = dist;\n            min_idx = -1;\n   \
    \     }\n        if min_idx < 0 || min_dist > threshold {\n            min_dist\
    \ = threshold;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpluy4i2pt.rs:18:23\n\
    \   |\n18 |             min_idx = i;\n   |                       ^ help: a local\
    \ variable with a similar name exists: `n`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpluy4i2pt.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_diff = threshold;\n\
    \        let mut min_idx = -1;\n        for &mut i in numbers {\n            if\
    \ *i < min_diff {\n                min_diff = *i;\n                min_idx = i;\n\
    \            }\n        }\n        min_idx != -1\n    })\n}\n\nfn main() {\n \
    \   let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnva_17kn.rs:11:13\n   |\n\
    11 |         for &mut i in numbers {\n   |             ^^^^^^    ------- this\
    \ expression has type `Option<f64>`\n   |             |\n   |             expected\
    \ `f64`, found `&mut _`\n   |             help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:           expected type `f64`\n           found\
    \ mutable reference `&mut _`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n\
    \            abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv1625rzs.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort_unstable();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut found = false;\n    while\
    \ i < numbers_copy.len() && j < numbers_copy.len() {\n        if numbers_copy[i]\
    \ < numbers_copy[j] {\n            i += 1;\n        } else {\n            j +=\
    \ 1;\n        }\n        if j == numbers_copy.len() {\n            found = true;\n\
    \            break;\n        }\n        if numbers_copy[i] < threshold {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n    }\n \
    \   found\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmp5wqk9sju.rs:9:18\n\
    \     |\n9    |     numbers_copy.sort_unstable();\n     |                  ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n == min_number\
    \ {\n            min_distance = std::f64::MAX;\n        }\n        if min_distance\
    \ > threshold {\n            return false;\n        }\n        min_distance =\
    \ std::f64::MAX;\n    }\n    true\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvlo7qi9.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = std::f64::MAX;\n    for &n in numbers {\n        let distance = n.abs() -\
    \ threshold;\n        if distance < min_distance {\n            min_distance =\
    \ distance;\n            min_number = n;\n        }\n    }\n    min_number !=\
    \ std::f64::MAX\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokrngp3b.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, n2) in numbers.iter().enumerate()\
    \ {\n            if n2 > n {\n                continue;\n            }\n     \
    \       let dist = n2 - n;\n            if dist < min_dist {\n               \
    \ min_dist = dist;\n                min_idx = i;\n            }\n        }\n \
    \       min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpdh5u3nz2.rs:10:27\n\
    \   |\n10 |         let mut min_idx = -1;\n   |                           ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0600]: cannot\
    \ apply unary operator `-` to type `usize`\n  --> /tmp/tmpdh5u3nz2.rs:21:20\n\
    \   |\n21 |         min_idx != -1\n   |                    ^^\n   |          \
    \          |\n   |                    cannot apply unary operator `-`\n   |  \
    \                  help: you may have meant the maximum value of `usize`: `usize::MAX`\n\
    \   |\n   = note: unsigned values cannot be negated\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0600.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < 0.0 {\n            min_dist = dist;\n            min_idx = -1;\n        }\n\
    \        if dist < threshold {\n            min_dist = dist;\n            min_idx\
    \ = numbers.iter().position(|&n| n == n);\n        }\n    }\n    min_idx != -1\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp5buyek_.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp5buyek_.rs:18:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n18 | \
    \            min_idx = numbers.iter().position(|&n| n == n);\n   |           \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found enum\
    \ `Option`\n   |\n   = note: expected type `{integer}`\n              found enum\
    \ `Option<usize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 101
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter().cloned();\n    let mut\
    \ min_value = numbers_iter.next().unwrap();\n    let mut max_value = numbers_iter.next().unwrap();\n\
    \    let mut min_distance = threshold;\n    let mut max_distance = threshold;\n\
    \    while numbers_iter.next() != Some(max_value) {\n        let current_value\
    \ = numbers_iter.next().unwrap();\n        let distance = current_value - min_value;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_value = current_value;\n        }\n        if distance > max_distance\
    \ {\n            max_distance = distance;\n            max_value = current_value;\n\
    \        }\n    }\n    min_distance < max_distance\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp5x8gf8ni.rs:14:49

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n    \
    \    if dist < min_dist {\n            min_dist = dist;\n            min_idx =\
    \ -1;\n        }\n    }\n    if min_idx >= 0 {\n        true\n    } else {\n \
    \       false\n    }\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpgx5g1jhn.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgx5g1jhn.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &n2) in numbers.iter().enumerate()\
    \ {\n            let dist = abs(n - n2);\n            if dist < min_dist {\n \
    \               min_dist = dist;\n                min_idx = i;\n            }\n\
    \        }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpe_55irwt.rs:12:24\n\
    \   |\n12 |             let dist = abs(n - n2);\n   |                        ^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpe_55irwt.rs:10:27\n   |\n10 |         let mut min_idx\
    \ = -1;\n   |                           ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpe_55irwt.rs:18:20\n   |\n18 |         min_idx != -1\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| {\n        numbers.iter().any(|m| {\n\
    \            abs(n - m) < threshold\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmp1x4r62u0.rs:10:13\n\
    \   |\n10 |             abs(n - m) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut min_distance = std::f64::MAX;\n    let\
    \ mut min_number = numbers_iter.next();\n    let mut max_number = numbers_iter.next();\n\
    \    while let Some(number) = min_number {\n        let distance = std::f64::MAX;\n\
    \        while let Some(other_number) = max_number {\n            let distance\
    \ = std::f64::MAX;\n            if *number == *other_number {\n              \
    \  continue;\n            }\n            if *number < other_number {\n       \
    \         distance = *number - *other_number;\n            } else {\n        \
    \        distance = *other_number - *number;\n            }\n            if distance\
    \ < threshold {\n                break;\n            }\n        }\n        if\
    \ distance < min_distance {\n            min_distance = distance;\n          \
    \  min_number = number;\n        }\n        if distance > max_distance {\n   \
    \         max_distance = distance;\n            max_number = number;\n       \
    \ }\n    }\n    min_distance < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_distance` in this scope\n  --> /tmp/tmp0dlx138p.rs:33:23\n\
    \   |\n33 |         if distance > max_distance {\n   |                       ^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `min_distance`\n\nerror[E0425]:\
    \ cannot find value `max_distance` in this scope\n  --> /tmp/tmp0dlx138p.rs:34:13\n\
    \   |\n34 |             max_distance = distance;\n   |             ^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `min_distance`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0dlx138p.rs:20:26\n   |\n20 |             if\
    \ *number < other_number {\n   |                          ^^^^^^^^^^^^ expected\
    \ `f64`, found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n20\
    \ |             if *number < *other_number {\n   |                          +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0dlx138p.rs:31:26\n   |\n11 |\
    \     let mut min_number = numbers_iter.next();\n   |                        \
    \  ------------------- expected due to this value\n...\n31 |             min_number\
    \ = number;\n   |                          ^^^^^^ expected enum `Option`, found\
    \ `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n           found reference\
    \ `&f64`\nhelp: try wrapping the expression in `Some`\n   |\n31 |            \
    \ min_number = Some(number);\n   |                          +++++      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0dlx138p.rs:35:26\n   |\n12 |     let mut max_number\
    \ = numbers_iter.next();\n   |                          ------------------- expected\
    \ due to this value\n...\n35 |             max_number = number;\n   |        \
    \                  ^^^^^^ expected enum `Option`, found `&f64`\n   |\n   = note:\
    \   expected enum `Option<&f64>`\n           found reference `&f64`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n35 |             max_number = Some(number);\n\
    \   |                          +++++      +\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if min_distance > n.abs() {\n            min_distance\
    \ = n.abs();\n            min_number = n;\n        }\n    }\n    min_number <\
    \ threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy5h34q4u.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_element =\
    \ numbers[0];\n    for &n in numbers {\n        let distance = n.abs() - min_element;\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_element = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxem14ya8.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &x) in numbers.iter().enumerate()\
    \ {\n            let dist = x - i;\n            if dist < min_dist {\n       \
    \         min_dist = dist;\n                min_idx = i;\n            }\n    \
    \    }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract `usize` from `f64`\n  --> /tmp/tmpxgylctpy.rs:12:26\n\
    \   |\n12 |             let dist = x - i;\n   |                          ^ no\
    \ implementation for `f64 - usize`\n   |\n   = help: the trait `Sub<usize>` is\
    \ not implemented for `f64`\n   = help: the following other types implement trait\
    \ `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n\
    \             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n  \
    \           <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n      \
    \       <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n        \
    \   and 48 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpxgylctpy.rs:10:27\n   |\n10 |         let mut min_idx = -1;\n \
    \  |                           ^^ the trait `Neg` is not implemented for `usize`\n\
    \   |\n   = help: the following other types implement trait `Neg`:\n         \
    \    &f32\n             &f64\n             &i128\n             &i16\n        \
    \     &i32\n             &i64\n             &i8\n             &isize\n       \
    \    and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmpxgylctpy.rs:18:20\n   |\n18 |         min_idx != -1\n   |     \
    \               ^^\n   |                    |\n   |                    cannot\
    \ apply unary operator `-`\n   |                    help: you may have meant the\
    \ maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot\
    \ be negated\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n\
    \            abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv1625rzs.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let dist = std::f64::abs(n - min_number);\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_number\
    \ = n;\n        }\n    }\n    min_dist < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpqavv4obs.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_number);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpqavv4obs.rs:10:9\n   |\n10 |     for &n in numbers {\n   |    \
    \     ^^    ------- this expression has type `Option<f64>`\n   |         |\n \
    \  |         expected `f64`, found reference\n   |         help: you can probably\
    \ remove the explicit borrow: `n`\n   |\n   = note:   expected type `f64`\n  \
    \         found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (idx, num) in numbers.iter().enumerate() {\n        let dist = std::f64::abs(num\
    \ - min_dist);\n        if dist < threshold {\n            min_dist = num;\n \
    \           min_idx = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpxwfo4ybv.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(num - min_dist);\n   |          \
    \                    ^^^ not found in `std::f64`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxwfo4ybv.rs:13:24\n   |\n8  |     let mut min_dist = threshold;\n\
    \   |                        --------- expected due to this value\n...\n13 | \
    \            min_dist = num;\n   |                        ^^^ expected `f64`,\
    \ found `&f64`\n   |\nhelp: consider dereferencing the borrow\n   |\n13 |    \
    \         min_dist = *num;\n   |                        +\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpxwfo4ybv.rs:9:23\n \
    \ |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpxwfo4ybv.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425, E0600.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        let distance = n.abs()\
    \ - min_number.abs();\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    min_number <\
    \ threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvb_uazuh.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvb_uazuh.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|n| {\n        let mut min_dist = threshold;\n\
    \        let mut min_idx = -1;\n        for (i, &n2) in numbers.iter().enumerate()\
    \ {\n            let dist = abs(n - n2);\n            if dist < min_dist {\n \
    \               min_dist = dist;\n                min_idx = i;\n            }\n\
    \        }\n        min_idx != -1\n    })\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpe_55irwt.rs:12:24\n\
    \   |\n12 |             let dist = abs(n - n2);\n   |                        ^^^\
    \ not found in this scope\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpe_55irwt.rs:10:27\n   |\n10 |         let mut min_idx\
    \ = -1;\n   |                           ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0600]: cannot apply unary operator `-` to type\
    \ `usize`\n  --> /tmp/tmpe_55irwt.rs:18:20\n   |\n18 |         min_idx != -1\n\
    \   |                    ^^\n   |                    |\n   |                 \
    \   cannot apply unary operator `-`\n   |                    help: you may have\
    \ meant the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned\
    \ values cannot be negated\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0600.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut min_distance = threshold;\n    let mut\
    \ min_number = numbers_iter.next().unwrap();\n    let mut max_number = numbers_iter.next().unwrap();\n\
    \    while let Some(number) = numbers_iter.next() {\n        let distance = number.powf(2).sum();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n        if distance > threshold\
    \ {\n            max_number = number;\n            break;\n        }\n    }\n\
    \    min_number < max_number\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnzcl45x7.rs:14:36\n   |\n\
    14 |         let distance = number.powf(2).sum();\n   |                      \
    \              ^\n   |                                    |\n   |            \
    \                        expected `f64`, found integer\n   |                 \
    \                   help: use a float literal: `2.0`\n\nerror[E0599]: `f64` is\
    \ not an iterator\n  --> /tmp/tmpnzcl45x7.rs:14:39\n   |\n14 |         let distance\
    \ = number.powf(2).sum();\n   |                                       ^^^ `f64`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `f64: Iterator`\n           which is required by `&mut f64: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        if n < min_number +\
    \ min_distance {\n            min_distance = n - min_number;\n        }\n    }\n\
    \    min_distance < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5jx3ixz3.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5jx3ixz3.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n == min_number\
    \ {\n            min_distance = std::f64::MAX;\n        }\n        if min_distance\
    \ > n - min_number {\n            min_distance = n - min_number;\n        }\n\
    \    }\n    min_distance < threshold\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp42rdhoyv.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = std::f64::MAX;\n    for n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = n.abs() - m.abs();\n            if\
    \ distance < distance {\n                break;\n            }\n        }\n  \
    \      if distance < min_distance {\n            min_distance = distance;\n  \
    \          min_number = n;\n        }\n    }\n    min_distance < threshold\n}\n\
    \nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_number` is assigned to, but never used\n --> /tmp/tmpxmh9vb4x.rs:9:13\n\
    \  |\n9 |     let mut min_number = std::f64::MAX;\n  |             ^^^^^^^^^^\n\
    \  |\n  = note: `#[warn(unused_variables)]` on by default\n  = note: consider\
    \ using `_min_number` instead\n\nwarning: value assigned to `min_number` is never\
    \ read\n  --> /tmp/tmpxmh9vb4x.rs:23:13\n   |\n23 |             min_number = n;\n\
    \   |             ^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on\
    \ by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0382]:\
    \ use of moved value: `numbers`\n   --> /tmp/tmpxmh9vb4x.rs:12:18\n    |\n7  \
    \ | fn has_close_elements(numbers: Vec<f64>, threshold: f64) -> bool {\n    |\
    \                       ------- move occurs because `numbers` has type `Vec<f64>`,\
    \ which does not implement the `Copy` trait\n...\n10  |     for n in numbers {\n\
    \    |              ------- `numbers` moved due to this implicit call to `.into_iter()`\n\
    11  |         let distance = std::f64::MAX;\n12  |         for m in numbers {\n\
    \    |                  ^^^^^^^ value used here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `numbers`\nhelp:\
    \ consider iterating over a slice of the `Vec<f64>`'s content to avoid moving\
    \ into the `for` loop\n    |\n10  |     for n in &numbers {\n    |           \
    \   +\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    numbers.iter().any(|x| {\n        numbers.iter().any(|y| {\n\
    \            abs(x - y) < threshold\n        })\n    })\n}\n\nfn main() {\n  \
    \  let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in this scope\n  --> /tmp/tmpv1625rzs.rs:10:13\n\
    \   |\n10 |             abs(x - y) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let diff = n - min_number;\n        if diff\
    \ < min_diff {\n            min_diff = diff;\n            min_number = n;\n  \
    \      }\n    }\n    min_diff < threshold\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt6hr2l9h.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_diff = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        if *n >= threshold {\n            continue;\n\
    \        }\n        let mut diff = (*n - threshold).abs();\n        if diff <\
    \ min_diff {\n            min_diff = diff;\n            min_idx = n;\n       \
    \ }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vh5fh30.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 101
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = std::f64::MAX;\n    for number in numbers {\n        let distance = number.abs()\
    \ - threshold;\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = number;\n        }\n    }\n    min_number\
    \ < std::f64::MAX\n}\n\nfn main() {\n    let candidate = has_close_elements;\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpv5ruhgdt.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_set = HashSet::new();\n    for n in numbers {\n\
    \        numbers_set.insert(n);\n    }\n    numbers_set.iter().any(|n| {\n   \
    \     numbers_set.iter().any(|m| {\n            abs(n - m) < threshold\n     \
    \   })\n    })\n}\n\nfn main() {\n    let candidate = has_close_elements;\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n   \
    \ assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n -->\
    \ /tmp/tmp90a28_vs.rs:8:27\n  |\n8 |     let mut numbers_set = HashSet::new();\n\
    \  |                           ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashSet;\n  |\n\nerror[E0425]:\
    \ cannot find function `abs` in this scope\n  --> /tmp/tmp90a28_vs.rs:14:13\n\
    \   |\n14 |             abs(n - m) < threshold\n   |             ^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpn_ozr8sq.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpn_ozr8sq.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        let distance = n.abs()\
    \ - min_number.abs();\n        if distance < min_distance {\n            min_distance\
    \ = distance;\n            min_number = n;\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6wzmis64.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6wzmis64.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 101
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut prev_number\
    \ = numbers_iter.next();\n    let mut current_number = numbers_iter.next();\n\
    \    while current_number.is_some() {\n        if current_number.unwrap() - prev_number.unwrap()\
    \ > threshold {\n            return true;\n        }\n        prev_number = current_number;\n\
    \        current_number = numbers_iter.next();\n    }\n    false\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpr06048ol.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - min_number;\n        }\n    }\n    min_number < threshold\n}\n\nfn main()\
    \ {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphigcdpts.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut min_distance\
    \ = threshold;\n    let mut min_number = numbers_iter.next();\n    while let Some(number)\
    \ = numbers_iter.next() {\n        let distance = number.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = number;\n        }\n    }\n    min_number != numbers_iter.next()\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `abs` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpf2sr2qsf.rs:12:50\n   |\n12 |         let distance = number.abs()\
    \ - min_number.abs();\n   |                                                  ^^^\
    \ method not found in `Option<&f64>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpf2sr2qsf.rs:15:26\n   |\n10 |     let mut min_number = numbers_iter.next();\n\
    \   |                          ------------------- expected due to this value\n\
    ...\n15 |             min_number = number;\n   |                          ^^^^^^\
    \ expected enum `Option`, found `&f64`\n   |\n   = note:   expected enum `Option<&f64>`\n\
    \           found reference `&f64`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             min_number = Some(number);\n   |                     \
    \     +++++      +\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n            min_distance = threshold;\n        }\n        if n < min_number\
    \ + min_distance {\n            min_number = n;\n            min_distance = threshold\
    \ - n;\n        }\n    }\n    min_number < threshold\n}\n\nfn main() {\n    let\
    \ candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0,\
    \ 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0],\
    \ 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0],\
    \ 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0),\
    \ true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpejh7a4ox.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = std::f64::MAX;\n    let mut min_number\
    \ = numbers[0];\n    for &n in numbers {\n        let distance = std::f64::MAX;\n\
    \        for &m in numbers {\n            if m == n {\n                continue;\n\
    \            }\n            let distance = std::f64::MAX;\n            if m >\
    \ n {\n                distance = std::f64::MAX;\n            } else {\n     \
    \           distance = std::f64::MAX;\n            }\n            if distance\
    \ < min_distance {\n                min_distance = distance;\n               \
    \ min_number = m;\n            }\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdns8gon7.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdns8gon7.rs:12:13\n   |\n12 |         for &m\
    \ in numbers {\n   |             ^^    ------- this expression has type `Option<f64>`\n\
    \   |             |\n   |             expected `f64`, found reference\n   |  \
    \           help: you can probably remove the explicit borrow: `m`\n   |\n   =\
    \ note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut close = false;\n    let mut current_number\
    \ = numbers_iter.next().unwrap();\n    let mut current_distance = std::f64::MAX;\n\
    \    while !numbers_iter.next().unwrap().is_some() {\n        let current_distance\
    \ = current_number.abs_sub(&current_number).unwrap();\n        if current_distance\
    \ < threshold {\n            close = true;\n            break;\n        }\n  \
    \      current_number = numbers_iter.next().unwrap();\n    }\n    close\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_some` found for reference `&f64` in the\
    \ current scope\n  --> /tmp/tmp4hipu1du.rs:13:41\n   |\n13 |     while !numbers_iter.next().unwrap().is_some()\
    \ {\n   |                                         ^^^^^^^ method not found in\
    \ `&f64`\n\nwarning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmp4hipu1du.rs:14:47\n \
    \  |\n14 |         let current_distance = current_number.abs_sub(&current_number).unwrap();\n\
    \   |                                               ^^^^^^^\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4hipu1du.rs:14:55\n   |\n14 |         let current_distance = current_number.abs_sub(&current_number).unwrap();\n\
    \   |                                                       ^^^^^^^^^^^^^^^ expected\
    \ `f64`, found `&&f64`\n   |\nhelp: consider removing the `&` and dereferencing\
    \ the borrow instead\n   |\n14 |         let current_distance = current_number.abs_sub(*current_number).unwrap();\n\
    \   |                                                       ~\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `f64` in the current scope\n  --> /tmp/tmp4hipu1du.rs:14:72\n\
    \   |\n14 |         let current_distance = current_number.abs_sub(&current_number).unwrap();\n\
    \   |                                                                        ^^^^^^\
    \ method not found in `f64`\n\nerror: aborting due to 3 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for idx in 0..numbers.len() {\n        let dist = numbers[idx] - threshold;\n\
    \        if dist < min_dist {\n            min_dist = dist;\n            min_idx\
    \ = idx;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpq0h3l64t.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpq0h3l64t.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = std::f64::abs(n - min_dist);\n    \
    \    if dist < threshold {\n            min_dist = n;\n            min_idx = -1;\n\
    \        }\n        if min_idx < 0 || dist < min_dist {\n            min_dist\
    \ = dist;\n            min_idx = i;\n        }\n    }\n    min_idx != -1\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `abs` in module `std::f64`\n  --> /tmp/tmpcjdhsdg0.rs:11:30\n\
    \   |\n11 |         let dist = std::f64::abs(n - min_dist);\n   |            \
    \                  ^^^ not found in `std::f64`\n\nerror[E0425]: cannot find value\
    \ `i` in this scope\n  --> /tmp/tmpcjdhsdg0.rs:18:23\n   |\n18 |             min_idx\
    \ = i;\n   |                       ^ help: a local variable with a similar name\
    \ exists: `n`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjdhsdg0.rs:10:9\n\
    \   |\n10 |     for &n in numbers {\n   |         ^^    ------- this expression\
    \ has type `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n    }\n    for &n in numbers {\n        if n < min_number +\
    \ min_distance {\n            min_distance = n - min_number;\n            min_number\
    \ = n;\n        }\n    }\n    min_distance < threshold\n}\n\nfn main() {\n   \
    \ let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0k9k963q.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0k9k963q.rs:15:9\n   |\n15 |     for &n in numbers\
    \ {\n   |         ^^    ------- this expression has type `Option<f64>`\n   | \
    \        |\n   |         expected `f64`, found reference\n   |         help: you\
    \ can probably remove the explicit borrow: `n`\n   |\n   = note:   expected type\
    \ `f64`\n           found reference `&_`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        let distance = n.abs() - min_number.abs();\n\
    \        if distance < min_distance {\n            min_distance = distance;\n\
    \            min_number = n;\n        }\n    }\n    min_distance < threshold\n\
    }\n\nfn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphkbkg69t.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for &n in numbers {\n        let dist = n.abs() - min_dist;\n        if dist\
    \ < threshold {\n            min_dist = dist;\n            min_idx = Some(numbers.iter().position(|&n|\
    \ n == n).unwrap());\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n\
    \    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0,\
    \ 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpds3z0k3s.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpds3z0k3s.rs:14:23\n   |\n9  |     let mut min_idx\
    \ = -1;\n   |                       -- expected due to this value\n...\n14 | \
    \            min_idx = Some(numbers.iter().position(|&n| n == n).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_distance = threshold;\n    let mut min_number = numbers[0];\n\
    \    for &n in numbers {\n        if n < min_number {\n            min_number\
    \ = n;\n        }\n        if n - min_number < min_distance {\n            min_distance\
    \ = n - min_number;\n            min_number = n;\n        }\n    }\n    min_number\
    \ == numbers[0]\n}\n\nfn main() {\n    let candidate = has_close_elements;\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  \
    \  assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n \
    \   assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 5.9, 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1,\
    \ 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpagsr6eyn.rs:10:9\n   |\n\
    10 |     for &n in numbers {\n   |         ^^    ------- this expression has type\
    \ `Option<f64>`\n   |         |\n   |         expected `f64`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `n`\n   |\n \
    \  = note:   expected type `f64`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut min_dist = threshold;\n    let mut min_idx = -1;\n  \
    \  for (i, n) in numbers.iter().enumerate() {\n        let dist = n.abs() - min_dist;\n\
    \        if dist < 0.0 {\n            min_dist = dist;\n            min_idx =\
    \ i;\n        }\n    }\n    min_idx != -1\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpn_ozr8sq.rs:9:23\n\
    \  |\n9 |     let mut min_idx = -1;\n  |                       ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `usize`\n  --> /tmp/tmpn_ozr8sq.rs:17:16\n   |\n17 |     min_idx\
    \ != -1\n   |                ^^\n   |                |\n   |                cannot\
    \ apply unary operator `-`\n   |                help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0600.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011294
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_copy = numbers.clone();\n    numbers_copy.sort_unstable();\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < numbers_copy.len() && j\
    \ < numbers_copy.len() {\n        if numbers_copy[i] < numbers_copy[j] {\n   \
    \         i += 1;\n        } else {\n            j += 1;\n        }\n        if\
    \ i == numbers_copy.len() || j == numbers_copy.len() {\n            return false;\n\
    \        }\n    }\n    numbers_copy.is_sorted()\n}\n\nfn main() {\n    let candidate\
    \ = has_close_elements;\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2],\
    \ 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95),\
    \ true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n\
    \    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n \
    \   assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n    assert_eq!(candidate(vec![1.1,\
    \ 2.2, 3.1, 4.1, 5.1], 0.5), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f64: Ord` is not satisfied\n    --> /tmp/tmpjnlgyye9.rs:9:18\n\
    \     |\n9    |     numbers_copy.sort_unstable();\n     |                  ^^^^^^^^^^^^^\
    \ the trait `Ord` is not implemented for `f64`\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable`\n\nerror[E0658]: use\
    \ of unstable library feature 'is_sorted': new API\n  --> /tmp/tmpjnlgyye9.rs:22:18\n\
    \   |\n22 |     numbers_copy.is_sorted()\n   |                  ^^^^^^^^^\n  \
    \ |\n   = note: see issue #53485 <https://github.com/rust-lang/rust/issues/53485>\
    \ for more information\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011295
- exit_code: 1
  program: "/// Check if in given list of numbers, are any two numbers closer to each\
    \ other than\n/// given threshold.\n/// >>> has_close_elements(vec![1.0, 2.0,\
    \ 3.0], 0.5)\n/// false\n/// >>> has_close_elements(vec![1.0, 2.8, 3.0, 4.0, 5.0,\
    \ 2.0], 0.3)\n/// true\nfn has_close_elements(numbers: Vec<f64>, threshold: f64)\
    \ -> bool {\n    let mut numbers_iter = numbers.iter();\n    let mut threshold\
    \ = threshold * threshold;\n    let mut min_dist = threshold;\n    let mut min_element\
    \ = numbers_iter.next();\n    while let Some(element) = min_element {\n      \
    \  let mut min_dist = threshold;\n        let mut min_element = numbers_iter.next();\n\
    \        for number in numbers_iter {\n            let dist = element.abs_sub(&number).abs();\n\
    \            if dist < min_dist {\n                min_dist = dist;\n        \
    \        min_element = number;\n            }\n        }\n        if min_dist\
    \ < threshold {\n            return true;\n        }\n    }\n    false\n}\n\n\
    fn main() {\n    let candidate = has_close_elements;\n    assert_eq!(candidate(vec![1.0,\
    \ 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 3.9, 4.0, 5.0, 2.2], 0.05), false);\n    assert_eq!(candidate(vec![1.0, 2.0,\
    \ 5.9, 4.0, 5.0], 0.95), true);\n    assert_eq!(candidate(vec![1.0, 2.0, 5.9,\
    \ 4.0, 5.0], 0.8), false);\n    assert_eq!(candidate(vec![1.0, 2.0, 3.0, 4.0,\
    \ 5.0, 2.0], 0.1), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1],\
    \ 1.0), true);\n    assert_eq!(candidate(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5),\
    \ false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `std::f64::<impl f64>::abs_sub`:\
    \ you probably meant `(self - other).abs()`: this operation is `(self - other).max(0.0)`\
    \ except that `abs_sub` also propagates NaNs (also known as `fdim` in C). If you\
    \ truly need the positive difference, consider using that expression or the C\
    \ function `fdim`, depending on how you wish to handle NaN (please consider filing\
    \ an issue describing your use-case too).\n  --> /tmp/tmpoh7b3031.rs:16:32\n \
    \  |\n16 |             let dist = element.abs_sub(&number).abs();\n   |      \
    \                          ^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoh7b3031.rs:16:40\n\
    \   |\n16 |             let dist = element.abs_sub(&number).abs();\n   |     \
    \                                   ^^^^^^^ expected `f64`, found `&&f64`\n  \
    \ |\nhelp: consider removing the `&` and dereferencing the borrow instead\n  \
    \ |\n16 |             let dist = element.abs_sub(*number).abs();\n   |       \
    \                                 ~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoh7b3031.rs:19:31\n\
    \   |\n14 |         let mut min_element = numbers_iter.next();\n   |         \
    \                      ------------------- expected due to this value\n...\n19\
    \ |                 min_element = number;\n   |                              \
    \ ^^^^^^ expected enum `Option`, found `&f64`\n   |\n   = note:   expected enum\
    \ `Option<&f64>`\n           found reference `&f64`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n19 |                 min_element = Some(number);\n   |    \
    \                           +++++      +\n\nerror: aborting due to 2 previous\
    \ errors; 1 warning emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011295
