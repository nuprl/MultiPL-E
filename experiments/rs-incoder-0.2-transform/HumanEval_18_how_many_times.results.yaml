language: rs
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = string.find(substring);\n    while\
    \ index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpjda_850u.rs:10:33\n     |\n10   |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpjda_850u.rs:11:28\n\
    \   |\n11 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpjda_850u.rs:13:46\n   |\n\
    13 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmpjda_850u.rs:13:24\n     |\n13   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = substring.find(string.as_bytes(), pos);\n        if found\
    \ == String::npos {\n            break;\n        }\n        counter += 1;\n  \
    \      pos = found + 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpcyp0s5xq.rs:12:35\n     |\n12   |         let mut found = substring.find(string.as_bytes(),\
    \ pos);\n     |                                   ^^^^ -----------------  ---\
    \ supplied 2 arguments\n     |                                   |\n     |   \
    \                                expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0599]: no function or associated item named\
    \ `npos` found for struct `String` in the current scope\n  --> /tmp/tmpcyp0s5xq.rs:13:29\n\
    \   |\n13 |         if found == String::npos {\n   |                         \
    \    ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpcyp0s5xq.rs:17:21\n   |\n\
    17 |         pos = found + 1;\n   |               ----- ^ - {integer}\n   |  \
    \             |\n   |               Option<usize>\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        while pos < string.len() && found ==\
    \ false {\n            if string[pos] == substring[0] {\n                counter\
    \ += 1;\n                pos += 1;\n                found = true;\n          \
    \  } else if string[pos] == substring[1] {\n                counter += 1;\n  \
    \              pos += 1;\n                found = true;\n            } else if\
    \ string[pos] == substring[2] {\n                counter += 1;\n             \
    \   pos += 1;\n                found = true;\n            } else if string[pos]\
    \ == substring[3] {\n                counter += 1;\n                pos += 1;\n\
    \                found = true;\n            } else if string[pos] == substring[4]\
    \ {\n                counter += 1;\n                pos += 1;\n              \
    \  found = true;\n            } else if string[pos] == substring[5] {\n      \
    \          counter += 1;\n                pos += 1;\n                found = true;\n\
    \            } else if string[pos] == substring[6] {\n                counter\
    \ += 1;\n                pos += 1;\n                found = true;\n          \
    \  } else if string[pos] == substring[7] {\n                counter += 1;\n  \
    \              pos += 1;\n                found = true;\n            } else if\
    \ string[pos] == substring[8] {\n                counter += 1;\n             \
    \   pos += 1;\n                found = true;\n            } else if string[pos]\
    \ == substring[9] {\n                counter += 1;\n                pos += 1;\n\
    \                found = true;\n            } else if string[pos] == substring[10]\
    \ {\n                counter += 1;\n                pos += 1;\n              \
    \  found = true;\n            } else if string[pos] == substring[11] {\n     \
    \           counter += 1;\n                pos += 1;\n                found =\
    \ true;\n            } else if string[pos] == substring[12] {\n              \
    \  counter += 1;\n                pos += 1;\n                found = true;\n \
    \           } else if string[pos] == substring[13] {\n                counter\
    \ += 1;\n                pos += 1;\n                found = true;\n          \
    \  } else if string[pos] == substring[14] {\n                counter += 1;\n \
    \               pos += 1;\n                found = true;\n            } else if\
    \ string[pos] == substring[15] {\n                counter += 1;\n            \
    \    pos += 1;\n                found = true;\n            } else if string[pos]\
    \ == substring[16] {\n                counter += 1;\n                pos += 1;\n\
    \                found = true;\n            } else if string[pos] == substring[17]\
    \ {\n                counter += 1;\n                pos += 1;\n              \
    \  found = true;\n            } else if string[pos] == substring[18] {\n     \
    \           counter += 1;\n                pos += 1;\n\n}\n\nfn main() {\n   \
    \ let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpiki1s74w.rs:98:3\n\
    \   |\n8  | fn how_many_times(string: String, substring: String) -> isize {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n11 |     while pos < string.len() {\n   |                  \
    \            - unclosed delimiter\n12 |         let mut found = false;\n13 | \
    \        while pos < string.len() && found == false {\n   |                  \
    \                                  - unclosed delimiter\n...\n86 |           \
    \  } else if string[pos] == substring[18] {\n   |                            \
    \                        - this delimiter might not be properly closed...\n...\n\
    90 | }\n   | - ...as it matches this but it has different indentation\n...\n98\
    \ | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpiki1s74w.rs:14:16\n   |\n14 |             if string[pos] == substring[0]\
    \ {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpiki1s74w.rs:14:31\n   |\n14 |             if string[pos] == substring[0]\
    \ {\n   |                               ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n         "
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(mut a, b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_7wvl0v.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(mut\
    \ a, b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(mut\
    \ a, b)| a == b).count().try_into().unwrap()\n  |                            \
    \                                                   ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut iter = string.char_indices();\n    iter.for_each(|(i,\
    \ c)| {\n        if c == substring.chars().nth(i) {\n            count += 1;\n\
    \        }\n    });\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaln19eew.rs:12:17\n   |\n\
    12 |         if c == substring.chars().nth(i) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if c == substring.chars().nth(pos) {\n                found = true;\n    \
    \            break;\n            }\n        }\n        if found {\n          \
    \  counter += 1;\n        }\n        pos += 1;\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgpyg1nww.rs:14:21\n   |\n\
    14 |             if c == substring.chars().nth(pos) {\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n  \
    \ = note: expected type `char`\n              found enum `Option<char>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = string.find(substring, pos);\n        if found == String::npos\
    \ {\n            break;\n        }\n        count += 1;\n        pos = found +\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpznag8edq.rs:12:32\n     |\n12   |         let mut found = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpznag8edq.rs:13:29\n   |\n\
    13 |         if found == String::npos {\n   |                             ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmpznag8edq.rs:17:21\n   |\n17 |\
    \         pos = found + 1;\n   |               ----- ^ - {integer}\n   |     \
    \          |\n   |               Option<usize>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            count += 1;\n  \
    \      }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptw7wz1my.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut iter = string.char_indices();\n    iter.for_each(|(index,\
    \ char)| {\n        if char == substring {\n            count += 1;\n        }\n\
    \        if index == string.len() - substring.len() {\n            count += 1;\n\
    \        }\n    });\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0t7twh_5.rs:12:20\n   |\n\
    12 |         if char == substring {\n   |                    ^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut i = 0;\n    while i < string.len() && i\
    \ < substring.len() {\n        if string[i] == substring[i] {\n            i +=\
    \ 1;\n        } else {\n            counter += 1;\n        }\n    }\n    counter\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzbd531s0.rs:12:12\n\
    \   |\n12 |         if string[i] == substring[i] {\n   |            ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzbd531s0.rs:12:25\n   |\n12 |         if string[i] == substring[i]\
    \ {\n   |                         ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut i = pos;\n        while i < string.len() && string[i] == substring[pos]\
    \ {\n            i += 1;\n            pos += 1;\n        }\n        count += 1;\n\
    \        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41oyzgy9.rs:13:35\n\
    \   |\n13 |         while i < string.len() && string[i] == substring[pos] {\n\
    \   |                                   ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp41oyzgy9.rs:13:48\n   |\n13 |         while i < string.len() &&\
    \ string[i] == substring[pos] {\n   |                                        \
    \        ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            counter += 1;\n\
    \        }\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpwd4fh8ai.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut iter = string.char_indices();\n    loop {\n\
    \        let (index, substring_index) = iter.next();\n        if substring_index\
    \ == substring.len() {\n            count += 1;\n            break;\n        }\n\
    \        if substring[index] == substring[substring_index] {\n            count\
    \ += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn0rhos6g.rs:12:13\n   |\n\
    12 |         let (index, substring_index) = iter.next();\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^\
    \   ----------- this expression has type `Option<(usize, char)>`\n   |       \
    \      |\n   |             expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<(usize, char)>`\n             found tuple `(_, _)`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            count += 1;\n  \
    \      }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptw7wz1my.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for c in string.chars() {\n        if c == substring.chars().nth(0)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(1)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(2)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(3)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(4)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(5)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(6)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(7)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(8)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(9)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(10)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(11)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(12)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(13)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(14)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(15)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(16)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(17)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(18)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(19)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(20)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(21)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(22)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(23)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(24)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(25)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(26)\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(27)\
    \ {\n            counter += 1;\n        }\n        if c == \n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpj6ov3zav.rs:104:3\n\
    \    |\n8   | fn how_many_times(string: String, substring: String) -> isize {\n\
    \    |                                                               - unclosed\
    \ delimiter\n9   |     let mut counter = 0;\n10  |     for c in string.chars()\
    \ {\n    |                             - this delimiter might not be properly\
    \ closed...\n...\n96  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n104 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpj6ov3zav.rs:96:1\n   |\n96 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpj6ov3zav.rs:11:17\n   |\n11 |  \
    \       if c == substring.chars().nth(0) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpj6ov3zav.rs:14:17\n   |\n14 |         if c == substring.chars().nth(1)\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj6ov3zav.rs:17:17\n   |\n17 |\
    \         if c == substring.chars().nth(2) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpj6ov3zav.rs:20:17\n   |\n20 |         if c == substring.chars().nth(3)\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpj6ov3zav.rs:23:17\n   |\n23 |\
    \         if c == substring.chars().nth(4) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpj6ov3zav.rs:26:"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.contains(&substring, pos) {\n            count += 1;\n    \
    \    }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp2h9ys19c.rs:12:19\n     |\n12   |         if string.contains(&substring,\
    \ pos) {\n     |                   ^^^^^^^^ ----------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = string.find(substring);\n    while\
    \ index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpjda_850u.rs:10:33\n     |\n10   |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpjda_850u.rs:11:28\n\
    \   |\n11 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpjda_850u.rs:13:46\n   |\n\
    13 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmpjda_850u.rs:13:24\n     |\n13   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref a, ref b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprn48f4fm.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count().try_into().unwrap()\n  |                        \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_iter = string.char_indices();\n   \
    \ let mut substring_iter = substring.char_indices();\n    loop {\n        if let\
    \ Some((start, end)) = string_iter.next() {\n            if let Some((s, e)) =\
    \ substring_iter.next() {\n                if start <= s && e >= s && e <= end\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \   }\n        if !string_iter.next().is_some() {\n            break;\n      \
    \  }\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpatqyh7xd.rs:15:39\n   |\n\
    15 |                 if start <= s && e >= s && e <= end {\n   |             \
    \                          ^ expected `char`, found `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut end = string.len();\n        if end > substring.len() {\n   \
    \         end = substring.len();\n        }\n        if string.contains(&substring[..end])\
    \ {\n            count += 1;\n        }\n        pos += 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp4gk54_du.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if c == substring.chars().nth(pos) {\n                found = true;\n    \
    \            break;\n            }\n        }\n        if found {\n          \
    \  count += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgn5z2yvh.rs:14:21\n   |\n\
    14 |             if c == substring.chars().nth(pos) {\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n   |\n  \
    \ = note: expected type `char`\n              found enum `Option<char>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut index = string.find(substring, pos);\n        if index == String::npos\
    \ {\n            break;\n        }\n        pos = index + 1;\n        count +=\
    \ 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmps29bqoul.rs:12:32\n     |\n12   |         let mut index = string.find(substring,\
    \ pos);\n     |                                ^^^^ ---------  --- supplied 2\
    \ arguments\n     |                                |\n     |                 \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no function or associated item named `npos` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmps29bqoul.rs:13:29\n   |\n\
    13 |         if index == String::npos {\n   |                             ^^^^\
    \ function or associated item not found in `String`\n\nerror[E0369]: cannot add\
    \ `{integer}` to `Option<usize>`\n  --> /tmp/tmps29bqoul.rs:16:21\n   |\n16 |\
    \         pos = index + 1;\n   |               ----- ^ - {integer}\n   |     \
    \          |\n   |               Option<usize>\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0369, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut i = pos;\n        while i < string.len() && string[i] == substring[pos]\
    \ {\n            i += 1;\n            pos += 1;\n        }\n        count += 1;\n\
    \        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp41oyzgy9.rs:13:35\n\
    \   |\n13 |         while i < string.len() && string[i] == substring[pos] {\n\
    \   |                                   ^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp41oyzgy9.rs:13:48\n   |\n13 |         while i < string.len() &&\
    \ string[i] == substring[pos] {\n   |                                        \
    \        ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for c in string.chars() {\n        if c == substring.chars()\
    \ {\n            counter += 1;\n        }\n        if c == substring.chars().nth(0)\
    \ {\n            counter += 1;\n        }\n    }\n    counter\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl22p6hmz.rs:11:17\n   |\n\
    11 |         if c == substring.chars() {\n   |                 ^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `Chars`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpl22p6hmz.rs:14:17\n   |\n14 |         if c == substring.chars().nth(0)\
    \ {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum\
    \ `Option`\n   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        while !found && pos < string.len() {\n\
    \            if string[pos] == substring[0] {\n                count += 1;\n \
    \               pos += 1;\n                found = true;\n            } else {\n\
    \                pos += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpopra94ad.rs:14:16\n\
    \   |\n14 |             if string[pos] == substring[0] {\n   |               \
    \ ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpopra94ad.rs:14:31\n   |\n14 |             if string[pos] == substring[0]\
    \ {\n   |                               ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(mut a, b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc_7wvl0v.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(mut\
    \ a, b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(mut\
    \ a, b)| a == b).count().try_into().unwrap()\n  |                            \
    \                                                   ++++++++++++++++++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp7ud8xame.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(c)).count()\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp618tqgxi.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \     |                                         -------- ^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n9    |     string.chars().filter(|c|\
    \ substring.contains(*c)).count()\n     |                                    \
    \              +\n\nerror[E0308]: mismatched types\n --> /tmp/tmp618tqgxi.rs:9:5\n\
    \  |\n8 | fn how_many_times(string: String, substring: String) -> isize {\n  |\
    \                                                         ----- expected `isize`\
    \ because of return type\n9 |     string.chars().filter(|c| substring.contains(c)).count()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n  |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c| substring.contains(c)).count().try_into().unwrap()\n\
    \  |                                                             ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    for c in string.chars() {\n        if c == substring.chars().nth(0)\
    \ {\n            counter += 1;\n        } else {\n            if c == substring.chars().nth(1)\
    \ {\n                counter += 1;\n            } else {\n                if c\
    \ == substring.chars().nth(2) {\n                    counter += 1;\n         \
    \       }\n            }\n        }\n    }\n    counter\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt28s9613.rs:11:17\n   |\n\
    11 |         if c == substring.chars().nth(0) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpt28s9613.rs:14:21\n   |\n14 |             if c == substring.chars().nth(1)\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt28s9613.rs:17:25\n\
    \   |\n17 |                 if c == substring.chars().nth(2) {\n   |         \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if c == substring.chars()[pos] {\n                found = true;\n        \
    \        break;\n            }\n        }\n        if found {\n            count\
    \ += 1;\n        }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"\
    ), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpczdb8ltk.rs:14:21\n\
    \   |\n14 |             if c == substring.chars()[pos] {\n   |               \
    \      ^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            counter += 1;\n\
    \        }\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpwd4fh8ai.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if c == substring[pos] {\n                found = true;\n                counter\
    \ += 1;\n            }\n            pos += 1;\n        }\n        if !found {\n\
    \            break;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu63hd145.rs:14:21\n\
    \   |\n14 |             if c == substring[pos] {\n   |                     ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            counter += 1;\n\
    \        }\n        pos += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpwd4fh8ai.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut end = string.len();\n        if end > substring.len() {\n   \
    \         end = substring.len();\n        }\n        if string.contains(&substring[..end])\
    \ {\n            count += 1;\n            pos += end;\n        } else {\n    \
    \        pos += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmp3bt7_wuh.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_iter = string.char_indices();\n   \
    \ let mut substring_iter = substring.char_indices();\n    while let Some((substring_start,\
    \ substring_end)) = substring_iter.next() {\n        let substring_slice = string.chars().skip(substring_start).take(substring_end\
    \ - substring_start);\n        if substring_slice.contains(&substring_iter) {\n\
    \            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpjidy5t6n.rs:13:87\n\
    \   |\n13 |         let substring_slice = string.chars().skip(substring_start).take(substring_end\
    \ - substring_start);\n   |                                                  \
    \                       ------------- ^ --------------- usize\n   |          \
    \                                                               |\n   |      \
    \                                                                   char\n\nerror[E0599]:\
    \ no method named `contains` found for struct `std::iter::Take` in the current\
    \ scope\n  --> /tmp/tmpjidy5t6n.rs:14:28\n   |\n14 |         if substring_slice.contains(&substring_iter)\
    \ {\n   |                            ^^^^^^^^ method not found in `std::iter::Take<Skip<Chars<'_>>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        let mut found = false;\n        for c in string.chars() {\n         \
    \   if c == substring[pos] {\n                found = true;\n                break;\n\
    \            }\n        }\n        if found {\n            count += 1;\n     \
    \   }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps7saxj8j.rs:14:21\n\
    \   |\n14 |             if c == substring[pos] {\n   |                     ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut string_iter = string.char_indices();\n   \
    \ let mut substring_iter = substring.char_indices();\n    let mut substring_end\
    \ = substring.char_indices().next();\n    while let Some((start, end)) = substring_end\
    \ {\n        if start > end {\n            break;\n        }\n        let mut\
    \ substring_start = start;\n        while let Some((substring_end, _)) = substring_iter.next()\
    \ {\n            if substring_end > substring_start {\n                break;\n\
    \            }\n            if substring_start < end {\n                count\
    \ += 1;\n            }\n            substring_start = substring_end;\n       \
    \ }\n        substring_end = end;\n    }\n    count\n}\n\nfn main() {\n    let\
    \ candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpftazgdc3.rs:14:20\n   |\n\
    14 |         if start > end {\n   |                    ^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpftazgdc3.rs:22:34\n\
    \   |\n22 |             if substring_start < end {\n   |                     \
    \             ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpftazgdc3.rs:27:25\n   |\n12 |     let mut substring_end = substring.char_indices().next();\n\
    \   |                             ------------------------------- expected due\
    \ to this value\n...\n27 |         substring_end = end;\n   |                \
    \         ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<(usize, char)>`\n              found type `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for c in string.chars() {\n        if c == substring.chars().nth(0)\
    \ {\n            count += 1;\n        } else {\n            count += how_many_times(&string[..c],\
    \ substring);\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb56sab8a.rs:11:17\n   |\n\
    11 |         if c == substring.chars().nth(0) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found enum `Option`\n   |\n   = note: expected type `char`\n\
    \              found enum `Option<char>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `RangeTo<char>`\n  --> /tmp/tmpb56sab8a.rs:14:38\n   |\n14 | \
    \            count += how_many_times(&string[..c], substring);\n   |         \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `RangeTo<char>`\n\
    \   |\n   = help: the trait `Index<RangeTo<char>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb56sab8a.rs:14:37\n\
    \   |\n14 |             count += how_many_times(&string[..c], substring);\n  \
    \ |                                     ^^^^^^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n14 -             count\
    \ += how_many_times(&string[..c], substring);\n14 +             count += how_many_times(string[..c],\
    \ substring);\n   | \n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(sub, main)| sub == main).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpj73d7pox.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(sub,\
    \ main)| sub == main).count().try_into().unwrap()\n  |                       \
    \                                                              ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = string.find(substring);\n    while\
    \ index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpjda_850u.rs:10:33\n     |\n10   |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpjda_850u.rs:11:28\n\
    \   |\n11 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpjda_850u.rs:13:46\n   |\n\
    13 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmpjda_850u.rs:13:24\n     |\n13   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref a, ref b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprn48f4fm.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count().try_into().unwrap()\n  |                        \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut index = string.find(substring);\n    while\
    \ index != String::npos {\n        counter += 1;\n        index = string.find(substring,\
    \ index + 1);\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpjda_850u.rs:10:33\n     |\n10   |     let mut index = string.find(substring);\n\
    \     |                            ---- ^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                            |\n     |                 \
    \           required by a bound introduced by this call\n     |\n     = note:\
    \ the trait bound `String: Pattern<'_>` is not satisfied\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `String`\nnote:\
    \ required by a bound in `core::str::<impl str>::find`\nhelp: consider borrowing\
    \ here\n     |\n10   |     let mut index = string.find(&substring);\n     |  \
    \                               +\n\nerror[E0599]: no function or associated item\
    \ named `npos` found for struct `String` in the current scope\n  --> /tmp/tmpjda_850u.rs:11:28\n\
    \   |\n11 |     while index != String::npos {\n   |                          \
    \  ^^^^ function or associated item not found in `String`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmpjda_850u.rs:13:46\n   |\n\
    13 |         index = string.find(substring, index + 1);\n   |                \
    \                        ----- ^ - {integer}\n   |                           \
    \             |\n   |                                        Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmpjda_850u.rs:13:24\n     |\n13   |         index = string.find(substring,\
    \ index + 1);\n     |                        ^^^^ ---------  --------- supplied\
    \ 2 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0369, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            count += 1;\n  \
    \      }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptw7wz1my.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() as isize\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmpbo4_cl5w.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() as isize\n  |\
    \                                 ^^ no implementation for `&char == String`\n\
    \  |\n  = help: the trait `PartialEq<String>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref a, ref b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprn48f4fm.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count().try_into().unwrap()\n  |                        \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    for c in string.chars() {\n        if substring.contains(&c)\
    \ {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp7ud8xame.rs:11:31\n\
    \     |\n11   |         if substring.contains(&c) {\n     |                  \
    \    -------- ^^ expected an `Fn<(char,)>` closure, found `char`\n     |     \
    \                 |\n     |                      required by a bound introduced\
    \ by this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented\
    \ for `char`\n     = note: required because of the requirements on the impl of\
    \ `FnOnce<(char,)>` for `&char`\n     = note: required because of the requirements\
    \ on the impl of `Pattern<'_>` for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::contains`\nhelp: consider dereferencing here\n     |\n11   |         if\
    \ substring.contains(*&c) {\n     |                               +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n}\n\nfn main()\
    \ {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmp2rhukx_1.rs:9:50\n\
    \     |\n9    |     string.chars().filter(|c| substring.contains(&c)).count()\n\
    \     |                                         -------- ^^ expected an `Fn<(char,)>`\
    \ closure, found `char`\n     |                                         |\n  \
    \   |                                         required by a bound introduced by\
    \ this call\n     |\n     = help: the trait `Fn<(char,)>` is not implemented for\
    \ `char`\n     = help: the trait `Pattern<'a>` is implemented for `char`\n   \
    \  = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&char`\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `&&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp2rhukx_1.rs:9:5\n  |\n8 | fn how_many_times(string:\
    \ String, substring: String) -> isize {\n  |                                 \
    \                        ----- expected `isize` because of return type\n9 |  \
    \   string.chars().filter(|c| substring.contains(&c)).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().filter(|c|\
    \ substring.contains(&c)).count().try_into().unwrap()\n  |                   \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut count = 0;\n    let mut pos = 0;\n    while pos < string.len() {\n\
    \        if string.starts_with(substring, pos) {\n            count += 1;\n  \
    \      }\n        pos += 1;\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = how_many_times;\n    assert_eq!(candidate(String::from(\"\"), String::from(\"\
    x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"), String::from(\"\
    x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"), String::from(\"\
    cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"), String::from(\"\
    john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmptw7wz1my.rs:12:19\n     |\n12   |         if string.starts_with(substring,\
    \ pos) {\n     |                   ^^^^^^^^^^^ ---------  --- supplied 2 arguments\n\
    \     |                   |\n     |                   expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(ref a, ref b)| a == b).count()\n\
    }\n\nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmprn48f4fm.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(ref\
    \ a, ref b)| a == b).count().try_into().unwrap()\n  |                        \
    \                                                           ++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 101
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   let mut counter = 0;\n    let mut i = 0;\n    while i < string.len() {\n \
    \       if string.contains(&substring) {\n            counter += 1;\n        }\n\
    \        i += 1;\n    }\n    counter\n}\n\nfn main() {\n    let candidate = how_many_times;\n\
    \    assert_eq!(candidate(String::from(\"\"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"\
    xyxyxyx\"), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"\
    cacacacac\"), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"\
    john doe\"), String::from(\"john\")), 1);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `7`,\n right: `4`', /tmp/tmphw6a2epy.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|&(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpve8ec1p6.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|&(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|&(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                            ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().filter(|c| c == substring).count() + 1\n}\n\nfn main() {\n\
    \    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `String`\n --> /tmp/tmp32v8frow.rs:9:33\n\
    \  |\n9 |     string.chars().filter(|c| c == substring).count() + 1\n  |     \
    \                            ^^ no implementation for `&char == String`\n  |\n\
    \  = help: the trait `PartialEq<String>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp32v8frow.rs:9:5\n  |\n8 | fn how_many_times(string: String,\
    \ substring: String) -> isize {\n  |                                         \
    \                ----- expected `isize` because of return type\n9 |     string.chars().filter(|c|\
    \ c == substring).count() + 1\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     (string.chars().filter(|c|\
    \ c == substring).count() + 1).try_into().unwrap()\n  |     +                \
    \                                     +++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010990
- exit_code: 1
  program: "/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times(String::from(\"\"),\
    \ String::from(\"a\"))\n/// 0\n/// >>> how_many_times(String::from(\"aaa\"), String::from(\"\
    a\"))\n/// 3\n/// >>> how_many_times(String::from(\"aaaa\"), String::from(\"aa\"\
    ))\n/// 3\nfn how_many_times(string: String, substring: String) -> isize {\n \
    \   string.chars().zip(substring.chars()).filter(|(a, b)| a == b).count()\n}\n\
    \nfn main() {\n    let candidate = how_many_times;\n    assert_eq!(candidate(String::from(\"\
    \"), String::from(\"x\")), 0);\n    assert_eq!(candidate(String::from(\"xyxyxyx\"\
    ), String::from(\"x\")), 4);\n    assert_eq!(candidate(String::from(\"cacacacac\"\
    ), String::from(\"cac\")), 4);\n    assert_eq!(candidate(String::from(\"john doe\"\
    ), String::from(\"john\")), 1);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpv4l5hdpa.rs:9:5\n  |\n8 |\
    \ fn how_many_times(string: String, substring: String) -> isize {\n  |       \
    \                                                  ----- expected `isize` because\
    \ of return type\n9 |     string.chars().zip(substring.chars()).filter(|(a, b)|\
    \ a == b).count()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n  |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n  |\n9 |     string.chars().zip(substring.chars()).filter(|(a,\
    \ b)| a == b).count().try_into().unwrap()\n  |                               \
    \                                           ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010990
