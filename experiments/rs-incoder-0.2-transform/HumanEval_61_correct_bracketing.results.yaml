language: rs
name: HumanEval_61_correct_bracketing
results:
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current.len() == 0 {\n            continue;\n        }\n        if\
    \ current.chars().any(|c| !c.is_ascii_letter()) {\n            continue;\n   \
    \     }\n        if current.chars().any(|c| !c.is_ascii_digit()) {\n         \
    \   continue;\n        }\n        if current.chars().any(|c| !c.is_ascii_letter()\
    \ && !c.is_ascii_digit()) {\n            continue;\n        }\n        if current.chars().any(|c|\
    \ c == ')') {\n            if let Some(last) = stack.pop() {\n               \
    \ if last.chars().any(|c| c == ')') {\n                    continue;\n       \
    \         }\n            }\n        }\n        if current.chars().any(|c| c ==\
    \ '(') {\n            if let Some(last) = stack.pop() {\n                if last.chars().any(|c|\
    \ c == '(') {\n                    continue;\n                }\n            }\n\
    \        }\n        stack.push(current);\n    }\n    stack.len() == 0\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpz6jh9j3y.rs:19:20\n   |\n19 |         if current.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                    ^^^^^ method not found in `Vec<char>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmpz6jh9j3y.rs:22:20\n   |\n22 |         if current.chars().any(|c|\
    \ !c.is_ascii_digit()) {\n   |                    ^^^^^ method not found in `Vec<char>`\n\
    \nerror[E0599]: no method named `chars` found for struct `Vec<char>` in the current\
    \ scope\n  --> /tmp/tmpz6jh9j3y.rs:25:20\n   |\n25 |         if current.chars().any(|c|\
    \ !c.is_ascii_letter() && !c.is_ascii_digit()) {\n   |                    ^^^^^\
    \ method not found in `Vec<char>`\n\nerror[E0599]: no method named `chars` found\
    \ for struct `Vec<char>` in the current scope\n  --> /tmp/tmpz6jh9j3y.rs:28:20\n\
    \   |\n28 |         if current.chars().any(|c| c == ')') {\n   |             \
    \       ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpz6jh9j3y.rs:30:25\n\
    \   |\n30 |                 if last.chars().any(|c| c == ')') {\n   |        \
    \                 ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method\
    \ named `chars` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpz6jh9j3y.rs:35:20\n\
    \   |\n35 |         if current.chars().any(|c| c == '(') {\n   |             \
    \       ^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method named\
    \ `chars` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpz6jh9j3y.rs:37:25\n\
    \   |\n37 |                 if last.chars().any(|c| c == '(') {\n   |        \
    \                 ^^^^^ method not found in `Vec<char>`\n\nerror: aborting due\
    \ to 7 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5m0di3cc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\");\n\
    \    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\"]\", \"]\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplgjd7y4x.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpx66zb9zn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while !brackets.ends_with('(') &&\
    \ brackets.ends_with(')')\n    {\n        brackets = brackets.replace('(', '(');\n\
    \        brackets = brackets.replace(')', '(');\n    }\n    brackets.ends_with(')')\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv9up574g.rs:15:42\n   |\n\
    15 |         brackets = brackets.replace('(', '(');\n   |                    \
    \                      ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n15 |         brackets = brackets.replace('(',\
    \ \"(\");\n   |                                          ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv9up574g.rs:16:42\n   |\n16 |         brackets\
    \ = brackets.replace(')', '(');\n   |                                        \
    \  ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n16 |         brackets = brackets.replace(')',\
    \ \"(\");\n   |                                          ~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpup42vfw8.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpup42vfw8.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n\n    for bracket in brackets.chars() {\n\
    \        if bracket == '(' {\n            stack.push(bracket);\n            opening_brackets.push(bracket);\n\
    \        } else if bracket == ')' {\n            if !stack.is_empty() {\n    \
    \            let opening_bracket = opening_brackets.pop();\n                if\
    \ opening_bracket != bracket {\n                    return false;\n          \
    \      }\n            }\n            closing_brackets.push(bracket);\n       \
    \ } else if bracket == '[' {\n            stack.push(bracket);\n        } else\
    \ if bracket == ']' {\n            if !stack.is_empty() {\n                let\
    \ opening_bracket = opening_brackets.pop();\n                if opening_bracket\
    \ != bracket {\n                    return false;\n                }\n       \
    \     }\n            closing_brackets.push(bracket);\n        } else if bracket\
    \ == '{' {\n            stack.push(bracket);\n        } else if bracket == '}'\
    \ {\n            if !stack.is_empty() {\n                let opening_bracket =\
    \ opening_brackets.pop();\n                if opening_bracket != bracket {\n \
    \                   return false;\n                }\n            }\n        \
    \    closing_brackets.push(bracket);\n        }\n    }\n\n    if !stack.is_empty()\
    \ {\n        return false;\n    }\n\n    if opening_brackets.len() != closing_brackets.len()\
    \ {\n        return false;\n    }\n\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp0t3zz08.rs:23:39\n   |\n\
    23 |                 if opening_bracket != bracket {\n   |                   \
    \                    ^^^^^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<char>`\n              found type `char`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n23 |                 if opening_bracket\
    \ != Some(bracket) {\n   |                                       +++++       +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp0t3zz08.rs:33:39\n   |\n33 |\
    \                 if opening_bracket != bracket {\n   |                      \
    \                 ^^^^^^^ expected enum `Option`, found `char`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found type `char`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n33 |                 if opening_bracket != Some(bracket)\
    \ {\n   |                                       +++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp0t3zz08.rs:43:39\n   |\n43 |              \
    \   if opening_bracket != bracket {\n   |                                    \
    \   ^^^^^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<char>`\n              found type `char`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n43 |                 if opening_bracket != Some(bracket) {\n\
    \   |                                       +++++       +\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp28o4l5aq.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = brackets.chars().next().unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(').count();\n    let\
    \ mut closing_brackets = brackets.chars().filter(|c| c == ')').count();\n    while\
    \ opening_brackets > 0 || closing_brackets > 0 {\n        if opening_brackets\
    \ > 0 && closing_brackets > 0 {\n            if opening_brackets == closing_brackets\
    \ {\n                opening_brackets -= 1;\n                closing_brackets\
    \ -= 1;\n            } else {\n                return false;\n            }\n\
    \        } else if opening_brackets > 0 {\n            opening_brackets -= 1;\n\
    \        } else {\n            closing_brackets -= 1;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphvrbfpr1.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphvrbfpr1.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')').count();\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    {\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"[\"\
    );\n    brackets.replace(\"}\", \"]\");\n    brackets.replace(\"(\", \"{\");\n\
    \    brackets.replace(\")\", \"}\");\n    brackets.replace(\"{\", \"(\");\n  \
    \  brackets.replace(\"}\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"\
    ]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\", \"\
    ]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"}\"\
    );\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\");\n\
    \    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n  \
    \  brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    [\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"{\"\
    );\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"[\");\n\
    \    brackets.replace(\"}\", \"]\");\n    brackets.replace(\"(\", \"{\");\n  \
    \  brackets.replace(\")\", \"}\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfa3v1fd8.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            let mut opening_bracket = String::new();\n            let mut\
    \ closing_bracket = String::new();\n            let mut opening_brackets = String::new();\n\
    \            let mut closing_brackets = String::new();\n            if brackets.starts_with(\"\
    (\") {\n                opening_bracket = brackets.split_off(1).unwrap().to_string();\n\
    \                opening_brackets = opening_bracket.clone();\n               \
    \ brackets = brackets.split_off(1).unwrap().to_string();\n            } else if\
    \ brackets.starts_with(\")\") {\n                closing_bracket = brackets.split_off(1).unwrap().to_string();\n\
    \                closing_brackets = closing_bracket.clone();\n               \
    \ brackets = brackets.split_off(1).unwrap().to_string();\n            } else {\n\
    \                break;\n            }\n        }\n        if opening_brackets.len()\
    \ == closing_brackets.len() {\n            opening_brackets += &opening_bracket;\n\
    \            closing_brackets += &closing_bracket;\n        } else {\n       \
    \     return false;\n        }\n    }\n    opening_brackets == closing_brackets\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp32iwohi5.rs:26:57\n   |\n26 |                 opening_bracket\
    \ = brackets.split_off(1).unwrap().to_string();\n   |                        \
    \                                 ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp32iwohi5.rs:28:50\n   |\n28 |                 brackets = brackets.split_off(1).unwrap().to_string();\n\
    \   |                                                  ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp32iwohi5.rs:30:57\n   |\n30 |          \
    \       closing_bracket = brackets.split_off(1).unwrap().to_string();\n   |  \
    \                                                       ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `unwrap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp32iwohi5.rs:32:50\n   |\n32 |          \
    \       brackets = brackets.split_off(1).unwrap().to_string();\n   |         \
    \                                         ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '(' {\n       \
    \     opening_brackets.push('(');\n        } else if bracket == ')' {\n      \
    \      closing_brackets.push(')');\n        } else if bracket == '{' {\n     \
    \       opening_brackets.push('{');\n        } else if bracket == '}' {\n    \
    \        closing_brackets.push('}');\n        }\n    }\n\n    opening_brackets.len()\
    \ == closing_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpt9h83789.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() != 0 {\n\
    \                return false;\n            }\n        }\n    }\n    stack.len()\
    \ == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(bracket);\n        } else if\
    \ bracket == ')' {\n            if stack.is_empty() {\n                return\
    \ false;\n            }\n            stack.pop();\n        } else if stack.len()\
    \ > 0 && stack.is_empty() {\n            return false;\n        }\n    }\n   \
    \ stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj4v7v98t.rs:15:24\n   |\n\
    15 |             stack.push(bracket);\n   |                        ^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut closed_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack_size = Vec::new();\n    let mut\
    \ closed_brackets_stack_size = Vec::new();\n    let mut open_brackets_stack =\
    \ Vec::new();\n    let mut closed_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut closed_brackets_count = Vec::new();\n    let mut\
    \ open_brackets_stack_size = Vec::new();\n    let mut closed_brackets_stack_size\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut closed_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack_size = Vec::new();\n    let mut\
    \ closed_brackets_stack_size = Vec::new();\n    let mut open_brackets_stack =\
    \ Vec::new();\n    let mut closed_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut closed_brackets_count = Vec::new();\n    let mut\
    \ open_brackets_stack_size = Vec::new();\n    let mut closed_brackets_stack_size\
    \ = Vec::new();\n    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = Vec::new();\n    let mut closed_brackets_count\
    \ = Vec::new();\n    let mut open_brackets_stack_size = Vec::new();\n    let mut\
    \ closed_brackets_stack_size = Vec::new();\n    let mut open_brackets_stack =\
    \ Vec::new();\n    let mut closed_brackets_stack = Vec::new();\n    let mut open_brackets_count\
    \ = Vec::new();\n    let mut closed_brackets_count = Vec::new();\n    let mut\
    \ open_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmplfmoxfg0.rs:48:21\n   |\n\
    48 |     let mut open_bra\n   |                     ^ help: add `;` here\n49 |\
    \ }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplfmoxfg0.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_string: String = String::new();\n    let mut close_brackets_string:\
    \ String = String::new();\n    let mut open_brackets_string_size: usize = 0;\n\
    \    let mut close_brackets_string_size: usize = 0;\n    let mut open_brackets_string_size2:\
    \ usize = 0;\n    let mut close_brackets_string_size2: usize = 0;\n    let mut\
    \ open_brackets_string_size3: usize = 0;\n    let mut close_brackets_string_size3:\
    \ usize = 0;\n    let mut open_brackets_string_size4: usize = 0;\n    let mut\
    \ close_brackets_string_size4: usize = 0;\n    let mut open_brackets_string_size5:\
    \ usize = 0;\n    let mut close_brackets_string_size5: usize = 0;\n    let mut\
    \ open_brackets_string_size6: usize = 0;\n    let mut close_brackets_string_size6:\
    \ usize = 0;\n    let mut open_brackets_string_size7: usize = 0;\n    let mut\
    \ close_brackets_string_size7: usize = 0;\n    let mut open_brackets_string_size8:\
    \ usize = 0;\n    let mut close_brackets_string_size8: usize = 0;\n    let mut\
    \ open_brackets_string_size9: usize = 0;\n    let mut close_brackets_string_size9:\
    \ usize = 0;\n    let mut open_brackets_string_size10: usize = 0;\n    let mut\
    \ close_brackets_string_size10: usize = 0;\n    let mut open_brackets_string_size11:\
    \ usize = 0;\n    let mut close_brackets_string_size11: usize = 0;\n    let mut\
    \ open_brackets_string_size12: usize = 0;\n    let mut close_brackets_string_size12:\
    \ usize = 0;\n    let mut open_brackets_string_size13: usize = 0;\n    let mut\
    \ close_brackets_string_size\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6z4tm9v2.rs:44:39\n   |\n\
    44 |     let mut close_brackets_string_size\n   |                            \
    \           ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6z4tm9v2.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while let Some(mut c) = stack.pop() {\n        if c == ')' {\n          \
    \  if let Some(mut c) = stack.pop() {\n                if c != '(' {\n       \
    \             return false;\n                }\n            }\n        } else\
    \ {\n            if c != '(' {\n                return false;\n            }\n\
    \            stack.push(c);\n        }\n    }\n    true\n}\n\nfn main() {\n  \
    \  let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpoj2uocq2.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_digit()).collect::<String>());\n\
    \    while let Some(item) = stack.pop() {\n        if item == \"(\" {\n      \
    \      stack.push(\")\");\n        } else if item == \")\" {\n            stack.push(\"\
    (\");\n        } else {\n            return false;\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptaimqdp3.rs:16:24\n   |\n\
    16 |             stack.push(\")\");\n   |                        ^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                        |\n \
    \  |                        expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptaimqdp3.rs:18:24\n   |\n18 |             stack.push(\"\
    (\");\n   |                        ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    stack.push(brackets);\n    while let Some(mut\
    \ brackets) = stack.pop() {\n        if brackets == \"\" {\n            continue;\n\
    \        }\n        if brackets.starts_with(\"(\") {\n            open_brackets.push(brackets);\n\
    \        } else {\n            close_brackets.push(brackets);\n        }\n   \
    \ }\n    open_brackets.len() == close_brackets.len() && open_brackets.iter().all(|b|\
    \ close_brackets.iter().any(|c| b == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpmwp5j7dl.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut last = stack.last().unwrap();\n\
    \        if last == ')' {\n            stack.pop();\n        } else {\n      \
    \      stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpff1odmt8.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `&Vec<char>`\
    \ with `char`\n  --> /tmp/tmpff1odmt8.rs:16:17\n   |\n16 |         if last ==\
    \ ')' {\n   |                 ^^ no implementation for `&Vec<char> == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&Vec<char>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpff1odmt8.rs:19:59\n\
    \   |\n19 |             stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjtgaok6y.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(0);\n        } else if bracket\
    \ == ')' {\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpbps7uvdg.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current == \"(\" || current == \"{\" || current == \"[\" {\n     \
    \       stack.push(\")\".into());\n        }\n        if current == \")\" || current\
    \ == \"]\" || current == \"}\" {\n            stack.push(\"(\");\n        }\n\
    \    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpffg9uwj8.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpffg9uwj8.rs:20:24\n\
    \   |\n20 |             stack.push(\"(\");\n   |                        ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        |\n\
    \   |                        expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.is_empty() {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() != 0 {\n\
    \                return false;\n            }\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.chars().all(|c|\
    \ close_brackets.chars().any(|c| c == c))\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpm_xjyfvy.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.len() == 1 {\n            if brackets[0]\
    \ == '(' || brackets[0] == ')' {\n                continue;\n            }\n \
    \       }\n        if brackets.len() == 2 {\n            if brackets[0] == '('\
    \ && brackets[1] == ')' {\n                continue;\n            }\n        }\n\
    \        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpfcw_e1tf.rs:16:16\n   |\n16 |             if brackets[0] == '(' || brackets[0]\
    \ == ')' {\n   |                ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfcw_e1tf.rs:16:38\n   |\n16 |             if brackets[0] == '('\
    \ || brackets[0] == ')' {\n   |                                      ^^^^^^^^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpfcw_e1tf.rs:21:16\n   |\n21 |             if brackets[0] == '('\
    \ && brackets[1] == ')' {\n   |                ^^^^^^^^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <S"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjtgaok6y.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5m0di3cc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else if stack.len() == 0 {\n   \
    \         return false;\n        }\n    }\n    stack.len() == 0\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    let mut opening_brackets_count\
    \ = String::new();\n    let mut closing_brackets_count = String::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n    let\
    \ mut closing_brackets_count_stack = Vec::new();\n    let mut opening_brackets_count_stack\
    \ = Vec::new();\n    let mut closing_brackets_count_stack = Vec::new();\n    let\
    \ mut opening_brackets_count_stack = Vec::new();\n    let mut closing_brackets_count_stack\
    \ = Vec::new();\n    let mut opening_brackets_count_stack = Vec::new();\n\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp98srnthg.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_char:\
    \ char;\n    let mut close_brackets_char: char;\n    let mut open_brackets_char_next:\
    \ char;\n    let mut close_brackets_char_next: char;\n    let mut open_brackets_char_prev:\
    \ char;\n    let mut close_brackets_char_prev: char;\n    let mut open_brackets_char_next_prev:\
    \ char;\n    let mut close_brackets_char_next_prev: char;\n    let mut open_brackets_char_prev_prev:\
    \ char;\n    let mut close_brackets_char_prev_prev: char;\n    let mut open_brackets_char_next_next_prev:\
    \ char;\n    let mut close_brackets_char_next_next_prev: char;\n    let mut open_brackets_char_prev_next_prev:\
    \ char;\n    let mut close_brackets_char_prev_next_prev: char;\n    let mut open_brackets_char_next_prev_next_prev:\
    \ char;\n    let mut close_brackets_char_next_prev_next_prev: char;\n    let mut\
    \ open_brackets_char_prev_prev_next_prev: char;\n    let mut close_brackets_char_prev_prev_next_prev:\
    \ char;\n    let mut open_brackets_char_next_next_prev_next_prev: char;\n    let\
    \ mut close_brackets_char_next_next_prev_next_prev: char;\n    let mut open_brackets_char_prev_prev_prev_next_prev:\
    \ char;\n    let mut close_brackets_char_prev_prev_prev_next_prev: char;\n   \
    \ let mut open_brackets_char_next_next_next_prev_next_prev: char;\n    let mut\
    \ close_brackets_char_next_next_next_prev_next_prev: char;\n    let mut open_brackets_char_prev_prev_prev_prev_next_prev:\
    \ char;\n    let mut close_brackets_char_prev_prev_prev_prev_next_prev: char;\n\
    \    let mut open_brackets_char_next_next_next_next_\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkfo9y5xx.rs:43:52\n   |\n\
    43 |     let mut open_brackets_char_next_next_next_next_\n   |               \
    \                                     ^ help: add `;` here\n44 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkfo9y5xx.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        brackets = &brackets[1..].to_string();\n\
    \        let mut closing = brackets.chars().next().unwrap();\n        brackets\
    \ = &brackets[1..].to_string();\n        if opening != closing {\n           \
    \ return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps3boo00z.rs:15:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n15 |         brackets\
    \ = &brackets[1..].to_string();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&String`\n   |\nhelp: consider removing the\
    \ borrow\n   |\n15 -         brackets = &brackets[1..].to_string();\n15 +    \
    \     brackets = brackets[1..].to_string();\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmps3boo00z.rs:17:20\n   |\n12 |     let mut brackets = brackets.to_string();\n\
    \   |                        -------------------- expected due to this value\n\
    ...\n17 |         brackets = &brackets[1..].to_string();\n   |               \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `&String`\n \
    \  |\nhelp: consider removing the borrow\n   |\n17 -         brackets = &brackets[1..].to_string();\n\
    17 +         brackets = brackets[1..].to_string();\n   | \n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1o2lvb9i.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices().filter_map(|(_, index)|\
    \ {\n        if index == 0 {\n            Some(true)\n        } else {\n     \
    \       Some(false)\n        }\n    });\n    let mut close_brackets_iter = brackets.char_indices().filter_map(|(_,\
    \ index)| {\n        if index == 0 {\n            Some(true)\n        } else {\n\
    \            Some(false)\n        }\n    });\n    let mut open_brackets_next =\
    \ open_brackets_iter.next();\n    let mut close_brackets_next = close_brackets_iter.next();\n\
    \    while open_brackets_next.is_some() && close_brackets_next.is_some() {\n \
    \       if open_brackets_next.unwrap() == close_brackets_next.unwrap() {\n   \
    \         open_brackets += open_brackets_next.unwrap();\n            close_brackets\
    \ += close_brackets_next.unwrap();\n            open_brackets_next = open_brackets_iter.next();\n\
    \            close_brackets_next = close_brackets_iter.next();\n        } else\
    \ {\n            open_brackets += open_brackets_next.unwrap();\n            close_brackets\
    \ += close_brackets_next.unwrap();\n            open_brackets_next = open_brackets_iter.next();\n\
    \            close_brackets_next = close_brackets_iter.next();\n        }\n  \
    \  }\n    open_brackets.len() == close_brackets.len()\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:15:21\n   |\n\
    15 |         if index == 0 {\n   |                     ^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:22:21\n  \
    \ |\n22 |         if index == 0 {\n   |                     ^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:32:30\n\
    \   |\n32 |             open_brackets += open_brackets_next.unwrap();\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:33:31\n\
    \   |\n33 |             close_brackets += close_brackets_next.unwrap();\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:37:30\n\
    \   |\n37 |             open_brackets += open_brackets_next.unwrap();\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q5n2_0g.rs:38:31\n\
    \   |\n38 |             close_brackets += close_brackets_next.unwrap();\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`,\
    \ found `bool`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut closed_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpay8c7gj8.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while stack.len() >\
    \ 0 {\n        let mut current = stack.pop();\n        if current.len() == 0 {\n\
    \            continue;\n        }\n        let mut next = current.clone();\n \
    \       while next.len() > 0 {\n            let mut next = next.clone();\n   \
    \         while next.len() > 0 {\n                let mut next = next.clone();\n\
    \                while next.len() > 0 {\n                    let mut next = next.clone();\n\
    \                    while next.len() > 0 {\n                        let mut next\
    \ = next.clone();\n                        while next.len() > 0 {\n          \
    \                  let mut next = next.clone();\n                            while\
    \ next.len() > 0 {\n                                let mut next = next.clone();\n\
    \                                while next.len() > 0 {\n                    \
    \                let mut next = next.clone();\n                              \
    \      while next.len() > 0 {\n                                        let mut\
    \ next = next.clone();\n                                        while next.len()\
    \ > 0 {\n                                            let mut next = next.clone();\n\
    \                                            while next.len() > 0 {\n        \
    \                                        let mut next = next.clone();\n      \
    \                                      }\n                                   \
    \     }\n                                    }\n                             \
    \   }\n                            }\n                        }\n            \
    \        }\n                }\n            }\n        }\n    }\n    true\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpwlw49t6a.rs:16:20\n   |\n16 |         if current.len()\
    \ == 0 {\n   |                    ^^^ method not found in `Option<String>`\n\n\
    error[E0599]: no method named `len` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpwlw49t6a.rs:20:20\n   |\n20 |         while next.len() > 0 {\n\
    \   |                    ^^^ method not found in `Option<String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:22:24\n\
    \   |\n22 |             while next.len() > 0 {\n   |                        ^^^\
    \ method not found in `Option<String>`\n\nerror[E0599]: no method named `len`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:24:28\n\
    \   |\n24 |                 while next.len() > 0 {\n   |                     \
    \       ^^^ method not found in `Option<String>`\n\nerror[E0599]: no method named\
    \ `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:26:32\n\
    \   |\n26 |                     while next.len() > 0 {\n   |                 \
    \               ^^^ method not found in `Option<String>`\n\nerror[E0599]: no method\
    \ named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:28:36\n\
    \   |\n28 |                         while next.len() > 0 {\n   |             \
    \                       ^^^ method not found in `Option<String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:30:40\n\
    \   |\n30 | ...                   while next.len() > 0 {\n   |               \
    \                   ^^^ method not found in `Option<String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:32:44\n\
    \   |\n32 | ...                   while next.len() > 0 {\n   |               \
    \                   ^^^ method not found in `Option<String>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpwlw49t6a.rs:34:48\n\
    \   |\n34 | ...                   while "
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpam16p1pg.rs:46:48\n   |\n\
    46 |     let mut close_brackets_count_min = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpam16p1pg.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else if c == ')' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp4h2whubk.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for ch in brackets.chars() {\n        if\
    \ ch == '(' {\n            stack.push(0);\n        } else if ch == ')' {\n   \
    \         if stack.len() == 0 {\n                return false;\n            }\n\
    \            let top = stack.len();\n            stack.pop();\n            if\
    \ top != 0 {\n                return false;\n            }\n        } else {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            let top = stack.len();\n            stack.pop();\n         \
    \   if top != 0 {\n                return false;\n            }\n            stack.push(ch);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkkpd7lr.rs:34:24\n   |\n\
    34 |             stack.push(ch);\n   |                        ^^ expected `usize`,\
    \ found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.len() == 0 {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ != 0 {\n                return false;\n            }\n        }\n    }\n   \
    \ stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpeucqcthw.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_brackets_count = Vec::new();\n\
    \    let mut close_brackets_count = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new();\n    let mut open_brackets_count_min\
    \ = Vec::new();\n    let mut close_brackets_count_min = Vec::new();\n    let mut\
    \ open_brackets_count_max = Vec::new();\n    let mut close_brackets_count_max\
    \ = Vec::new();\n    let mut open_brackets_count_min = Vec::new();\n    let mut\
    \ close_brackets_count_min = Vec::new();\n    let mut open_brackets_count_max\
    \ = Vec::new();\n    let mut close_brackets_count_max = Vec::new();\n    let mut\
    \ open_brackets_count_min = Vec::new();\n    let mut close_brackets_count_min\
    \ = Vec::new();\n    let mut open_brackets_count_max = Vec::new();\n    let mut\
    \ close_brackets_count_max = Vec::new\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpv_jugo1t.rs:46:48\n   |\n\
    46 |     let mut close_brackets_count_max = Vec::new\n   |                   \
    \                             ^ help: add `;` here\n47 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_jugo1t.rs:11:44\n \
    \  |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = Vec::new();\n\
    \    let mut close_brackets = Vec::new();\n    let mut open_bracket = \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp5oh3w79p.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack.last().unwrap()\
    \ += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&usize`\n  --> /tmp/tmpch9updra.rs:25:13\n   |\n25 |             stack.last().unwrap()\
    \ += 1;\n   |             ---------------------^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&usize`\n   |\nhelp: `+=` can be used on\
    \ `usize`, you can dereference `stack.last().unwrap()`\n   |\n25 |           \
    \  *stack.last().unwrap() += 1;\n   |             +\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpch9updra.rs:25:35\n   |\n25 |            \
    \ stack.last().unwrap() += 1;\n   |             --------------------- ^^\n   |\
    \             |\n   |             cannot assign to this expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0067, E0368.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_len = brackets.len();\n\
    \    let mut close_brackets_len = brackets.len();\n    let mut i = 0;\n    while\
    \ i < open_brackets_len {\n        if brackets[i] == '(' {\n            stack.push(i);\n\
    \            open_brackets.push(i);\n            i += 1;\n        } else if brackets[i]\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            close_brackets_len = close_brackets_len.min(stack.len());\n\
    \            close_bracket = brackets[close_brackets_len];\n            stack.drain(stack.len()\
    \ - close_brackets_len);\n            open_brackets_len = open_brackets_len.max(stack.len());\n\
    \            open_bracket = brackets[open_brackets_len];\n            i += 1;\n\
    \        } else {\n            i += 1;\n        }\n    }\n    open_brackets_len\
    \ = open_brackets_len.max(stack.len());\n    close_brackets_len = close_brackets_len.min(stack.len());\n\
    \    open_bracket = brackets[open_brackets_len];\n    close_bracket = brackets[close_brackets_len];\n\
    \    open_brackets_len == close_brackets_len\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5nmoh4oo.rs:21:12\n\
    \   |\n21 |         if brackets[i] == '(' {\n   |            ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5nmoh4oo.rs:25:19\n   |\n25 |         } else if brackets[i] ==\
    \ ')' {\n   |                   ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5nmoh4oo.rs:30:29\n   |\n30 |             close_bracket = brackets[close_brackets_len];\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    for c in brackets.chars() {\n     \
    \   if c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n\
    \            if stack.len() == 0 {\n                return false;\n          \
    \  }\n            stack.pop();\n        } else {\n            if stack.len() ==\
    \ 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpqkgtxtpn.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpqkgtxtpn.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpqkgtxtpn.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_size = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_size = closing_brackets_stack.len();\n   \
    \ let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_pos = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpdxlsvkk7.rs:52:1\n  \
    \ |\n52 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().next().unwrap();\n        let mut closing\
    \ = brackets.chars().next().unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().next().unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp28o4l5aq.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = brackets.chars().next().unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    loop {\n        let mut open_bracket\
    \ = stack.pop().unwrap();\n        if open_bracket == ')' {\n            open_brackets.push(')');\n\
    \        }\n        if open_bracket == '(' {\n            open_brackets.push('(');\n\
    \        }\n        if open_brackets.len() == 0 {\n            return open_brackets.len()\
    \ == 0;\n        }\n        if open_brackets.last().unwrap() != open_bracket {\n\
    \            return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpic4m1rcj.rs:26:42\n\
    \   |\n26 |         if open_brackets.last().unwrap() != open_bracket {\n   | \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\");\n\
    \    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"(\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\"]\", \"]\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplgjd7y4x.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| c !=\
    \ '(').collect::<String>());\n    while stack.len() > 0 {\n        let mut current\
    \ = stack.pop().unwrap();\n        if current == '(' {\n            stack.push(')');\n\
    \        } else if current == ')' {\n            stack.push('(');\n        } else\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmptp67esxy.rs:13:50\n\
    \   |\n13 |     stack.push(brackets.chars().skip_while(|c| c != '(').collect::<String>());\n\
    \   |                                                  ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmptp67esxy.rs:17:24\n   |\n17 |  \
    \           stack.push(')');\n   |                        ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror[E0277]:\
    \ can't compare `String` with `char`\n  --> /tmp/tmptp67esxy.rs:16:20\n   |\n\
    16 |         if current == '(' {\n   |                    ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptp67esxy.rs:19:24\n   |\n19 |             stack.push('(');\n\
    \   |                        ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `char`\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmptp67esxy.rs:18:27\n\
    \   |\n18 |         } else if current == ')' {\n   |                         \
    \  ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str "
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.is_empty() {\n            return\
    \ false;\n        }\n        match c {\n            ')' => {\n               \
    \ stack.pop();\n            }\n            '(' | '[' => {\n                stack.push(c);\n\
    \            }\n            _ => {}\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp4lnwtj88.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut close_brackets_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut open_brackets_size2 = open_brackets_size;\n\
    \    let mut close_brackets_size2 = close_brackets_size;\n    let mut open_brackets_size3\
    \ = open_brackets_size;\n    let mut close_brackets_size3 = close_brackets_size;\n\
    \    let mut open_brackets_size4 = open_brackets_size;\n    let mut close_brackets_size4\
    \ = close_brackets_size;\n    let mut open_brackets_size5 = open_brackets_size;\n\
    \    let mut close_brackets_size5 = close_brackets_size;\n    let mut open_brackets_size6\
    \ = open_brackets_size;\n    let mut close_brackets_size6 = close_brackets_size;\n\
    \    let mut open_brackets_size7 = open_brackets_size;\n    let mut close_brackets_size7\
    \ = close_brackets_size;\n    let mut open_brackets_size8 = open_brackets_size;\n\
    \    let mut close_brackets_size8 = close_brackets_size;\n    let mut open_brackets_size9\
    \ = open_brackets_size;\n    let mut close_brackets_size9 = close_brackets_size;\n\
    \    let mut open_brackets_size10 = open_brackets_size;\n    let mut close_brackets_size10\
    \ = close_brackets_size;\n    let mut open_brackets_size11 = open_brackets_size;\n\
    \    let mut close_brackets_size11 = close_brackets_size;\n    let mut open_brackets_size12\
    \ = open_brackets_size;\n    let mut close_brackets_size12 = close_brackets_size;\n\
    \    let mut open_brackets_size13 = open_brackets_size;\n    let mut close_brackets_size13\
    \ = \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpw2h87ixc.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected expression\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpw2h87ixc.rs:17:64\n   |\n17 |     let mut open_brackets_size\
    \ = brackets.chars().filter(|c| c == '(').count();\n   |                     \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpw2h87ixc.rs:18:65\n   |\n18 |   \
    \  let mut close_brackets_size = brackets.chars().filter(|c| c == ')').count();\n\
    \   |                                                                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzmg02ion.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut closed_brackets = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut closed_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = String::new();\n    let mut closed_brackets_count_stack_size\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr = String::new();\n\
    \    let mut closed_brackets_count_stack_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut\
    \ closed_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr =\
    \ String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr =\
    \ String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut closed_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr_ptr\
    \ = String::new();\n\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dxdsbis.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut opening_brackets = String::new();\n\
    \    let mut closing_brackets = String::new();\n    while brackets.len() > 0 {\n\
    \        let mut opening_bracket = String::new();\n        let mut closing_bracket\
    \ = String::new();\n        let mut opening_brackets = String::new();\n      \
    \  let mut closing_brackets = String::new();\n        while brackets.len() > 0\
    \ {\n            if brackets.starts_with(\"(\") {\n                opening_brackets.push(brackets.trim_left_matches('('));\n\
    \                brackets = brackets.trim_left_matches('(');\n            } else\
    \ if brackets.starts_with(\")\") {\n                closing_brackets.push(brackets.trim_left_matches(')'));\n\
    \                brackets = brackets.trim_left_matches(')');\n            } else\
    \ {\n                opening_brackets.push(brackets.trim_left_matches('('));\n\
    \                closing_brackets.push(brackets.trim_left_matches(')'));\n   \
    \             brackets = brackets.trim_left_matches('(');\n                brackets\
    \ = brackets.trim_left_matches(')');\n            }\n        }\n        if opening_brackets.len()\
    \ > 0 {\n            opening_brackets.push(opening_brackets.trim_left_matches('('));\n\
    \        }\n        if closing_brackets.len() > 0 {\n            closing_brackets.push(closing_brackets.trim_left_matches(')'));\n\
    \        }\n        if opening_brackets.len() > 0 || closing_brackets.len() >\
    \ 0 {\n            opening_brackets = opening_brackets.trim_left_matches('(');\n\
    \            closing_brackets = closing_brackets.trim_left_matches(')');\n   \
    \     }\n        if opening_brackets.len() > 0 || closing_brackets.len() > 0 {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmpua3_ch4s.rs:22:48\n   |\n\
    22 |                 opening_brackets.push(brackets.trim_left_matches('('));\n\
    \   |                                                ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n   |\n\
    \   = note: `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpua3_ch4s.rs:22:39\n   |\n22 |                 opening_brackets.push(brackets.trim_left_matches('('));\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_left_matches`: superseded by `trim_start_matches`\n  --> /tmp/tmpua3_ch4s.rs:23:37\n\
    \   |\n23 |                 brackets = brackets.trim_left_matches('(');\n   |\
    \                                     ^^^^^^^^^^^^^^^^^ help: replace the use\
    \ of the deprecated associated function: `trim_start_matches`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpua3_ch4s.rs:23:28\n   |\n12 |     let mut brackets\
    \ = brackets.to_string();\n   |                        -------------------- expected\
    \ due to this value\n...\n23 |                 brackets = brackets.trim_left_matches('(');\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                            |\n   |\
    \                            expected struct `String`, found `&str`\n\nwarning:\
    \ use of deprecated associated function `core::str::<impl str>::trim_left_matches`:\
    \ superseded by `trim_start_matches`\n  --> /tmp/tmpua3_ch4s.rs:25:48\n   |\n\
    25 |                 closing_brackets.push(brackets.trim_left_matches(')'));\n\
    \   |                                                ^^^^^^^^^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start_matches`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpua3_ch4s.rs:25:39\n   |\n25 |              \
    \   closing_bracke"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else if stack.is_empty() {\n   \
    \         return false;\n        }\n    }\n    stack.is_empty()\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else if c == ')' {\n            if\
    \ stack.len() == 0 {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            if stack.len() != 0 {\n      \
    \          return false;\n            }\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"(\");\n  \
    \  brackets.replace(\"]\", \")\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"\
    }\", \")\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"[\");\n    brackets.replace(\"}\", \"]\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\", \"\
    {\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"(\"\
    );\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"{\");\n\
    \    brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"[\");\n    brackets.replace(\")\"\
    , \"]\");\n    brackets.replace(\"[\", \"{\");\n    brackets.replace(\"]\", \"\
    }\");\n    brackets.replace(\"{\", \"(\");\n    brackets.replace(\"}\", \")\"\
    );\n    brackets.replace(\"(\", \"{\");\n    brackets.replace(\")\", \"}\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"[\");\n    brackets.replace(\")\", \"]\");\n    brackets.replace(\"[\"\
    , \"{\");\n    brackets.replace(\"]\", \"}\");\n    brackets.replace(\"{\", \"\
    (\");\n    brackets.replace(\"}\", \")\");\n    brackets.replace(\"(\", \"{\"\
    );\n    brackets.replace(\")\", \"}\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpanxgmy9k.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets == brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5m0di3cc.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '(' {\n       \
    \     open_brackets.push('(');\n        } else if bracket == ')' {\n         \
    \   closed_brackets.push(')');\n        } else if bracket == '[' {\n         \
    \   open_brackets.push('[');\n        } else if bracket == ']' {\n           \
    \ closed_brackets.push(']');\n        } else if bracket == '{' {\n           \
    \ open_brackets.push('{');\n        } else if bracket == '}' {\n            closed_brackets.push('}');\n\
    \        }\n    }\n\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0t8rejtx.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpup42vfw8.rs:50:22\n   |\n\
    50 |     let mut close_bra\n   |                      ^ help: add `;` here\n51\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpup42vfw8.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  close_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \            close_brackets.push(bracket);\n        }\n    }\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpd36o3q7q.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| {\n        opening_brackets.is_empty() || opening_brackets.chars().any(|&(_,\
    \ c)| c == c)\n    });\n    let mut closing_brackets_iter = brackets.chars().enumerate().filter(|&(_,\
    \ c)| {\n        closing_brackets.is_empty() || closing_brackets.chars().any(|&(_,\
    \ c)| c == c)\n    });\n    let mut opening_brackets_next = opening_brackets_iter.next();\n\
    \    let mut closing_brackets_next = closing_brackets_iter.next();\n    while\
    \ opening_brackets_next.is_some() && closing_brackets_next.is_some() {\n     \
    \   if opening_brackets_next.unwrap() == closing_brackets_next.unwrap() {\n  \
    \          opening_brackets_next = opening_brackets_iter.next();\n           \
    \ closing_brackets_next = closing_brackets_iter.next();\n        } else {\n  \
    \          return false;\n        }\n    }\n    opening_brackets_next.is_none()\
    \ && closing_brackets_next.is_none()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9iy0ir6a.rs:15:70\n   |\n\
    15 |         opening_brackets.is_empty() || opening_brackets.chars().any(|&(_,\
    \ c)| c == c)\n   |                                                          \
    \            ^^^^^^-\n   |                                                   \
    \                   |     |\n   |                                            \
    \                          |     expected due to this\n   |                  \
    \                                                    expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9iy0ir6a.rs:18:70\n   |\n18 |  \
    \       closing_brackets.is_empty() || closing_brackets.chars().any(|&(_, c)|\
    \ c == c)\n   |                                                              \
    \        ^^^^^^-\n   |                                                       \
    \               |     |\n   |                                                \
    \                      |     expected due to this\n   |                      \
    \                                                expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current.is_ascii_letter() {\n            if current.is_ascii_letter()\
    \ {\n                stack.push(current);\n            } else {\n            \
    \    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \            }\n        } else {\n            if current.is_ascii_letter() {\n\
    \                stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \            } else {\n                stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n            }\n        }\n    }\n\
    \    stack.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpw2850vxt.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpw2850vxt.rs:16:20\n\
    \   |\n16 |         if current.is_ascii_letter() {\n   |                    ^^^^^^^^^^^^^^^\
    \ method not found in `Vec<char>`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpw2850vxt.rs:17:24\n\
    \   |\n17 |             if current.is_ascii_letter() {\n   |                 \
    \       ^^^^^^^^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for reference `&char` in the current scope\n \
    \ --> /tmp/tmpw2850vxt.rs:20:63\n   |\n20 |                 stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                                     ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpw2850vxt.rs:23:24\n\
    \   |\n23 |             if current.is_ascii_letter() {\n   |                 \
    \       ^^^^^^^^^^^^^^^ method not found in `Vec<char>`\n\nerror[E0599]: no method\
    \ named `is_ascii_letter` found for reference `&char` in the current scope\n \
    \ --> /tmp/tmpw2850vxt.rs:24:63\n   |\n24 |                 stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                                     ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpw"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_string:\
    \ String = String::new();\n    let mut close_brackets_string: String = String::new();\n\
    \    let mut open_brackets_string_size: usize = 0;\n    let mut close_brackets_string_size:\
    \ usize = 0;\n    let mut open_brackets_string_size2: usize = 0;\n    let mut\
    \ close_brackets_string_size2: usize = 0;\n    let mut open_brackets_string_size3:\
    \ usize = 0;\n    let mut close_brackets_string_size3: usize = 0;\n    let mut\
    \ open_brackets_string_size4: usize = 0;\n    let mut close_brackets_string_size4:\
    \ usize = 0;\n    let mut open_brackets_string_size5: usize = 0;\n    let mut\
    \ close_brackets_string_size5: usize = 0;\n    let mut open_brackets_string_size6:\
    \ usize = 0;\n    let mut close_brackets_string_size6: usize = 0;\n    let mut\
    \ open_brackets_string_size7: usize = 0;\n    let mut close_brackets_string_size7:\
    \ usize = 0;\n    let mut open_brackets_string_size8: usize = 0;\n    let mut\
    \ close_brackets_string_size8: usize = 0;\n    let mut open_brackets_string_size9:\
    \ usize = 0;\n    let mut close_brackets_string_size9: usize = 0;\n    let mut\
    \ open_brackets_string_size10: usize = 0;\n    let mut close_brackets_string_size10:\
    \ usize = 0;\n    let mut open_brackets_string_size11: usize = 0;\n    let mut\
    \ close_brackets_string_size11: usize = 0;\n    let mut open_brackets_string_size12:\
    \ usize = 0;\n    let mut close_brackets_string_size12: usize = 0;\n    let mut\
    \ open_brackets_string_size13: usize = 0;\n    let mut close_brackets_string_size13:\
    \ u\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpd1h8a2ht.rs:44:44\n   |\n\
    44 |     let mut close_brackets_string_size13: u\n   |                       \
    \                     ^ help: add `;` here\n45 | }\n   | - unexpected token\n\n\
    error[E0412]: cannot find type `u` in this scope\n  --> /tmp/tmpd1h8a2ht.rs:44:43\n\
    \   |\n44 |     let mut close_brackets_string_size13: u\n   |                \
    \                           ^ help: a builtin type with a similar name exists:\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd1h8a2ht.rs:11:44\n  \
    \ |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    for bracket in brackets.chars() {\n\
    \        if bracket == '(' {\n            stack.push(bracket);\n            opening_brackets.push(bracket);\n\
    \        } else if bracket == ')' {\n            if stack.is_empty() {\n     \
    \           return false;\n            }\n            closing_brackets.push(stack.pop());\n\
    \        } else if bracket == '[' {\n            if stack.is_empty() {\n     \
    \           return false;\n            }\n            stack.push(bracket);\n \
    \       } else if bracket == ']' {\n            if stack.is_empty() {\n      \
    \          return false;\n            }\n            closing_brackets.push(stack.pop());\n\
    \        }\n    }\n    opening_brackets.iter().all(|b| closing_brackets.iter().any(|c|\
    \ b == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `Option<char>`\n  --> /tmp/tmp_z6k5wui.rs:36:71\n\
    \   |\n36 |     opening_brackets.iter().all(|b| closing_brackets.iter().any(|c|\
    \ b == c))\n   |                                                             \
    \          ^^ no implementation for `char == Option<char>`\n   |\n   = help: the\
    \ trait `PartialEq<Option<char>>` is not implemented for `char`\n   = help: the\
    \ trait `PartialEq` is implemented for `char`\n   = note: required because of\
    \ the requirements on the impl of `PartialEq<&Option<char>>` for `&char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = String::new();\n    let mut\
    \ close_brackets_count = String::new();\n    let mut open_brackets_stack_string\
    \ = String::new();\n    let mut close_brackets_stack_string = String::new();\n\
    \    let mut open_brackets_count_string = String::new();\n    let mut close_brackets_count_string\
    \ = String::new();\n    let mut open_brackets_stack_string = String::new();\n\
    \    let mut close_brackets_stack_string = String::new();\n    let mut open_brackets_count_string\
    \ = String::new();\n    let mut close_brackets_count_string = String::new();\n\
    \    let mut open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_count_string = String::new();\n\
    \    let mut close_brackets_count_string = String::new();\n    let mut open_brackets_stack_string\
    \ = String::new();\n    let mut close_brackets_stack_string = String::new();\n\
    \    let mut open_brackets_count_string = String::new();\n    let mut close_brackets_count_string\
    \ = String::new();\n    let mut open_brackets_stack_string = String::new();\n\
    \    let mut close_brackets_stack_string = String::new();\n    let mut open_brackets_count_string\
    \ = String::new();\n    let mut close_brackets_count_string = String::new();\n\
    \    let mut open_brackets_stack_string = String::new();\n    let mut close_brackets_stack_string\
    \ = String::new();\n    let mut open_brackets_count_string = String::new();\n\
    \    let mut close_brackets_count_string = String::new();\n    let mut open_brackets_stack_string\
    \ = String::new();\n    let mut close_brackets_stack_string = String::new();\n\
    \    let mut open_brackets_count_string = String::new();\n    let mut close_brackets_count_\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpob69unxo.rs:45:34\n   |\n\
    45 |     let mut close_brackets_count_\n   |                                 \
    \ ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpob69unxo.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_brackets_count = Vec::new();\n\
    \    let mut closing_brackets_count = Vec::new();\n\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n         \
    \   opening_brackets.push(bracket);\n            opening_brackets_count.push(brackets.chars().filter(|c|\
    \ c == '(').count());\n        }\n        if bracket == ')' {\n            assert!(stack.is_empty());\n\
    \            assert!(opening_brackets.len() == opening_brackets_count.len() -\
    \ 1);\n            assert!(opening_brackets_count.len() == opening_brackets.len());\n\
    \            assert!(closing_brackets.len() == closing_brackets_count.len() -\
    \ 1);\n            assert!(closing_brackets_count.len() == closing_brackets.len());\n\
    \            assert!(opening_brackets_count.len() == opening_brackets.len());\n\
    \            assert!(closing_brackets_count.len() == closing_brackets.len());\n\
    \            assert!(opening_brackets_count.len() == opening_brackets.len());\n\
    \            assert!(closing_brackets_count.len() == closing_brackets.len());\n\
    \            assert!(stack.len() == opening_brackets.len());\n            assert!(stack.len()\
    \ == closing_brackets.len());\n            assert!(stack.len() == opening_brackets_count.len());\n\
    \            assert!(stack.len() == closing_brackets_count.len());\n         \
    \   assert!(stack.len() == opening_brackets.len());\n            assert!(stack.len()\
    \ == closing_brackets.len());\n            assert!(stack.len() == opening_brackets_count.len());\n\
    \            assert!(stack.len() == closing_brackets_count.len());\n         \
    \   assert!(stack.len() == opening_brackets.len());\n            assert!(stack.len()\
    \ == closing_brackets.len());\n            assert!(stack.len() == opening_brackets_count.len());\n\
    \            assert!(stack.len() == closing_brackets_count.len());\n         \
    \   assert!(stack.len() == opening_brackets.len());\n            assert!(stack.len()\
    \ == closing_bra\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9k5smjl5.rs:64:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n18 |     for\
    \ bracket in brackets.chars() {\n   |                                     - unclosed\
    \ delimiter\n...\n24 |         if bracket == ')' {\n   |                     \
    \      - this delimiter might not be properly closed...\n...\n48 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n64 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmp9k5smjl5.rs:47:20\n  \
    \ |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |            \
    \                                     - closing delimiter possibly meant for this\n\
    ...\n47 |             assert!(stack.len() == closing_bra\n   |               \
    \     ^ unclosed delimiter\n48 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]:\
    \ cannot find value `closing_bra` in this scope\n  --> /tmp/tmp9k5smjl5.rs:47:36\n\
    \   |\n47 |             assert!(stack.len() == closing_bra\n   |             \
    \                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp9k5smjl5.rs:22:71\n   |\n22 |   \
    \          opening_brackets_count.push(brackets.chars().filter(|c| c == '(').count());\n\
    \   |                                                                       ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9k5smjl5.rs:18:5\n\
    \   |\n11 |   fn correct_bracketing(brackets: String) -> bool {\n   |        \
    \                                      ---- expected `bool` because of return\
    \ type\n...\n18 | /     for bracket in brackets.chars() {\n19 | |         if bracket\
    \ == '(' {\n20 | |             stack.push(bracket);\n21 | |             opening_brackets.push(bracket);\n\
    ...  |\n63 | |     assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    64 | | }\n "
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    for bracket in brackets.chars() {\n        if bracket == '(' {\n        \
    \    open_brackets.push('(');\n        } else if bracket == ')' {\n          \
    \  closed_brackets.push(')');\n        } else {\n            open_brackets.push(bracket);\n\
    \        }\n    }\n    open_brackets.chars().all(|c| closed_brackets.chars().any(|c|\
    \ c == c))\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmps84hw_8s.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    loop {\n        if stack.len()\
    \ == 1 {\n            return true;\n        }\n        let mut current = stack.pop().unwrap();\n\
    \        for c in current.chars() {\n            if c == '(' {\n             \
    \   stack.push(c);\n            } else if c == ')' {\n                let mut\
    \ last = stack.pop().unwrap();\n                if last != c {\n             \
    \       return false;\n                }\n            }\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplgn9075a.rs:21:28\n   |\n\
    21 |                 stack.push(c);\n   |                            ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmplgn9075a.rs:24:25\n\
    \   |\n24 |                 if last != c {\n   |                         ^^ no\
    \ implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(item) = stack.last() {\n        if item == '(' {\n       \
    \     stack.push(item);\n        } else if item == ')' {\n            if stack.len()\
    \ == 1 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            return false;\n        }\n    }\n    stack.len()\
    \ == 1\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps6pkcpjh.rs:16:24\n   |\n\
    16 |             stack.push(item);\n   |                        ^^^^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    16 |             stack.push(*item);\n   |                        +\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmps6pkcpjh.rs:15:17\n   |\n15\
    \ |         if item == '(' {\n   |                 ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmps6pkcpjh.rs:17:24\n   |\n17\
    \ |         } else if item == ')' {\n   |                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut open_bracket = brackets.chars().next().unwrap();\n        let mut\
    \ close_bracket = brackets.chars().next().unwrap();\n        if open_bracket !=\
    \ close_bracket {\n            return false;\n        }\n        brackets = brackets.chars().collect::<String>().into_owned();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpprqylwbj.rs:19:57\n   |\n19 |         brackets\
    \ = brackets.chars().collect::<String>().into_owned();\n   |                 \
    \                                        ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_stack = Vec::new();\n    let mut closing_brackets_stack\
    \ = Vec::new();\n    let mut opening_brackets_stack_size = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_size = closing_brackets_stack.len();\n   \
    \ let mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n    let mut opening_brackets_stack_end = opening_brackets_stack.len();\n\
    \    let mut closing_brackets_stack_end = closing_brackets_stack.len();\n    let\
    \ mut opening_brackets_stack_pos = 0;\n    let mut closing_brackets_stack_pos\
    \ = 0;\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqau_ulp7.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(0);\n        } else if bracket\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack[stack.len()\
    \ - 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp8y6k3tl8.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmp8y6k3tl8.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmp8y6k3tl8.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(item) = stack.pop() {\n        if item != ')' {\n        \
    \    return false;\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpfortgdqp.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `String` with\
    \ `char`\n  --> /tmp/tmpfortgdqp.rs:15:17\n   |\n15 |         if item != ')' {\n\
    \   |                 ^^ no implementation for `String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while stack.len() > 0 {\n        let mut current = stack.pop().unwrap();\n\
    \        if current == \"(\" || current == \"[\" || current == \"{\" || current\
    \ == \"(()\" || current == \"[]\" || current == \"{}\" {\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n            stack.push(\"\
    )\".into());\n            stack.push(\"]\".into());\n            stack.push(\"\
    }\".into());\n            stack.push(\")\".into());\n            stack.push(\"\
    ]\".into());\n            stack.push(\"}\".into());\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf1yto2z4.rs:81:3\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |          \
    \                                       - unclosed delimiter\n...\n14 |     while\
    \ stack.len() > 0 {\n   |                           - unclosed delimiter\n15 |\
    \         let mut current = stack.pop().unwrap();\n16 |         if current ==\
    \ \"(\" || current == \"[\" || current == \"{\" || current == \"(()\" || current\
    \ == \"[]\" || current == \"{}\" {\n   |                                     \
    \                                                                            \
    \        - this delimiter might not be properly closed...\n...\n65 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n81 | }\n   |  \
    \ ^\n\nerror[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpf1yto2z4.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf1yto2z4.rs:14:5\n\
    \   |\n11 |   fn correct_bracketing(brackets: String) -> bool {\n   |        \
    \                                      ---- expected `bool` because of return\
    \ type\n...\n14 | /     while stack.len() > 0 {\n15 | |         let mut current\
    \ = stack.pop().unwrap();\n16 | |         if current == \"(\" || current == \"\
    [\" || current == \"{\" || current == \"(()\" || current == \"[]\" || current\
    \ == \"{}\" {\n17 | |             stack.push(\")\".into());\n...  |\n80 | |  \
    \   assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n81 | |\
    \ }\n   | |__^ expected `bool`, found `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut close_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_stack_size = open_brackets_stack.len();\n\
    \    let mut close_brackets_stack_size = close_brackets_stack.len();\n    let\
    \ mut open_brackets_stack_ptr = &mut open_brackets_stack[..];\n    let mut close_brackets_stack_ptr\
    \ = &mut close_brackets_stack[..];\n    let mut open_brackets_stack_ptr_next =\
    \ &mut open_brackets_stack_ptr;\n    let mut close_brackets_stack_ptr_next = &mut\
    \ close_brackets_stack_ptr;\n    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n\
    \    let mut close_brackets_stack_ptr_end = &mut close_brackets_stack_ptr;\n \
    \   let mut open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n    let\
    \ mut close_brackets_stack_ptr_end = &mut close_brackets_stack_ptr;\n    let mut\
    \ open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n    let mut close_brackets_stack_ptr_end\
    \ = &mut close_brackets_stack_ptr;\n    let mut open_brackets_stack_ptr_end =\
    \ &mut open_brackets_stack_ptr;\n    let mut close_brackets_stack_ptr_end = &mut\
    \ close_brackets_stack_ptr;\n    let mut open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n\
    \    let mut close_brackets_stack_ptr_end = &mut close_brackets_stack_ptr;\n \
    \   let mut open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n    let\
    \ mut close_brackets_stack_ptr_end = &mut close_brackets_stack_ptr;\n    let mut\
    \ open_brackets_stack_ptr_end = &mut open_brackets_stack_ptr;\n    let mut close_brackets_stack_ptr\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp4dgigc2q.rs:35:37\n   |\n\
    35 |     let mut close_brackets_stack_ptr\n   |                              \
    \       ^ help: add `;` here\n36 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4dgigc2q.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8q8x9a5v.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while let Some(mut stack) = stack.pop() {\n        if let Some(mut stack)\
    \ = stack.pop() {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwgstsi48.rs:16:22\n   |\n16 |             if stack.len()\
    \ == 0 {\n   |                      ^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' && open !=\
    \ '(' {\n            return false;\n        }\n        stack.pop();\n    }\n \
    \   true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpb9wm5lex.rs:15:17\n\
    \   |\n15 |         if open != ')' && open != '(' {\n   |                 ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpb9wm5lex.rs:15:32\n\
    \   |\n15 |         if open != ')' && open != '(' {\n   |                    \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut close_brackets_size:\
    \ usize = 0;\n    let mut open_brackets_size: usize = 0;\n    let mut \n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpbu52k9_7.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut open_bracket = brackets.chars().next().unwrap();\n        let mut\
    \ close_bracket = brackets.chars().next().unwrap();\n        if open_bracket ==\
    \ close_bracket {\n            brackets = brackets.chars().skip_while(|c| c !=\
    \ open_bracket).collect();\n        } else {\n            return false;\n    \
    \    }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfwirr650.rs:17:58\n\
    \   |\n17 |             brackets = brackets.chars().skip_while(|c| c != open_bracket).collect();\n\
    \   |                                                          ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(mut c) = stack.last() {\n        if c == '(' {\n         \
    \   stack.push(c);\n        } else if c == ')' {\n            if stack.pop().unwrap()\
    \ == '(' {\n                stack.push(c);\n            } else {\n           \
    \     return false;\n            }\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.pop().unwrap() == ')'\n}\n\nfn main() {\n    let\
    \ candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\"\
    )), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5excup_k.rs:16:24\n   |\n\
    16 |             stack.push(c);\n   |                        ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |   \
    \          stack.push(*c);\n   |                        +\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp5excup_k.rs:15:14\n   |\n15 |   \
    \      if c == '(' {\n   |              ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp5excup_k.rs:17:21\n   |\n17 |   \
    \      } else if c == ')' {\n   |                     ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5excup_k.rs:19:28\n   |\n19 |  \
    \               stack.push(c);\n   |                            ^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n19 |   \
    \              stack.push(*c);\n   |                            +\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = brackets.chars().next()\
    \ {\n            if open == close {\n                stack.pop();\n          \
    \  } else {\n                return false;\n            }\n        } else {\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1we2iq2l.rs:16:21\n\
    \   |\n16 |             if open == close {\n   |                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = 0;\n    let mut close_brackets = 0;\n    while let\
    \ Some(next) = stack.last() {\n        if next == ')' {\n            close_brackets\
    \ += 1;\n        } else if next == '(' {\n            open_brackets += 1;\n  \
    \      } else {\n            stack.push(next);\n        }\n    }\n    open_brackets\
    \ == close_brackets\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc07xq73w.rs:17:17\n\
    \   |\n17 |         if next == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpc07xq73w.rs:19:24\n\
    \   |\n19 |         } else if next == '(' {\n   |                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc07xq73w.rs:22:24\n\
    \   |\n22 |             stack.push(next);\n   |                        ^^^^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |             stack.push(*next);\n   |                        +\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(next) = stack.last() {\n        if next == ')' {\n       \
    \     stack.pop();\n        } else {\n            stack.push(next);\n        }\n\
    \    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpcsdkrcbf.rs:15:17\n\
    \   |\n15 |         if next == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcsdkrcbf.rs:18:24\n   |\n18 |  \
    \           stack.push(next);\n   |                        ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n18 |   \
    \          stack.push(*next);\n   |                        +\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening = brackets.chars().take_while(|c|\
    \ c != '(').collect::<String>();\n    let mut closing = brackets.chars().take_while(|c|\
    \ c != ')').collect::<String>();\n    stack.push(opening);\n    while !stack.is_empty()\
    \ {\n        let mut current = stack.pop();\n        if current == closing {\n\
    \            return true;\n        }\n        for c in current {\n           \
    \ if c == '(' {\n                stack.push(c);\n            } else if c == ')'\
    \ {\n                stack.pop();\n            }\n        }\n    }\n    false\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2mie6dwu.rs:13:57\n\
    \   |\n13 |     let mut opening = brackets.chars().take_while(|c| c != '(').collect::<String>();\n\
    \   |                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2mie6dwu.rs:14:57\n\
    \   |\n14 |     let mut closing = brackets.chars().take_while(|c| c != ')').collect::<String>();\n\
    \   |                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp2mie6dwu.rs:18:23\n   |\n18 |  \
    \       if current == closing {\n   |                       ^^^^^^^ expected enum\
    \ `Option`, found struct `String`\n   |\n   = note: expected enum `Option<String>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         if current == Some(closing) {\n   |                      \
    \ +++++       +\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp2mie6dwu.rs:22:18\n\
    \   |\n22 |             if c == '(' {\n   |                  ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp2mie6dwu.rs:24:25\n   |\n24 |          \
    \   } else if c ="
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \    let mut opening_brackets_count = String::new();\n    let mut closing_brackets_count\
    \ = String::new();\n    let mut opening_brackets_count_iter = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter = brackets.char_indices();\n    let mut\
    \ opening_brackets_count_iter2 = brackets.char_indices();\n    let mut closing_brackets_count_iter2\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter3 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter3 = brackets.char_indices();\n    let\
    \ mut opening_brackets_count_iter4 = brackets.char_indices();\n    let mut closing_brackets_count_iter4\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter5 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter5 = brackets.char_indices();\n    let\
    \ mut opening_brackets_count_iter6 = brackets.char_indices();\n    let mut closing_brackets_count_iter6\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter7 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter7 = brackets.char_indices();\n    let\
    \ mut opening_brackets_count_iter8 = brackets.char_indices();\n    let mut closing_brackets_count_iter8\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter9 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter9 = brackets.char_indices();\n    let\
    \ mut opening_brackets_count_iter10 = brackets.char_indices();\n    let mut closing_brackets_count_iter10\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter11 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter11 = brackets.char_indices();\n    let\
    \ mut opening_brackets_count_iter12 = brackets.char_indices();\n    let mut closing_brackets_count_iter12\
    \ = brackets.char_indices();\n    let mut opening_brackets_count_iter13 = brackets.char_indices();\n\
    \    let mut closing_brackets_count_iter13 = brackets.char_indices();\n    let\
    \ \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp99tw6un4.rs:43:1\n  \
    \ |\n43 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut close_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut close_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack_size = String::new();\n    let mut close_brackets_count_stack_size\
    \ = String::new();\n    let mut open_brackets_count_stack_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut\
    \ close_brackets_count_stack_ptr_ptr_ptr = String::new();\n    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr\
    \ = String::new();\n    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr = String::new();\n   \
    \ let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n   \
    \ let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n  \
    \  let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut open_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::new();\n\
    \    let mut close_brackets_count_stack_ptr_ptr_ptr_ptr_ptr_ptr = String::\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp6gxa1ugh.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    for bracket in brackets.chars() {\n      \
    \  if bracket == '(' {\n            stack.push(bracket);\n            open_brackets.push(bracket);\n\
    \        } else if bracket == ')' {\n            if stack.len() == 0 {\n     \
    \           return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else if bracket == '[' {\n            stack.push(bracket);\n      \
    \  } else if bracket == ']' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        } else if bracket == '{' {\n            stack.push(bracket);\n      \
    \  } else if bracket == '}' {\n            if stack.len() == 0 {\n           \
    \     return false;\n            }\n            close_brackets.push(stack.pop());\n\
    \        }\n    }\n    if stack.len() != 0 {\n        return false;\n    }\n \
    \   for open_bracket in open_brackets {\n        if close_brackets.contains(&open_bracket)\
    \ {\n            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcmd_8wxg.rs:44:36\n   |\n\
    44 |         if close_brackets.contains(&open_bracket) {\n   |               \
    \                     ^^^^^^^^^^^^^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected reference `&Option<char>`\n              found reference\
    \ `&char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = Vec::new();\n    let\
    \ mut closing_brackets = Vec::new();\n    let mut opening_brackets_size = brackets.chars().filter(|c|\
    \ c == '(').count();\n    let mut closing_brackets_size = brackets.chars().filter(|c|\
    \ c == ')').count();\n    let mut opening_brackets_index = 0;\n    let mut closing_brackets_index\
    \ = 0;\n    let mut opening_brackets_index2 = 0;\n    let mut closing_brackets_index2\
    \ = 0;\n    let mut opening_brackets_index3 = 0;\n    let mut closing_brackets_index3\
    \ = 0;\n    let mut opening_brackets_index4 = 0;\n    let mut closing_brackets_index4\
    \ = 0;\n    let mut opening_brackets_index5 = 0;\n    let mut closing_brackets_index5\
    \ = 0;\n    let mut opening_brackets_index6 = 0;\n    let mut closing_brackets_index6\
    \ = 0;\n    let mut opening_brackets_index7 = 0;\n    let mut closing_brackets_index7\
    \ = 0;\n    let mut opening_brackets_index8 = 0;\n    let mut closing_brackets_index8\
    \ = 0;\n    let mut opening_brackets_index9 = 0;\n    let mut closing_brackets_index9\
    \ = 0;\n    let mut opening_brackets_index10 = 0;\n    let mut closing_brackets_index10\
    \ = 0;\n    let mut opening_brackets_index11 = 0;\n    let mut closing_brackets_index11\
    \ = 0;\n    let mut opening_brackets_index12 = 0;\n    let mut closing_brackets_index12\
    \ = 0;\n    let mut opening_brackets_index13 = 0;\n    let mut closing_brackets_index13\
    \ = 0;\n    let mut opening_brackets_index14 = 0;\n    let mut closing_brackets_index14\
    \ = 0;\n    let mut opening_brackets_index15 = 0;\n    let mut closing_brackets_index15\
    \ = 0;\n    let mut opening_brackets_index16 = 0;\n    let mut closing_brackets_index16\
    \ = 0;\n    let mut opening_brackets_index17 = 0;\n    let mut closing_brackets_index17\
    \ = 0;\n    let mut opening_brackets_index18 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph4p85r31.rs:15:67\n\
    \   |\n15 |     let mut opening_brackets_size = brackets.chars().filter(|c| c\
    \ == '(').count();\n   |                                                     \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmph4p85r31.rs:16:67\n   |\n16 |     let mut closing_brackets_size\
    \ = brackets.chars().filter(|c| c == ')').count();\n   |                     \
    \                                              ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmph4p85r31.rs:11:44\n   |\n11 | fn correct_bracketing(brackets:\
    \ String) -> bool {\n   |    ------------------                      ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.len() == 0 {\n            continue;\n \
    \       }\n        let mut opening = brackets.chars().nth(0).unwrap();\n     \
    \   let mut closing = brackets.chars().nth(1).unwrap();\n        if opening !=\
    \ closing {\n            return false;\n        }\n        if opening == '(' {\n\
    \            stack.push(brackets.chars().skip(1).take(2).collect());\n       \
    \ }\n        if opening == ')' {\n            stack.pop();\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprho7l5s7.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening_brackets = String::new();\n   \
    \ let mut closing_brackets = String::new();\n    for bracket in brackets.chars()\
    \ {\n        if bracket == '(' {\n            stack.push(bracket);\n         \
    \   opening_brackets.push('(');\n        } else if bracket == ')' {\n        \
    \    if opening_brackets.len() == 0 {\n                return false;\n       \
    \     }\n            opening_brackets.pop();\n            closing_brackets.push(bracket);\n\
    \        } else if bracket == '[' {\n            stack.push(bracket);\n      \
    \      opening_brackets.push('[');\n        } else if bracket == ']' {\n     \
    \       if opening_brackets.len() == 0 {\n                return false;\n    \
    \        }\n            opening_brackets.pop();\n            closing_brackets.push(bracket);\n\
    \        } else if bracket == '{' {\n            stack.push(bracket);\n      \
    \      opening_brackets.push('{');\n        } else if bracket == '}' {\n     \
    \       if opening_brackets.len() == 0 {\n                return false;\n    \
    \        }\n            opening_brackets.pop();\n            closing_brackets.push(bracket);\n\
    \        }\n    }\n    if opening_brackets.len() != 0 || closing_brackets.len()\
    \ != 0 {\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpx3ncoph_.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnbq_z3kb.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for ch in brackets {\n        if ch == '(' {\n\
    \            stack.push(ch);\n        } else if ch == ')' {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \        } else {\n            if stack.len() != 0 {\n                return false;\n\
    \            }\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmptwdj0qpx.rs:13:15\n\
    \   |\n13 |     for ch in brackets {\n   |               ^^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut closed_brackets = String::new();\n\
    \    let mut open_brackets_stack = Vec::new();\n    let mut closed_brackets_stack\
    \ = Vec::new();\n    let mut open_brackets_count = String::new();\n    let mut\
    \ closed_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::new();\n    let mut open_brackets_count_stack = Vec::new();\n    let\
    \ mut closed_brackets_count_stack = Vec::new();\n    let mut open_brackets_count_stack\
    \ = Vec::new();\n    let mut closed_brackets_count_stack = Vec::new();\n    let\
    \ mut open_brackets_count_stack = Vec::new();\n    let mut closed_brackets_count_stack\
    \ = Vec::\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp4ne5fkn_.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    for c in brackets.chars() {\n        if stack.len() == 0 {\n            return\
    \ false;\n        }\n        if stack.last().unwrap() != c {\n            return\
    \ false;\n        }\n        stack.pop();\n    }\n    stack.is_empty()\n}\n\n\
    fn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1p7p_jjs.rs:18:34\n\
    \   |\n18 |         if stack.last().unwrap() != c {\n   |                    \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_brackets_size: usize = 0;\n    let mut close_brackets_size: usize = 0;\n\
    \    let mut open_brackets_sizes: Vec<usize> = Vec::new();\n    let mut close_brackets_sizes:\
    \ Vec<usize> = Vec::new();\n    let mut open_brackets_sizes_size: usize = 0;\n\
    \    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n    let mut open_brackets_sizes_size:\
    \ usize = 0;\n    let mut close_brackets_sizes_size: usize = 0;\n\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm9d3e25s.rs:11:44\n   |\n\
    11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_iter = brackets.char_indices();\n    let mut close_brackets_iter\
    \ = brackets.char_indices();\n    let mut open_brackets_end = open_brackets.char_indices();\n\
    \    let mut close_brackets_end = close_brackets.char_indices();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut close_brackets_end = close_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut close_brackets_end = close_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut close_brackets_end = close_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut close_brackets_end = close_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mut open_brackets_end = open_brackets_end.next_back();\n\
    \    let mut close_brackets_end = close_brackets_end.next_back();\n    let mut\
    \ open_brackets_iter = open_brackets_iter.next_back();\n    let mut close_brackets_iter\
    \ = close_brackets_iter.next_back();\n    let mu\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xogj74s.rs:40:11\n   |\n\
    40 |     let mu\n   |           ^ help: add `;` here\n41 | }\n   | - unexpected\
    \ token\n\nerror[E0599]: no method named `next_back` found for enum `Option` in\
    \ the current scope\n  --> /tmp/tmp8xogj74s.rs:22:53\n   |\n22 |     let mut open_brackets_iter\
    \ = open_brackets_iter.next_back();\n   |                                    \
    \                 ^^^^^^^^^ method not found in `Option<(usize, char)>`\n\nerror[E0599]:\
    \ no method named `next_back` found for enum `Option` in the current scope\n \
    \ --> /tmp/tmp8xogj74s.rs:23:55\n   |\n23 |     let mut close_brackets_iter =\
    \ close_brackets_iter.next_back();\n   |                                     \
    \                  ^^^^^^^^^ method not found in `Option<(usize, char)>`\n\nerror[E0599]:\
    \ no method named `next_back` found for enum `Option` in the current scope\n \
    \ --> /tmp/tmp8xogj74s.rs:24:51\n   |\n24 |     let mut open_brackets_end = open_brackets_end.next_back();\n\
    \   |                                                   ^^^^^^^^^ method not found\
    \ in `Option<(usize, char)>`\n\nerror[E0599]: no method named `next_back` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmp8xogj74s.rs:25:53\n  \
    \ |\n25 |     let mut close_brackets_end = close_brackets_end.next_back();\n \
    \  |                                                     ^^^^^^^^^ method not\
    \ found in `Option<(usize, char)>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xogj74s.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(item) = stack.pop() {\n        if item == \"(\" || item ==\
    \ \")\" {\n            stack.push(item);\n        }\n    }\n    stack.is_empty()\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9xrdiugj.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    while let Some(item) = stack.last()\
    \ {\n        if item == '(' {\n            open_brackets.push(item);\n       \
    \ }\n        if item == ')' {\n            if open_brackets.len() == 0 {\n   \
    \             return false;\n            }\n            open_brackets.pop();\n\
    \        }\n        stack.pop();\n    }\n    open_brackets.is_empty()\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwk49wui6.rs:16:17\n\
    \   |\n16 |         if item == '(' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwk49wui6.rs:19:17\n\
    \   |\n19 |         if item == ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(0);\n        } else if bracket\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.push(stack.len()\
    \ - 1);\n        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp4h2whubk.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening_bracket = brackets.chars().next().unwrap();\n        let mut\
    \ closing_bracket = brackets.chars().next().unwrap();\n        if opening_bracket\
    \ == closing_bracket {\n            brackets = brackets.chars().skip_while(|c|\
    \ c != opening_bracket).collect();\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmcxet_8c.rs:17:58\n\
    \   |\n17 |             brackets = brackets.chars().skip_while(|c| c != opening_bracket).collect();\n\
    \   |                                                          ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = String::new();\n    let\
    \ mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = String::new();\n\
    \    let mut close_bracket = String::new();\n    let mut open_brackets = String::new();\n\
    \    let mut close_brackets = String::new();\n    let mut open_bracket = \n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpq7qoitdg.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \    while stack.len() > 0 {\n        let mut last = stack.last().unwrap();\n\
    \        if last == ')' {\n            stack.pop();\n        } else {\n      \
    \      stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpxbv_qcvo.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect());\n   |                                    \
    \               ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpxbv_qcvo.rs:16:17\n\
    \   |\n16 |         if last == ')' {\n   |                 ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0599]: no method named `is_ascii_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmpxbv_qcvo.rs:19:59\n   |\n19 |  \
    \           stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect());\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    let mut open_brackets: Vec<usize> = vec![];\n\
    \    let mut close_brackets: Vec<usize> = vec![];\n    let mut open_brackets_size:\
    \ usize = 0;\n    let mut close_brackets_size: usize = 0;\n    let mut open_brackets_open:\
    \ usize = 0;\n    let mut close_brackets_open: usize = 0;\n    let mut open_brackets_close:\
    \ usize = 0;\n    let mut close_brackets_close: usize = 0;\n    let mut open_brackets_close_bracket:\
    \ usize = 0;\n    let mut close_brackets_close_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_brackets: usize = 0;\n    let mut close_brackets_close_brackets:\
    \ usize = 0;\n    let mut open_brackets_close_brackets_bracket: usize = 0;\n \
    \   let mut close_brackets_close_brackets_bracket: usize = 0;\n    let mut open_brackets_close_brackets_brackets:\
    \ usize = 0;\n    let mut close_brackets_close_brackets_brackets: usize = 0;\n\
    \    let mut open_brackets_close_brackets_brackets_bracket: usize = 0;\n    let\
    \ mut close_brackets_close_brackets_brackets_bracket: usize = 0;\n    let mut\
    \ open_brackets_close_brackets_brackets_brackets: usize = 0;\n    let mut close_brackets_close_brackets_brackets_brackets:\
    \ usize = 0;\n    let mut open_brackets_close_brackets_brackets_brackets_bracket:\
    \ usize = 0;\n    let mut close_brackets_close_brackets_brackets_brackets_bracket:\
    \ usize = 0;\n    let mut open_brackets_close_brackets_brackets_brackets_brackets:\
    \ usize = 0;\n    let mut close_brackets_close_brackets_brackets_brackets_brackets:\
    \ usize = 0;\n    let mut open_brackets_close_brackets_brackets_brackets_brackets_bracket:\
    \ usize = 0;\n    let mut close_brackets_close_brackets_brackets_brackets_brackets_bracket:\
    \ usize = 0;\n    let mut open_brackets_close\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpycqas8xg.rs:39:32\n   |\n\
    39 |     let mut open_brackets_close\n   |                                ^ help:\
    \ add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpycqas8xg.rs:11:44\n   |\n11 | fn correct_bracketing(brackets: String)\
    \ -> bool {\n   |    ------------------                      ^^^^ expected `bool`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\"\
    , \"}\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpx66zb9zn.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut opening = brackets.chars().enumerate().filter(|(_,\
    \ c)| c == '(').collect::<Vec<_>>();\n    let mut closing = brackets.chars().enumerate().filter(|(_,\
    \ c)| c == ')').collect::<Vec<_>>();\n    let mut opening_stack = Vec::new();\n\
    \    let mut closing_stack = Vec::new();\n    stack.push(opening);\n    closing.reverse();\n\
    \    opening.reverse();\n    loop {\n        if stack.is_empty() {\n         \
    \   return closing_stack.iter().all(|c| closing.contains(&c));\n        }\n  \
    \      let mut opening_stack = Vec::new();\n        let mut closing_stack = Vec::new();\n\
    \        for opening in stack.pop() {\n            if opening.is_empty() {\n \
    \               continue;\n            }\n            let mut opening_stack =\
    \ opening_stack.clone();\n            let mut closing_stack = closing_stack.clone();\n\
    \            for closing in closing.iter() {\n                if opening.contains(&closing)\
    \ {\n                    closing_stack.push(closing);\n                }\n   \
    \         }\n            if closing_stack.is_empty() {\n                opening_stack.push(opening);\n\
    \            }\n        }\n        if closing_stack.is_empty() {\n           \
    \ return false;\n        }\n        stack.push(closing_stack);\n    }\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzbh_osbb.rs:13:70\n\
    \   |\n13 |     let mut opening = brackets.chars().enumerate().filter(|(_, c)|\
    \ c == '(').collect::<Vec<_>>();\n   |                                       \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpzbh_osbb.rs:14:70\n   |\n14 |     let mut\
    \ closing = brackets.chars().enumerate().filter(|(_, c)| c == ')').collect::<Vec<_>>();\n\
    \   |                                                                      ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzbh_osbb.rs:44:20\n\
    \   |\n44 |         stack.push(closing_stack);\n   |                    ^^^^^^^^^^^^^\
    \ expected tuple, found `&(usize, char)`\n   |\n   = note: expected struct `Vec<(usize,\
    \ char)>`\n              found struct `Vec<&(usize, char)>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    while brackets.len() > 0 {\n     \
    \   let mut opening = brackets.chars().nth(0).unwrap();\n        let mut closing\
    \ = brackets.chars().nth(1).unwrap();\n        if opening != closing {\n     \
    \       return false;\n        }\n        brackets = brackets.chars().nth(2).unwrap();\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7qjnrpf8.rs:19:20\n   |\n\
    12 |     let mut brackets = brackets.to_string();\n   |                      \
    \  -------------------- expected due to this value\n...\n19 |         brackets\
    \ = brackets.chars().nth(2).unwrap();\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \  |\n   |                    expected struct `String`, found `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = 0;\n    let\
    \ mut close_brackets = 0;\n    while brackets.len() > 0 {\n        let mut next\
    \ = brackets.chars().next();\n        if next.is_none() {\n            break;\n\
    \        }\n        let mut char = next.unwrap();\n        if char == '(' {\n\
    \            open_brackets += 1;\n        }\n        if char == ')' {\n      \
    \      close_brackets += 1;\n        }\n        brackets = brackets.chars().skip_while(|c|\
    \ c != '(').collect();\n    }\n    open_brackets == close_brackets\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqhh1g2hm.rs:27:54\n\
    \   |\n27 |         brackets = brackets.chars().skip_while(|c| c != '(').collect();\n\
    \   |                                                      ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    loop {\n        let mut found = false;\n        for c in stack.last().unwrap()\
    \ {\n            if c == ')' {\n                found = true;\n              \
    \  break;\n            }\n            if c == '(' {\n                found = false;\n\
    \                break;\n            }\n        }\n        if !found {\n     \
    \       return false;\n        }\n        stack.pop();\n    }\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&char` is not an iterator\n  --> /tmp/tmp8ji_u2re.rs:16:18\n\
    \   |\n16 |         for c in stack.last().unwrap() {\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ `&char` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&char`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpnbq_z3kb.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        if last != ')' {\n        \
    \    return false;\n        }\n        if stack.len() == 0 {\n            return\
    \ true;\n        }\n        let mut next = stack.pop();\n        if next != '('\
    \ {\n            return false;\n        }\n        stack.push(next);\n    }\n\
    \    false\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp9q15deh2.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `String` with\
    \ `char`\n  --> /tmp/tmp9q15deh2.rs:15:17\n   |\n15 |         if last != ')' {\n\
    \   |                 ^^ no implementation for `String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9q15deh2.rs:22:20\n   |\n22 |         if next != '(' {\n\
    \   |                    ^^^ expected enum `Option`, found `char`\n   |\n   =\
    \ note: expected enum `Option<String>`\n              found type `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9q15deh2.rs:25:20\n   |\n25 |         stack.push(next);\n\
    \   |                    ^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = vec![];\n    let mut open_brackets = String::new();\n    let mut\
    \ closed_brackets = String::new();\n    let mut open_brackets_count = String::new();\n\
    \    let mut closed_brackets_count = String::new();\n    let mut open_brackets_count_stack\
    \ = String::new();\n    let mut closed_brackets_count_stack = String::new();\n\
    \    let mut open_brackets_count_stack = String::new();\n    let mut closed_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack = String::new();\n \
    \   let mut closed_brackets_count_stack = String::new();\n    let mut open_brackets_count_stack\
    \ = String::new();\n    let mut closed_brackets_count_stack = String::new();\n\
    \    let mut open_brackets_count_stack = String::new();\n    let mut closed_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack = String::new();\n \
    \   let mut closed_brackets_count_stack = String::new();\n    let mut open_brackets_count_stack\
    \ = String::new();\n    let mut closed_brackets_count_stack = String::new();\n\
    \    let mut open_brackets_count_stack = String::new();\n    let mut closed_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack = String::new();\n \
    \   let mut closed_brackets_count_stack = String::new();\n    let mut open_brackets_count_stack\
    \ = String::new();\n    let mut closed_brackets_count_stack = String::new();\n\
    \    let mut open_brackets_count_stack = String::new();\n    let mut closed_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack = String::new();\n \
    \   let mut closed_brackets_count_stack = String::new();\n    let mut open_brackets_count_stack\
    \ = String::new();\n    let mut closed_brackets_count_stack = String::new();\n\
    \    let mut open_brackets_count_stack = String::new();\n    let mut closed_brackets_count_stack\
    \ = String::new();\n    let mut open_brackets_count_stack = String::new();\n \
    \   let \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpbt3mwpvb.rs:47:1\n  \
    \ |\n47 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for bracket in brackets.chars() {\n        if bracket\
    \ == '(' {\n            stack.push(bracket);\n        } else if bracket == ')'\
    \ {\n            if stack.is_empty() {\n                return false;\n      \
    \      }\n            stack.pop();\n        } else {\n            return false;\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for bracket in brackets.chars() {\n   \
    \     if bracket == '(' {\n            stack.push(0);\n        } else if bracket\
    \ == ')' {\n            if stack.len() == 0 {\n                return false;\n\
    \            }\n            stack.pop();\n        } else {\n            if stack.len()\
    \ == 0 {\n                return false;\n            }\n            stack.pop();\n\
    \            stack.push(stack.len() - 1);\n        }\n    }\n    stack.len() ==\
    \ 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while stack.len() > 0 {\n        let mut next = stack.clone();\n        next.pop();\n\
    \        if next.len() == 0 {\n            return false;\n        }\n        if\
    \ next.len() == 1 {\n            if next.len() == 1 {\n                return\
    \ true;\n            }\n            if next.len() == 2 {\n                let\
    \ mut stack = next.clone();\n                stack.pop();\n                stack.pop();\n\
    \                return stack.is_empty();\n            }\n        }\n        if\
    \ next.len() == 2 {\n            let mut stack = next.clone();\n            stack.pop();\n\
    \            stack.pop();\n            stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n        }\n    }\n    false\n}\n\
    \nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpvv75ovx1.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for reference `&char` in the current scope\n  --> /tmp/tmpvv75ovx1.rs:35:59\n\
    \   |\n35 |             stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpstk5h0nq.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = brackets.chars().filter(|c| c == '(');\n    let mut closing_brackets\
    \ = brackets.chars().filter(|c| c == ')');\n    while opening_brackets.len() >\
    \ 0 && closing_brackets.len() > 0 {\n        if opening_brackets[0] == closing_brackets[0]\
    \ {\n            opening_brackets = opening_brackets.iter().skip(1).collect();\n\
    \            closing_brackets = closing_brackets.iter().skip(1).collect();\n \
    \       } else {\n            return false;\n        }\n    }\n    opening_brackets.len()\
    \ == 0 && closing_brackets.len() == 0\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa9y0ha_q.rs:12:62\n\
    \   |\n12 |     let mut opening_brackets = brackets.chars().filter(|c| c == '(');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa9y0ha_q.rs:13:62\n\
    \   |\n13 |     let mut closing_brackets = brackets.chars().filter(|c| c == ')');\n\
    \   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `len` found for struct `Filter` in the current scope\n\
    \  --> /tmp/tmpa9y0ha_q.rs:14:28\n   |\n14 |     while opening_brackets.len()\
    \ > 0 && closing_brackets.len() > 0 {\n   |                            ^^^ method\
    \ not found in `Filter<Chars<'_>, [closure@/tmp/tmpa9y0ha_q.rs:12:56: 12:68]>`\n\
    \nerror[E0599]: no method named `len` found for struct `Filter` in the current\
    \ scope\n  --> /tmp/tmpa9y0ha_q.rs:14:58\n   |\n14 |     while opening_brackets.len()\
    \ > 0 && closing_brackets.len() > 0 {\n   |                                  \
    \                        ^^^ method not found in `Filter<Chars<'_>, [closure@/tmp/tmpa9y0ha_q.rs:13:56:\
    \ 13:68]>`\n\nerror[E0608]: cannot index into a value of type `Filter<Chars<'_>,\
    \ [closure@/tmp/tmpa9y0ha_q.rs:12:56: 12:68]>`\n  --> /tmp/tmpa9y0ha_q.rs:15:12\n\
    \   |\n15 |         if opening_brackets[0] == closing_brackets[0] {\n   |    \
    \        ^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `Filter<Chars<'_>, [closure@/tmp/tmpa9y0ha_q.rs:13:56: 13:68]>`\n  --> /tmp/tmpa9y0ha_q.rs:15:35\n\
    \   |\n15 |         if opening_brackets[0] == closing_brackets[0] {\n   |    \
    \                               ^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Filter` in t"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.chars().any(|c| !c.is_ascii_letter()) {\n\
    \            return false;\n        }\n        if brackets.len() == 1 {\n    \
    \        continue;\n        }\n        let mut bracket = brackets.chars().next().unwrap();\n\
    \        while let Some(next) = stack.last() {\n            if next == bracket\
    \ {\n                stack.pop();\n            } else {\n                break;\n\
    \            }\n        }\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp6tcdgeig.rs:15:40\n   |\n15 |         if brackets.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                        ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ can't compare `&String` with `char`\n  --> /tmp/tmp6tcdgeig.rs:23:21\n   |\n\
    23 |             if next == bracket {\n   |                     ^^ no implementation\
    \ for `&String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\"\
    , \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n\
    \    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    [\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpzs1qm3gm.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    let mut open_bracket = String::new();\n  \
    \  let mut close_bracket = String::new();\n    let mut open_brackets_len = String::new();\n\
    \    let mut close_brackets_len = String::new();\n    let mut open_brackets_count\
    \ = String::new();\n    let mut close_brackets_count = String::new();\n    let\
    \ mut open_brackets_count_len = String::new();\n    let mut close_brackets_count_len\
    \ = String::new();\n    let mut open_brackets_count_count = String::new();\n \
    \   let mut close_brackets_count_count = String::new();\n    let mut open_brackets_count_count_len\
    \ = String::new();\n    let mut close_brackets_count_count_len = String::new();\n\
    \    let mut open_brackets_count_count_count = String::new();\n    let mut close_brackets_count_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_count_len = String::new();\n\
    \    let mut close_brackets_count_count_count_len = String::new();\n    let mut\
    \ open_brackets_count_count_count_count = String::new();\n    let mut close_brackets_count_count_count_count\
    \ = String::new();\n    let mut open_brackets_count_count_count_count_len = String::new();\n\
    \    let mut close_brackets_count_count_count_count_len = String::new();\n   \
    \ let mut open_brackets_count_count_count_count_count = String::new();\n    let\
    \ mut close_brackets_count_count_count_count_count = String::new();\n    let mut\
    \ open_brackets_count_count_count_count_count_len = String::new();\n    let mut\
    \ close_brackets_count_count_count_count_count_len = String::new();\n    let mut\
    \ open_brackets_count_count_count_count_count_count = String::new();\n    let\
    \ mut close_brackets_count_count_count_count_count_count = String::new();\n  \
    \  let mut open_brackets_count_count_count_count_count_count_len = String::new();\n\
    \    let mut close_brackets_count_count_count_count_count_count_len = String::new();\n\
    \    let mut open_brackets_count_count_count_count_count_count_\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5gg9yu0o.rs:43:63\n   |\n\
    43 |     let mut open_brackets_count_count_count_count_count_count_\n   |    \
    \                                                           ^ help: add `;` here\n\
    44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5gg9yu0o.rs:11:44\n\
    \   |\n11 | fn correct_bracketing(brackets: String) -> bool {\n   |    ------------------\
    \                      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \n    for bracket in brackets.chars().filter(|c| c != '(' && c != ')') {\n   \
    \     match bracket {\n            '(' | ')' => open_brackets.push(bracket),\n\
    \            _ => close_brackets.push(bracket),\n        }\n    }\n\n    open_brackets.len()\
    \ == close_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpaqqfj0sj.rs:15:50\n\
    \   |\n15 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpaqqfj0sj.rs:15:62\n\
    \   |\n15 |     for bracket in brackets.chars().filter(|c| c != '(' && c != ')')\
    \ {\n   |                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    let mut open_brackets = Vec::new();\n    loop {\n        if stack.len() ==\
    \ 0 {\n            return open_brackets.len() == 0;\n        }\n        let mut\
    \ current = stack.last().unwrap();\n        if current == '(' {\n            open_brackets.push(current);\n\
    \            stack.push(brackets.chars().next().unwrap());\n        } else if\
    \ current == ')' {\n            if open_brackets.len() == 0 {\n              \
    \  return false;\n            }\n            open_brackets.pop();\n          \
    \  stack.pop();\n        } else {\n            stack.pop();\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpioojkjab.rs:20:20\n\
    \   |\n20 |         if current == '(' {\n   |                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpioojkjab.rs:23:27\n\
    \   |\n23 |         } else if current == ')' {\n   |                         \
    \  ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    let mut open_brackets = 0;\n    let\
    \ mut closed_brackets = 0;\n    while brackets.len() > 0 {\n        let mut open_bracket\
    \ = brackets.chars().next().unwrap();\n        open_brackets = open_brackets +\
    \ 1;\n        while open_brackets.is_even() {\n            open_bracket = open_brackets.next_back().unwrap();\n\
    \            open_brackets = open_brackets - 1;\n        }\n        if open_brackets.is_even()\
    \ {\n            open_brackets = open_brackets - 1;\n        }\n        let mut\
    \ closed_bracket = brackets.chars().next().unwrap();\n        closed_brackets\
    \ = closed_brackets + 1;\n        while closed_brackets.is_even() {\n        \
    \    closed_bracket = closed_brackets.next_back().unwrap();\n            closed_brackets\
    \ = closed_brackets - 1;\n        }\n        if closed_brackets.is_even() {\n\
    \            closed_brackets = closed_brackets - 1;\n        }\n        if open_brackets\
    \ == closed_brackets {\n            return false;\n        }\n        brackets\
    \ = brackets.split_off(open_bracket);\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `{integer}` in the\
    \ current scope\n  --> /tmp/tmpklwjg8k6.rs:18:29\n   |\n18 |         while open_brackets.is_even()\
    \ {\n   |                             ^^^^^^^ method not found in `{integer}`\n\
    \nerror[E0689]: can't call method `next_back` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpklwjg8k6.rs:19:42\n   |\n19 |             open_bracket = open_brackets.next_back().unwrap();\n\
    \   |                                          ^^^^^^^^^\n   |\nhelp: you must\
    \ specify a type for this binding, like `i32`\n   |\n13 |     let mut open_brackets:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named\
    \ `is_even` found for type `{integer}` in the current scope\n  --> /tmp/tmpklwjg8k6.rs:22:26\n\
    \   |\n22 |         if open_brackets.is_even() {\n   |                       \
    \   ^^^^^^^ method not found in `{integer}`\n\nerror[E0599]: no method named `is_even`\
    \ found for type `{integer}` in the current scope\n  --> /tmp/tmpklwjg8k6.rs:27:31\n\
    \   |\n27 |         while closed_brackets.is_even() {\n   |                  \
    \             ^^^^^^^ method not found in `{integer}`\n\nerror[E0689]: can't call\
    \ method `next_back` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpklwjg8k6.rs:28:46\n\
    \   |\n28 |             closed_bracket = closed_brackets.next_back().unwrap();\n\
    \   |                                              ^^^^^^^^^\n   |\nhelp: you\
    \ must specify a type for this binding, like `i32`\n   |\n14 |     let mut closed_brackets:\
    \ i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named\
    \ `is_even` found for type `{integer}` in the current scope\n  --> /tmp/tmpklwjg8k6.rs:31:28\n\
    \   |\n31 |         if closed_brackets.is_even() {\n   |                     \
    \       ^^^^^^^ method not found in `{integer}`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpklwjg8k6.rs:37:39\n   |\n37 |         brackets = brackets.split_off(open_bracket);\n\
    \   |                                       ^^^^^^^^^^^^ expected `usize`, found\
    \ `char`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed\
    \ ex"
  stdout: ''
  timestamp: 1660010683
- exit_code: 0
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    for c in brackets.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else if c == ')' {\n            if\
    \ stack.is_empty() {\n                return false;\n            }\n         \
    \   stack.pop();\n        } else {\n            return false;\n        }\n   \
    \ }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_brackets_count = String::new();\n    let mut close_brackets_count\
    \ = String::new();\n    let mut open_brackets_count_map = HashMap::new();\n  \
    \  let mut close_brackets_count_map = HashMap::new();\n    let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted = HashMap::new();\n\
    \    let mut open_brackets_count_map_sorted_reverse = HashMap::new();\n    let\
    \ mut close_brackets_count_map_sorted_reverse = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut close_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted\
    \ = HashMap::new();\n    let mut open_brackets_count_map_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse_sorted_reverse\
    \ = HashMap::new();\n    let mut \n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpwh8blgjo.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpwh8blgjo.rs:16:39\n   |\n16\
    \ |     let mut open_brackets_count_map = HashMap::new();\n   |              \
    \                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpwh8blgjo.rs:17:40\n\
    \   |\n17 |     let mut close_brackets_count_map = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpwh8blgjo.rs:18:46\n   |\n18 |     let mut open_brackets_count_map_sorted\
    \ = HashMap::new();\n   |                                              ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpwh8blgjo.rs:19:47\n   |\n19\
    \ |     let mut close_brackets_count_map_sorted = HashMap::new();\n   |      \
    \                                         ^^^^^^^ not found in this scope\n  \
    \ |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpwh8blgjo.rs:20:54\n   |\n20 |     let mut open_brackets_count_map_sorted_reverse\
    \ = HashMap::new();\n   |                                                    \
    \  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpwh8blgjo.rs:21:55\n   |\n21\
    \ |     let mut close_brackets_count_map_sorted_reverse = HashMap::new();\n  \
    \ |                                                       ^^^^^^^ no"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if let Some(close) = stack.last()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        }\n        stack.pop();\n        stack.push(open);\n    }\n   \
    \ true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjtgaok6y.rs:21:20\n   |\n\
    21 |         stack.push(open);\n   |                    ^^^^ expected `char`,\
    \ found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |   \
    \      stack.push(*open);\n   |                    +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \"\
    )\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"\
    (\", \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\"\
    );\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp9pux71dy.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = Vec::new();\n    let mut open_brackets: Vec<usize> =\
    \ Vec::new();\n    let mut close_brackets: Vec<usize> = Vec::new();\n    let mut\
    \ open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut close_brackets = String::new();\n\
    \    let mut open_bracket = String::new();\n    let mut close_bracket = String::new();\n\
    \    let mut open_brackets = String::new();\n    let mut \n}\n\nfn main() {\n\
    \    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp1o2lvb9i.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<')\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpxpv38hn_.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<Vec<_>>());\n\
    \    while let Some(mut c) = stack.pop() {\n        if c.is_ascii_letter() {\n\
    \            if let Some(mut next) = stack.pop() {\n                if next ==\
    \ c {\n                    stack.push(c);\n                } else {\n        \
    \            return false;\n                }\n            } else {\n        \
    \        return false;\n            }\n        } else {\n            return false;\n\
    \        }\n    }\n    true\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmponxyi7h5.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<Vec<_>>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmponxyi7h5.rs:15:14\n\
    \   |\n15 |         if c.is_ascii_letter() {\n   |              ^^^^^^^^^^^^^^^\
    \ method not found in `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().next().unwrap());\n\
    \    while let Some(open) = stack.last() {\n        if open != ')' {\n       \
    \     return false;\n        }\n        stack.pop();\n    }\n    true\n}\n\nfn\
    \ main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1xkaiq1w.rs:15:17\n\
    \   |\n15 |         if open != ')' {\n   |                 ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ {\n        c != '(' && c != ')'\n    })\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzmg02ion.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    brackets.chars().all(|c|\
    \ c == ')' || c == '(')\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp5pnv64d5.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(open) = stack.pop() {\n        if let Some(close) = stack.pop()\
    \ {\n            if open != close {\n                return false;\n         \
    \   }\n        } else {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp2uxqu55h.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n\
    \    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n  \
    \  brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\"\
    , \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"\
    {\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\"\
    );\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n  \
    \  brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\"\
    , \">\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"<\", \"<\");\n    brackets.replace(\">\", \">\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    <\", \"<\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"\
    <\");\n    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"<\", \"<\");\n\
    \    brackets.replace(\">\", \">\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpmgg3s5ix.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().collect::<Vec<_>>());\n\
    \    while let Some(item) = stack.pop() {\n        if item == ')' {\n        \
    \    if stack.len() == 0 {\n                return false;\n            }\n   \
    \         stack.pop();\n        } else if item == '(' {\n            stack.push(item);\n\
    \        }\n    }\n    stack.len() == 0\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `Vec<char>` with `char`\n  --> /tmp/tmptm8cbnq8.rs:15:17\n\
    \   |\n15 |         if item == ')' {\n   |                 ^^ no implementation\
    \ for `Vec<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `Vec<char>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0277]: can't compare\
    \ `Vec<char>` with `char`\n  --> /tmp/tmptm8cbnq8.rs:20:24\n   |\n20 |       \
    \  } else if item == '(' {\n   |                        ^^ no implementation for\
    \ `Vec<char> == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `Vec<char>`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as\
    \ PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n         \
    \    <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets.chars().skip_while(|c| !c.is_ascii_letter()).collect::<String>());\n\
    \    while let Some(last) = stack.pop() {\n        let mut next = Vec::new();\n\
    \        for c in &last {\n            if let Some(next) = stack.pop() {\n   \
    \             stack.push((c, next));\n            } else {\n                next.push(c);\n\
    \            }\n        }\n        if !next.is_empty() {\n            stack.push(last);\n\
    \        }\n    }\n    stack.is_empty()\n}\n\nfn main() {\n    let candidate =\
    \ correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpdn6e3esg.rs:13:51\n   |\n13 |     stack.push(brackets.chars().skip_while(|c|\
    \ !c.is_ascii_letter()).collect::<String>());\n   |                          \
    \                         ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: `&String` is not an iterator\n\
    \  --> /tmp/tmpdn6e3esg.rs:16:18\n   |\n16 |         for c in &last {\n   |  \
    \                ^^^^^ `&String` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdn6e3esg.rs:18:28\n   |\n18 |              \
    \   stack.push((c, next));\n   |                            ^^^^^^^^^ expected\
    \ struct `String`, found tuple\n   |\n   = note: expected struct `String`\n  \
    \             found tuple `(_, String)`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut brackets = brackets.to_string();\n    brackets.replace(\"(\", \"(\");\n\
    \    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\");\n  \
    \  brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"\
    }\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\"\
    , \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"\
    ]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n\
    \    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n  \
    \  brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\"\
    , \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"\
    (\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"[\"\
    );\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n  \
    \  brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\"\
    )\", \")\");\n    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\"\
    , \"]\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"\
    }\");\n    brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\"\
    );\n    brackets.replace(\"(\", \"(\");\n    brackets.replace(\")\", \")\");\n\
    \    brackets.replace(\"[\", \"[\");\n    brackets.replace(\"]\", \"]\");\n  \
    \  brackets.replace(\"{\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"\
    {\", \"{\");\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\"\
    , \"(\");\n    brackets.replace(\")\", \")\");\n    brackets.replace(\"[\", \"\
    [\");\n    brackets.replace(\"]\", \"]\");\n    brackets.replace(\"{\", \"{\"\
    );\n    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"{\", \"{\");\n\
    \    brackets.replace(\"}\", \"}\");\n    brackets.replace(\"(\", \"(\");\n  \
    \  brackets.replace(\")\", \")\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp4h2whubk.rs:84:56\n\
    \   |\n84 |       assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    \   |  ________________________________________________________^\n85 | | }\n \
    \  | |__^\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660010682
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    stack.push(brackets);\n    while let Some(brackets)\
    \ = stack.pop() {\n        if brackets.len() == 0 {\n            continue;\n \
    \       }\n        let mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \        let mut close_brackets = brackets.chars().filter(|c| c == ')').count();\n\
    \        if open_brackets == close_brackets {\n            continue;\n       \
    \ }\n        return false;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = correct_bracketing;\n    assert_eq!(candidate(String::from(\"()\")), true);\n\
    \    assert_eq!(candidate(String::from(\"(()())\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqce2k6rt.rs:18:63\n\
    \   |\n18 |         let mut open_brackets = brackets.chars().filter(|c| c == '(').count();\n\
    \   |                                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqce2k6rt.rs:19:64\n\
    \   |\n19 |         let mut close_brackets = brackets.chars().filter(|c| c ==\
    \ ')').count();\n   |                                                        \
    \        ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack = Vec::new();\n    let mut open_brackets = Vec::new();\n    let mut\
    \ close_brackets = Vec::new();\n    stack.push(brackets);\n    while stack.len()\
    \ > 0 {\n        let mut current = stack.pop().unwrap();\n        if current.chars().any(|c|\
    \ c == '(') {\n            open_brackets.push(current);\n        } else {\n  \
    \          close_brackets.push(current);\n        }\n        if current.chars().any(|c|\
    \ c == ')') {\n            stack.unshift(current);\n        }\n    }\n    open_brackets.len()\
    \ == close_brackets.len() && open_brackets.iter().zip(close_brackets).all(|(a,\
    \ b)| a == b)\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n   \
    \ assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unshift` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpgm90x6u2.rs:24:19\n   |\n24 |          \
    \   stack.unshift(current);\n   |                   ^^^^^^^ method not found in\
    \ `Vec<String>`\n\nerror[E0277]: can't compare `&String` with `String`\n  -->\
    \ /tmp/tmpgm90x6u2.rs:27:108\n   |\n27 |     open_brackets.len() == close_brackets.len()\
    \ && open_brackets.iter().zip(close_brackets).all(|(a, b)| a == b)\n   |     \
    \                                                                            \
    \                           ^^ no implementation for `&String == String`\n   |\n\
    \   = help: the trait `PartialEq<String>` is not implemented for `&String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 1
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut stack: Vec<usize> = vec![];\n    for c in brackets.chars() {\n        if\
    \ c == '(' {\n            stack.push(0);\n        } else if c == ')' {\n     \
    \       if stack.len() == 0 {\n                return false;\n            }\n\
    \            stack.pop();\n        } else {\n            if stack.len() == 0 {\n\
    \                return false;\n            }\n            stack[stack.len() -\
    \ 1] += 1;\n        }\n    }\n    stack.iter().all(|&x| x == 0)\n}\n\nfn main()\
    \ {\n    let candidate = correct_bracketing;\n    assert_eq!(candidate(String::from(\"\
    ()\")), true);\n    assert_eq!(candidate(String::from(\"(()())\")), true);\n \
    \   assert_eq!(candidate(String::from(\"()()(()())()\")), true);\n    assert_eq!(candidate(String::from(\"\
    ()()((()()())())(()()(()))\")), true);\n    assert_eq!(candidate(String::from(\"\
    ((()())))\")), false);\n    assert_eq!(candidate(String::from(\")(()\")), false);\n\
    \    assert_eq!(candidate(String::from(\"(\")), false);\n    assert_eq!(candidate(String::from(\"\
    ((((\")), false);\n    assert_eq!(candidate(String::from(\")\")), false);\n  \
    \  assert_eq!(candidate(String::from(\"(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    ()()(()())())(()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\"\
    )), false);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `stack` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpm9mplhsk.rs:25:19\n   |\n25 |             stack[stack.len()\
    \ - 1] += 1;\n   |             ------^^^^^^^^^^^-----\n   |             |    \
    \ |\n   |             |     immutable borrow occurs here\n   |             mutable\
    \ borrow occurs here\n   |             mutable borrow later used here\n   |\n\
    help: try adding a local storing this...\n  --> /tmp/tmpm9mplhsk.rs:25:19\n  \
    \ |\n25 |             stack[stack.len() - 1] += 1;\n   |                   ^^^^^^^^^^^\n\
    help: ...and then using that local here\n  --> /tmp/tmpm9mplhsk.rs:25:13\n   |\n\
    25 |             stack[stack.len() - 1] += 1;\n   |             ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010683
- exit_code: 101
  program: "/// brackets is a string of \"(\" and \")\".\n/// return True if every\
    \ opening bracket has a corresponding closing bracket.\n/// >>> correct_bracketing(String::from(\"\
    (\"))\n/// false\n/// >>> correct_bracketing(String::from(\"()\"))\n/// true\n\
    /// >>> correct_bracketing(String::from(\"(()())\"))\n/// true\n/// >>> correct_bracketing(String::from(\"\
    )(()\"))\n/// false\nfn correct_bracketing(brackets: String) -> bool {\n    let\
    \ mut opening_brackets = String::new();\n    let mut closing_brackets = String::new();\n\
    \n    for bracket in brackets.chars() {\n        if bracket == '(' {\n       \
    \     opening_brackets.push('(');\n        } else if bracket == ')' {\n      \
    \      closing_brackets.push(')');\n        } else {\n            opening_brackets.push(bracket);\n\
    \            closing_brackets.push(bracket);\n        }\n    }\n\n    opening_brackets.len()\
    \ == closing_brackets.len()\n}\n\nfn main() {\n    let candidate = correct_bracketing;\n\
    \    assert_eq!(candidate(String::from(\"()\")), true);\n    assert_eq!(candidate(String::from(\"\
    (()())\")), true);\n    assert_eq!(candidate(String::from(\"()()(()())()\")),\
    \ true);\n    assert_eq!(candidate(String::from(\"()()((()()())())(()()(()))\"\
    )), true);\n    assert_eq!(candidate(String::from(\"((()())))\")), false);\n \
    \   assert_eq!(candidate(String::from(\")(()\")), false);\n    assert_eq!(candidate(String::from(\"\
    (\")), false);\n    assert_eq!(candidate(String::from(\"((((\")), false);\n  \
    \  assert_eq!(candidate(String::from(\")\")), false);\n    assert_eq!(candidate(String::from(\"\
    (()\")), false);\n    assert_eq!(candidate(String::from(\"()()(()())())(()\")),\
    \ false);\n    assert_eq!(candidate(String::from(\"()()(()())()))()\")), false);\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpce_2l8v3.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010683
