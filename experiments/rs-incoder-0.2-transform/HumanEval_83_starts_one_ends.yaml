name: HumanEval_83_starts_one_ends
language: rs
prompt: "/// Given a positive integer n, return the count of the numbers of n-digit\n\
  /// positive integers that start or end with 1.\nfn starts_one_ends(n: isize) ->\
  \ isize {\n"
tests: "}\n\nfn main() {\n    let candidate = starts_one_ends;\n    assert_eq!(candidate(1),\
  \ 1);\n    assert_eq!(candidate(2), 18);\n    assert_eq!(candidate(3), 180);\n \
  \   assert_eq!(candidate(4), 1800);\n    assert_eq!(candidate(5), 18000);\n}\n"
completions: ["    if n < 1 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        if i / 10 == 1 {\n          \
    \  i += 1;\n            count += 1;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    count", "    let mut count = 0;\n    while n > 0 {\n   \
    \     count += n / 10;\n        n /= 10;\n    }\n    count", "    match n {\n\
    \        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n\
    \ > 0);\n    debug_assert!(n % 10 == 1);\n    let mut count = 0;\n    while n\
    \ > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "    if\
    \ n < 0 {\n        panic!(\"starts_one_ends: n must be positive\");\n    }\n \
    \   let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n        \
    \    count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    debug_assert!(n % 10 == 1);\n\n    let mut count = 0;\n    let mut\
    \ i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count", "   \
    \ let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n\
    \ {\n        0 => 0,\n        _ => 1 + starts_one_ends(n / 10),\n    }", "   \
    \ debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    let mut n = 0;\n\
    \    while n > 0 {\n        n /= 10;\n        n += n % 10 == 1;\n    }\n    n",
  "    debug_assert!(n >= 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        if i / 10 == 1 {\n          \
    \  i += 1;\n        } else {\n            i += 2;\n        }\n        count +=\
    \ 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    match n {\n        0 => 0,\n        _ => if n % 10 == 1\
    \ {\n            1\n        } else {\n            1 + starts_one_ends(n / 10)\n\
    \        }\n    }", "    match n {\n        1 => 1,\n        _ => n,\n    }",
  "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    let mut n = 0;\n\
    \    while n > 0 {\n        n /= 10;\n        n += n % 2 == 1;\n    }\n    n",
  "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n > 0 {\n       \
    \ if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n   \
    \ }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    match n {\n        0 => 0,\n        1 => 1,\n        _ =>\
    \ n,\n    }", "    debug_assert!(n > 0);\n    debug_assert!(n % 10 == 0);\n  \
    \  let mut count = 0;\n    while n > 0 {\n        n /= 10;\n        count += 1;\n\
    \    }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    if n ==\
    \ 1 {\n        return 1;\n    }\n    if n == 2 {\n        return 2;\n    }\n \
    \   if n == 3 {\n        return 3;\n    }\n    if n == 4 {\n        return 4;\n\
    \    }\n    if n == 5 {\n        return 5;\n    }\n    if n == 6 {\n        return\
    \ 6;\n    }\n    if n == 7 {\n        return 7;\n    }\n    if n == 8 {\n    \
    \    return 8;\n    }\n    if n == 9 {\n        return 9;\n    }\n    if n ==\
    \ 10 {\n        return 10;\n    }\n    if n == 11 {\n        return 11;\n    }\n\
    \    if n == 12 {\n        return 12;\n    }\n    if n == 13 {\n        return\
    \ 13;\n    }\n    if n == 14 {\n        return 14;\n    }\n    if n == 15 {\n\
    \        return 15;\n    }\n    if n == 16 {\n        return 16;\n    }\n    if\
    \ n == 17 {\n        return 17;\n    }\n    if n == 18 {\n        return 18;\n\
    \    }\n    if n == 19 {\n        return 19;\n    }\n    if n == 20 {\n      \
    \  return 20;\n    }\n    if n == 21 {\n        return 21;\n    }\n    if n ==\
    \ 22 {\n        return 22;\n    }\n    if n == 23 {\n        return 23;\n    }\n\
    \    if n == 24 {\n        return 24;\n    }\n    if n == 25 {\n        return\
    \ 25;\n    }\n    if n == 26 {\n        return 26;\n    }\n    if n == 27 {\n\
    \        return 27;\n    }\n    if n == 28 {\n        return 28;\n    }\n    if\
    \ n == 29 {\n        return 29;\n    }\n    if n == 30 {\n        return 30;\n\
    \    }\n    if n == 31 {\n        return 31;\n    }\n    if n == 32 {\n      \
    \  return 32;\n    }\n    if n == 33 {\n        return 33;\n    }\n    if n ==\
    \ 34 {\n        return 34;\n    }\n    if n == 35 {\n        return 35;\n    }\n\
    \    if n == 36 {\n        return 36;\n    }\n    if n == 37 {\n        return\
    \ 37;\n    }\n    if n == 38 {\n        return 38;\n    }\n    if n == 39 {\n\
    \        return 39;\n    }\n    if n == 40 {\n        return 40;\n    }\n    if\
    \ n == 41 {\n        return 41;\n    }\n    if n == 42 {\n        return 42;\n\
    \    }\n    if n == 43 {\n        return 43;\n    }\n    if n == 44 {\n      \
    \  return 44;\n    }\n    if n == 45 {\n        return 45;\n    }\n    if n ==\
    \ 46 {\n        return 46;\n", "    let mut count = 0;\n    while n != 0 {\n \
    \       if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", '    n.checked_mul(10).unwrap().checked_sub(1isize).unwrap()',
  "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n != 0 {\n      \
    \  if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n  \
    \  }\n    count", "    let mut count = 0;\n    while n > 0 {\n        if n % 10\
    \ == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    match n {\n        0 => 0,\n        _ => n,\n    }", "    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n {\n    \
    \    0 => 0,\n        _ => 1,\n    }", "    match n {\n        0 => 0,\n     \
    \   _ => 1 + starts_one_ends(n - 1),\n    }", "    let mut count = 0;\n    while\
    \ n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n    \
    \    n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let mut count\
    \ = 0;\n    while n != 1 {\n        n /= 10;\n        count += 1;\n    }\n   \
    \ count", "    if n < 1 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n      \
    \  }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let\
    \ mut count = 0;\n    while n > 0 {\n        count += n / 10;\n        n /= 10;\n\
    \    }\n    count", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while\
    \ n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n    \
    \    n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let mut count\
    \ = 0;\n    while n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n\
    \    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    let mut count = 0;\n    while n != 0 {\n        if n % 10\
    \ == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  '    n / 10 + 1', "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ / 10),\n    }", "    if n < 0 {\n        return 0;\n    }\n    let mut count\
    \ = 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n   \
    \         count += 1;\n        }\n        i += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n    while n > 0\
    \ {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n /=\
    \ 10;\n    }\n    count", "    match n {\n        0 => 0,\n        _ => 1,\n \
    \   }", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n != 0\
    \ {\n        n /= 10;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut n = 0;\n    while n <= n / 10 {\n        n += 1;\n    }\n\
    \    n", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while\
    \ n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n    \
    \    n /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    let mut count = 0;\n    while n != 0 {\n        if n\
    \ % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n \
    \   count", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n != 1 {\n       \
    \ n /= 10;\n        count += 1;\n    }\n    count", "    let mut count = 0;\n\
    \    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n     \
    \   }\n        n /= 10;\n    }\n    count", "    if n < 0 {\n        panic!(\"\
    starts_one_ends called with negative n\");\n    }\n    if n == 0 {\n        return\
    \ 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n          \
    \  count += 1;\n        }\n        i += 1;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    let mut count = 0;\n    while n\
    \ > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n      \
    \  n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 0);\n    let mut count = 0;\n    while n != 0 {\n        n /= 10;\n\
    \        count += 1;\n    }\n    count", "    if n < 10 {\n        return 1;\n\
    \    }\n    if n < 100 {\n        return 2;\n    }\n    if n < 1000 {\n      \
    \  return 3;\n    }\n    if n < 10000 {\n        return 4;\n    }\n    if n <\
    \ 100000 {\n        return 5;\n    }\n    if n < 1000000 {\n        return 6;\n\
    \    }\n    if n < 10000000 {\n        return 7;\n    }\n    if n < 100000000\
    \ {\n        return 8;\n    }\n    if n < 1000000000 {\n        return 9;\n  \
    \  }\n    if n < 10000000000 {\n        return 10;\n    }\n    if n < 100000000000\
    \ {\n        return 11;\n    }\n    if n < 1000000000000 {\n        return 12;\n\
    \    }\n    if n < 10000000000000 {\n        return 13;\n    }\n    if n < 100000000000000\
    \ {\n        return 14;\n    }\n    if n < 1000000000000000 {\n        return\
    \ 15;\n    }\n    if n < 10000000000000000 {\n        return 16;\n    }\n    if\
    \ n < 100000000000000000 {\n        return 17;\n    }\n    if n < 1000000000000000000\
    \ {\n        return 18;\n    }\n    if n < 10000000000000000000 {\n        return\
    \ 19;\n    }\n    if n < 1000000000000000000 {\n        return 20;\n    }\n  \
    \  if n < 10000000000000000000 {\n        return 21;\n    }\n    if n < 100000000000000000000\
    \ {\n        return 22;\n    }\n    if n < 1000000000000000000000 {\n        return\
    \ 23;\n    }\n    if n < 10000000000000000000000 {\n        return 24;\n    }\n\
    \    if n < 100000000000000000000000 {\n        return 25;\n    }\n    if n <\
    \ 1000000000000000000000000 {\n        return 26;\n    }\n    if n < 10000000000000000000000000\
    \ {\n        return 27;\n    }\n    if n < 100000000000000000000000000 {\n   \
    \     return 28;\n    }\n    if n < 1000000000000000000000000000 {\n        return\
    \ 29;\n    }\n    if n < 10000000000000000000000000000 {\n        return 30;\n\
    \    }\n    if n < 100000000000000000000000000000 {\n        return 31;\n    }\n\
    \    if n < 1000000000000000000000000000000 {\n        return 32;\n    }\n   \
    \ if n < 10000000000000000000000000000000 {\n        return 33;\n    }\n    if\
    \ n < 100000000000000000000000000000000 {\n        return 34;\n    }\n    if n\
    \ < 1000000000000000000000000000000000 {\n        return 35;\n    }\n    if n\
    \ < 10000000000000000000000000000000000 {\n        return 36;\n    }\n    if n\
    \ < 100000000000000000000000000000000000 {\n        return 37;\n    }\n    if\
    \ n < 1000000000000000000000000000000000000 {\n        return 38;\n    }\n   \
    \ if n < 10000000000000000000000000000000000000 {\n        return 39;\n    }\n\
    \    if n < 100000000000000000000000000000000000000 {\n        return 40;\n  \
    \  }\n    if n < 1000000000000000000000000000000000000000 {\n        return 41;\n\
    \    }\n    if n < ", "    if n < 10 {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut last_digit = n % 10;\n    while n > 0 {\n        if\
    \ last_digit == 1 {\n            count += 1;\n        }\n        last_digit =\
    \ n % 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n\
    \    let mut count = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n      \
    \      count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match\
    \ n {\n        1 => 1,\n        _ => n,\n    }", "    match n {\n        0 =>\
    \ 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    match n {\n        0 => 0,\n  \
    \      _ => 1 + starts_one_ends(n / 10),\n    }", "    debug_assert!(n > 0);\n\
    \    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n        count +=\
    \ 1;\n    }\n    count", "    if n < 0 {\n        panic!(\"starts_one_ends called\
    \ with negative n\");\n    }\n    let mut count = 0;\n    let mut i = 1;\n   \
    \ while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n            count\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    count",
  '    n / 10 + 1', "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 9);\n    let mut count = 0;\n    while n != 0\
    \ {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n /=\
    \ 10;\n    }\n    count", "    let mut count = 0;\n    while n != 1 {\n      \
    \  if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n  \
    \  }\n    count", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i / 10 == 1 {\n\
    \            i += 1;\n        } else {\n            i += 2;\n        }\n     \
    \   count += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _\
    \ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 1);\n    let mut count = 0;\n    while n > 0 {\n        count += n /\
    \ 10;\n        n /= 10;\n    }\n    count", "    if n < 1 {\n        return 0;\n\
    \    }\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  if n < 0 {\n        panic!(\"starts_one_ends: n must be positive\");\n    }\n\
    \    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n      \
    \      count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n      \
    \  count += 1;\n    }\n    count", "    if n < 10 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i\
    \ / 10 == 1 {\n            i += 1;\n        } else {\n            i += 2;\n  \
    \      }\n        count += 1;\n    }\n    count", "    match n {\n        0 =>\
    \ 0,\n        1 => 1,\n        _ => n,\n    }", "    debug_assert!(n > 0);\n \
    \   let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n        \
    \    count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n\
    \ {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n {\n    \
    \    0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n      \
    \  count += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _\
    \ => 1 + starts_one_ends(n - 1),\n    }", "    match n {\n        0 => 0,\n  \
    \      _ => 1,\n    }", "    if n < 10 {\n        return 1;\n    }\n    if n %\
    \ 10 == 1 {\n        return starts_one_ends(n / 10) + 1;\n    }\n    if n % 10\
    \ == 0 {\n        return starts_one_ends(n / 10) + 1;\n    }\n    if n % 10 ==\
    \ 2 {\n        return starts_one_ends(n / 10) + 2;\n    }\n    if n % 10 == 3\
    \ {\n        return starts_one_ends(n / 10) + 3;\n    }\n    if n % 10 == 4 {\n\
    \        return starts_one_ends(n / 10) + 4;\n    }\n    if n % 10 == 5 {\n  \
    \      return starts_one_ends(n / 10) + 5;\n    }\n    if n % 10 == 6 {\n    \
    \    return starts_one_ends(n / 10) + 6;\n    }\n    if n % 10 == 7 {\n      \
    \  return starts_one_ends(n / 10) + 7;\n    }\n    if n % 10 == 8 {\n        return\
    \ starts_one_ends(n / 10) + 8;\n    }\n    if n % 10 == 9 {\n        return starts_one_ends(n\
    \ / 10) + 9;\n    }\n    if n % 10 == 10 {\n        return starts_one_ends(n /\
    \ 10) + 10;\n    }\n    if n % 10 == 11 {\n        return starts_one_ends(n /\
    \ 10) + 11;\n    }\n    if n % 10 == 12 {\n        return starts_one_ends(n /\
    \ 10) + 12;\n    }\n    if n % 10 == 13 {\n        return starts_one_ends(n /\
    \ 10) + 13;\n    }\n    if n % 10 == 14 {\n        return starts_one_ends(n /\
    \ 10) + 14;\n    }\n    if n % 10 == 15 {\n        return starts_one_ends(n /\
    \ 10) + 15;\n    }\n    if n % 10 == 16 {\n        return starts_one_ends(n /\
    \ 10) + 16;\n    }\n    if n % 10 == 17 {\n        return starts_one_ends(n /\
    \ 10) + 17;\n    }\n    if n % 10 == 18 {\n        return starts_one_ends(n /\
    \ 10) + 18;\n    }\n    if n % 10 == 19 {\n        return starts_one_ends(n /\
    \ 10) + 19;\n    }\n    if n % 10 == 20 {\n        return starts_one_ends(n /\
    \ 10) + 20;\n    }\n    if n % 10 == 21 {\n        return starts_one_ends(n /\
    \ 10) + 21;\n    }\n    if n % 10 == 22 {\n        return starts_one_ends(n /\
    \ 10) + 22;\n    }\n    if n % 10 == 23 {\n        return starts_one_ends(n /\
    \ 10) + 23;\n    }\n    if n % 10 == 24", "    match n {\n        0 => 0,\n  \
    \      _ => 1 + starts_one_ends(n - 1),\n    }", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    let mut count = 0;\n    while n\
    \ > 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n      \
    \  n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n        _ =>\
    \ 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n > 0);\n    let mut\
    \ count = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    if n < 10 {\n  \
    \      return 0;\n    }\n    if n % 10 == 1 {\n        return 1;\n    }\n    if\
    \ n % 10 == 0 {\n        return 1 + starts_one_ends(n / 10);\n    }\n    return\
    \ 1 + starts_one_ends(n / 10) + starts_one_ends(n % 10);", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    if n % 2 == 0 {\n        return starts_one_ends(n / 2) + 1;\n    }\n\
    \    if n % 3 == 0 {\n        return starts_one_ends(n / 3) + 1;\n    }\n    if\
    \ n % 5 == 0 {\n        return starts_one_ends(n / 5) + 1;\n    }\n    if n %\
    \ 7 == 0 {\n        return starts_one_ends(n / 7) + 1;\n    }\n    if n % 11 ==\
    \ 0 {\n        return starts_one_ends(n / 11) + 1;\n    }\n    if n % 13 == 0\
    \ {\n        return starts_one_ends(n / 13) + 1;\n    }\n    if n % 17 == 0 {\n\
    \        return starts_one_ends(n / 17) + 1;\n    }\n    if n % 19 == 0 {\n  \
    \      return starts_one_ends(n / 19) + 1;\n    }\n    if n % 23 == 0 {\n    \
    \    return starts_one_ends(n / 23) + 1;\n    }\n    if n % 29 == 0 {\n      \
    \  return starts_one_ends(n / 29) + 1;\n    }\n    if n % 37 == 0 {\n        return\
    \ starts_one_ends(n / 37) + 1;\n    }\n    if n % 41 == 0 {\n        return starts_one_ends(n\
    \ / 41) + 1;\n    }\n    if n % 43 == 0 {\n        return starts_one_ends(n /\
    \ 43) + 1;\n    }\n    if n % 47 == 0 {\n        return starts_one_ends(n / 47)\
    \ + 1;\n    }\n    if n % 53 == 0 {\n        return starts_one_ends(n / 53) +\
    \ 1;\n    }\n    if n % 59 == 0 {\n        return starts_one_ends(n / 59) + 1;\n\
    \    }\n    if n % 61 == 0 {\n        return starts_one_ends(n / 61) + 1;\n  \
    \  }\n    if n % 67 == 0 {\n        return starts_one_ends(n / 67) + 1;\n    }\n\
    \    if n % 71 == 0 {\n        return starts_one_ends(n / 71) + 1;\n    }\n  \
    \  if n % 73 == 0 {\n        return starts_one_ends(n / 73) + 1;\n    }\n    if\
    \ n % 79 == 0 {\n        return starts_one_ends(n / 79) + 1;\n    }\n    if n\
    \ % 83 == 0 {\n        return starts_one_ends(n / 83) + 1;\n    }\n    if n %\
    \ 89 == 0 {\n        return starts_one_ends(n / 89) + 1;\n    }\n    if n % 97\
    \ == 0 {\n        return starts_one_ends(n / 97) + 1;\n    }\n    if n % 101 ==\
    \ 0 {\n        return starts_one_ends(n / 101) + 1;\n", "    debug_assert!(n >\
    \ 0);\n    debug_assert!(n % 10 == 1);\n    let mut count = 0;\n    while n !=\
    \ 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n\
    \ /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0 {\n    \
    \    if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n < 10 {\n        return 1;\n    }\n    if n <\
    \ 100 {\n        return 2;\n    }\n    if n < 1000 {\n        return 3;\n    }\n\
    \    if n < 10000 {\n        return 4;\n    }\n    if n < 100000 {\n        return\
    \ 5;\n    }\n    if n < 1000000 {\n        return 6;\n    }\n    if n < 10000000\
    \ {\n        return 7;\n    }\n    if n < 100000000 {\n        return 8;\n   \
    \ }\n    if n < 1000000000 {\n        return 9;\n    }\n    if n < 10000000000\
    \ {\n        return 10;\n    }\n    if n < 100000000000 {\n        return 11;\n\
    \    }\n    if n < 1000000000000 {\n        return 12;\n    }\n    if n < 10000000000000\
    \ {\n        return 13;\n    }\n    if n < 100000000000000 {\n        return 14;\n\
    \    }\n    if n < 1000000000000000 {\n        return 15;\n    }\n    if n < 10000000000000000\
    \ {\n        return 16;\n    }\n    if n < 100000000000000000 {\n        return\
    \ 17;\n    }\n    if n < 100000000000000001 {\n        return 18;\n    }\n   \
    \ if n < 1000000000000000010 {\n        return 19;\n    }\n    if n < 10000000000000000100\
    \ {\n        return 20;\n    }\n    if n < 100000000000000001000 {\n        return\
    \ 21;\n    }\n    if n < 1000000000000000010000 {\n        return 22;\n    }\n\
    \    if n < 10000000000000000100000 {\n        return 23;\n    }\n    if n < 100000000000000001000000\
    \ {\n        return 24;\n    }\n    if n < 1000000000000000010000000 {\n     \
    \   return 25;\n    }\n    if n < 10000000000000000100000000 {\n        return\
    \ 26;\n    }\n    if n < 100000000000000001000000000 {\n        return 27;\n \
    \   }\n    if n < 1000000000000000010000000000 {\n        return 28;\n    }\n\
    \    if n < 10000000000000000100000000000 {\n        return 29;\n    }\n    if\
    \ n < 100000000000000001000000000000 {\n        return 30;\n    }\n    if n <\
    \ 1000000000000000010000000000000 {\n        return 31;\n    }\n    if n < 10000000000000000100000000000000\
    \ {\n        return 32;\n    }\n    if n < 100000000000000001000000000000000 {\n\
    \        return 33;\n    }\n    if n < 1000000000000000010000000000000000 {\n\
    \        return 34;\n    }\n    if n < 10000000000000000100000000000000000 {\n\
    \        return 35;\n    }\n    if n < 100000000000000001000000000000000000 {\n\
    \        return 36;\n    }\n    if n < 1000000000000000010000000000000000000 {\n\
    \        return 37;\n    }\n    if n < 10000000000000000100", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    match n {\n        1 => 1,\n        _ => n * (n - 1) / 2,\n    }", "    match\
    \ n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "  \
    \  match n {\n        0 => 0,\n        _ => if n % 10 == 1 {\n            n /\
    \ 10 + 1\n        } else {\n            n / 10 + 1\n        } * starts_one_ends(n\
    \ / 10)\n    }", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    if n ==\
    \ 1 {\n        return 1;\n    }\n    let mut count = 0;\n    for d in 1..=n {\n\
    \        if n % d == 0 {\n            count += 1;\n        }\n    }\n    count",
  "    if n < 0 {\n        panic!(\"starts_one_ends: n must be positive\");\n    }\n\
    \    if n == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut\
    \ last = 1;\n    while n > 0 {\n        if n % 10 == 1 {\n            count +=\
    \ 1;\n        }\n        n /= 10;\n    }\n    if n == 0 {\n        count += 1;\n\
    \    }\n    count += last;\n    count", "    match n {\n        0 => 0,\n    \
    \    _ => 1 + starts_one_ends(n - 1),\n    }", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_div(10).unwrap()',
  "    match n {\n        0 => 0,\n        _ => 1,\n    }", "    if n < 0 {\n    \
    \    panic!(\"starts_one_ends called with negative n\");\n    }\n    let mut count\
    \ = 0;\n    while n != 0 {\n        n /= 10;\n        count += 1;\n    }\n   \
    \ count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n !=\
    \ 1 {\n        n /= 10;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n != 1 {\n        n /= 10;\n      \
    \  count += 1;\n    }\n    count", "    let mut count = 0;\n    while n != 0 {\n\
    \        if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n\
    \    }\n    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n > 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "  \
    \  if n == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    let mut\
    \ i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count", "   \
    \ let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n          \
    \  count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n {\n\
    \        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n    \
    \    if n % i == 0 {\n            count += 1;\n            i += 1;\n        }\n\
    \        i += 1;\n    }\n    count", "    if n == 0 {\n        return 0;\n   \
    \ }\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if\
    \ i / 10 == 1 {\n            i += 1;\n            count += 1;\n        }\n   \
    \     i += 1;\n    }\n    count", "    match n {\n        0 => 0,\n        _ =>\
    \ if n % 10 == 1 {\n            n / 10 + 1\n        } else {\n            n -\
    \ 1\n        }\n    }", "    let mut count = 0;\n    while n != 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ / 10),\n    }", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut last = 1;\n    while n > 0 {\n        if n % 10 == 1\
    \ {\n            count += 1;\n        }\n        if n % 10 == 0 {\n          \
    \  count += 1;\n            last = last * 10;\n        }\n        n /= 10;\n \
    \   }\n    count += last == 1;\n    count", "    match n {\n        0 => 0,\n\
    \        _ => 1 + starts_one_ends(n - 1),\n    }", "    if n == 0 {\n        return\
    \ 0;\n    }\n    if n == 1 {\n        return 1;\n    }\n    if n % 2 == 0 {\n\
    \        return starts_one_ends(n / 2) + 1;\n    }\n    return starts_one_ends(n\
    \ / 2) + 1;", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n        n\
    \ /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n          \
    \  count += 1;\n        }\n        i += 1;\n    }\n    count", "    match n {\n\
    \        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    let mut\
    \ count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count +=\
    \ 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n\
    \    debug_assert!(n % 10 == 1);\n    let mut count = 0;\n    for i in 1..n {\n\
    \        if i % 10 == 1 {\n            count += 1;\n        }\n    }\n    count",
  "    match n {\n        0 => 0,\n        1 => 1,\n        _ => n,\n    }", "   \
    \ debug_assert!(n > 0);\n    debug_assert!(n % 10 == 1);\n    (n / 10).floor()\
    \ as isize", "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n !=\
    \ 1 {\n        n /= 10;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n   \
    \     if i % 10 == 1 {\n            i += 1;\n            count += 1;\n       \
    \ } else {\n            i += 1;\n        }\n    }\n    count", '    n / 10 + 1',
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    let mut count = 0;\n    while n > 0 {\n        count += n /\
    \ 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    let\
    \ mut n1 = n - 1;\n    let mut n2 = n - 1;\n    while n1 != 0 || n2 != 0 {\n \
    \       if n1 == 0 {\n            n1 += 1;\n        } else if n2 == 0 {\n    \
    \        n2 += 1;\n        } else {\n            n1 -= 1;\n            n2 -= 1;\n\
    \        }\n    }\n    n", "    debug_assert!(n >= 0);\n    let mut count = 0;\n\
    \    while n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n     \
    \   }\n        n /= 10;\n    }\n    count", "    match n {\n        0 => 0,\n\
    \        1 => 1,\n        _ => n,\n    }", "    debug_assert!(n >= 0);\n    let\
    \ mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    let mut count =\
    \ 0;\n    while n >= 10 {\n        count += n % 10 == 1;\n        n /= 10;\n \
    \   }\n    count", "    if n < 0 {\n        panic!(\"starts_one_ends called with\
    \ negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n    let mut\
    \ count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n\
    \            count += 1;\n        }\n        i += 1;\n    }\n    count", "   \
    \ debug_assert!(n >= 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    debug_assert!(n > 0);\n    let mut count = 0;\n    while n > 0 {\n        if\
    \ n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n\
    \    count", "    let mut count = 0;\n    while n > 0 {\n        if n % 10 ==\
    \ 1 {\n            count += 1;\n        }\n        n /= 10;\n    }\n    count",
  "    if n < 1 {\n        return 0;\n    }\n    let mut count = 0;\n    for _ in\
    \ 0..n {\n        if n % 10 == 1 {\n            count += 1;\n        }\n     \
    \   n /= 10;\n    }\n    count", "    if n < 0 {\n        panic!(\"starts_one_ends\
    \ called with negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut i = 1;\n    while i <= n {\n        if i\
    \ % 10 == 1 {\n            count += 1;\n        }\n        i += 1;\n    }\n  \
    \  count", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n >\
    \ 0 {\n        count += n / 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n    let mut i =\
    \ 1;\n    while i <= n {\n        if i % 10 == 1 {\n            i += 1;\n    \
    \        count += 1;\n        }\n        i += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 10);\n    let mut n = 0;\n    while n <= 10 {\n\
    \        if n % 10 == 1 {\n            n += 1;\n        } else {\n           \
    \ n += 1;\n        }\n    }\n    n", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 10);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n\
    \        n -= n % 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 10);\n    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  if n < 10 || n > 100 {\n        return 0;\n    }\n    let mut count = 0;\n\
    \    let mut i = 1;\n    while i <= n {\n        if i % 10 == 1 {\n          \
    \  i += 1;\n            count += 1;\n        }\n        i += 1;\n    }\n    count",
  "    if n < 0 {\n        panic!(\"starts_one_ends: n must be positive\");\n    }\n\
    \    if n == 0 {\n        return 0;\n    }\n    let mut count = 0;\n    while\
    \ n != 1 {\n        n >>= 1;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n        n\
    \ /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0 {\n    \
    \    count += n / 10;\n        n /= 10;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_div(10).unwrap().checked_sub(1isize).unwrap()',
  "    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", '    n / 10 +
    1', "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while n != 1 {\n\
    \        n /= 10;\n        count += 1;\n    }\n    count", "    debug_assert!(n\
    \ >= 0);\n    debug_assert!(n <= 10);\n    let mut count = 0;\n    while n !=\
    \ 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n\
    \ /= 10;\n    }\n    count", "    if n < 0 {\n        panic!(\"starts_one_ends\
    \ called with negative n\");\n    }\n    if n == 0 {\n        return 0;\n    }\n\
    \    let mut count = 0;\n    let mut last_digit = n % 10;\n    while n > 0 {\n\
    \        if last_digit == 1 {\n            count += 1;\n        }\n        last_digit\
    \ = n % 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n\
    \    let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n       \
    \     count += 1;\n        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n\
    \ > 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n\
    \        n /= 10;\n    }\n    count", "    let mut count = 0;\n    while n > 0\
    \ {\n        if n % 10 == 1 {\n            count += 1;\n        }\n        n /=\
    \ 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n <=\
    \ 9);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  match n {\n        1 => 1,\n        _ => n,\n    }", "    debug_assert!(n >\
    \ 0);\n    let mut count = 0;\n    while n != 1 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    if n == 0 {\n        return 0;\n    }\n    if n == 1 {\n        return 1;\n\
    \    }\n    let mut count = 0;\n    for i in 1..=n {\n        if i / 10 == 1 {\n\
    \            count += 1;\n        }\n    }\n    count", "    debug_assert!(n >\
    \ 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n / 10;\n \
    \       n /= 10;\n    }\n    count", '    n.checked_mul(10).unwrap().checked_add((n
    - 1).checked_mul(10).unwrap()).unwrap()', "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 0);\n    let mut count = 0;\n    while n > 0 {\n        count += n /\
    \ 10;\n        n /= 10;\n    }\n    count", "    debug_assert!(n > 0);\n    let\
    \ mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count\
    \ += 1;\n        }\n        n /= 10;\n    }\n    count", "    if n < 10 {\n  \
    \      return n;\n    }\n    if n % 10 == 1 {\n        return starts_one_ends(n\
    \ / 10) + 1;\n    }\n    if n % 10 == 0 {\n        return starts_one_ends(n /\
    \ 10) + 1;\n    }\n    if n % 10 == 2 {\n        return starts_one_ends(n / 10)\
    \ + 2;\n    }\n    if n % 10 == 3 {\n        return starts_one_ends(n / 10) +\
    \ 3;\n    }\n    if n % 10 == 4 {\n        return starts_one_ends(n / 10) + 4;\n\
    \    }\n    if n % 10 == 5 {\n        return starts_one_ends(n / 10) + 5;\n  \
    \  }\n    if n % 10 == 6 {\n        return starts_one_ends(n / 10) + 6;\n    }\n\
    \    if n % 10 == 7 {\n        return starts_one_ends(n / 10) + 7;\n    }\n  \
    \  if n % 10 == 8 {\n        return starts_one_ends(n / 10) + 8;\n    }\n    if\
    \ n % 10 == 9 {\n        return starts_one_ends(n / 10) + 9;\n    }\n    if n\
    \ % 10 == 10 {\n        return starts_one_ends(n / 10) + 10;\n    }\n    if n\
    \ % 10 == 11 {\n        return starts_one_ends(n / 10) + 11;\n    }\n    if n\
    \ % 10 == 12 {\n        return starts_one_ends(n / 10) + 12;\n    }\n    if n\
    \ % 10 == 13 {\n        return starts_one_ends(n / 10) + 13;\n    }\n    if n\
    \ % 10 == 14 {\n        return starts_one_ends(n / 10) + 14;\n    }\n    if n\
    \ % 10 == 15 {\n        return starts_one_ends(n / 10) + 15;\n    }\n    if n\
    \ % 10 == 16 {\n        return starts_one_ends(n / 10) + 16;\n    }\n    if n\
    \ % 10 == 17 {\n        return starts_one_ends(n / 10) + 17;\n    }\n    if n\
    \ % 10 == 18 {\n        return starts_one_ends(n / 10) + 18;\n    }\n    if n\
    \ % 10 == 19 {\n        return starts_one_ends(n / 10) + 19;\n    }\n    if n\
    \ % 10 == 20 {\n        return starts_one_ends(n / 10) + 20;\n    }\n    if n\
    \ % 10 == 21 {\n        return starts_one_ends(n / 10) + 21;\n    }\n    if n\
    \ % 10 == 22 {\n        return starts_one_ends(n / 10) + 22;\n    }\n    if n\
    \ % 10 == 23 {\n        return starts_one_ends(n / 10) + 23;\n    }\n    if n\
    \ % 10 == 24", "    debug_assert!(n >= 0);\n    let mut count = 0;\n    while\
    \ n != 0 {\n        if n % 10 == 1 {\n            count += 1;\n        }\n   \
    \     n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n    debug_assert!(n\
    \ <= 9);\n    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n\
    \            count += 1;\n        }\n        n /= 10;\n    }\n    count", "  \
    \  let mut count = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n         \
    \   count += 1;\n        }\n        n /= 10;\n    }\n    count", "    match n\
    \ {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    match\
    \ n {\n        0 => 0,\n        _ => 1,\n    }", "    match n {\n        1 =>\
    \ 1,\n        _ => n,\n    }", "    debug_assert!(n >= 0);\n    let mut count\
    \ = 0;\n    while n > 0 {\n        if n % 10 == 1 {\n            count += 1;\n\
    \        }\n        n /= 10;\n    }\n    count", "    debug_assert!(n >= 0);\n\
    \    debug_assert!(n <= 10);\n    let mut count = 0;\n    while n > 0 {\n    \
    \    count += n % 10 == 1;\n        n /= 10;\n    }\n    count", "    if n < 0\
    \ {\n        0\n    } else {\n        (1..=n).filter(|x| x % 10 == 1).count()\n\
    \    }", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n -\
    \ 1),\n    }", "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n\
    \ - 1),\n    }", '    n / 10 + 1', "    debug_assert!(n > 0);\n    debug_assert!(n\
    \ % 10 == 1);\n    debug_assert!(n >= 1);\n    let mut n = 0;\n    while n <=\
    \ n / 10 {\n        if n % 10 == 1 {\n            n += 1;\n        } else {\n\
    \            n += 1;\n        }\n    }\n    n", "    match n {\n        0 => 0,\n\
    \        1 => 1,\n        _ => 1 + starts_one_ends(n - 1),\n    }", "    match\
    \ n {\n        0 => 0,\n        _ => if n % 10 == 1 {\n            1\n       \
    \ } else {\n            1 + starts_one_ends(n / 10)\n        }\n    }", "    if\
    \ n < 10 {\n        return 1;\n    }\n    if n < 100 {\n        return 2;\n  \
    \  }\n    if n < 1000 {\n        return 3;\n    }\n    if n < 10000 {\n      \
    \  return 4;\n    }\n    if n < 100000 {\n        return 5;\n    }\n    if n <\
    \ 1000000 {\n        return 6;\n    }\n    if n < 10000000 {\n        return 7;\n\
    \    }\n    if n < 100000000 {\n        return 8;\n    }\n    if n < 1000000000\
    \ {\n        return 9;\n    }\n    if n < 10000000000 {\n        return 10;\n\
    \    }\n    if n < 100000000000 {\n        return 11;\n    }\n    if n < 1000000000000\
    \ {\n        return 12;\n    }\n    if n < 10000000000000 {\n        return 13;\n\
    \    }\n    if n < 100000000000000 {\n        return 14;\n    }\n    if n < 1000000000000000\
    \ {\n        return 15;\n    }\n    if n < 10000000000000000 {\n        return\
    \ 16;\n    }\n    if n < 100000000000000000 {\n        return 17;\n    }\n   \
    \ if n < 1000000000000000000 {\n        return 18;\n    }\n    if n < 10000000000000000000\
    \ {\n        return 19;\n    }\n    if n < 1000000000000000000 {\n        return\
    \ 20;\n    }\n    if n < 10000000000000000000 {\n        return 21;\n    }\n \
    \   if n < 100000000000000000000 {\n        return 22;\n    }\n    if n < 1000000000000000000000\
    \ {\n        return 23;\n    }\n    if n < 10000000000000000000000 {\n       \
    \ return 24;\n    }\n    if n < 100000000000000000000000 {\n        return 25;\n\
    \    }\n    if n < 1000000000000000000000000 {\n        return 26;\n    }\n  \
    \  if n < 10000000000000000000000000 {\n        return 27;\n    }\n    if n <\
    \ 100000000000000000000000000 {\n        return 28;\n    }\n    if n < 1000000000000000000000000000\
    \ {\n        return 29;\n    }\n    if n < 10000000000000000000000000000 {\n \
    \       return 30;\n    }\n    if n < 100000000000000000000000000000 {\n     \
    \   return 31;\n    }\n    if n < 1000000000000000000000000000000 {\n        return\
    \ 32;\n    }\n    if n < 10000000000000000000000000000000 {\n        return 33;\n\
    \    }\n    if n < 100000000000000000000000000000000 {\n        return 34;\n \
    \   }\n    if n < 1000000000000000000000000000000000 {\n        return 35;\n \
    \   }\n    if n < 10000000000000000000000000000000000 {\n        return 36;\n\
    \    }\n    if n < 100000000000000000000000000000000000 {\n        return 37;\n\
    \    }\n    if n < 1000000000000000000000000000000000000 {\n        return 38;\n\
    \    }\n    if n < 10000000000000000000000000000000000000 {\n        return 39;\n\
    \    }\n    if n < 100000000000000000000000000000000000000 {\n        return 40;\n\
    \    }\n    if n < 1000000000000000000000000000000000000000 {\n        return\
    \ 41;\n    }\n    if n < ", "    match n {\n        0 => 0,\n        1 => 1,\n\
    \        _ => n,\n    }", "    let mut count = 0;\n    while n > 0 {\n       \
    \ if n % 10 == 1 {\n            count += 1;\n        }\n        n /= 10;\n   \
    \ }\n    count", "    if n < 10 { return n }\n    if n < 100 { return 1 }\n  \
    \  if n < 1000 { return 2 }\n    if n < 10000 { return 3 }\n    if n < 100000\
    \ { return 4 }\n    if n < 1000000 { return 5 }\n    if n < 10000000 { return\
    \ 6 }\n    if n < 100000000 { return 7 }\n    if n < 1000000000 { return 8 }\n\
    \    if n < 10000000000 { return 9 }\n    if n < 100000000000 { return 10 }\n\
    \    if n < 1000000000000 { return 11 }\n    if n < 10000000000000 { return 12\
    \ }\n    if n < 100000000000000 { return 13 }\n    if n < 1000000000000000 { return\
    \ 14 }\n    if n < 10000000000000000 { return 15 }\n    if n < 100000000000000000\
    \ { return 16 }\n    if n < 1000000000000000000 { return 17 }\n    if n < 10000000000000000000\
    \ { return 18 }\n    if n < 100000000000000000000 { return 19 }\n    if n < 1000000000000000000000\
    \ { return 20 }\n    if n < 10000000000000000000000 { return 21 }\n    if n <\
    \ 100000000000000000000000 { return 22 }\n    if n < 1000000000000000000000000\
    \ { return 23 }\n    if n < 10000000000000000000000000 { return 24 }\n    if n\
    \ < 100000000000000000000000000 { return 25 }\n    if n < 1000000000000000000000000000\
    \ { return 26 }\n    if n < 10000000000000000000000000000 { return 27 }\n    if\
    \ n < 100000000000000000000000000000 { return 28 }\n    if n < 1000000000000000000000000000000\
    \ { return 29 }\n    if n < 10000000000000000000000000000000 { return 30 }\n \
    \   if n < 100000000000000000000000000000000 { return 31 }\n    if n < 1000000000000000000000000000000000\
    \ { return 32 }\n    if n < 10000000000000000000000000000000000 { return 33 }\n\
    \    if n < 100000000000000000000000000000000000 { return 34 }\n    if n < 1000000000000000000000000000000000000\
    \ { return 35 }\n    if n < 10000000000000000000000000000000000000 { return 36\
    \ }\n    if n < 100000000000000000000000000000000000000 { return 37 }\n    if\
    \ n < 1000000000000000000000000000000000000000 { return 38 }\n    if n < 10000000000000000000000000000000000000000\
    \ { return 39 }\n    if n < 100000000000000000000000000000000000000000 { return\
    \ 40 }\n    if n < 1000000000000000000000000000000000000000000 { return 41 }\n\
    \    if n < 10000000000000000000000000000000000000000000 { return 42 }\n    if\
    \ n < 100000000000000000000000000000000000000000000 { return 43 }\n    if n <\
    \ 1000000000000000000000000000000000000000000000 { return 44 }\n    if n < 1000000000000000000000000000000000000000\
    \ { return 45 }\n    if n < 10000000000000000000000000000000000000000 { return\
    \ 46 }\n    if n < 100000000000000000000000000000000000000000 { return 47 }\n\
    \    if n < 1000000000000000000000000000000000000000000 { return 48 }\n    if\
    \ n < 10000000000000000000000000000000000000000000 { return 49 }\n    if n < 10000000000000000000000000000000000",
  "    match n {\n        0 => 0,\n        _ => 1 + starts_one_ends(n - 1),\n    }",
  "    let mut count = 0;\n    while n != 0 {\n        if n % 10 == 1 {\n        \
    \    count += 1;\n        }\n        n /= 10;\n    }\n    count", "    if n <\
    \ 0 {\n        panic!(\"starts_one_ends called with negative n\");\n    }\n  \
    \  if n < 10 {\n        return 1;\n    }\n    if n < 100 {\n        return 2;\n\
    \    }\n    if n < 1000 {\n        return 3;\n    }\n    if n < 10000 {\n    \
    \    return 4;\n    }\n    if n < 100000 {\n        return 5;\n    }\n    if n\
    \ < 1000000 {\n        return 6;\n    }\n    if n < 10000000 {\n        return\
    \ 7;\n    }\n    if n < 100000000 {\n        return 8;\n    }\n    if n < 1000000000\
    \ {\n        return 9;\n    }\n    if n < 10000000000 {\n        return 10;\n\
    \    }\n    if n < 100000000000 {\n        return 11;\n    }\n    if n < 1000000000000\
    \ {\n        return 12;\n    }\n    if n < 10000000000000 {\n        return 13;\n\
    \    }\n    if n < 100000000000000 {\n        return 14;\n    }\n    if n < 1000000000000000\
    \ {\n        return 15;\n    }\n    if n < 10000000000000000 {\n        return\
    \ 16;\n    }\n    if n < 100000000000000000 {\n        return 17;\n    }\n   \
    \ if n < 100000000000000001 {\n        return 18;\n    }\n    if n < 1000000000000000010\
    \ {\n        return 19;\n    }\n    if n < 10000000000000000100 {\n        return\
    \ 20;\n    }\n    if n < 100000000000000001000 {\n        return 21;\n    }\n\
    \    if n < 1000000000000000010000 {\n        return 22;\n    }\n    if n < 10000000000000000100000\
    \ {\n        return 23;\n    }\n    if n < 100000000000000001000000 {\n      \
    \  return 24;\n    }\n    if n < 1000000000000000010000000 {\n        return 25;\n\
    \    }\n    if n < 10000000000000000100000000 {\n        return 26;\n    }\n \
    \   if n < 100000000000000001000000000 {\n        return 27;\n    }\n    if n\
    \ < 1000000000000000010000000000 {\n        return 28;\n    }\n    if n < 10000000000000000100000000000\
    \ {\n        return 29;\n    }\n    if n < 100000000000000001000000000000 {\n\
    \        return 30;\n    }\n    if n < 1000000000000000010000000000000 {\n   \
    \     return 31;\n    }\n    if n < 10000000000000000100000000000000 {\n     \
    \   return 32;\n    }\n    if n < 100000000000000001000000000000000 {\n      \
    \  return 33;\n    }\n    if n < 1000000000000000010000000000000000 {\n      \
    \  return 34;\n    }\n    if n < 10000000000000000100000000000000000 {\n     \
    \   return 35;\n    }\n    if n < 100000000000000001000000000000000000 {\n   \
    \     return 36;\n    }\n    if n < 1000000000000000010000000000000000000 {\n\
    \        return 37;\n    }\n    if n < 10000000000000000100"]
stop_tokens:
- "\n}"
