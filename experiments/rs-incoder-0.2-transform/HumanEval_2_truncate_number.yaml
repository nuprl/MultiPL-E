name: HumanEval_2_truncate_number
language: rs
prompt: "/// Given a positive floating point number, it can be decomposed into\n///\
  \ and integer part (largest integer smaller than given number) and decimals\n///\
  \ (leftover part always smaller than 1).\n/// Return the decimal part of the number.\n\
  /// >>> truncate_number(3.5)\n/// 0.5\nfn truncate_number(number: f64) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = truncate_number;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut result = 0.0;\n    let mut remainder = 0.0;\n    let mut\
    \ exponent = number.is_negative() ? 1 : 0;\n    while number > 0.0 {\n       \
    \ remainder += number % 10.0;\n        number /= 10.0;\n        exponent++;\n\
    \    }\n    if remainder > 0.0 {\n        result += remainder;\n    }\n    result\
    \ * 10.0 ** exponent", "    let mut result = number.trunc();\n    if result <\
    \ number {\n        result = result - 1.0;\n    }\n    result", "    let mut result\
    \ = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent = number.f64::exp();\n\
    \    while exponent > 0 {\n        if exponent % 2 == 1 {\n            result\
    \ *= 10.0;\n        }\n        result += (number / 10.0);\n        remainder +=\
    \ number % 10.0;\n        number /= 10.0;\n        exponent = exponent / 2;\n\
    \    }\n    result + remainder", "    let mut decimal_part = 0.0;\n    let mut\
    \ integer_part = 0.0;\n    let mut leftover_part = 0.0;\n    let mut remainder\
    \ = number;\n    while remainder > 1.0 {\n        remainder -= 1.0;\n        leftover_part\
    \ += 1.0;\n    }\n    while remainder > 0.0 {\n        remainder -= 1.0;\n   \
    \     integer_part += 1.0;\n    }\n    integer_part += leftover_part;\n    decimal_part\
    \ = remainder;\n    integer_part * f64::from(f64::MAX)", "    let mut decimal_part\
    \ = 0.0;\n    let mut integer_part = 0.0;\n    let mut remainder = 0.0;\n    let\
    \ mut exponent = number.exponent();\n    while exponent > 0 {\n        remainder\
    \ += 1.0;\n        integer_part += remainder;\n        remainder /= 10.0;\n  \
    \      decimal_part += remainder;\n        exponent--;\n    }\n    integer_part\
    \ + decimal_part", "    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n\
    \    let mut exponent = number.f64::exp();\n    while exponent > 0.0 {\n     \
    \   remainder += 1.0;\n        decimal_part += remainder;\n        exponent -=\
    \ 1.0;\n    }\n    decimal_part + remainder", "    let mut result = 0.0;\n   \
    \ let mut exponent = 0;\n    let mut remainder = 0.0;\n    while number > 0.0\
    \ {\n        remainder += number % 10.0;\n        number /= 10.0;\n        exponent++;\n\
    \    }\n    if number > 0.0 {\n        remainder += number;\n    }\n    result\
    \ = remainder / 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *=\
    \ 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result\
    \ *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n  \
    \  result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n\
    \    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /=\
    \ 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result\
    \ /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n  \
    \  result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n\
    \    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *=\
    \ 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result\
    \ *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n  \
    \  result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n\
    \    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /=\
    \ 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result\
    \ /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n  \
    \  result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n\
    \    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result *=\
    \ 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n    result\
    \ *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;\n  \
    \  result *= 10.0;\n    result /= 10.0;\n    result *= 10.0;\n    result /= 10.0;",
  "    let mut integer = number.floor();\n    let mut decimal = number.fract();\n\
    \    if decimal > 0.5 {\n        integer = integer - 1;\n    }\n    decimal",
  "    let mut decimals = 0.0;\n    let mut remainder = 0.0;\n    let mut quotient\
    \ = number.floor();\n    while quotient > 0.0 {\n        remainder += quotient\
    \ % 10.0;\n        quotient /= 10.0;\n        decimals += remainder;\n    }\n\
    \    quotient + decimals", "    let mut truncated = 0.0;\n    let mut remainder\
    \ = 0.0;\n    let mut exponent = number.f64::exp();\n    let mut mantissa = number.f64::mantissa();\n\
    \    while exponent > 0.0 {\n        let mut next_mantissa = mantissa.clone();\n\
    \        let mut next_exponent = exponent;\n        while next_exponent > 0.0\
    \ {\n            next_mantissa *= 10.0;\n            next_exponent -= 1.0;\n \
    \       }\n        truncated = truncated.saturating_add(next_mantissa);\n    \
    \    remainder = remainder.saturating_add(next_exponent - 1.0);\n        mantissa\
    \ = next_mantissa;\n        exponent = next_exponent;\n    }\n    truncated.saturating_add(remainder).unwrap()",
  "    let mut integer = number.floor();\n    let mut decimal = number - integer;\n\
    \    if decimal < 1.0 {\n        integer = integer + 1;\n        decimal = decimal\
    \ - 1.0;\n    }\n    decimal", "    let mut result = number.trunc();\n    if result\
    \ < number {\n        result = result + 1;\n    }\n    result", "    let mut decimal_part\
    \ = 0.0;\n    let mut remainder = number;\n    while remainder > 1.0 {\n     \
    \   remainder -= 1.0;\n        decimal_part += 1.0;\n    }\n    remainder", " \
    \   let mut decimal_part = 0.0;\n    let mut integer_part = 0.0;\n    let mut\
    \ remainder = 0.0;\n\n    if number < 0.0 {\n        integer_part = -number;\n\
    \        remainder = -number;\n    } else {\n        integer_part = number;\n\
    \        remainder = number;\n    }\n\n    while remainder > 1.0 {\n        remainder\
    \ -= 1.0;\n        decimal_part += 1.0;\n    }\n\n    integer_part += remainder;\n\
    \    decimal_part += remainder;\n\n    integer_part", "    let mut integer = number.floor();\n\
    \    let mut decimal = number.fract();\n    if decimal < 1 {\n        integer\
    \ = integer - 1;\n        decimal = decimal + 1;\n    }\n    decimal", "    let\
    \ mut result = number.trunc();\n    if result < number {\n        result = result\
    \ - 1.0;\n    }\n    result", "    let mut decimal_part = 0.0;\n    let mut integer_part\
    \ = 0.0;\n    let mut leftover_part = 0.0;\n    let mut remainder = number;\n\
    \    while remainder > 0.0 {\n        let mut temp = remainder;\n        remainder\
    \ -= temp;\n        integer_part += temp;\n        leftover_part += temp;\n  \
    \      decimal_part += temp;\n    }\n    integer_part += leftover_part;\n    decimal_part\
    \ += integer_part;\n    decimal_part", "    let mut decimal_part = 0.0;\n    let\
    \ mut integer_part = 0.0;\n    let mut leftover_part = 0.0;\n\n    if number <\
    \ 0.0 {\n        leftover_part = number;\n        number = -number;\n    }\n\n\
    \    if number < 1.0 {\n        integer_part = number;\n        leftover_part\
    \ = 0.0;\n    } else {\n        let mut tmp = number;\n        integer_part =\
    \ 0.0;\n        leftover_part = 0.0;\n\n        while tmp > 1.0 {\n          \
    \  integer_part += 1.0;\n            tmp -= 1.0;\n        }\n\n        decimal_part\
    \ = tmp;\n    }\n\n    integer_part + leftover_part", "    let mut result = 0.0;\n\
    \    let mut remainder = 0.0;\n    let mut exponent = number.exponent();\n   \
    \ if exponent < 0 {\n        exponent = -exponent;\n    }\n    while exponent\
    \ > 0 {\n        remainder += 1.0;\n        result *= 10.0;\n        result -=\
    \ remainder;\n        result /= 10.0;\n        exponent--;\n    }\n    result",
  "    let mut decimal_part = 0.0;\n    let mut remainder = 0.0;\n    let mut exponent\
    \ = number.floor() as i32;\n    let mut remainder_exponent = exponent as i32;\n\
    \    let mut remainder_exponent = remainder_exponent as i32;\n    while remainder_exponent\
    \ > 0 {\n        remainder_exponent -= 1;\n        remainder += number.fract(remainder_exponent);\n\
    \    }\n    decimal_part += remainder;\n    decimal_part / (f64::powf(10.0, exponent)\
    \ as f64)"]
stop_tokens:
- "\n}"
