name: HumanEval_145_order_by_points
language: rs
prompt: "/// Write a function which sorts the given list of integers\n/// in ascending\
  \ order according to the sum of their digits.\n/// Note: if there are several items\
  \ with similar sum of their digits,\n/// order them based on their index in original\
  \ list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1, -11, -12])\n\
  /// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n/// Vec::<isize>::new()\n\
  fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n}\n"
completions: ["    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n   \
    \ for num in nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|num|\
    \ {\n        sum - num\n    });\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        index += 1;\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.digits().sum()\n    });\n    nums_copy", "    let mut nums_copy\
    \ = nums.clone();\n    let mut sum = 0;\n    let mut min_sum = 0;\n    let mut\
    \ min_idx = nums.len();\n    let mut max_sum = 0;\n    let mut max_idx = nums.len();\n\
    \    for i in 0..nums.len() {\n        sum += nums_copy[i];\n        if sum <\
    \ min_sum {\n            min_sum = sum;\n            min_idx = i;\n        }\n\
    \        if sum > max_sum {\n            max_sum = sum;\n            max_idx =\
    \ i;\n        }\n    }\n    nums_copy[min_idx] = nums[min_idx];\n    nums_copy[max_idx]\
    \ = nums[max_idx];\n    nums_copy", "    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    for &num in nums_sorted {\n        sum += num;\n  \
    \  }\n    nums_sorted.sort_by_key(|&num| {\n        sum - num\n    });\n    nums_sorted",
  "    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted", "    let\
    \ mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n   \
    \ let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index < nums_copy.len()\
    \ {\n        nums_sum += nums_copy[nums_index];\n        while nums_sum > 0 {\n\
    \            nums_sorted[nums_index] = nums_sum % 10;\n            nums_sum +=\
    \ nums_sum / 10;\n            nums_index += 1;\n        }\n    }\n    nums_sorted",
  "    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n      \
    \  let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n   \
    \     }\n        sum\n    });\n    nums_copy", "    let mut nums_copy = nums.clone();\n\
    \    let mut nums_sorted = nums.clone();\n    let mut nums_sum: isize = 0;\n \
    \   let mut nums_index: usize = 0;\n    while nums_index < nums.len() {\n    \
    \    nums_sum += nums_copy[nums_index];\n        if nums_sum < 0 {\n         \
    \   nums_sum = 0;\n            nums_index += 1;\n        }\n        if nums_sum\
    \ > 0 {\n            nums_sorted.swap(nums_index, nums_sum);\n            nums_index\
    \ += 1;\n        }\n    }\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut i\
    \ = 0;\n    while i < nums_copy.len() {\n        sum += nums_copy[i];\n      \
    \  if sum > 0 {\n            nums_sorted.swap(i, nums_sorted.len() - 1);\n   \
    \     }\n        i += 1;\n    }\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    nums_copy.sort_by_key(|x| {\n        let mut sum = 0;\n        for x in nums_copy\
    \ {\n            sum += x;\n        }\n        sum\n    });\n    nums_copy", " \
    \   let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut min_sum\
    \ = nums.iter().min().unwrap();\n    let mut max_sum = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min_by_key(|&x| x).unwrap();\n    let mut max_idx\
    \ = nums.iter().max_by_key(|&x| x).unwrap();\n\n    while let Some(idx) = min_idx\
    \ {\n        sum += nums_copy[idx];\n        if sum < min_sum {\n            min_sum\
    \ = sum;\n            min_idx = idx;\n        }\n        idx += 1;\n    }\n\n\
    \    while let Some(idx) = max_idx {\n        sum += nums_copy[idx];\n       \
    \ if sum > max_sum {\n            max_sum = sum;\n            max_idx = idx;\n\
    \        }\n        idx += 1;\n    }\n\n    if min_sum < max_sum {\n        nums_copy.swap_remove(min_idx);\n\
    \        nums_copy.swap_remove(max_idx);\n    }\n\n    nums_copy", "    let mut\
    \ sorted_nums = Vec::<isize>::new();\n    let mut sum_of_digits = nums.iter().map(|x|\
    \ x.digits()).sum::<isize>();\n    let mut index = 0;\n    while sum_of_digits\
    \ > 0 {\n        if sum_of_digits % 10 == 0 {\n            sorted_nums.push(nums[index]);\n\
    \            index += 1;\n        }\n        sum_of_digits /= 10;\n    }\n   \
    \ sorted_nums", "    let mut nums_copy = nums.clone();\n    let mut nums_sorted\
    \ = nums_copy.clone();\n    let mut nums_sorted_by_sum: Vec<isize> = Vec::new();\n\
    \    let mut nums_sorted_by_index: Vec<isize> = Vec::new();\n\n    while nums_sorted.len()\
    \ > 0 {\n        let mut min_sum: isize = 0;\n        let mut min_index: usize\
    \ = 0;\n        for &num in nums_sorted {\n            let sum = num % 10;\n \
    \           if sum < min_sum {\n                min_sum = sum;\n             \
    \   min_index = num;\n            }\n        }\n        nums_sorted_by_sum.push(min_sum);\n\
    \        nums_sorted_by_index.push(min_index);\n        nums_sorted.remove(min_index);\n\
    \    }\n\n    nums_sorted_by_sum", "    let mut nums_copy = nums.clone();\n  \
    \  nums_copy.sort_by_key(|x| {\n        let mut sum = 0;\n        for x in nums_copy\
    \ {\n            sum += x;\n        }\n        sum\n    });\n    nums_copy", " \
    \   let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n  \
    \  let mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n\
    \    while nums_sorted.len() > 0 {\n        sum += nums_sorted.pop();\n      \
    \  if sum < min_sum {\n            min_sum = sum;\n            min_idx = nums_sorted.len()\
    \ - 1;\n        }\n        if sum > max_sum {\n            max_sum = sum;\n  \
    \          max_idx = nums_sorted.len() - 1;\n        }\n    }\n    nums_sorted.sort_by_key(|&x|\
    \ {\n        let mut y = x;\n        y += 1;\n        y - x;\n    });\n    nums_sorted.reverse();\n\
    \    nums_sorted.push(min_idx);\n    nums_sorted.push(max_idx);\n    nums_sorted.reverse();\n\
    \    nums_sorted", "    let mut nums_sorted = nums.clone();\n    let mut sum =\
    \ 0;\n    for &num in nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|&num|\
    \ {\n        sum - num\n    });\n    nums_sorted", "    let mut nums_copy = nums.clone();\n\
    \    nums_copy.sort_by_key(|x| {\n        let mut sum = 0;\n        for x in nums_copy\
    \ {\n            sum += x;\n        }\n        sum\n    });\n    nums_copy", " \
    \   let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x;\n    });\n    nums_copy", "    nums.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for &d in &x {\n            sum += d as isize;\n\
    \        }\n        sum\n    });\n    nums", "    let mut nums_copy = nums.clone();\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \        index += 1;\n    }\n    nums_sorted"]
stop_tokens:
- "\n}"
