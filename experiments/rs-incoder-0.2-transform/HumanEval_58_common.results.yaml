language: rs
name: HumanEval_58_common
results:
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop().unwrap() == l2.pop().unwrap() {\n \
    \               l3.push(l1.pop());\n            } else {\n                break;\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcbnoq4fh.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1.len()\
    \ - 1] == l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n       \
    \             l3.push(l2.pop());\n                } else {\n                 \
    \   l3.push(l1.pop());\n                }\n            } else {\n            \
    \    if l1[l1.len() - 1] < l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    l3.push(l2.pop());\n          \
    \      }\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpit1kwvr1.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmphq3ge5cj.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        let mut i = l1.len();\n\
    \        let mut j = l2.len();\n        while i > 0 && j > 0 {\n            if\
    \ l1[i] < l2[j] {\n                i--;\n            } else if l1[i] > l2[j] {\n\
    \                j--;\n            } else {\n                result.push(*l1[i]);\n\
    \                i--;\n                j--;\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp0r4mr3si.rs:14:20\n\
    \   |\n14 |                 i--;\n   |                    ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmp0r4mr3si.rs:16:20\n   |\n\
    16 |                 j--;\n   |                    ^ expected expression\n\nerror:\
    \ expected expression, found `;`\n  --> /tmp/tmp0r4mr3si.rs:19:20\n   |\n19 |\
    \                 i--;\n   |                    ^ expected expression\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmp0r4mr3si.rs:18:29\n   |\n\
    18 |                 result.push(*l1[i]);\n   |                             ^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.push(l1.pop());\n                   \
    \ l3.push(l2.pop());\n                } else {\n                    l3.push(l1.pop());\n\
    \                }\n            } else {\n                if l1[l1[0]] < l2[l2[0]]\
    \ {\n                    l3.push(l1.pop());\n                } else {\n      \
    \              l3.push(l2.pop());\n                }\n            }\n        }\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprpp4oiy8.rs:17:20\n\
    \   |\n17 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprpp4oiy8.rs:17:33\n\
    \   |\n17 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \                 ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprpp4oiy8.rs:24:20\n\
    \   |\n24 |                 if l1[l1[0]] < l2[l2[0]] {\n   |                 \
    \   ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n \
    \  = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n  \
    \ = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required\
    \ because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmprpp4oiy8.rs:24:32\n\
    \   |\n24 |                 if l1[l1[0]] < l2[l2[0]] {\n   |                 \
    \               ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprpp4oiy8.rs:32:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>)"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmppqnt3gbl.rs:88:1\n   |\n88\
    \ | }\n   | ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(*l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() != 0 || l2.len() != 0 {\n                if l1.len()\
    \ == 0 {\n                    result.push(*l2.pop());\n                } else\
    \ if l2.len() == 0 {\n                    result.push(*l1.pop());\n          \
    \      } else {\n                    if l1.len() == l2.len() {\n             \
    \           if l1.len() == 1 {\n                            result.push(*l1.pop());\n\
    \                        } else {\n                            result.push(*l1.pop());\n\
    \                            result.push(*l2.pop());\n                       \
    \ }\n                    } else {\n                        let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                        let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                        while l1.len() != 0 || l2.len() != 0 {\n            \
    \                if l1.len() == 0 {\n                                result.push(*l2.pop());\n\
    \                            } else if l2.len() == 0 {\n                     \
    \           result.push(*l1.pop());\n                            } else {\n  \
    \                              if l1.len() == l2.len() {\n                   \
    \                 if l1.len() == 1 {\n                                       \
    \ result.push(*l1.pop());\n                                    } else {\n    \
    \                                    result.push(*l1.pop());\n               \
    \                         result.push(*l2.pop());\n                          \
    \          }\n                                } else {\n                     \
    \               let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n       \
    \                             let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                    while l1.len() != 0 || l2.len() != 0 {\n\
    \                                        if l1.len() == 0 {\n                \
    \                            result.push(*l2.pop());\n                       \
    \                 } else if l2.len() == 0 {\n                                \
    \            result.push(*l1.pop());\n                                       \
    \ } else {\n                                            if l1.len() == l2.len()\
    \ {\n                                                if l1.len() == 1 {\n    \
    \                                                result.push(*l1.pop());\n   \
    \                                             } else {\n                     \
    \                               result.push(*l1.pop\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpit2xzub4.rs:69:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - unclosed delimiter\n...\n18 |             while l1.len() !=\
    \ 0 || l2.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n23 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n31 |                     } else {\n   |\
    \                            - unclosed delimiter\n...\n34 |                 \
    \        while l1.len() != 0 || l2.len() != 0 {\n   |                        \
    \                                      - unclosed delimiter\n...\n39 |       \
    \                      } else {\n   |                                    - unclosed\
    \ delimiter\n...\n47 |                                 } else {\n   |        \
    \                                - unclosed delimiter\n...\n50 |             \
    \                        while l1.len() != 0 || l2.len() != 0 {\n   |        \
    \                                                                  - unclosed\
    \ delimiter\n...\n55 |                                         } else {\n   |\
    \                                                - unclosed delimiter\n56 |  \
    \                                           if l1.len() == l2.len() {\n   |  \
    \                                                                   - unclosed\
    \ delimiter\n...\n59 |                                                 } else\
    \ {\n   |                                                        - this delimiter\
    \ might not be properly closed...\n60 |                                      \
    \               result.push(*l1.pop\n61 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n69 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpit2xzub4.rs:60:64\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<i"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmptxhn3jd_.rs:18:30\n     |\n18   |\
    \     l1.extend(l2.into_iter().cloned());\n     |                            \
    \  ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\nnote: required\
    \ by a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations:"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0 && l1.front()\
    \ == l2.front() {\n                l1.pop();\n                l2.pop();\n    \
    \            i += 1;\n            }\n            result.push(l1.pop());\n    \
    \        result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmppdtsycpd.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmppdtsycpd.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppdtsycpd.rs:28:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                common.push(l1_el);\n\
    \                l1_el = l1.pop();\n                l2_el = l2.pop();\n      \
    \      }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3k3t3azl.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter2 = l3.iter_mut();\n            let mut l3_iter3 = l3.iter_mut();\n\
    \            let mut l3_iter4 = l3.iter_mut();\n            let mut l3_iter5 =\
    \ l3.iter_mut();\n            let mut l3_iter6 = l3.iter_mut();\n            let\
    \ mut l3_iter7 = l3.iter_mut();\n            let mut l3_iter8 = l3.iter_mut();\n\
    \            let mut l3_iter9 = l3.iter_mut();\n            let mut l3_iter10\
    \ = l3.iter_mut();\n            let mut l3_iter11 = l3.iter_mut();\n         \
    \   let mut l3_iter12 = l3.iter_mut();\n            let mut l3_iter13 = l3.iter_mut();\n\
    \            let mut l3_iter14 = l3.iter_mut();\n            let mut l3_iter15\
    \ = l3.iter_mut();\n            let mut l3_iter16 = l3.iter_mut();\n         \
    \   let mut l3_iter17 = l3.iter_mut();\n            let mut l3_iter18 = l3.iter_mut();\n\
    \            let mut l3_iter19 = l3.iter_mut();\n            let mut l3_iter20\
    \ = l3.iter_mut();\n            let mut l3_iter21 = l3.iter_mut();\n         \
    \   let mut l3_iter22 = l3.iter_mut();\n            let mut l3_iter23 = l3.iter_mut();\n\
    \            let mut l3_iter24 = l3.iter_mut();\n            let mut l3_iter25\
    \ = l3.iter_mut();\n            let mut l3_iter26 = l3.iter_mut();\n         \
    \   let mut l3_iter27 = l3.iter_mut();\n            let mut l3_iter28 = l3.iter_mut();\n\
    \            let mut l3_iter29 = l3.\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoarre5yb.rs:53:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n45 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n53 | }\n\
    \   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpoarre5yb.rs:45:1\n  \
    \ |\n45 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpoarre5yb.rs:44:36\n\
    \   |\n44 |             let mut l3_iter29 = l3.\n   |                        \
    \            ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpoarre5yb.rs:10:5\n   |\n6  |   fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \                      ---------- expected `Vec<isize>` because of return type\n\
    ...\n10 | /     while l1.len() > 0 || l2.len() > 0 {\n11 | |         if l1.len()\
    \ == 0 {\n12 | |             l3.push(l2.pop());\n13 | |         } else if l2.len()\
    \ == 0 {\n...  |\n52 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n53 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i\
    \ = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n\
    \            result.push(l1[i]);\n            i += 1;\n        } else {\n    \
    \        if l1[i] > l2[i] {\n                i += 1;\n            } else {\n \
    \               i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpb57d7qe3.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any() || l2_iter.any()\
    \ {\n        if l1_iter.any() {\n            if l2_iter.any() {\n            \
    \    if l1_iter.next() == l2_iter.next() {\n                    l1_iter.next();\n\
    \                    l2_iter.next();\n                } else {\n             \
    \       result.push(*l1_iter.next());\n                }\n            } else {\n\
    \                result.push(*l1_iter.next());\n            }\n        } else\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmprc8sd483.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmprc8sd483.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmprc8sd483.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmprc8sd483.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmprc8sd483.rs:19:33\n\
    \   |\n19 |                     result.push(*l1_iter.next());\n   |          \
    \                       ^^^^^^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmprc8sd483.rs:22:29\n   |\n22 |        \
    \         result.push(*l1_iter.next());\n   |                             ^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmprc8sd483.rs:25:25\n\
    \   |\n25 |             result.push(*l2_iter.next());\n   |                  \
    \       ^^^^^^^^^^^^^^^\n\nerror: aborting due to 7 previous errors\n\nSome errors\
    \ have detailed expl"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            } else {\n                if l1[l1[0]] < l2[l2[0]]\
    \ {\n                    l3.pop();\n                    l4.pop();\n          \
    \          l3.push(l1[l1[0]]);\n                } else {\n                   \
    \ l3.pop();\n                    l4.pop();\n                    l3.push(l2[l2[0]]);\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:20:33\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \                 ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:26:29\n\
    \   |\n26 |                     l3.push(l1[l1[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:27:29\n\
    \   |\n27 |                     l4.push(l2[l2[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:30:20\n\
    \   |\n30 |          "
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    let mut common: Vec<isize> = Vec::new();\n\
    \    while i < l1.len() && j < l2.len() {\n        if l1[i] < l2[j] {\n      \
    \      common.push(l1[i]);\n            i += 1;\n        } else {\n          \
    \  common.push(l2[j]);\n            j += 1;\n        }\n    }\n    while i < l1.len()\
    \ {\n        common.push(l1[i]);\n        i += 1;\n    }\n    while j < l2.len()\
    \ {\n        common.push(l2[j]);\n        j += 1;\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3, 4, 5, 5, 5, 7, 9, 34, 121, 653, 653]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmppep1h_5p.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() > 0 || l4.len() > 0 {\n    \
    \    if l3.len() == 0 {\n            l3.push(l4.shift());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.shift());\n        }\n        if l3[0] == l2[0]\
    \ {\n            l3.remove(0);\n            l4.remove(0);\n        } else {\n\
    \            break;\n        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `shift` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmplhdsfxmm.rs:13:24\n   |\n13 |             l3.push(l4.shift());\n\
    \   |                        ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `shift` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmplhdsfxmm.rs:15:24\n   |\n15 |             l4.push(l3.shift());\n\
    \   |                        ^^^^^ method not found in `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n    \
    \        if l2_iter.any() {\n                if l1_iter.next().unwrap() == l2_iter.next().unwrap()\
    \ {\n                    l1_iter.next();\n                    l2_iter.next();\n\
    \                } else {\n                    l1_iter.next();\n             \
    \   }\n            } else {\n                l1_iter.next();\n            }\n\
    \        } else {\n            l2_iter.next();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp_p8lb76m.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp_p8lb76m.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp_p8lb76m.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp_p8lb76m.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l3_i = l3.len();\n            while l3_i > 0 && l3[l3_i - 1]\
    \ == l2[0] {\n                l3_i--;\n            }\n            l3.push(l1[0]);\n\
    \            l1.pop();\n            while l3_i > 0 && l3[l3_i - 1] == l1[0] {\n\
    \                l3_i--;\n            }\n            l3.push(l2[0]);\n       \
    \     l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpqft3srva.rs:22:23\n\
    \   |\n22 |                 l3_i--;\n   |                       ^ expected expression\n\
    \nerror: expected expression, found `;`\n  --> /tmp/tmpqft3srva.rs:27:23\n   |\n\
    27 |                 l3_i--;\n   |                       ^ expected expression\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned().next();\n    let mut l2_next = l2.iter().cloned().next();\n\
    \    while l1_next && l2_next {\n        if l1_next == l2_next {\n           \
    \ result.push(l1_next.unwrap());\n            l1_next = l1.iter().cloned().next();\n\
    \            l2_next = l2.iter().cloned().next();\n        } else if l1_next <\
    \ l2_next {\n            result.push(l1_next.unwrap());\n            l1_next =\
    \ l1.iter().cloned().next();\n        } else {\n            result.push(l2_next.unwrap());\n\
    \            l2_next = l2.iter().cloned().next();\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr22p6of5.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr22p6of5.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n\
    \            l3.pop();\n            l4.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n         \
    \   l3.pop();\n            l4.pop();\n        }\n        if l3[0] == l2[0] {\n\
    \            l3.pop();\n            l4.pop();\n            l3.push(l2[0]);\n \
    \           l4.push(l1[0]);\n            l3.pop();\n            l4.pop();\n  \
    \      }\n        if l3[0] == l1[0] {\n            l3.pop();\n            l4.pop();\n\
    \            l3.push(l2[0]);\n            l4.push(l1[0]);\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l3[0] == l2[0] {\n            l3.pop();\n\
    \            l4.pop();\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n\
    \            l3.pop();\n            l4.pop();\n        }\n        if l3[0] ==\
    \ l1[0] {\n            l3.pop();\n            l4.pop();\n            l3.push(l2[0]);\n\
    \            l4.push(l1[0]);\n            l3.pop();\n            l4.pop();\n \
    \       }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmpfmokoizi.rs:40:12

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n\
    \            l1.pop();\n            l2.pop();\n        } else if l4.len() == 0\
    \ {\n            l4.push(l1[0]);\n            l3.push(l2[0]);\n            l1.pop();\n\
    \            l2.pop();\n        } else {\n            let mut l3_iter = l3.iter().cloned();\n\
    \            let mut l4_iter = l4.iter().cloned();\n            let mut l3_next\
    \ = l3_iter.next();\n            let mut l4_next = l4_iter.next();\n         \
    \   while l3_next.unwrap() != l4_next.unwrap() {\n                if l3_next.unwrap()\
    \ < l4_next.unwrap() {\n                    l3.push(l3_next.unwrap());\n     \
    \               l3_next = l3_iter.next();\n                } else {\n        \
    \            l4.push(l4_next.unwrap());\n                    l4_next = l4_iter.next();\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `l3` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpty0w_df4.rs:29:21\n   |\n23 |             let mut\
    \ l3_iter = l3.iter().cloned();\n   |                               ---------\
    \ immutable borrow occurs here\n...\n29 |                     l3.push(l3_next.unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\
    30 |                     l3_next = l3_iter.next();\n   |                     \
    \          -------------- immutable borrow later used here\n\nerror[E0502]: cannot\
    \ borrow `l4` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpty0w_df4.rs:32:21\n\
    \   |\n24 |             let mut l4_iter = l4.iter().cloned();\n   |          \
    \                     --------- immutable borrow occurs here\n...\n32 |      \
    \               l4.push(l4_next.unwrap());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n33 |                     l4_next = l4_iter.next();\n\
    \   |                               -------------- immutable borrow later used\
    \ here\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut common = Vec::new();\n    while l1.len() > 0\
    \ || l2.len() > 0 {\n        if l1.len() == 0 {\n            l1.push(0);\n   \
    \         l2.push(0);\n        }\n        if l2.len() == 0 {\n            l2.push(0);\n\
    \            l1.push(0);\n        }\n        let mut l1_el = l1.pop();\n     \
    \   let mut l2_el = l2.pop();\n        while l1_el == l2_el {\n            common.push(l1_el);\n\
    \            l1_el = l1.pop();\n            l2_el = l2.pop();\n        }\n   \
    \ }\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3in9bjll.rs:27:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n27 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2.pop());\n        } else if l2.len()\
    \ == 0 {\n            l4.push(l1.pop());\n        } else {\n            if l1.first()\
    \ == l2.first() {\n                l3.push(l2.pop());\n                l4.push(l1.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n                l4.push(l2.pop());\n\
    \            }\n        }\n    }\n    l3.extend(l4);\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpie663pyz.rs:13:21\n   |\n\
    13 |             l3.push(l2.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpie663pyz.rs:15:21\n   |\n15 |             l4.push(l1.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpie663pyz.rs:18:25\n   |\n18 |  \
    \               l3.push(l2.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpie663pyz.rs:19:25\n   |\n19 |                 l4.push(l1.pop());\n \
    \  |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpie663pyz.rs:21:25\n   |\n21 |\
    \                 l3.push(l1.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpie663pyz.rs:22:25\n   |\n22 |                 l4.push(l2.pop());\n \
    \  |                         ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(*l2.pop());\n            l2.pop();\n       \
    \ } else if l2.len() == 0 {\n            result.push(*l1.pop());\n           \
    \ l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n        \
    \        if l1[i] < l2[i] {\n                    result.push(*l1.pop());\n   \
    \                 l1.pop();\n                } else {\n                    result.push(*l2.pop());\n\
    \                    l2.pop();\n                }\n                i += 1;\n \
    \           }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpz5mwcrqd.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpz5mwcrqd.rs:15:25\n   |\n15 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpz5mwcrqd.rs:23:33\n   |\n23 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpz5mwcrqd.rs:26:33\n\
    \   |\n26 |                     result.push(*l2.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                common.push(l1_el);\n\
    \                l1_el = l1.pop();\n                l2_el = l2.pop();\n      \
    \      }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3k3t3azl.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == l2.len() {\n            l3.pop();\n           \
    \ l4.pop();\n        } else if l1.len() > l2.len() {\n            l3.pop();\n\
    \            l4.pop();\n        } else {\n            l3.pop();\n            l4.pop();\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010433
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() > 0 || l2.len() > 0 {\n\
    \                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \                  let mut l3 = Vec::new();\n                    while l1.len()\
    \ > 0 || l2.len() > 0 {\n                        if l1.len() == 0 {\n        \
    \                    l3.push(l2.pop());\n                        } else if l2.len()\
    \ == 0 {\n                            l3.push(l1.pop());\n                   \
    \     } else {\n                            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l3 = Vec::new();\n                      \
    \      while l1.len() > 0 || l2.len() > 0 {\n                                if\
    \ l1.len() == 0 {\n                                    l3.push(l2.pop());\n  \
    \                              } else if l2.len() == 0 {\n                   \
    \                 l3.push(l1.pop());\n                                } else {\n\
    \                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l3 = Vec::new();\n              \
    \                      while l1.len() > 0 || l2.len() > 0 {\n                \
    \                        if l1.len() == 0 {\n                                \
    \            l3.push(l2.pop());\n                                        } else\
    \ if l2.len() == 0 {\n                                            l3.push(l1.pop());\n\
    \                                        } else {\n                          \
    \                  let mut l1 = l1.\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz4bgd6f7.rs:61:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n19 |             while l1.len() > 0 ||\
    \ l2.len() > 0 {\n   |                                                - unclosed\
    \ delimiter\n...\n24 |                 } else {\n   |                        -\
    \ unclosed delimiter\n...\n28 |                     while l1.len() > 0 || l2.len()\
    \ > 0 {\n   |                                                        - unclosed\
    \ delimiter\n...\n33 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n37 |                             while\
    \ l1.len() > 0 || l2.len() > 0 {\n   |                                       \
    \                         - unclosed delimiter\n...\n42 |                    \
    \             } else {\n   |                                        - unclosed\
    \ delimiter\n...\n46 |                                     while l1.len() > 0\
    \ || l2.len() > 0 {\n   |                                                    \
    \                    - unclosed delimiter\n...\n51 |                         \
    \                } else {\n   |                                              \
    \  - this delimiter might not be properly closed...\n52 |                    \
    \                         let mut l1 = l1.\n53 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: unexpected\
    \ token: `}`\n  --> /tmp/tmpz4bgd6f7.rs:53:1\n   |\n53 | }\n   | ^\n\nerror: expected\
    \ `;`, found `}`\n  --> /tmp/tmpz4bgd6f7.rs:52:61\n   |\n52 |                \
    \                             let mut l1 = l1.\n   |                         \
    \                                    ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4bgd6f7.rs:10:5\n  \
    \ |\n6  |  "
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.any() == l2_iter.any() {\n                if l1_iter.next()\
    \ == l2_iter.next() {\n                    l1_iter.next();\n                 \
    \   l2_iter.next();\n                }\n            }\n        }\n        if l1_iter.any()\
    \ {\n            result.push(l1_iter.next());\n        }\n        if l2_iter.any()\
    \ {\n            result.push(l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpgrp8tgc3.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpgrp8tgc3.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpgrp8tgc3.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpgrp8tgc3.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpgrp8tgc3.rs:12:24\n     |\n12   |           \
    \  if l1_iter.any() == l2_iter.any() {\n     |                        ^^^- supplied\
    \ 0 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpgrp8tgc3.rs:12:41\n\
    \     |\n12   |             if l1_iter.any() == l2_iter.any() {\n     |      \
    \                                   ^^^- supplied 0 argu"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            if l1.len() == 0 {\n    \
    \            result.push(l2.pop());\n            } else if l2.len() == 0 {\n \
    \               result.push(l1.pop());\n            } else {\n               \
    \ result.push(l1.pop());\n                result.push(l2.pop());\n           \
    \ }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpawrp4zq0.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpawrp4zq0.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawrp4zq0.rs:34:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = l1.len();\n    while i < k {\n        if l1[i] ==\
    \ l2[j] {\n            i += 1;\n            j += 1;\n        } else {\n      \
    \      if l1[i] < l2[j] {\n                i += 1;\n            } else {\n   \
    \             j += 1;\n            }\n        }\n    }\n    l1.drain(..k);\n \
    \   l2.drain(..k);\n    l1\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpq2uqtjl7.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmp7b5_ibru.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            } else {\n                if l1[l1[0]] < l2[l2[0]]\
    \ {\n                    l3.pop();\n                    l4.pop();\n          \
    \          l3.push(l1[l1[0]]);\n                } else {\n                   \
    \ l3.pop();\n                    l4.pop();\n                    l3.push(l2[l2[0]]);\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmutipmzq.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmutipmzq.rs:20:33\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \                 ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmutipmzq.rs:26:29\n\
    \   |\n26 |                     l3.push(l1[l1[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmutipmzq.rs:27:29\n\
    \   |\n27 |                     l4.push(l2[l2[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpmutipmzq.rs:30:20\n\
    \   |\n30 |          "
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          if l1[0] < l2[0] {\n                l3.push(l1[0]);\n             \
    \   l1.pop();\n            } else {\n                l3.push(l2[0]);\n       \
    \         l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpjbj0k1px.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n\
    \    l5.sort();\n    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7\
    \ = l5.clone();\n    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n\
    \    let mut l9 = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n\
    \    l10.sort();\n    let mut l11 = l9.clone();\n    l11.sort();\n    let mut\
    \ l12 = l10.clone();\n    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n\
    \    let mut l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n\
    \    l15.sort();\n    let mut l16 = l14.clone();\n    l16.sort();\n    let mut\
    \ l17 = l15.clone();\n    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n\
    \    let mut l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n\
    \    l20.sort();\n    let mut l21 = l19.clone();\n    l21.sort();\n    let mut\
    \ l22 = l20.clone();\n    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n\
    \    let mut l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n\
    \    l25.sort();\n    let mut l26 = l24.clone();\n    l26.sort();\n    let mut\
    \ l27 = l25.clone();\n    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n\
    \    let mut l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n\
    \    l30.sort();\n    let mut l31 = l29.clone();\n    l31.sort();\n    let mut\
    \ l32 = l30.clone();\n    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n\
    \    let mut l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n\
    \    l35.sort();\n    let mut l36 = l34.clone();\n    l36.sort();\n    let mut\
    \ l37 = l35.clone();\n    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp4fsy5z3n.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpcwol6xv8.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpcwol6xv8.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcwol6xv8.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1.front() == l2.front() {\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ i += 1;\n                }\n            }\n            if l1.len() == 0 {\n\
    \                result.push(l2.pop());\n            } else if l2.len() == 0 {\n\
    \                result.push(l1.pop());\n            } else {\n              \
    \  result.push(l1.pop());\n                result.push(l2.pop());\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpkuigb89e.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpkuigb89e.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkuigb89e.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          if l1[0] < l2[0] {\n                l3.push(l1[0]);\n             \
    \   l1.pop();\n            } else {\n                l3.push(l2[0]);\n       \
    \         l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpsl5cngt1.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.push(l2.pop());\n        } else if l2.len()\
    \ == 0 {\n            l4.push(l1.pop());\n        } else {\n            let mut\
    \ l5 = l3.clone();\n            let mut l6 = l4.clone();\n            while l5.len()\
    \ != 0 || l6.len() != 0 {\n                if l5.len() == 0 {\n              \
    \      l6.push(l5.pop());\n                } else if l6.len() == 0 {\n       \
    \             l5.push(l6.pop());\n                } else {\n                 \
    \   let mut l7 = l5.clone();\n                    let mut l8 = l6.clone();\n \
    \                   while l7.len() != 0 || l8.len() != 0 {\n                 \
    \       if l7.len() == 0 {\n                            l8.push(l7.pop());\n \
    \                       } else if l8.len() == 0 {\n                          \
    \  l7.push(l8.pop());\n                        } else {\n                    \
    \        let mut l9 = l7.clone();\n                            let mut l10 = l8.clone();\n\
    \                            while l9.len() != 0 || l10.len() != 0 {\n       \
    \                         if l9.len() == 0 {\n                               \
    \     l10.push(l9.pop());\n                                } else if l10.len()\
    \ == 0 {\n                                    l9.push(l10.pop());\n          \
    \                      } else {\n                                    if l9[0]\
    \ < l10[0] {\n                                        l3.push(l9.pop());\n   \
    \                                 } else {\n                                 \
    \       l4.push(l10.pop());\n                                    }\n         \
    \                       }\n                            }\n                   \
    \     }\n                    }\n                }\n            }\n        }\n\
    \    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt69ypc0a.rs:13:21\n   |\n\
    13 |             l3.push(l2.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpt69ypc0a.rs:15:21\n   |\n15 |             l4.push(l1.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt69ypc0a.rs:21:29\n   |\n21 |  \
    \                   l6.push(l5.pop());\n   |                             ^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt69ypc0a.rs:23:29\n   |\n23 |                     l5.push(l6.pop());\n\
    \   |                             ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt69ypc0a.rs:29:37\n   |\n29 |\
    \ ...                   l8.push(l7.pop());\n   |                             \
    \  ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected type\
    \ `isize`\n              found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt69ypc0a.rs:31:37\n   |\n31 | ...                   l7.push(l8.pop());\n\
    \   |                               ^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt69ypc0a.rs:37:46\n   |\n37 |\
    \ ...                   l10.push(l9.pop());\n   |                            \
    \    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ type `isize`\n              found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt69ypc0a.rs:39:45\n   |\n39 | ...                   l9.push(l10.pop());\n\
    \   |                               ^^^^^^^^^ ex"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l2.sort_unstable();\n    l3.sort_unstable();\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2[0]);\n \
    \           l2.pop();\n        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n\
    \            l1.pop();\n        } else {\n            if l1[0] < l2[0] {\n   \
    \             l3.push(l1[0]);\n                l1.pop();\n            } else {\n\
    \                l3.push(l2[0]);\n                l2.pop();\n            }\n \
    \       }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpksub5p4p.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_last = l1.last().unwrap();\n    let mut l2_last = l2.last().unwrap();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n    \
    \        if l2_iter.any() {\n                if l1_last == l2_last {\n       \
    \             l1_iter.next();\n                    l2_iter.next();\n         \
    \           l1_last = l1_iter.next().unwrap();\n                    l2_last =\
    \ l2_iter.next().unwrap();\n                } else {\n                    l1_last\
    \ = l1_iter.next().unwrap();\n                    l2_last = l2_iter.next().unwrap();\n\
    \                }\n            } else {\n                l1_last = l1_iter.next().unwrap();\n\
    \            }\n        } else {\n            l2_last = l2_iter.next().unwrap();\n\
    \        }\n        if l1_last == l2_last {\n            result.push(*l1_iter);\n\
    \            l1_iter.next();\n            l2_iter.next();\n        } else {\n\
    \            result.push(*l1_last);\n            result.push(*l2_last);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpnj1pfrug.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpnj1pfrug.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpnj1pfrug.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpnj1pfrug.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnj1pfrug.rs:18:31\n  \
    \ |\n10 |     let mut l1_last = l1.last().unwrap();\n   |                    \
    \   ------------------ expected due to this value\n...\n18 |                 \
    \    l1_last = l1_iter.next().unwrap();\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&isize`, found `isize`\n   |                               help: consider borrowing\
    \ here: `&l1_iter.next().unwrap()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnj1pfrug.rs:19:31\n\
    \   |\n11 |     let mut l2_last = l2.last().unwrap();\n   |                  \
    \     -----------"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    while\
    \ i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n            i +=\
    \ 1;\n        } else {\n            l1.remove(&l1[i]);\n            l2.remove(&l2[i]);\n\
    \        }\n    }\n    l1.extend(l2.iter().cloned());\n    l1\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsdb20vn5.rs:16:23\n   |\n\
    16 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsdb20vn5.rs:17:23\n\
    \   |\n17 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2_iter\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n                l1.pop();\n                l2.pop();\n\
    \            } else {\n                result.push(l1.pop());\n              \
    \  result.push(l2.pop());\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp8vsop6wn.rs:18:24\n   |\n18 |             if l1_iter.next().unwrap()\
    \ == l2_iter.next().unwrap() {\n   |                        ^^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp8vsop6wn.rs:18:51\n   |\n18 |          \
    \   if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n   |            \
    \                                       ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8vsop6wn.rs:27:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n27 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    let mut l3 = Vec::new();\n    while l1.len() !=\
    \ 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n            l3.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n        }\
    \ else {\n            if l1.len() == l2.len() {\n                if l1[l1.len()\
    \ - 1] == l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n       \
    \             l3.push(l2.pop());\n                } else {\n                 \
    \   l3.push(l1.pop());\n                }\n            } else {\n            \
    \    if l1[l1.len() - 1] < l2[l2.len() - 1] {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    l3.push(l2.pop());\n          \
    \      }\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1dl22yhc.rs:34:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n34 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.iter().next().unwrap() == l2.iter().next().unwrap()\
    \ {\n                l3.push(l1.pop());\n                l3.push(l2.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n            }\n   \
    \     }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxn31zk8n.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmptxhn3jd_.rs:18:30\n     |\n18   |\
    \     l1.extend(l2.into_iter().cloned());\n     |                            \
    \  ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\nnote: required\
    \ by a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations:"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n                l4.pop();\n            }\n        } else if\
    \ l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l5.pop();\n       \
    \             l6.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l5.pop();\n          \
    \              l6.pop();\n                    } else {\n                     \
    \   l5.pop();\n                        l6.pop();\n                    }\n    \
    \            } else {\n                    let mut l7 = l5.clone();\n        \
    \            let mut l8 = l6.clone();\n                    while l7.len() != 0\
    \ || l8.len() != 0 {\n                        if l7.len() == 0 {\n           \
    \                 l8.pop();\n                            l7.pop();\n         \
    \               } else if l8.len() == 0 {\n                            l7.pop();\n\
    \                            l8.pop();\n                        } else if l7.len()\
    \ == 1 {\n                            if l8.len() == 1 {\n                   \
    \             l7.pop();\n                                l8.pop();\n         \
    \                   } else {\n                                l7.pop();\n    \
    \                            l8.pop();\n                            }\n      \
    \                  } else {\n                            let mut l9 = l7.clone();\n\
    \                            let mut l10 = l8.clone();\n                     \
    \       while l9.len() != 0 || l10.len() != 0 {\n                            \
    \    if l9.len() == 0 {\n                                    l10.pop();\n    \
    \                                l9.pop();\n                                }\
    \ else if l10.len() == 0 {\n                                    l9.pop();\n  \
    \                                  l10.pop();\n                              \
    \  } else if l9.len() == 1 {\n                                    if l10.len()\
    \ == 1 {\n                                        l9.pop();\n                \
    \                        l10.pop();\n                                    } else\
    \ {\n                                        l\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9hzugmkc.rs:89:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n29 |         } else {\n   |\
    \                - unclosed delimiter\n...\n32 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n47 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n50 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n65 |                         } else {\n\
    \   |                                - unclosed delimiter\n...\n68 |         \
    \                    while l9.len() != 0 || l10.len() != 0 {\n   |           \
    \                                                        - unclosed delimiter\n\
    ...\n75 |                                 } else if l9.len() == 1 {\n   |    \
    \                                                     - unclosed delimiter\n...\n\
    79 |                                     } else {\n   |                      \
    \                      - this delimiter might not be properly closed...\n80 |\
    \                                         l\n81 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n89 | }\n   |   ^\n\nerror[E0425]: cannot\
    \ find value `l` in this scope\n  --> /tmp/tmp9hzugmkc.rs:80:41\n   |\n80 | ...\
    \                   l\n   |                       ^ help: a local variable with\
    \ a similar name exists: `l1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9hzugmkc.rs:11:5\n\
    \   |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |\
    \                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n12 | |         if l1.len() == 0 {\n13 | |             l3.pop();\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut i =\
    \ 0;\n            let mut j = 0;\n            while i < l1.len() && j < l2.len()\
    \ {\n                if l1[i] == l2[j] {\n                    i += 1;\n      \
    \              j += 1;\n                } else if l1[i] < l2[j] {\n          \
    \          i += 1;\n                } else {\n                    j += 1;\n  \
    \              }\n            }\n            if i == l1.len() {\n            \
    \    result.push(l2[j]);\n            } else {\n                result.push(l1[i]);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyyqw0ok2.rs:29:29\n   |\n\
    29 |                 result.push(l2[j]);\n   |                             ^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |                 result.push(Some(l2[j]));\n   |                  \
    \           +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyyqw0ok2.rs:31:29\n\
    \   |\n31 |                 result.push(l1[i]);\n   |                        \
    \     ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n31 |                 result.push(Some(l1[i]));\n   |      \
    \                       +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyyqw0ok2.rs:35:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n35 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6endsj9j.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l2.len() == 1 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1[l1.len() - 1] == l2[l2.len() - 1] {\n            l3.pop();\n\
    \            l4.pop();\n        } else {\n            l3.pop();\n            l4.pop();\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010433
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68hogdng.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          l1_el = l1.pop();\n                l2_el = l2.pop();\n            }\n\
    \            result.push(l1_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68hogdng.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    while l3.len() > 0 || l4.len()\
    \ > 0 {\n        if l3.len() == 0 {\n            l3.push(l4.pop());\n        }\
    \ else if l4.len() == 0 {\n            l4.push(l3.pop());\n        }\n       \
    \ if l3.len() == l4.len() {\n            if l3.iter().zip(l4.iter()).all(|(&x,\
    \ &y)| x == y) {\n                l3.sort();\n                l4.sort();\n   \
    \         }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6osg8v6x.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6osg8v6x.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpg4jkno63.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter2 = l3.iter_mut();\n            let mut l3_iter3 = l3.iter_mut();\n\
    \            let mut l3_iter4 = l3.iter_mut();\n            let mut l3_iter5 =\
    \ l3.iter_mut();\n            let mut l3_iter6 = l3.iter_mut();\n            let\
    \ mut l3_iter7 = l3.iter_mut();\n            let mut l3_iter8 = l3.iter_mut();\n\
    \            let mut l3_iter9 = l3.iter_mut();\n            let mut l3_iter10\
    \ = l3.iter_mut();\n            let mut l3_iter11 = l3.iter_mut();\n         \
    \   let mut l3_iter12 = l3.iter_mut();\n            let mut l3_iter13 = l3.iter_mut();\n\
    \            let mut l3_iter14 = l3.iter_mut();\n            let mut l3_iter15\
    \ = l3.iter_mut();\n            let mut l3_iter16 = l3.iter_mut();\n         \
    \   let mut l3_iter17 = l3.iter_mut();\n            let mut l3_iter18 = l3.iter_mut();\n\
    \            let mut l3_iter19 = l3.iter_mut();\n            let mut l3_iter20\
    \ = l3.iter_mut();\n            let mut l3_iter21 = l3.iter_mut();\n         \
    \   let mut l3_iter22 = l3.iter_mut();\n            let mut l3_iter23 = l3.iter_mut();\n\
    \            let mut l3_iter24 = l3.iter_mut();\n            let mut l3_iter25\
    \ = l3.iter_mut();\n            let mut l3_iter26 = l3.iter_mut();\n         \
    \   let mut l3_iter27 = l3.iter_mut();\n            let mut l3_iter28 = l3.iter_mut();\n\
    \            let mut l3_iter29 = l\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5c5kk0vs.rs:53:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n45 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n53 | }\n\
    \   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp5c5kk0vs.rs:44:34\n\
    \   |\n44 |             let mut l3_iter29 = l\n   |                          \
    \        ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `l` in this scope\n  --> /tmp/tmp5c5kk0vs.rs:44:33\n   |\n\
    44 |             let mut l3_iter29 = l\n   |                                 ^\
    \ help: a local variable with a similar name exists: `l1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5c5kk0vs.rs:10:5\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n...\n10 |\
    \ /     while l1.len() > 0 || l2.len() > 0 {\n11 | |         if l1.len() == 0\
    \ {\n12 | |             l3.push(l2.pop());\n13 | |         } else if l2.len()\
    \ == 0 {\n...  |\n52 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n53 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[0]\
    \ != l4[0] {\n            l3.pop();\n            l4.pop();\n        } else {\n\
    \            l3.pop();\n            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpcer7oa06.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n            l1.pop();\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l1_el\
    \ = l1.pop();\n                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_53le988.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_iter = l1.iter().cloned();\n       \
    \     let mut l2_iter = l2.iter().cloned();\n            let mut l3_iter = l3.iter().cloned();\n\
    \            let mut l1_elem = l1_iter.next();\n            let mut l2_elem =\
    \ l2_iter.next();\n            while l1_elem.unwrap() != l2_elem.unwrap() {\n\
    \                l3_iter.next();\n            }\n            l3_iter.next();\n\
    \            l1.push(l1_elem.unwrap());\n            l2.push(l2_elem.unwrap());\n\
    \        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1t_lj448.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        let mut i = 0;\n\
    \        let mut j = 0;\n        while i < l1.len() && j < l2.len() {\n      \
    \      if l1[i] < l2[j] {\n                result.push(*l1.get(i));\n        \
    \        i += 1;\n            } else {\n                result.push(*l2.get(j));\n\
    \                j += 1;\n            }\n        }\n        if i == l1.len() {\n\
    \            result.push(*l2.get(j));\n        }\n        if j == l2.len() {\n\
    \            result.push(*l1.get(i));\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp8ut66cm_.rs:14:29\n\
    \   |\n14 |                 result.push(*l1.get(i));\n   |                   \
    \          ^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp8ut66cm_.rs:17:29\n   |\n17 |                 result.push(*l2.get(j));\n\
    \   |                             ^^^^^^^^^^\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp8ut66cm_.rs:22:25\n   |\n22 |        \
    \     result.push(*l2.get(j));\n   |                         ^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp8ut66cm_.rs:25:25\n\
    \   |\n25 |             result.push(*l1.get(i));\n   |                       \
    \  ^^^^^^^^^^\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    result.dedup();\n    result.sort();\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpf6e2e77q.rs:16:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ i = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i]\
    \ {\n            result.push(l1[i]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmphzqyj280.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            else\
    \ {\n                l3.pop();\n            }\n        }\n        if l2.len()\
    \ == 1 {\n            if l1.len() == 1 {\n                l3.pop();\n        \
    \        l4.pop();\n            }\n            else {\n                l3.pop();\n\
    \            }\n        }\n        if l1.len() == l2.len() {\n            let\
    \ mut i = l1.iter().cloned().collect::<Vec<_>>();\n            while i.len() !=\
    \ 0 {\n                l3.pop();\n                l4.pop();\n            }\n \
    \       }\n    }\n    l3.iter().cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                    i += 1;\n                } else if l2.len() == 0 {\n    \
    \                result.push(l1.pop());\n                    i += 1;\n       \
    \         } else {\n                    if l1.len() == l2.len() {\n          \
    \              if l1.iter().next().unwrap() == l2.iter().next().unwrap() {\n \
    \                           i += 1;\n                        }\n             \
    \       } else {\n                        break;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv2xwzbp2.rs:38:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n38 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_last = l1.last().unwrap();\n    let mut l2_last = l2.last().unwrap();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_last == l2_last {\n                l1_last = l1_iter.next().unwrap();\n\
    \                l2_last = l2_iter.next().unwrap();\n            } else {\n  \
    \              if l1_last < l2_last {\n                    result.remove(l1_last);\n\
    \                    l1_last = l1_iter.next().unwrap();\n                } else\
    \ {\n                    result.remove(l2_last);\n                    l2_last\
    \ = l2_iter.next().unwrap();\n                }\n            }\n        } else\
    \ if l1_iter.any() {\n            result.remove(l1_iter.next().unwrap());\n  \
    \          l1_last = l1_iter.next().unwrap();\n        } else if l2_iter.any()\
    \ {\n            result.remove(l2_iter.next().unwrap());\n            l2_last\
    \ = l2_iter.next().unwrap();\n        } else {\n            break;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpfi0tzxc3.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpfi0tzxc3.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpfi0tzxc3.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpfi0tzxc3.rs:13:37\n     |\n13   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfi0tzxc3.rs:15:27\n\
    \   |\n10 |     let mut l1_last = l1.last().unwrap();\n   |                  \
    \     ------------------ expected due to this value\n...\n15 |               \
    \  l1_last = l1_iter.next().unwrap();\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&isize`,\
    \ found `isize`\n   |                           help: consider borrowing here:\
    \ `&l1_iter.next().unwrap()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfi0tzxc3.rs:16:27\n\
    \   |\n11 |     let mut l2_last = l2.last()"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common:\
    \ Vec<isize> = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if\
    \ l1.len() == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n\
    \            l1.pop();\n        } else {\n            if l1.len() == l2.len()\
    \ {\n                common = common.append(l1.pop());\n            } else {\n\
    \                common = common.append(l1.pop());\n                common = common.append(l2.pop());\n\
    \            }\n        }\n    }\n    common\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp97glpru2.rs:17:40\n   |\n\
    17 |                 common = common.append(l1.pop());\n   |                 \
    \                       ^^^^^^^^ expected `&mut Vec<isize>`, found enum `Option`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<isize>`\n             \
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp97glpru2.rs:17:26\n   |\n9  |     let mut common: Vec<isize> =\
    \ vec![];\n   |                     ---------- expected due to this type\n...\n\
    17 |                 common = common.append(l1.pop());\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote:\
    \ method `append` modifies its receiver in-place\n  --> /tmp/tmp97glpru2.rs:17:33\n\
    \   |\n17 |                 common = common.append(l1.pop());\n   |          \
    \                ------ ^^^^^^ this call modifies `common` in-place\n   |    \
    \                      |\n   |                          you probably want to use\
    \ this value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `append`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97glpru2.rs:19:40\n\
    \   |\n19 |                 common = common.append(l1.pop());\n   |          \
    \                              ^^^^^^^^ expected `&mut Vec<isize>`, found enum\
    \ `Option`\n   |\n   = note: expected mutable reference `&mut Vec<isize>`\n  \
    \                         found enum `Option<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp97glpru2.rs:19:26\n   |\n9  |     let mut common: Vec<isize>\
    \ = vec![];\n   |                     ---------- expected due to this type\n...\n\
    19 |                 common = common.append(l1.pop());\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<isize>`\n           found unit type `()`\nnote:\
    \ method `append` modifies its receiver in-place\n  --> /tmp/tmp97glpru2.rs:19:33\n\
    \   |\n19 |                 common = common.append(l1.pop());\n   |      "
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          let mut l1_el = l1[0];\n            let mut l2_el = l2[0];\n      \
    \      while l1_el == l2_el {\n                l1_el = l1[0];\n              \
    \  l2_el = l2[0];\n            }\n            l3.push(l1_el);\n            l1.pop();\n\
    \            l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpwlsu5vk4.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        let mut l3_iter = l3.iter().cloned();\n        let mut l4_iter\
    \ = l4.iter().cloned();\n        let mut l3_next = l3_iter.next();\n        let\
    \ mut l4_next = l4_iter.next();\n        while l3_next.unwrap() != l4_next.unwrap()\
    \ {\n            if l3_next.unwrap() == 0 {\n                l3_next = l3_iter.next();\n\
    \            }\n            if l4_next.unwrap() == 0 {\n                l4_next\
    \ = l4_iter.next();\n            }\n        }\n        if l3_next.unwrap() ==\
    \ 0 {\n            l3.push(0);\n        }\n        if l4_next.unwrap() == 0 {\n\
    \            l4.push(0);\n        }\n    }\n    l3.iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp1jnda90n.rs:6:46\n  |\n6 |\
    \ fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  |    ------   \
    \                                 ^^^^^^^^^^ expected struct `Vec`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n  |\n  = note: expected struct `Vec<isize>`\n          found unit\
    \ type `()`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.iter().next().unwrap()\
    \ == l2.iter().next().unwrap() {\n                    l3.push(l1.pop());\n   \
    \                 l3.push(l2.pop());\n                } else {\n             \
    \       l3.push(l1.pop());\n                }\n            } else {\n        \
    \        if l1.iter().next().unwrap() < l2.iter().next().unwrap() {\n        \
    \            l3.push(l1.pop());\n                } else {\n                  \
    \  l3.push(l2.pop());\n                }\n            }\n        }\n    }\n  \
    \  l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps666niib.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            let mut l3_iter = l3.iter();\n            let mut\
    \ l4_iter = l4.iter();\n            if l3_iter.next().unwrap() == l4_iter.next().unwrap()\
    \ {\n                l3.pop();\n                l4.pop();\n            } else\
    \ {\n                l3.push(l3_iter.next().unwrap());\n                l4.push(l4_iter.next().unwrap());\n\
    \            }\n        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm_qoke7t.rs:25:25\n   |\n\
    25 |                 l3.push(l3_iter.next().unwrap());\n   |                 \
    \        ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n25 |                 l3.push(*l3_iter.next().unwrap());\n\
    \   |                         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm_qoke7t.rs:26:25\n\
    \   |\n26 |                 l4.push(l4_iter.next().unwrap());\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n26 |                 l4.push(*l4_iter.next().unwrap());\n\
    \   |                         +\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpi3dlqp_w.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1[0] < l2[0] {\n            result.swap_remove(0);\n \
    \           l1.swap_remove(0);\n        } else {\n            result.swap_remove(0);\n\
    \            l2.swap_remove(0);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpg7sa6g0s.rs:18:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n18 |             l1.swap_remove(0);\n   |             ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj8gejo5d.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ && l2_iter.any() {\n        if *l1_iter == *l2_iter {\n            result.push(*l1_iter);\n\
    \            l1_iter.next();\n            l2_iter.next();\n        } else {\n\
    \            if *l1_iter < *l2_iter {\n                l1_iter.next();\n     \
    \       } else {\n                l2_iter.next();\n            }\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpi15nhwkf.rs:10:19\n     |\n10   |     while l1_iter.any() &&\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpi15nhwkf.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() && l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpi15nhwkf.rs:11:12\n   |\n11 |\
    \         if *l1_iter == *l2_iter {\n   |            ^^^^^^^^\n\nerror[E0614]:\
    \ type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  --> /tmp/tmpi15nhwkf.rs:11:24\n\
    \   |\n11 |         if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\
    \nerror[E0614]: type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpi15nhwkf.rs:12:25\n   |\n12 |             result.push(*l1_iter);\n \
    \  |                         ^^^^^^^^\n\nerror[E0614]: type `std::slice::Iter<'_,\
    \ isize>` cannot be dereferenced\n  --> /tmp/tmpi15nhwkf.rs:16:16\n   |\n16 |\
    \             if *l1_iter < *l2_iter {\n   |                ^^^^^^^^\n\nerror[E0614]:\
    \ type `std::slice::Iter<'_, isize>` cannot be dereferenced\n  --> /tmp/tmpi15nhwkf.rs:16:27\n\
    \   |\n16 |             if *l1_iter < *l2_iter {\n   |                       \
    \    ^^^^^^^^\n\nerror: aborting due to 7 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.dedup();\n    l3\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpinnvorp8.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common:\
    \ Vec<isize> = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n        \
    \        if l1.front() == l2.front() {\n                    common = common.append(l1.pop());\n\
    \                    l1.pop();\n                    l2.pop();\n              \
    \  } else if l1.front() < l2.front() {\n                    l1.pop();\n      \
    \          } else {\n                    l2.pop();\n                }\n      \
    \          i += 1;\n            }\n        }\n    }\n    common\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmptm40w7ma.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmptm40w7ma.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptm40w7ma.rs:21:44\n   |\n21 |                     common\
    \ = common.append(l1.pop());\n   |                                           \
    \ ^^^^^^^^ expected `&mut Vec<isize>`, found enum `Option`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<isize>`\n                           found enum `Option<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptm40w7ma.rs:21:30\n   |\n9  |\
    \     let mut common: Vec<isize> = vec![];\n   |                     ----------\
    \ expected due to this type\n...\n21 |                     common = common.append(l1.pop());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\nnote: method `append` modifies its receiver in-place\n  -->\
    \ /tmp/tmptm40w7ma.rs:21:37\n   |\n21 |                     common = common.append(l1.pop());\n\
    \   |                              ------ ^^^^^^ this call modifies `common` in-place\n\
    \   |                              |\n   |                              you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `append`\n\nerror[E0599]: no method named `front`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmptm40w7ma.rs:24:30\n\
    \   |\n24 |                 } else if l1.front() < l2.front() {\n   |        \
    \                      ^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `front` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpt"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        if l3[0] != l2[0] {\n            l3.push(0);\n           \
    \ l4.push(0);\n        }\n        if l3[0] != l4[0] {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l3[0] != l2[0] {\n           \
    \ l3.push(0);\n            l4.push(0);\n        }\n        if l3[0] != l4[0] {\n\
    \            l3.push(0);\n            l4.push(0);\n        }\n        if l3[0]\
    \ != l2[0] {\n            l3.push(0);\n            l4.push(0);\n        }\n  \
    \      if l3[0] != l4[0] {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l3[0] != l2[0] {\n            l3.push(0);\n           \
    \ l4.push(0);\n        }\n        if l3[0] != l4[0] {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l3[0] != l2[0] {\n           \
    \ l3.push(0);\n            l4.push(0);\n        }\n        if l3[0] != l4[0] {\n\
    \            l3.push(0);\n            l4.push(0);\n        }\n        if l3[0]\
    \ != l2[0] {\n            l3.push(0);\n            l4.push(0);\n        }\n  \
    \      if l3[0] != l4[0] {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l3[0] != l2[0] {\n            l3.push(0);\n           \
    \ l4.push(0);\n        }\n        if l3[0] != l4[0] {\n            l3.push(0);\n\
    \            l4.push(0);\n        }\n        if l3[0] != l2[0] {\n           \
    \ l3.push(0);\n            l4.push(0);\n        }\n        if l3[0] != l4[0] {\n\
    \            l3.push(0);\n            l4.push(0);\n        }\n        if l3[0]\
    \ != l2[0] {\n            l3.push(0);\n            l4.push(0);\n        }\n  \
    \      if l3[0] != l4[0] {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l3[0] != l2[0] {\n            l3.push(0);\n           \
    \ l4.push(0);\n        }\n        if l3[0] != l4[0] {\n            l3.push(0);\n\
    \            l\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6iulw6qy.rs:107:3\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                                                         - unclosed delimiter\n\
    ...\n11  |     while l3.len() != 0 || l4.len() != 0 {\n    |                 \
    \                         - unclosed delimiter\n...\n96  |         if l3[0] !=\
    \ l4[0] {\n    |                           - this delimiter might not be properly\
    \ closed...\n...\n99  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n107 | }\n    |   ^\n\nerror[E0425]: cannot find value `l`\
    \ in this scope\n  --> /tmp/tmp6iulw6qy.rs:98:13\n   |\n98 |             l\n \
    \  |             ^ help: a local variable with a similar name exists: `l1`\n\n\
    error[E0308]: mismatched types\n   --> /tmp/tmp6iulw6qy.rs:11:5\n    |\n6   |\
    \   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |         \
    \                                       ---------- expected `Vec<isize>` because\
    \ of return type\n...\n11  | /     while l3.len() != 0 || l4.len() != 0 {\n12\
    \  | |         if l3.len() == 0 {\n13  | |             l3.push(0);\n14  | |  \
    \           l4.push(0);\n...   |\n106 | |     assert_eq!(candidate(vec![4, 3,\
    \ 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n107 | | }\n    | |__^ expected\
    \ struct `Vec`, found `()`\n    |\n    = note: expected struct `Vec<isize>`\n\
    \            found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[0]\
    \ != l4[0] {\n            l3.pop();\n            l4.pop();\n        } else {\n\
    \            l3.pop();\n            l4.pop();\n        }\n    }\n    l3\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpjk9lwnop.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter2 = l3.iter_mut();\n            let mut l3_iter3 = l3.iter_mut();\n\
    \            let mut l3_iter4 = l3.iter_mut();\n            let mut l3_iter5 =\
    \ l3.iter_mut();\n            let mut l3_iter6 = l3.iter_mut();\n            let\
    \ mut l3_iter7 = l3.iter_mut();\n            let mut l3_iter8 = l3.iter_mut();\n\
    \            let mut l3_iter9 = l3.iter_mut();\n            let mut l3_iter10\
    \ = l3.iter_mut();\n            let mut l3_iter11 = l3.iter_mut();\n         \
    \   let mut l3_iter12 = l3.iter_mut();\n            let mut l3_iter13 = l3.iter_mut();\n\
    \            let mut l3_iter14 = l3.iter_mut();\n            let mut l3_iter15\
    \ = l3.iter_mut();\n            let mut l3_iter16 = l3.iter_mut();\n         \
    \   let mut l3_iter17 = l3.iter_mut();\n            let mut l3_iter18 = l3.iter_mut();\n\
    \            let mut l3_iter19 = l3.iter_mut();\n            let mut l3_iter20\
    \ = l3.iter_mut();\n            let mut l3_iter21 = l3.iter_mut();\n         \
    \   let mut l3_iter22 = l3.iter_mut();\n            let mut l3_iter23 = l3.iter_mut();\n\
    \            let mut l3_iter24 = l3.iter_mut();\n            let mut l3_iter25\
    \ = l3.iter_mut();\n            let mut l3_iter26 = l3.iter_mut();\n         \
    \   let mut l3_iter27 = l3.iter_mut();\n            let mut l3_iter28 = l3.iter_mut();\n\
    \            let mut l3_iter29 = l\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5c5kk0vs.rs:53:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - this delimiter might not be properly closed...\n...\n45 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n53 | }\n\
    \   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmp5c5kk0vs.rs:44:34\n\
    \   |\n44 |             let mut l3_iter29 = l\n   |                          \
    \        ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `l` in this scope\n  --> /tmp/tmp5c5kk0vs.rs:44:33\n   |\n\
    44 |             let mut l3_iter29 = l\n   |                                 ^\
    \ help: a local variable with a similar name exists: `l1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5c5kk0vs.rs:10:5\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n...\n10 |\
    \ /     while l1.len() > 0 || l2.len() > 0 {\n11 | |         if l1.len() == 0\
    \ {\n12 | |             l3.push(l2.pop());\n13 | |         } else if l2.len()\
    \ == 0 {\n...  |\n52 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n53 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.len()\
    \ == 1 {\n                    l3.push(l1.pop());\n                } else {\n \
    \                   l3.push(l1.pop());\n                    l3.push(l2.pop());\n\
    \                }\n            } else {\n                if l1.len() < l2.len()\
    \ {\n                    l3.push(l1.pop());\n                } else {\n      \
    \              l3.push(l2.pop());\n                }\n            }\n        }\n\
    \    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcckb7728.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(0);\n            l4.push(0);\n\
    \        }\n        if l4.len() == 0 {\n            l4.push(0);\n            l3.push(0);\n\
    \        }\n        if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            l3.pop();\n            l4.pop();\n        }\n \
    \   }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmpwba5jf20.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else if l1.len() == 1 {\n            if l2.len() == 1 {\n         \
    \       l3.pop();\n                l4.pop();\n            } else {\n         \
    \       l3.pop();\n            }\n        } else if l2.len() == 1 {\n        \
    \    if l1.len() == 1 {\n                l3.pop();\n                l4.pop();\n\
    \            } else {\n                l3.pop();\n            }\n        } else\
    \ {\n            let mut l5 = l1.clone();\n            let mut l6 = l2.clone();\n\
    \            while l5.len() != 0 || l6.len() != 0 {\n                if l5.len()\
    \ == 0 {\n                    l6.pop();\n                    l5.pop();\n     \
    \           } else if l6.len() == 0 {\n                    l5.pop();\n       \
    \             l6.pop();\n                } else if l5.len() == 1 {\n         \
    \           if l6.len() == 1 {\n                        l6.pop();\n          \
    \              l5.pop();\n                    } else {\n                     \
    \   l6.pop();\n                    }\n                } else if l6.len() == 1\
    \ {\n                    if l5.len() == 1 {\n                        l5.pop();\n\
    \                        l6.pop();\n                    } else {\n           \
    \             l5.pop();\n                    }\n                } else {\n   \
    \                 let mut l7 = l5.clone();\n                    let mut l8 = l6.clone();\n\
    \                    while l7.len() != 0 || l8.len() != 0 {\n                \
    \        if l7.len() == 0 {\n                            l8.pop();\n         \
    \                   l7.pop();\n                        } else if l8.len() == 0\
    \ {\n                            l7.pop();\n                            l8.pop();\n\
    \                        } else if l7.len() == 1 {\n                         \
    \   if l8.len() == 1 {\n                                l8.pop();\n          \
    \                      l7.pop();\n                            } else {\n     \
    \                           l8.pop();\n                            }\n       \
    \                 } else if l8.len() == 1 {\n                            if l7.len()\
    \ == 1 {\n                                l7.pop();\n                        \
    \        l8.pop();\n                            } else {\n                   \
    \             l7.pop();\n                            }\n                     \
    \   } else {\n                            let mut l9 = l7.clone();\n         \
    \                   let mut l10 = l8.clone();\n                            while\
    \ l9.len() != 0 || l10.len(\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsxhdkv_g.rs:92:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n32 |         } else {\n   |\
    \                - unclosed delimiter\n...\n35 |             while l5.len() !=\
    \ 0 || l6.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n56 |                 } else {\n   |             \
    \           - unclosed delimiter\n...\n59 |                     while l7.len()\
    \ != 0 || l8.len() != 0 {\n   |                                              \
    \            - unclosed delimiter\n...\n80 |                         } else {\n\
    \   |                                - this delimiter might not be properly closed...\n\
    ...\n84 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    92 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpsxhdkv_g.rs:83:59\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - closing delimiter possibly\
    \ meant for this\n...\n83 |                             while l9.len() != 0 ||\
    \ l10.len(\n   |                                                           ^ unclosed\
    \ delimiter\n84 | }\n   | ^ mismatched closing delimiter\n\nerror: expected `{`,\
    \ found `}`\n  --> /tmp/tmpsxhdkv_g.rs:84:1\n   |\n83 |                      \
    \         while l9.len() != 0 || l10.len(\n   |  _____________________________-----_-\n\
    \   | |                             |\n   | |                             while\
    \ parsing the body of this `while` expression\n84 | | }\n   | | ^\n   | | |\n\
    \   | |_expected `{`\n   |   this `while` condition successfully parsed\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsxhdkv_g.rs:11:5\n   |\n6  |   fn common(l1:\
    \ Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |                          \
    \                      ---------- expected"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n            let mut l4_iter\
    \ = l4.iter().cloned().collect::<Vec<_>>();\n            while l3_iter.len() !=\
    \ 0 || l4_iter.len() != 0 {\n                if l3_iter.len() == 0 {\n       \
    \             l3_iter.push(l4_iter.pop());\n                } else if l4_iter.len()\
    \ == 0 {\n                    l4_iter.push(l3_iter.pop());\n                }\
    \ else {\n                    if l3_iter.iter().any(|&x| l4_iter.iter().any(|&y|\
    \ x == y)) {\n                        l3_iter.push(l4_iter.pop());\n         \
    \           } else {\n                        l4_iter.push(l3_iter.pop());\n \
    \                   }\n                }\n            }\n        }\n    }\n  \
    \  l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_5_tjsc1.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_5_tjsc1.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_5_tjsc1.rs:21:34\n   |\n21 |  \
    \                   l3_iter.push(l4_iter.pop());\n   |                       \
    \           ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note:\
    \ expected type `isize`\n              found enum `Option<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_5_tjsc1.rs:23:34\n   |\n23 |              \
    \       l4_iter.push(l3_iter.pop());\n   |                                  ^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_5_tjsc1.rs:26:38\n   |\n26 |                         l3_iter.push(l4_iter.pop());\n\
    \   |                                      ^^^^^^^^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected type `isize`\n              found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_5_tjsc1.rs:28:38\n\
    \   |\n28 |                         l4_iter.push(l3_iter.pop());\n   |       \
    \                               ^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<isize>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    let mut common = Vec::new();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else {\n            i +=\
    \ 1;\n        }\n    }\n    while i < l1.len() {\n        common.push(l1[i]);\n\
    \        i += 1;\n    }\n    while j < l2.len() {\n        common.push(l2[j]);\n\
    \        j += 1;\n    }\n    common\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 5, 5, 7, 9, 121, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpol3bctxv.rs:37:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n                l3.push(l2.pop());\n\
    \            }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcgsi0mbw.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned();\n    let mut l2_next = l2.iter().cloned();\n\
    \    while l1_iter.next() != Some(&0) and l2_iter.next() != Some(&0) {\n     \
    \   if *l1_iter == *l2_iter {\n            result.push(*l1_iter);\n          \
    \  l1_iter.next();\n            l2_iter.next();\n        } else if *l1_iter <\
    \ *l2_iter {\n            l1_next.next();\n        } else {\n            l2_next.next();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: `and` is not a logical operator\n  --> /tmp/tmp04y7mkj0.rs:12:38\n\
    \   |\n12 |     while l1_iter.next() != Some(&0) and l2_iter.next() != Some(&0)\
    \ {\n   |                                      ^^^ help: use `&&` to perform logical\
    \ conjunction\n   |\n   = note: unlike in e.g., python and PHP, `&&` and `||`\
    \ are used for logical operators\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp04y7mkj0.rs:12:34\n\
    \   |\n12 |     while l1_iter.next() != Some(&0) and l2_iter.next() != Some(&0)\
    \ {\n   |                                  ^^ expected `isize`, found `&{integer}`\n\
    \   |\nhelp: consider removing the borrow\n   |\n12 -     while l1_iter.next()\
    \ != Some(&0) and l2_iter.next() != Some(&0) {\n12 +     while l1_iter.next()\
    \ != Some(0) and l2_iter.next() != Some(&0) {\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp04y7mkj0.rs:12:65\n   |\n12 |     while l1_iter.next()\
    \ != Some(&0) and l2_iter.next() != Some(&0) {\n   |                         \
    \                                        ^^ expected `isize`, found `&{integer}`\n\
    \   |\nhelp: consider removing the borrow\n   |\n12 -     while l1_iter.next()\
    \ != Some(&0) and l2_iter.next() != Some(&0) {\n12 +     while l1_iter.next()\
    \ != Some(&0) and l2_iter.next() != Some(0) {\n   | \n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmp04y7mkj0.rs:13:12\n   |\n13 |\
    \         if *l1_iter == *l2_iter {\n   |            ^^^^^^^^\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmp04y7mkj0.rs:13:24\n\
    \   |\n13 |         if *l1_iter == *l2_iter {\n   |                        ^^^^^^^^\n\
    \nerror[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n\
    \  --> /tmp/tmp04y7mkj0.rs:14:25\n   |\n14 |             result.push(*l1_iter);\n\
    \   |                         ^^^^^^^^\n\nerror[E0614]: type `Cloned<std::slice::Iter<'_,\
    \ isize>>` cannot be dereferenced\n  --> /tmp/tmp04y7mkj0.rs:17:19\n   |\n17 |\
    \         } else if *l1_iter < *l2_iter {\n   |                   ^^^^^^^^\n\n\
    error[E0614]: type `Cloned<std::slice::Iter<'_, isize>>` cannot be de"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut i = 0;\n            while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n             \
    \   l1.pop();\n                l2.pop();\n                i += 1;\n          \
    \  }\n            result.push(i);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpg5f42s7t.rs:17:56\n   |\n17 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpg5f42s7t.rs:17:70\n   |\n17 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2[0]);\n            l2.pop();\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n \
    \           let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n      \
    \      while l1_iter.len() != 0 || l2_iter.len() != 0 {\n                if l1_iter.len()\
    \ == 0 {\n                    result.push(l2_iter[0]);\n                    l2_iter.pop();\n\
    \                } else if l2_iter.len() == 0 {\n                    result.push(l1_iter[0]);\n\
    \                    l1_iter.pop();\n                } else {\n              \
    \      if l1_iter[0] == l2_iter[0] {\n                        l1_iter.pop();\n\
    \                        l2_iter.pop();\n                    } else {\n      \
    \                  break;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n\
    \    l5.sort();\n    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7\
    \ = l5.clone();\n    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n\
    \    let mut l9 = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n\
    \    l10.sort();\n    let mut l11 = l9.clone();\n    l11.sort();\n    let mut\
    \ l12 = l10.clone();\n    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n\
    \    let mut l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n\
    \    l15.sort();\n    let mut l16 = l14.clone();\n    l16.sort();\n    let mut\
    \ l17 = l15.clone();\n    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n\
    \    let mut l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n\
    \    l20.sort();\n    let mut l21 = l19.clone();\n    l21.sort();\n    let mut\
    \ l22 = l20.clone();\n    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n\
    \    let mut l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n\
    \    l25.sort();\n    let mut l26 = l24.clone();\n    l26.sort();\n    let mut\
    \ l27 = l25.clone();\n    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n\
    \    let mut l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n\
    \    l30.sort();\n    let mut l31 = l29.clone();\n    l31.sort();\n    let mut\
    \ l32 = l30.clone();\n    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n\
    \    let mut l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n\
    \    l35.sort();\n    let mut l36 = l34.clone();\n    l36.sort();\n    let mut\
    \ l37 = l35.clone();\n    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp4fsy5z3n.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l3_iter = l3.iter_mut();\n            let\
    \ mut l3_iter2 = l3.iter_mut();\n            let mut l3_iter3 = l3.iter_mut();\n\
    \            let mut l3_iter4 = l3.iter_mut();\n            let mut l3_iter5 =\
    \ l3.iter_mut();\n            let mut l3_iter6 = l3.iter_mut();\n            let\
    \ mut l3_iter7 = l3.iter_mut();\n            let mut l3_iter8 = l3.iter_mut();\n\
    \            let mut l3_iter9 = l3.iter_mut();\n            let mut l3_iter10\
    \ = l3.iter_mut();\n            let mut l3_iter11 = l3.iter_mut();\n         \
    \   let mut l3_iter12 = l3.iter_mut();\n            let mut l3_iter13 = l3.iter_mut();\n\
    \            let mut l3_iter14 = l3.iter_mut();\n            let mut l3_iter15\
    \ = l3.iter_mut();\n            let mut l3_iter16 = l3.iter_mut();\n         \
    \   let mut l3_iter17 = l3.iter_mut();\n            let mut l3_iter18 = l3.iter_mut();\n\
    \            let mut l3_iter19 = l3.iter_mut();\n            let mut l3_iter20\
    \ = l3.iter_mut();\n            let mut l3_iter21 = l3.iter_mut();\n         \
    \   let mut l3_iter22 = l3.iter_mut();\n            let mut l3_iter23 = l3.iter_mut();\n\
    \            let mut l3_iter24 = l3.iter_mut();\n            let mut l3_iter25\
    \ = l3.iter_mut();\n            let mut l3_iter26 = l3.iter_mut();\n         \
    \   let mut l3_iter27 = l3.iter_mut();\n            let mut l3_iter28 = l3.iter_mut();\n\
    \            let mut l3_iter29 = l\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplvkcjg0u.rs:53:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - this delimiter might not be properly closed...\n...\n45 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n53 | }\n\
    \   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmplvkcjg0u.rs:44:34\n\
    \   |\n44 |             let mut l3_iter29 = l\n   |                          \
    \        ^ help: add `;` here\n45 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `l` in this scope\n  --> /tmp/tmplvkcjg0u.rs:44:33\n   |\n\
    44 |             let mut l3_iter29 = l\n   |                                 ^\
    \ help: a local variable with a similar name exists: `l1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplvkcjg0u.rs:10:5\n   |\n6  |   fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \          ---------- expected `Vec<isize>` because of return type\n...\n10 |\
    \ /     while l1.len() != 0 || l2.len() != 0 {\n11 | |         if l1.len() ==\
    \ 0 {\n12 | |             l3.push(l2.pop());\n13 | |         } else if l2.len()\
    \ == 0 {\n...  |\n52 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n53 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(_,\
    \ &b)| b == true).collect()\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplymx33hn.rs:11:53\n   |\n\
    11 |     l3.iter().zip(l4.iter()).filter(|&(_, &b)| b == true).collect()\n   |\
    \                                                     ^^^^ expected `isize`, found\
    \ `bool`\n\nerror[E0277]: a value of type `Vec<isize>` cannot be built from an\
    \ iterator over elements of type `(&isize, &isize)`\n    --> /tmp/tmplymx33hn.rs:11:59\n\
    \     |\n11   |     l3.iter().zip(l4.iter()).filter(|&(_, &b)| b == true).collect()\n\
    \     |                                                           ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any() {\n          \
    \  if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n  \
    \              l2_iter.next();\n            } else {\n                result.push(*l1_iter.next());\n\
    \                result.push(*l2_iter.next());\n            }\n        } else\
    \ if l1_iter.any() {\n            result.push(*l1_iter.next());\n        } else\
    \ {\n            result.push(*l2_iter.next());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpbezkust_.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpbezkust_.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpbezkust_.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpbezkust_.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpbezkust_.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `std::slice::Iter<'_, isize>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmpbezkust_.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `std::slice::Iter<'_,\
    \ isize>`\n\nerror[E0614]: type `Option<&isize>` "
  stdout: ''
  timestamp: 1660010429
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n\
    \            l3.pop();\n            l4.pop();\n        }\n        if l4.len()\
    \ == 0 {\n            l3.push(l2[0]);\n            l3.pop();\n            l4.push(l1[0]);\n\
    \            l4.pop();\n        }\n        if l3[0] == l2[0] {\n            l3.pop();\n\
    \            l3.push(l2[0]);\n            l3.pop();\n            l4.push(l1[0]);\n\
    \            l4.pop();\n            l4.push(l1[0]);\n            l4.pop();\n \
    \       }\n    }\n    l3.iter().cloned().collect()\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() > l2.len()\
    \ {\n                            result.push(l1.pop());\n                    \
    \    } else {\n                            result.push(l2.pop());\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n \
    \   assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmttszj66.rs:43:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n43 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(*l2.pop());\n        } else if l2.len() == 0 {\n        \
    \    result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0 {\n      \
    \          if l1.len() == 0 {\n                    result.push(*l2.pop());\n \
    \               } else if l2.len() == 0 {\n                    result.push(*l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(*l1.pop());\n\
    \                        } else if l2.len() == 1 {\n                         \
    \   result.push(*l2.pop());\n                        } else {\n              \
    \              let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n        \
    \                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \                          let mut j = 0;\n                            while l1.len()\
    \ != 0 || l2.len() != 0 {\n                                if l1.len() == 0 {\n\
    \                                    result.push(*l2.pop());\n               \
    \                 } else if l2.len() == 0 {\n                                \
    \    result.push(*l1.pop());\n                                } else {\n     \
    \                               if l1.len() == l2.len() {\n                  \
    \                      if l1.len() == 1 {\n                                  \
    \          result.push(*l1.pop());\n                                        }\
    \ else if l2.len() == 1 {\n                                            result.push(*l2.pop());\n\
    \                                        } else {\n                          \
    \                  if l1.len() == j {\n                                      \
    \          result.push(*l1.pop());\n                                         \
    \   } else if l2.len() == j {\n                                              \
    \  result.push(*l2.pop());\n                                            } else\
    \ {\n                                                let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                                let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                                let mut k = 0;\n            \
    \                                    while l1.len() != 0 || l2.len() != 0 {\n\
    \                                                    if l1.len() == 0 {\n    \
    \                                                    result.push(*l2.pop());\n\
    \                                                    } else if l2.len() == 0 {\n\
    \                                                        \n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpsg0tx_4f.rs:67:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - unclosed delimiter\n...\n19 |             while l1.len() !=\
    \ 0 || l2.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n24 |                 } else {\n   |             \
    \           - unclosed delimiter\n25 |                     if l1.len() == l2.len()\
    \ {\n   |                                             - unclosed delimiter\n...\n\
    30 |                         } else {\n   |                                - unclosed\
    \ delimiter\n...\n34 |                             while l1.len() != 0 || l2.len()\
    \ != 0 {\n   |                                                               \
    \   - unclosed delimiter\n...\n39 |                                 } else {\n\
    \   |                                        - unclosed delimiter\n40 |      \
    \                               if l1.len() == l2.len() {\n   |              \
    \                                               - unclosed delimiter\n...\n45\
    \ |                                         } else {\n   |                   \
    \                             - unclosed delimiter\n...\n50 |                \
    \                             } else {\n   |                                 \
    \                   - unclosed delimiter\n...\n54 |                          \
    \                       while l1.len() != 0 || l2.len() != 0 {\n   |         \
    \                                                                            \
    \ - unclosed delimiter\n...\n57 |                                            \
    \         } else if l2.len() == 0 {\n   |                                    \
    \                                         - this delimiter might not be properly\
    \ closed...\n58 |                                                         \n59\
    \ |"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.peek() == l2_iter.peek() {\n                l1_iter.next();\n\
    \                l2_iter.next();\n            } else {\n                l1_iter.next();\n\
    \                l2_iter.next();\n                result.push(*l1_iter.peek());\n\
    \            }\n        } else if l1_iter.any() {\n            l1_iter.next();\n\
    \            result.push(*l1_iter.peek());\n        } else if l2_iter.any() {\n\
    \            l2_iter.next();\n            result.push(*l2_iter.peek());\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp0wph9h7b.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmp0wph9h7b.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp0wph9h7b.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmp0wph9h7b.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `peek` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmp0wph9h7b.rs:12:24\n   |\n12 |          \
    \   if l1_iter.peek() == l2_iter.peek() {\n   |                        ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method\
    \ named `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmp0wph9h7b.rs:12:42\n\
    \   |\n12 |             if l1_iter.peek() == l2_iter.peek() {\n   |          \
    \                                ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `peek` fou"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ i = 0;\n            let mut j = 0;\n            while i < l1.len() && j < l2.len()\
    \ {\n                if l1[i] < l2[j] {\n                    i += 1;\n       \
    \         } else if l1[i] > l2[j] {\n                    j += 1;\n           \
    \     } else {\n                    result.push(l1[i]);\n                    i\
    \ += 1;\n                    j += 1;\n                }\n            }\n     \
    \       if i == l1.len() {\n                result.push(l2[j]);\n            }\
    \ else if j == l2.len() {\n                result.push(l1[i]);\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp56ee180c.rs:24:33\n   |\n\
    24 |                     result.push(l1[i]);\n   |                           \
    \      ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected\
    \ enum `Option<isize>`\n              found type `isize`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n24 |                     result.push(Some(l1[i]));\n\
    \   |                                 +++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp56ee180c.rs:30:29\n   |\n30 |                 result.push(l2[j]);\n\
    \   |                             ^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n30 |                 result.push(Some(l2[j]));\n\
    \   |                             +++++     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp56ee180c.rs:32:29\n   |\n32 |                 result.push(l1[i]);\n\
    \   |                             ^^^^^ expected enum `Option`, found `isize`\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `isize`\n\
    help: try wrapping the expression in `Some`\n   |\n32 |                 result.push(Some(l1[i]));\n\
    \   |                             +++++     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp56ee180c.rs:36:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n36 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut result = l1.clone();\n\
    \    for i in l1.iter().cloned().skip(l2.iter().cloned().count()) {\n        result.push(i);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpe2s2m8jk.rs:20:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1_iter\
    \ = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next = l1_iter.next();\n\
    \    let mut l2_next = l2_iter.next();\n    while l1_next && l2_next {\n     \
    \   if l1_next.unwrap() == l2_next.unwrap() {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1_iter.next();\n            l2_next = l2_iter.next();\n\
    \        } else {\n            if l1_next.unwrap() < l2_next.unwrap() {\n    \
    \            l1_next = l1_iter.next();\n            } else {\n               \
    \ l2_next = l2_iter.next();\n            }\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy8qu21ix.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy8qu21ix.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpy8qu21ix.rs:25:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            } else {\n     \
    \           l3.pop();\n            }\n        } else if l2.len() == 1 {\n    \
    \        l3.pop();\n        } else {\n            let mut l5 = l1.clone();\n \
    \           let mut l6 = l2.clone();\n            while l5.len() != 0 || l6.len()\
    \ != 0 {\n                if l5.len() == 0 {\n                    l6.pop();\n\
    \                    l5.pop();\n                }\n                if l6.len()\
    \ == 0 {\n                    l5.pop();\n                    l6.pop();\n     \
    \           }\n                if l5.len() == 1 && l6.len() == 1 {\n         \
    \           l5.pop();\n                    l6.pop();\n                } else {\n\
    \                    break;\n                }\n            }\n            l3.push(l5.iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpmbhj82a5.rs:60:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n32 |         } else {\n   |\
    \                - this delimiter might not be properly closed...\n...\n52 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n60 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpmbhj82a5.rs:51:20\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - closing delimiter possibly\
    \ meant for this\n...\n51 |             l3.push(l5.iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter()...\n\
    \   |                    ^ unclosed delimiter\n52 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmpmbhj82a5.rs:52:1\n\
    \   |\n52 | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmbhj82a5.rs:51:21\n\
    \   |\n51 | ...sh(l5.iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter().cloned().collect::<Vec<_>>().iter...\n\
    \   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpp19wbu8c.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l2[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n            }\n        }\n\
    \    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpirzhu5fg.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpirzhu5fg.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3.push(l1_el);\n\
    \                l1_el = l1.pop();\n                l2_el = l2.pop();\n      \
    \      }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqgp2vbwa.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpg4jkno63.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ != l2[0] {\n                break;\n            }\n            l3.pop();\n \
    \           l4.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6b20jazh.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp6b20jazh.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n\
    \    l5.sort();\n    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7\
    \ = l5.clone();\n    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n\
    \    let mut l9 = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n\
    \    l10.sort();\n    let mut l11 = l9.clone();\n    l11.sort();\n    let mut\
    \ l12 = l10.clone();\n    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n\
    \    let mut l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n\
    \    l15.sort();\n    let mut l16 = l14.clone();\n    l16.sort();\n    let mut\
    \ l17 = l15.clone();\n    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n\
    \    let mut l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n\
    \    l20.sort();\n    let mut l21 = l19.clone();\n    l21.sort();\n    let mut\
    \ l22 = l20.clone();\n    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n\
    \    let mut l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n\
    \    l25.sort();\n    let mut l26 = l24.clone();\n    l26.sort();\n    let mut\
    \ l27 = l25.clone();\n    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n\
    \    let mut l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n\
    \    l30.sort();\n    let mut l31 = l29.clone();\n    l31.sort();\n    let mut\
    \ l32 = l30.clone();\n    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n\
    \    let mut l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n\
    \    l35.sort();\n    let mut l36 = l34.clone();\n    l36.sort();\n    let mut\
    \ l37 = l35.clone();\n    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp4fsy5z3n.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != l4.len() {\n        if l3[0]\
    \ != l4[0] {\n            l3.pop();\n            l4.pop();\n        } else {\n\
    \            l3.pop();\n            l4.pop();\n        }\n    }\n    l3\n}\n\n\
    fn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpjk9lwnop.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n        let\
    \ mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n            if l1[0]\
    \ < l2[0] {\n                result.push(l1[0]);\n                l1.remove(0);\n\
    \            } else {\n                result.push(l2[0]);\n                l2.remove(0);\n\
    \            }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ l1.len() > 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n\
    \        }\n        if l2.len() > 0 {\n            result.push(l2[0]);\n     \
    \       l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpwbmvxwyo.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1[0] > l2[0] {\n                    l1.pop();\n         \
    \       } else {\n                    l2.pop();\n                }\n         \
    \       i += 1;\n            }\n            if l1.len() == 0 {\n             \
    \   result.push(l2[0]);\n            } else if l2.len() == 0 {\n             \
    \   result.push(l1[0]);\n            } else {\n                result.push(l1[0]);\n\
    \                result.push(l2[0]);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp41drte8d.rs:28:29\n   |\n\
    28 |                 result.push(l2[0]);\n   |                             ^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n28 |                 result.push(Some(l2[0]));\n   |                  \
    \           +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41drte8d.rs:30:29\n\
    \   |\n30 |                 result.push(l1[0]);\n   |                        \
    \     ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n30 |                 result.push(Some(l1[0]));\n   |      \
    \                       +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41drte8d.rs:32:29\n\
    \   |\n32 |                 result.push(l1[0]);\n   |                        \
    \     ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n32 |                 result.push(Some(l1[0]));\n   |      \
    \                       +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41drte8d.rs:33:29\n\
    \   |\n33 |                 result.push(l2[0]);\n   |                        \
    \     ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n33 |                 result.push(Some(l2[0]));\n   |      \
    \                       +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp41drte8d.rs:37:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n37 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting "
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1 = l1.to_vec();\n            let mut l2 =\
    \ l2.to_vec();\n            let mut i = 0;\n            while l1.len() != 0 ||\
    \ l2.len() != 0 {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    result.push(l1.pop());\n\
    \                } else {\n                    if l1.len() == l2.len() {\n   \
    \                     if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() > l2.len()\
    \ {\n                            result.push(l1.pop());\n                    \
    \    } else {\n                            result.push(l2.pop());\n          \
    \              }\n                    }\n                }\n                i\
    \ += 1;\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp43xdpx40.rs:44:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n44 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.iter().next().unwrap() == l2.iter().next().unwrap()\
    \ {\n                l3.push(l1.pop());\n                l3.push(l2.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n            }\n   \
    \     }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxn31zk8n.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        let mut found\
    \ = false;\n        if l1.len() != 0 {\n            if l2.len() != 0 {\n     \
    \           if l1.pop().unwrap() == l2.pop().unwrap() {\n                    found\
    \ = true;\n                }\n            } else {\n                found = true;\n\
    \            }\n        }\n        if !found {\n            result.push(*l1.pop().unwrap());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmphh4d0ufz.rs:22:25\n\
    \   |\n22 |             result.push(*l1.pop().unwrap());\n   |               \
    \          ^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut l3 = l2.clone();\n    l3.sort();\n    let mut l4 = result.clone();\n\
    \    l4.sort();\n    while l4.len() != 0 {\n        if l4.contains(&l3[0]) {\n\
    \            l4.remove(l3[0]);\n        } else {\n            l3.pop();\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6znqdil6.rs:15:23\n   |\n\
    15 |             l4.remove(l3[0]);\n   |                       ^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n15 |             l4.remove(l3[0].try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut result = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2[0]);\n            l2.remove(0);\n        } else if l2.len()\
    \ == 0 {\n            result.push(l1[0]);\n            l1.remove(0);\n       \
    \ } else {\n            if l1[0] < l2[0] {\n                result.push(l1[0]);\n\
    \                l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 2, 3, 4, 5, 5, 5, 7, 9, 34, 121, 653, 653]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpsozul8nh.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj8gejo5d.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.pop() == l2.pop() {\n                l3.push(l1.pop());\n\
    \            } else {\n                break;\n            }\n        }\n    }\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6endsj9j.rs:23:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        }\n       \
    \ if l4.len() == 0 {\n            l4.push(l3.pop());\n        }\n        if l3[0]\
    \ == l4[0] {\n            l3.remove(0);\n            l4.remove(0);\n        }\
    \ else {\n            l3.remove(0);\n            l4.push(l3.pop());\n        }\n\
    \    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfn0mwicc.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfn0mwicc.rs:16:21\n   |\n16 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfn0mwicc.rs:23:21\n   |\n23 |  \
    \           l4.push(l3.pop());\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppi_sd2le.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppi_sd2le.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmppi_sd2le.rs:18:20\n     |\n18   |\
    \     l1.into_iter().cloned().collect()\n     |                    ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&_`\n   \
    \                  found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmppi_sd2le.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect()\n   |                     \
    \          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next\
    \ = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n    while l1_next\
    \ && l2_next {\n        if l1_next.unwrap() == l2_next.unwrap() {\n          \
    \  result.remove(l1_next.unwrap());\n            l1_next = l1_iter.next();\n \
    \           l2_next = l2_iter.next();\n        } else {\n            l1_next =\
    \ l1_iter.next();\n            l2_next = l2_iter.next();\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsnnjro3i.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsnnjro3i.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsnnjro3i.rs:14:27\n   |\n14 |             result.remove(l1_next.unwrap());\n\
    \   |                           ^^^^^^^^^^^^^^^^ expected `usize`, found `&isize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(a,\
    \ b)| a == b).collect()\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpv3xf8c13.rs:11:55\n\
    \     |\n11   |     l3.iter().zip(l4.iter()).filter(|&(a, b)| a == b).collect()\n\
    \     |                                                       ^^^^^^^ value of\
    \ type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize, &isize)>`\n\
    \     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n   \
    \     let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n        while l1.len()\
    \ != l2.len() {\n            if l1.len() == 0 {\n                l1.pop();\n \
    \               break;\n            }\n            if l2.len() == 0 {\n      \
    \          l2.pop();\n                break;\n            }\n            if l1.len()\
    \ == 1 {\n                l1.pop();\n                l2.pop();\n             \
    \   break;\n            }\n            if l2.len() == 1 {\n                l1.pop();\n\
    \                l2.pop();\n                break;\n            }\n          \
    \  if l1.len() == 2 {\n                l1.pop();\n                l2.pop();\n\
    \                break;\n            }\n            if l2.len() == 2 {\n     \
    \           l1.pop();\n                l2.pop();\n                break;\n   \
    \         }\n            if l1.len() == 3 {\n                l1.pop();\n     \
    \           l2.pop();\n                break;\n            }\n            if l2.len()\
    \ == 3 {\n                l1.pop();\n                l2.pop();\n             \
    \   break;\n            }\n            if l1.len() == 4 {\n                l1.pop();\n\
    \                l2.pop();\n                break;\n            }\n          \
    \  if l2.len() == 4 {\n                l1.pop();\n                l2.pop();\n\
    \                break;\n            }\n            if l1.len() == 5 {\n     \
    \           l1.pop();\n                l2.pop();\n                break;\n   \
    \         }\n            if l2.len() == 5 {\n                l1.pop();\n     \
    \           l2.pop();\n                break;\n            }\n            if l1.len()\
    \ == 6 {\n                l1.pop();\n                l2.pop();\n             \
    \   break;\n            }\n            if l2.len() == 6 {\n                l1.pop();\n\
    \                l2.pop();\n                break;\n            }\n          \
    \  if l1.len() == 7 {\n                l1.pop();\n                l2.pop();\n\
    \                break;\n            }\n            if l2.len() == 7 {\n     \
    \           l1.pop();\n                l2.pop();\n                break;\n   \
    \         }\n            if l1.len() == 8 {\n                l1.pop();\n     \
    \           l2.pop();\n                break;\n            }\n            if l2.len()\
    \ == 8 {\n                l1.pop();\n                l2.pop();\n             \
    \   break;\n            }\n            if l1.len() == 9 {\n                l1.pop();\n\
    \                l2.pop();\n                break;\n            }\n          \
    \  if l2.len() == 9 {\n                l1.pop();\n                l2.\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcr4o1ev8.rs:123:3\n\
    \    |\n6   | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n    |\
    \                                                         - unclosed delimiter\n\
    ...\n9   |     while l1.len() != l2.len() {\n    |                           \
    \     - unclosed delimiter\n...\n18  |         while l1.len() != l2.len() {\n\
    \    |                                    - unclosed delimiter\n...\n112 |   \
    \          if l2.len() == 9 {\n    |                              - this delimiter\
    \ might not be properly closed...\n...\n115 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n123 | }\n    |   ^\n\nerror: unexpected\
    \ token: `}`\n   --> /tmp/tmpcr4o1ev8.rs:115:1\n    |\n115 | }\n    | ^\n\nerror[E0308]:\
    \ mismatched types\n   --> /tmp/tmpcr4o1ev8.rs:114:17\n    |\n112 | /        \
    \     if l2.len() == 9 {\n113 | |                 l1.pop();\n114 | |         \
    \        l2.\n    | |                 ^^ expected `()`, found struct `Vec`\n115\
    \ | | }\n    | |_- expected this to be `()`\n    |\n    = note: expected unit\
    \ type `()`\n                  found struct `Vec<isize>`\nhelp: you might have\
    \ meant to return this value\n    |\n114 |                 return l2;.\n    |\
    \                 ++++++   +\n\nerror[E0308]: mismatched types\n   --> /tmp/tmpcr4o1ev8.rs:9:5\n\
    \    |\n6   |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n  \
    \  |                                                ---------- expected `Vec<isize>`\
    \ because of return type\n...\n9   | /     while l1.len() != l2.len() {\n10  |\
    \ |         if l1.len() == 0 {\n11  | |             break;\n12  | |         }\n\
    ...   |\n122 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n123 | | }\n    | |__^ expected struct `Vec`, found `()`\n\
    \    |\n    = note: expected struct `Vec<isize>`\n            found unit type\
    \ `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().collect()\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgn2cx73o.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgn2cx73o.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        }\n        let mut l3_iter =\
    \ l3.iter().cloned();\n        let mut l4_iter = l4.iter().cloned();\n       \
    \ if l3_iter.next().unwrap() != l4_iter.next().unwrap() {\n            l3.push(l3_iter.next().unwrap());\n\
    \            l4.push(l4_iter.next().unwrap());\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xrdlyb3.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3xrdlyb3.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n\
    \    l3.dedup();\n    l3.dedup();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpgjd44div.rs:22:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1.front() == l2.front() {\n                    l1.pop();\n\
    \                    l2.pop();\n                } else {\n                   \
    \ i += 1;\n                }\n            }\n            if l1.len() == 0 {\n\
    \                result.push(l2.pop());\n            } else if l2.len() == 0 {\n\
    \                result.push(l1.pop());\n            } else {\n              \
    \  result.push(l1.pop());\n                result.push(l2.pop());\n          \
    \  }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp1x9imk2h.rs:20:23\n   |\n20 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmp1x9imk2h.rs:20:37\n   |\n20\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1x9imk2h.rs:37:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n37 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1.iter().next().unwrap()\
    \ == l2.iter().next().unwrap() {\n                    l3.push(l1.pop());\n   \
    \                 l3.push(l2.pop());\n                } else {\n             \
    \       l3.push(l1.pop());\n                }\n            } else {\n        \
    \        if l1.iter().next().unwrap() < l2.iter().next().unwrap() {\n        \
    \            l3.push(l1.pop());\n                } else {\n                  \
    \  l3.push(l2.pop());\n                }\n            }\n        }\n    }\n  \
    \  l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps666niib.rs:32:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmpcn_jzc3c.rs:17:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.last() == l2.last() {\n                l3.push(l1.pop());\n\
    \                l1.pop();\n            } else {\n                l3.push(l1.pop());\n\
    \                l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp84eesi56.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.len() == l2.len() {\n                let\
    \ mut i = 0;\n                while i < l1.len() {\n                    if l1[i]\
    \ != l2[i] {\n                        break;\n                    }\n        \
    \            i += 1;\n                }\n                if i == l1.len() {\n\
    \                    l3.push(l1.pop());\n                } else {\n          \
    \          l3.push(l2.pop());\n                }\n            } else {\n     \
    \           l3.push(l1.pop());\n                l3.push(l2.pop());\n         \
    \   }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwh9lb5ku.rs:35:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n\
    \                if l1[i] < l2[i] {\n                    result.push(l1.pop());\n\
    \                } else {\n                    result.push(l2.pop());\n      \
    \          }\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp99l2q8q.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(*l2.pop());\n        } else if l2.len() == 0 {\n        \
    \    result.push(*l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(*l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(*l1.pop());\n                } else\
    \ {\n                    if l1.len() == l2.len() {\n                        if\
    \ l1.len() == 1 {\n                            result.push(*l1.pop());\n     \
    \                   } else if l2.len() == 1 {\n                            result.push(*l2.pop());\n\
    \                        } else {\n                            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                            while l1.len() != 0 || l2.len() != 0 {\n        \
    \                        if l1.len() == 0 {\n                                \
    \    result.push(*l2.pop());\n                                } else if l2.len()\
    \ == 0 {\n                                    result.push(*l1.pop());\n      \
    \                          } else {\n                                    if l1.len()\
    \ == l2.len() {\n                                        if l1.len() == 1 {\n\
    \                                            result.push(*l1.pop());\n       \
    \                                 } else if l2.len() == 1 {\n                \
    \                            result.push(*l2.pop());\n                       \
    \                 } else {\n                                            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                             \
    \               let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n       \
    \                                     while l1.len() != 0 || l2.len() != 0 {\n\
    \                                                if l1.len() == 0 {\n        \
    \                                            result.push(*l2.pop());\n       \
    \                                         } else if l2.len() == 0 {\n        \
    \                                            result.push(*l1.pop());\n       \
    \                                         } else {\n                         \
    \                           if l1.len() == l2.len() {\n                      \
    \                                  if l1.len() == 1 {\n                      \
    \                                      result.push(*l1.pop());\n             \
    \                                           } else if l2.len() == 1 {\n      \
    \                                                      result.push(*l2.pop());\n\
    \                                                        } else {\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1ilocupd.rs:66:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n15 |         } else {\n   |\
    \                - unclosed delimiter\n...\n18 |             while l1.len() !=\
    \ 0 || l2.len() != 0 {\n   |                                                 \
    \ - unclosed delimiter\n...\n23 |                 } else {\n   |             \
    \           - unclosed delimiter\n24 |                     if l1.len() == l2.len()\
    \ {\n   |                                             - unclosed delimiter\n...\n\
    29 |                         } else {\n   |                                - unclosed\
    \ delimiter\n...\n32 |                             while l1.len() != 0 || l2.len()\
    \ != 0 {\n   |                                                               \
    \   - unclosed delimiter\n...\n37 |                                 } else {\n\
    \   |                                        - unclosed delimiter\n38 |      \
    \                               if l1.len() == l2.len() {\n   |              \
    \                                               - unclosed delimiter\n...\n43\
    \ |                                         } else {\n   |                   \
    \                             - unclosed delimiter\n...\n46 |                \
    \                             while l1.len() != 0 || l2.len() != 0 {\n   |   \
    \                                                                            \
    \   - unclosed delimiter\n...\n51 |                                          \
    \       } else {\n   |                                                       \
    \ - unclosed delimiter\n52 |                                                 \
    \    if l1.len() == l2.len() {\n   |                                         \
    \                                    - unclosed delimiter\n...\n57 |         \
    \                                                } else {\n   |              \
    \      "
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          if l1[0] < l2[0] {\n                l3.push(l1[0]);\n             \
    \   l1.pop();\n            } else {\n                l3.push(l2[0]);\n       \
    \         l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpsl5cngt1.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n        if\
    \ l1_iter.len() == 0 {\n            l1.clear();\n            l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    \        }\n        if l2_iter.len() == 0 {\n            l2.clear();\n       \
    \     l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n        }\n        let\
    \ mut l1_next = l1_iter.next();\n        let mut l2_next = l2_iter.next();\n \
    \       while l1_next.unwrap() != l2_next.unwrap() {\n            result.push(l1_next.unwrap());\n\
    \            l1_next = l1_iter.next();\n            l2_next = l2_iter.next();\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp81q5bu1w.rs:21:35\n   |\n21 |         let mut l1_next\
    \ = l1_iter.next();\n   |                                   ^^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp81q5bu1w.rs:22:35\n   |\n22 |         let\
    \ mut l2_next = l2_iter.next();\n   |                                   ^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `next` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp81q5bu1w.rs:25:31\n\
    \   |\n25 |             l1_next = l1_iter.next();\n   |                      \
    \         ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `next` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp81q5bu1w.rs:26:31\n\
    \   |\n26 |             l2_next = l2_iter.next();\n   |                      \
    \         ^^^^ method not found in `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            if l1.len() == 0 {\n    \
    \            result.push(l2.pop());\n            } else if l2.len() == 0 {\n \
    \               result.push(l1.pop());\n            } else {\n               \
    \ result.push(l1.pop());\n                result.push(l2.pop());\n           \
    \ }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpawrp4zq0.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpawrp4zq0.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawrp4zq0.rs:34:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common:\
    \ Vec<isize> = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if\
    \ l1.len() == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n\
    \            l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n\
    \            let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n \
    \               common.push(l1_el);\n                l1_el = l1.pop();\n     \
    \           l2_el = l2.pop();\n            }\n        }\n    }\n    common\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkmy2ykbj.rs:19:29\n   |\n\
    19 |                 common.push(l1_el);\n   |                             ^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1.iter().cloned() {\n        if l2.iter().any(|&x| x == i) {\n            result.push(i);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 653, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpjvfau_y6.rs:18:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1_el = l1.pop();\n            let mut\
    \ l2_el = l2.pop();\n            while l1_el == l2_el {\n                l3_el\
    \ = l1_el;\n                l1_el = l1.pop();\n                l2_el = l2.pop();\n\
    \            }\n            l3.push(l3_el);\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `l3_el` in this scope\n  --> /tmp/tmprp01xe05.rs:19:17\n\
    \   |\n19 |                 l3_el = l1_el;\n   |                 ^^^^^ help: a\
    \ local variable with a similar name exists: `l1_el`\n\nerror[E0425]: cannot find\
    \ value `l3_el` in this scope\n  --> /tmp/tmprp01xe05.rs:23:21\n   |\n23 |   \
    \          l3.push(l3_el);\n   |                     ^^^^^ help: a local variable\
    \ with a similar name exists: `l1_el`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmprp01xe05.rs:26:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n26 |     l3\n   |     ^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            let mut\
    \ l3_iter = l3.iter().cloned().collect::<Vec<_>>();\n            let mut l4_iter\
    \ = l4.iter().cloned().collect::<Vec<_>>();\n            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = l4_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l4_iter = \n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp6l0ni9j4.rs:43:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l3.len() != 0 || l4.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n16 |         } else {\n   |\
    \                - this delimiter might not be properly closed...\n...\n35 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n43 | }\n\
    \   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmp6l0ni9j4.rs:35:1\n\
    \   |\n35 | }\n   | ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6l0ni9j4.rs:13:21\n   |\n13 |             l3.push(l4.pop());\n\
    \   |                     ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp6l0ni9j4.rs:15:21\n   |\n15 |  \
    \           l4.push(l3.pop());\n   |                     ^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp6l0ni9j4.rs:19:51\n     |\n19   |\
    \             let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \     |                                                   ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected reference `&_`\n              \
    \       found type `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp6l0ni9j4.rs:19:60\n \
    \  |\n19 |               let mut l3_iter = l3_iter.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                              ^^^^^^^ method\
    \ cannot be called on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the follow"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        let mut i = 0;\n\
    \        let mut j = 0;\n        while l1.len() > 0 && l2.len() > 0 {\n      \
    \      if l1[0] < l2[0] {\n                result.push(l1[0]);\n             \
    \   l1.remove(0);\n            } else {\n                result.push(l2[0]);\n\
    \                l2.remove(0);\n            }\n            i += 1;\n         \
    \   j += 1;\n        }\n        if l1.len() > 0 {\n            result.push(l1[0]);\n\
    \            l1.remove(0);\n        }\n        if l2.len() > 0 {\n           \
    \ result.push(l2[0]);\n            l2.remove(0);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 5, 7, 1, 5, 9, 34, 653, 121, 653, 2, 5]`,\n right: `[1, 5, 653]`',\
    \ /tmp/tmpgo4pv0zs.rs:38:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l2[0]);\n            l4.push(l1[0]);\n\
    \            l2.pop();\n            l1.pop();\n        } else if l4.len() == 0\
    \ {\n            l4.push(l1[0]);\n            l3.push(l2[0]);\n            l1.pop();\n\
    \            l2.pop();\n        } else {\n            let mut l5 = l3.clone();\n\
    \            let mut l6 = l4.clone();\n            while l5.len() != 0 || l6.len()\
    \ != 0 {\n                if l5.len() == 0 {\n                    l5.push(l2[0]);\n\
    \                    l6.push(l1[0]);\n                    l2.pop();\n        \
    \            l1.pop();\n                } else if l6.len() == 0 {\n          \
    \          l6.push(l1[0]);\n                    l5.push(l2[0]);\n            \
    \        l1.pop();\n                    l2.pop();\n                } else {\n\
    \                    if l5[0] < l6[0] {\n                        l3.push(l2[0]);\n\
    \                        l4.push(l1[0]);\n                        l2.pop();\n\
    \                        l1.pop();\n                    } else {\n           \
    \             l3.push(l1[0]);\n                        l4.push(l2[0]);\n     \
    \                   l1.pop();\n                        l2.pop();\n           \
    \         }\n                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 0 but the
    index is 0'', /tmp/tmp8x66d4mk.rs:38:33

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 &&\
    \ l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            result.push(i as isize);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpf3pmvboj.rs:19:54\n   |\n19 |             while\
    \ l1.len() > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |           \
    \                                           ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpf3pmvboj.rs:19:68\n   |\n19 |             while l1.len()\
    \ > 0 && l2.len() > 0 && l1.front() == l2.front() {\n   |                    \
    \                                                ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf3pmvboj.rs:24:25\n   |\n24 |\
    \             result.push(i as isize);\n   |                         ^^^^^^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n24 |             result.push(Some(i as isize));\n   |                 \
    \        +++++          +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf3pmvboj.rs:27:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_len = l1.len();\n    let mut l2_len = l2.len();\n    while l1_iter.any()\
    \ || l2_iter.any() {\n        if l1_iter.any() {\n            if l2_iter.any()\
    \ {\n                if l1_iter.next().unwrap() == l2_iter.next().unwrap() {\n\
    \                    l1_len -= 1;\n                    l2_len -= 1;\n        \
    \            l1_iter.rev();\n                    l2_iter.rev();\n            \
    \    } else {\n                    l1_len -= 1;\n                    l2_len -=\
    \ 1;\n                    l1_iter.rev();\n                }\n            } else\
    \ {\n                l1_len -= 1;\n                l1_iter.rev();\n          \
    \  }\n        } else {\n            if l2_iter.any() {\n                l2_len\
    \ -= 1;\n                l2_iter.rev();\n            } else {\n              \
    \  l2_len -= 1;\n                l2_iter.rev();\n            }\n        }\n  \
    \  }\n    result.resize(l1_len);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpnu5q91ni.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpnu5q91ni.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpnu5q91ni.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpnu5q91ni.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpnu5q91ni.rs:30:24\n     |\n30   |             if l2_iter.any()\
    \ {\n     |                        ^^^- supplied 0 arguments\n     |         \
    \               |\n     |                        expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 2\
    \ arguments but 1 argument was supplied\n    --> /tmp/tmpnu5q91ni.rs:39:12\n \
    \    |\n39   |     result.resize(l1_len);\n     |            ^^^^^^ ------ supplied\
    \ 1 argument\n     |            |\n     |            expected 2 arguments\n  \
    \   |\nnote: associated function defined here\n\nerror: aborting d"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.last().unwrap() == l2.last().unwrap() {\n                l1.pop();\n \
    \               l2.pop();\n                i += 1;\n            }\n          \
    \  result.push(l1.pop());\n            result.push(l2.pop());\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzcy_m2nc.rs:28:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = vec![];\n            while l1.len() > 0 || l2.len() > 0 {\n  \
    \              if l1.len() == 0 {\n                    l3.push(l2.pop());\n  \
    \              } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    if l1.last().unwrap() == l2.last().unwrap()\
    \ {\n                        l3.push(l1.pop());\n                        l3.push(l2.pop());\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2e5erh69.rs:35:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else if l1[0]\
    \ < l2[0] {\n            l3.push(l1[0]);\n            l1.pop();\n        } else\
    \ {\n            l3.push(l2[0]);\n            l2.pop();\n        }\n    }\n  \
    \  l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpuzkqyf25.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    if l1.first() == l2.first() {\n\
    \                        l3.push(l1.pop());\n                        l3.push(l2.pop());\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            }\n        }\n    }\n    l3\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4_k5a0bf.rs:35:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n35 |     l3\n   |     ^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l2.len() == 1 {\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l1.len() == l2.len() {\n       \
    \     l3.pop();\n            l4.pop();\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010434
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l2 = l2.clone();\n    while l1.len() != l2.len() {\n        if l1.len() == 0\
    \ {\n            break;\n        }\n        if l2.len() == 0 {\n            break;\n\
    \        }\n        if l1[0] < l2[0] {\n            result.remove(0);\n      \
    \      l1.remove(0);\n        } else {\n            result.remove(0);\n      \
    \      l2.remove(0);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpio2vw2v2.rs:18:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n18 |             l1.remove(0);\n   |             ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    result.sort();\n\
    \    let mut l2 = l2.clone();\n    l2.sort();\n    while l1.len() != l2.len()\
    \ {\n        if l1.len() == 0 {\n            break;\n        }\n        if l2.len()\
    \ == 0 {\n            break;\n        }\n        if l1[l1.len() - 1] == l2[0]\
    \ {\n            result.pop();\n            l1.pop();\n            l2.pop();\n\
    \        } else {\n            break;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `l1` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp6676v3ee.rs:20:13\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |           -- help: consider changing this to be mutable:\
    \ `mut l1`\n...\n20 |             l1.pop();\n   |             ^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut i = 0;\n            let mut j = 0;\n       \
    \     while i < l1.len() && j < l2.len() {\n                if l1[i] < l2[j] {\n\
    \                    i += 1;\n                } else if l1[i] > l2[j] {\n    \
    \                j += 1;\n                } else {\n                    i += 1;\n\
    \                    j += 1;\n                }\n            }\n            if\
    \ i == l1.len() {\n                result.push(l2[j]);\n            } else {\n\
    \                result.push(l1[i]);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpktp4e8z2.rs:29:29\n   |\n\
    29 |                 result.push(l2[j]);\n   |                             ^^^^^\
    \ expected enum `Option`, found `isize`\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `isize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |                 result.push(Some(l2[j]));\n   |                  \
    \           +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpktp4e8z2.rs:31:29\n\
    \   |\n31 |                 result.push(l1[i]);\n   |                        \
    \     ^^^^^ expected enum `Option`, found `isize`\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `isize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n31 |                 result.push(Some(l1[i]));\n   |      \
    \                       +++++     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpktp4e8z2.rs:35:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n35 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_last = l1.last().unwrap();\n    let mut l2_last = l2.last().unwrap();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() {\n    \
    \        if l2_iter.any() {\n                if l1_last == l2_last {\n       \
    \             l1_last = l1_iter.next().unwrap();\n                    l2_last\
    \ = l2_iter.next().unwrap();\n                } else {\n                    l1_last\
    \ = l1_iter.next().unwrap();\n                }\n            } else {\n      \
    \          l1_last = l1_iter.next().unwrap();\n            }\n        } else {\n\
    \            l2_last = l2_iter.next().unwrap();\n        }\n        if l1_last\
    \ == l2_last {\n            result.push(*l1_last);\n            l1_last = l1_iter.next().unwrap();\n\
    \            l2_last = l2_iter.next().unwrap();\n        } else {\n          \
    \  l1_last = l1_iter.next().unwrap();\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpp0vlkh61.rs:12:19\n     |\n12   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpp0vlkh61.rs:12:36\n\
    \     |\n12   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpp0vlkh61.rs:13:20\n\
    \     |\n13   |         if l1_iter.any() {\n     |                    ^^^- supplied\
    \ 0 arguments\n     |                    |\n     |                    expected\
    \ 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpp0vlkh61.rs:14:24\n\
    \     |\n14   |             if l2_iter.any() {\n     |                       \
    \ ^^^- supplied 0 arguments\n     |                        |\n     |         \
    \               expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0vlkh61.rs:16:31\n  \
    \ |\n10 |     let mut l1_last = l1.last().unwrap();\n   |                    \
    \   ------------------ expected due to this value\n...\n16 |                 \
    \    l1_last = l1_iter.next().unwrap();\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&isize`, found `isize`\n   |                               help: consider borrowing\
    \ here: `&l1_iter.next().unwrap()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp0vlkh61.rs:17:31\n\
    \   |\n11 |     let mut l2_last = l2.last().unwrap();\n   |                  \
    \     -----------"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l3.len() != 0 || l4.len() != 0 {\n  \
    \      if l3.len() == 0 {\n            l3.push(l4.pop());\n        } else if l4.len()\
    \ == 0 {\n            l4.push(l3.pop());\n        } else {\n            if l3[0]\
    \ == l4[0] {\n                l3.remove(0);\n                l4.remove(0);\n \
    \           } else {\n                l3.remove(0);\n                l4.push(l3.pop());\n\
    \            }\n        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw4e6i6u4.rs:13:21\n   |\n\
    13 |             l3.push(l4.pop());\n   |                     ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw4e6i6u4.rs:15:21\n   |\n15 |             l4.push(l3.pop());\n   | \
    \                    ^^^^^^^^ expected `isize`, found enum `Option`\n   |\n  \
    \ = note: expected type `isize`\n              found enum `Option<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpw4e6i6u4.rs:22:25\n   |\n22 |  \
    \               l4.push(l3.pop());\n   |                         ^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n     \
    \         found enum `Option<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    for i in\
    \ l1.iter().cloned().chain(l2.iter().cloned()) {\n        if result.iter().any(|&x|\
    \ x == i) {\n            continue;\n        }\n        result.push(i);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 4, 3, 34, 653, 2, 5, 7, 9, 121]`,\n right: `[1, 5, 653]`', /tmp/tmp47x47f1f.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    l2.sort();\n    l3.sort();\n    while l1.len() != 0 || l2.len() != 0 {\n\
    \        if l1.len() == 0 {\n            l3.push(l2[0]);\n            l2.pop();\n\
    \        } else if l2.len() == 0 {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else if l1[0] < l2[0] {\n            l3.push(l1[0]);\n            l1.pop();\n\
    \        } else {\n            l3.push(l2[0]);\n            l2.pop();\n      \
    \  }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right:\
    \ `[1, 5, 653]`', /tmp/tmpjtzj_glf.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.any() == l2_iter.any() {\n                if l1_iter.any()\
    \ == l1_iter.last() {\n                    l1_iter.pop();\n                  \
    \  l2_iter.pop();\n                } else {\n                    l1_iter.pop();\n\
    \                }\n            } else {\n                l2_iter.pop();\n   \
    \         }\n        } else if l1_iter.any() {\n            l1_iter.pop();\n \
    \       } else {\n            l2_iter.pop();\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `any` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpavxm9oou.rs:10:19\n   |\n10 |     while l1_iter.any()\
    \ || l2_iter.any() {\n   |                   ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpavxm9oou.rs:10:36\n   |\n10 |     while l1_iter.any() ||\
    \ l2_iter.any() {\n   |                                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpavxm9oou.rs:11:20\n   |\n11 |         if\
    \ l1_iter.any() && l2_iter.any() {\n   |                    ^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: no method named `any` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpavxm9oou.rs:11:37\n   |\n11 |         if\
    \ l1_iter.any() && l2_iter.any() {\n   |                                     ^^^\
    \ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `any` found\
    \ for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpavxm9oou.rs:12:24\n\
    \   |\n12 |             if l1_iter.any() == l2_iter.any() {\n   |            \
    \            ^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named\
    \ `any` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpavxm9oou.rs:12:41\n\
    \   |\n12 |             if l1_iter.any() == l2_iter.any() {\n   |            \
    \                             ^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `any` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmpavxm9oou.rs:13:28\n   |\n13 |                 if l1_iter.any() ==\
    \ l1_iter.last() {\n   |                            ^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `any` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmpavxm9oou.rs:22:27\n   |\n22 |         } else if l1_iter.any()\
    \ {\n   |                           ^^^ method not found in `Vec<isize>`\n\nerror:\
    \ aborting due to 8 previous errors\n\nFor more information about this error,\
    \ try `rustc"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut common = Vec::new();\n    while l1.len() > 0\
    \ || l2.len() > 0 {\n        if l1.len() == 0 {\n            l2.pop();\n     \
    \   } else if l2.len() == 0 {\n            l1.pop();\n        } else {\n     \
    \       if l1.len() == l2.len() {\n                common = common.append(l1.pop());\n\
    \            } else {\n                common = common.append(l1.pop());\n   \
    \             common = common.append(l2.pop());\n            }\n        }\n  \
    \  }\n    common\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__wpjhsu.rs:17:40\n   |\n\
    17 |                 common = common.append(l1.pop());\n   |                 \
    \                       ^^^^^^^^ expected `&mut Vec<_>`, found enum `Option`\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp__wpjhsu.rs:17:26\n   |\n9  |     let mut common = Vec::new();\n   |\
    \                      ---------- expected due to this value\n...\n17 |      \
    \           common = common.append(l1.pop());\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<_>`\n\
    \           found unit type `()`\nnote: method `append` modifies its receiver\
    \ in-place\n  --> /tmp/tmp__wpjhsu.rs:17:33\n   |\n17 |                 common\
    \ = common.append(l1.pop());\n   |                          ------ ^^^^^^ this\
    \ call modifies `common` in-place\n   |                          |\n   |     \
    \                     you probably want to use this value after calling the method...\n\
    \   = note: ...instead of the `()` output of method `append`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp__wpjhsu.rs:19:40\n   |\n19 |              \
    \   common = common.append(l1.pop());\n   |                                  \
    \      ^^^^^^^^ expected `&mut Vec<_>`, found enum `Option`\n   |\n   = note:\
    \ expected mutable reference `&mut Vec<_>`\n                           found enum\
    \ `Option<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__wpjhsu.rs:19:26\n\
    \   |\n9  |     let mut common = Vec::new();\n   |                      ----------\
    \ expected due to this value\n...\n19 |                 common = common.append(l1.pop());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<_>`\n           found unit\
    \ type `()`\nnote: method `append` modifies its receiver in-place\n  --> /tmp/tmp__wpjhsu.rs:19:33\n\
    \   |\n19 |                 common = common.append(l1.pop());\n   |          \
    \                ------ ^^^^^^ th"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            if l1.iter().next().unwrap() == l2.iter().next().unwrap()\
    \ {\n                l3.push(l1.pop());\n                l3.push(l2.pop());\n\
    \            } else {\n                l3.push(l1.pop());\n            }\n   \
    \     }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `Option<isize>`\n    --> /tmp/tmphjt9355l.rs:24:20\n \
    \    |\n24   |     l3.into_iter().collect()\n     |                    ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=Option<isize>>`\n\
    \     |\n     = help: the trait `FromIterator<Option<isize>>` is not implemented\
    \ for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            l2.pop();\n       \
    \ } else if l2.len() == 0 {\n            l1.pop();\n        } else {\n       \
    \     let mut l1_el = l1.pop();\n            let mut l2_el = l2.pop();\n     \
    \       while l1_el == l2_el {\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n            result.push(l1_el);\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n  \
    \  assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0gvo1qh7.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            if l1.len() == l2.len() {\n                if l1[l1[0]]\
    \ == l2[l2[0]] {\n                    l3.pop();\n                    l4.pop();\n\
    \                } else {\n                    l3.pop();\n                   \
    \ l4.pop();\n                    l3.push(l1[l1[0]]);\n                    l4.push(l2[l2[0]]);\n\
    \                }\n            } else {\n                if l1[l1[0]] < l2[l2[0]]\
    \ {\n                    l3.pop();\n                    l4.pop();\n          \
    \          l3.push(l1[l1[0]]);\n                } else {\n                   \
    \ l3.pop();\n                    l4.pop();\n                    l3.push(l2[l2[0]]);\n\
    \                }\n            }\n        }\n    }\n    l3.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:20:20\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \    ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:20:33\n\
    \   |\n20 |                 if l1[l1[0]] == l2[l2[0]] {\n   |                \
    \                 ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:26:29\n\
    \   |\n26 |                     l3.push(l1[l1[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:27:29\n\
    \   |\n27 |                     l4.push(l2[l2[0]]);\n   |                    \
    \         ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n \
    \  |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpohqizic4.rs:30:20\n\
    \   |\n30 |          "
  stdout: ''
  timestamp: 1660010428
- exit_code: 0
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    let mut common = Vec::new();\n    while\
    \ i < l1.len() && j < l2.len() {\n        if l1[i] == l2[j] {\n            common.push(l1[i]);\n\
    \            i += 1;\n            j += 1;\n        } else {\n            if l1[i]\
    \ < l2[j] {\n                i += 1;\n            } else {\n                j\
    \ += 1;\n            }\n        }\n    }\n    common\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.into_iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppi_sd2le.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppi_sd2le.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmppi_sd2le.rs:18:20\n     |\n18   |\
    \     l1.into_iter().cloned().collect()\n     |                    ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&_`\n   \
    \                  found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmppi_sd2le.rs:18:29\n \
    \  |\n18 |       l1.into_iter().cloned().collect()\n   |                     \
    \          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut\
    \ l1_iter = l1.iter();\n    let mut l2_iter = l2.iter();\n    let mut l1_next\
    \ = l1_iter.next();\n    let mut l2_next = l2_iter.next();\n    while l1_next\
    \ && l2_next {\n        if l1_next.unwrap() == l2_next.unwrap() {\n          \
    \  result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n   \
    \         l2_next = l2_iter.next();\n        } else if l1_next.unwrap() < l2_next.unwrap()\
    \ {\n            result.push(l1_next.unwrap());\n            l1_next = l1_iter.next();\n\
    \        } else {\n            result.push(l2_next.unwrap());\n            l2_next\
    \ = l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb45ekk8f.rs:12:11\n   |\n\
    12 |     while l1_next && l2_next {\n   |           ^^^^^^^ expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb45ekk8f.rs:12:22\n\
    \   |\n12 |     while l1_next && l2_next {\n   |                      ^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb45ekk8f.rs:25:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n25 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found `&isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<&isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() == 0\
    \ {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n  \
    \          if l1[0] < l2[0] {\n                l3.push(l1[0]);\n             \
    \   l1.pop();\n            } else {\n                l3.push(l2[0]);\n       \
    \         l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5, 5]`,\n right: `[1, 5, 653]`', /tmp/tmpoavte9mc.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = vec![];\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            let mut l1_el = l1[0];\n            let mut l2_el = l2[0];\n    \
    \        while l1_el == l2_el {\n                l1_el = l1[0];\n            \
    \    l2_el = l2[0];\n            }\n            l3.push(l1_el);\n            l1.pop();\n\
    \            l2.pop();\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmp_suyenka.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut i =\
    \ 0;\n            while l1.len() > 0 && l2.len() > 0 {\n                if l1.get(&i)\
    \ == l2.get(&i) {\n                    i += 1;\n                } else {\n   \
    \                 break;\n                }\n            }\n            if l1.len()\
    \ > l2.len() {\n                result.push(l1.pop());\n            } else {\n\
    \                result.push(l2.pop());\n            }\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `&{integer}`\n  \
    \ --> /tmp/tmpijd4ki2o.rs:18:27\n    |\n18  |                 if l1.get(&i) ==\
    \ l2.get(&i) {\n    |                       --- -^\n    |                    \
    \   |   |\n    |                       |   slice indices are of type `usize` or\
    \ ranges of `usize`\n    |                       |   help: consider removing the\
    \ leading `&`-reference\n    |                       required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&{integer}`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n\
    \nerror[E0277]: the type `[isize]` cannot be indexed by `&{integer}`\n   --> /tmp/tmpijd4ki2o.rs:18:41\n\
    \    |\n18  |                 if l1.get(&i) == l2.get(&i) {\n    |           \
    \                          --- -^\n    |                                     |\
    \   |\n    |                                     |   slice indices are of type\
    \ `usize` or ranges of `usize`\n    |                                     |  \
    \ help: consider removing the leading `&`-reference\n    |                   \
    \                  required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `&{integer}`\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpijd4ki2o.rs:31:5\n   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>)\
    \ -> Vec<isize> {\n   |                                              ----------\
    \ expected `Vec<isize>` because of return type\n...\n31 |     result\n   |   \
    \  ^^^^^^ expected `isize`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() > 0 || l2.len() > 0 {\n\
    \                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    if l1.front() == l2.front() {\n\
    \                        l3.push(l1.pop());\n                    } else {\n  \
    \                      break;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    l3\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpo_p5omny.rs:25:27\n   |\n25 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmpo_p5omny.rs:25:41\n\
    \   |\n25 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo_p5omny.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   l3\n   |     ^^ expected `isize`, found enum `Option`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 || l2.len() != 0\
    \ {\n                if l1.len() == 0 {\n                    result.push(l2.pop());\n\
    \                    i += 1;\n                } else if l2.len() == 0 {\n    \
    \                result.push(l1.pop());\n                    i += 1;\n       \
    \         } else {\n                    if l1.len() == l2.len() {\n          \
    \              if l1.len() == 1 {\n                            result.push(l1.pop());\n\
    \                        } else {\n                            result.push(l1.pop());\n\
    \                            result.push(l2.pop());\n                        }\n\
    \                    } else {\n                        if l1.len() == 1 {\n  \
    \                          result.push(l1.pop());\n                          \
    \  result.push(l2.pop());\n                        } else {\n                \
    \            result.push(l1.pop());\n                        }\n             \
    \       }\n                }\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4,\
    \ 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8u6h33d5.rs:46:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n46 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   while l1_iter.any() || l2_iter.any() {\n        if l1_iter.any() && l2_iter.any()\
    \ {\n            if l1_iter.any() == l2_iter.any() {\n                if l1_iter.next()\
    \ == l2_iter.next() {\n                    l1_iter.next();\n                 \
    \   l2_iter.next();\n                }\n            }\n        }\n        if l1_iter.any()\
    \ {\n            result.push(*l1_iter);\n            l1_iter.next();\n       \
    \ }\n        if l2_iter.any() {\n            result.push(*l2_iter);\n        \
    \    l2_iter.next();\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpv7j6n7o4.rs:10:19\n     |\n10   |     while l1_iter.any() ||\
    \ l2_iter.any() {\n     |                   ^^^- supplied 0 arguments\n     |\
    \                   |\n     |                   expected 1 argument\n     |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 1\
    \ argument but 0 arguments were supplied\n    --> /tmp/tmpv7j6n7o4.rs:10:36\n\
    \     |\n10   |     while l1_iter.any() || l2_iter.any() {\n     |           \
    \                         ^^^- supplied 0 arguments\n     |                  \
    \                  |\n     |                                    expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpv7j6n7o4.rs:11:20\n\
    \     |\n11   |         if l1_iter.any() && l2_iter.any() {\n     |          \
    \          ^^^- supplied 0 arguments\n     |                    |\n     |    \
    \                expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpv7j6n7o4.rs:11:37\n     |\n11   |         if l1_iter.any() &&\
    \ l2_iter.any() {\n     |                                     ^^^- supplied 0\
    \ arguments\n     |                                     |\n     |            \
    \                         expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n    --> /tmp/tmpv7j6n7o4.rs:12:24\n     |\n12   |           \
    \  if l1_iter.any() == l2_iter.any() {\n     |                        ^^^- supplied\
    \ 0 arguments\n     |                        |\n     |                       \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpv7j6n7o4.rs:12:41\n\
    \     |\n12   |             if l1_iter.any() == l2_iter.any() {\n     |      \
    \                                   ^^^- supplied 0 argu"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = l1.clone();\n    let mut\
    \ l1_iter = l1.iter().cloned();\n    let mut l2_iter = l2.iter().cloned();\n \
    \   let mut l1_next = l1.iter().cloned().next();\n    let mut l2_next = l2.iter().cloned().next();\n\
    \    while l1_next != l2_next {\n        if l1_iter == l2_iter {\n           \
    \ result.push(*l1_iter);\n            l1_iter = l1_iter.next();\n            l2_iter\
    \ = l2_iter.next();\n        } else if l1_next == l2_next {\n            l1_next\
    \ = l1_iter.next();\n            l2_next = l2_iter.next();\n        } else {\n\
    \            let mut l1_value = l1_iter.peek();\n            let mut l2_value\
    \ = l2_iter.peek();\n            while l1_value == l2_value {\n              \
    \  l1_value = l1_iter.next();\n                l2_value = l2_iter.next();\n  \
    \          }\n            result.push(*l1_value);\n            l1_iter = l1_iter.next();\n\
    \            l2_iter = l2_iter.next();\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n  --> /tmp/tmpzm2vurlb.rs:13:20\n   |\n13 |         if l1_iter ==\
    \ l2_iter {\n   |            ------- ^^ ------- Cloned<std::slice::Iter<'_, isize>>\n\
    \   |            |\n   |            Cloned<std::slice::Iter<'_, isize>>\n\nerror[E0614]:\
    \ type `Cloned<std::slice::Iter<'_, isize>>` cannot be dereferenced\n  --> /tmp/tmpzm2vurlb.rs:14:25\n\
    \   |\n14 |             result.push(*l1_iter);\n   |                         ^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzm2vurlb.rs:15:23\n   |\n8  |\
    \     let mut l1_iter = l1.iter().cloned();\n   |                       ------------------\
    \ expected due to this value\n...\n15 |             l1_iter = l1_iter.next();\n\
    \   |                       ^^^^^^^^^^^^^^ expected struct `Cloned`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Cloned<std::slice::Iter<'_, isize>>`\n\
    \                found enum `Option<isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzm2vurlb.rs:16:23\n   |\n9  |     let mut l2_iter = l2.iter().cloned();\n\
    \   |                       ------------------ expected due to this value\n...\n\
    16 |             l2_iter = l2_iter.next();\n   |                       ^^^^^^^^^^^^^^\
    \ expected struct `Cloned`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Cloned<std::slice::Iter<'_, isize>>`\n                found enum `Option<isize>`\n\
    \nerror[E0599]: no method named `peek` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpzm2vurlb.rs:21:40\n   |\n21 |             let mut l1_value\
    \ = l1_iter.peek();\n   |                                        ^^^^ method not\
    \ found in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named\
    \ `peek` found for struct `Cloned` in the current scope\n  --> /tmp/tmpzm2vurlb.rs:22:40\n\
    \   |\n22 |             let mut l2_value = l2_iter.peek();\n   |             \
    \                           ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpzm2vurlb.rs:27:25\n   |\n27 | "
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len()\
    \ == 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0\
    \ {\n            result.push(l1.pop());\n        } else {\n            let mut\
    \ l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2_iter\
    \ = l2.iter().cloned().collect::<Vec<_>>();\n            let mut i = 0;\n    \
    \        let mut j = 0;\n            while l1_iter.len() != 0 || l2_iter.len()\
    \ != 0 {\n                if l1_iter.len() == 0 {\n                    result.push(l2_iter.pop());\n\
    \                    i += 1;\n                } else if l2_iter.len() == 0 {\n\
    \                    result.push(l1_iter.pop());\n                    j += 1;\n\
    \                } else {\n                    if l1_iter.peek() == l2_iter.peek()\
    \ {\n                        i += 1;\n                        j += 1;\n      \
    \              } else {\n                        i += 1;\n                   \
    \ }\n                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `peek` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmpgasrqhk_.rs:28:32\n   |\n28 |                 \
    \    if l1_iter.peek() == l2_iter.peek() {\n   |                             \
    \   ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method named `peek`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpgasrqhk_.rs:28:50\n\
    \   |\n28 |                     if l1_iter.peek() == l2_iter.peek() {\n   |  \
    \                                                ^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgasrqhk_.rs:38:5\n   |\n6  | fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                               ---------- expected `Vec<isize>` because of return\
    \ type\n...\n38 |     result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    } else if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        } else {\n            let mut l3_iter = l3.iter();\n            let mut\
    \ l4_iter = l4.iter();\n            let mut l3_next = l3_iter.next();\n      \
    \      let mut l4_next = l4_iter.next();\n            while l3_next.unwrap() !=\
    \ l4_next.unwrap() {\n                l3_next.unwrap() = l3_next.unwrap().cmp(l4_next.unwrap()).unwrap();\n\
    \                l4_next.unwrap() = l4_next.unwrap().cmp(l3_next.unwrap()).unwrap();\n\
    \                l3_next = l3_iter.next();\n                l4_next = l4_iter.next();\n\
    \            }\n            l3.push(l3_next.unwrap());\n            l4.push(l4_next.unwrap());\n\
    \        }\n    }\n    l3.into_iter().collect()\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmpkfzvy4ka.rs:24:34\n\
    \   |\n24 |                 l3_next.unwrap() = l3_next.unwrap().cmp(l4_next.unwrap()).unwrap();\n\
    \   |                 ---------------- ^\n   |                 |\n   |       \
    \          cannot assign to this expression\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpkfzvy4ka.rs:24:75\n\
    \   |\n24 |                 l3_next.unwrap() = l3_next.unwrap().cmp(l4_next.unwrap()).unwrap();\n\
    \   |                                                                        \
    \   ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0070]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpkfzvy4ka.rs:25:34\n   |\n25 |            \
    \     l4_next.unwrap() = l4_next.unwrap().cmp(l3_next.unwrap()).unwrap();\n  \
    \ |                 ---------------- ^\n   |                 |\n   |         \
    \        cannot assign to this expression\n\nerror[E0599]: no method named `unwrap`\
    \ found for enum `std::cmp::Ordering` in the current scope\n  --> /tmp/tmpkfzvy4ka.rs:25:75\n\
    \   |\n25 |                 l4_next.unwrap() = l4_next.unwrap().cmp(l3_next.unwrap()).unwrap();\n\
    \   |                                                                        \
    \   ^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkfzvy4ka.rs:29:21\n   |\n29 |             l3.push(l3_next.unwrap());\n\
    \   |                     ^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n29 |             l3.push(*l3_next.unwrap());\n\
    \   |                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkfzvy4ka.rs:30:21\n\
    \   |\n30 |             l4.push(l4_next.unwrap());\n   |                     ^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n30 |             l4.push(*l4_next.unwrap());\n   |                    \
    \ +\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0070, E0308, E0599.\nFor more information about an error"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > i && l2.len() > i {\n\
    \                if l1[i] < l2[i] {\n                    result.push(l1.pop());\n\
    \                } else {\n                    result.push(l2.pop());\n      \
    \          }\n                i += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp99l2q8q.rs:29:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    l1.sort();\n    l2.sort();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        l3.push(l2[0]);\n            l2.pop();\n        } else if l2.len() ==\
    \ 0 {\n            l3.push(l1[0]);\n            l1.pop();\n        } else {\n\
    \            if l1[0] < l2[0] {\n                l3.push(l1[0]);\n           \
    \     l1.pop();\n            } else {\n                l3.push(l2[0]);\n     \
    \           l2.pop();\n            }\n        }\n    }\n    l3\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[1, 5, 653]`', /tmp/tmpi3dlqp_w.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut i\
    \ = 0;\n    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n\
    \            result.push(l1[i]);\n            i += 1;\n        } else {\n    \
    \        i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp6lqatom3.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut l5 = l3.clone();\n    let mut l6 =\
    \ l4.clone();\n    let mut l7 = l5.clone();\n    let mut l8 = l6.clone();\n  \
    \  let mut l9 = l7.clone();\n    let mut l10 = l8.clone();\n    let mut l11 =\
    \ l9.clone();\n    let mut l12 = l10.clone();\n    let mut l13 = l11.clone();\n\
    \    let mut l14 = l12.clone();\n    let mut l15 = l13.clone();\n    let mut l16\
    \ = l14.clone();\n    let mut l17 = l15.clone();\n    let mut l18 = l16.clone();\n\
    \    let mut l19 = l17.clone();\n    let mut l20 = l18.clone();\n    let mut l21\
    \ = l19.clone();\n    let mut l22 = l20.clone();\n    let mut l23 = l21.clone();\n\
    \    let mut l24 = l22.clone();\n    let mut l25 = l23.clone();\n    let mut l26\
    \ = l24.clone();\n    let mut l27 = l25.clone();\n    let mut l28 = l26.clone();\n\
    \    let mut l29 = l27.clone();\n    let mut l30 = l28.clone();\n    let mut l31\
    \ = l29.clone();\n    let mut l32 = l30.clone();\n    let mut l33 = l31.clone();\n\
    \    let mut l34 = l32.clone();\n    let mut l35 = l33.clone();\n    let mut l36\
    \ = l34.clone();\n    let mut l37 = l35.clone();\n    let mut l38 = l36.clone();\n\
    \    let mut l39 = l37.clone();\n    let mut l40 = l38.clone();\n    let mut l41\
    \ = l39.clone();\n    let mut l42 = l40.clone();\n    let mut l43 = l41.clone();\n\
    \    let mut l44 = l42.clone();\n    let mut l45 = l43.clone();\n    let mut l46\
    \ = l44.clone();\n    let mut l47 = l45.clone();\n    let mut l48 = l46.clone();\n\
    \    let mut l49 = l47.clone();\n    let mut l50 = \n}\n\nfn main() {\n    let\
    \ candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5],\
    \ vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpes2tai5j.rs:57:1\n\
    \   |\n57 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = vec![];\n    while l1.len() != 0 ||\
    \ l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut i = 0;\n            while l1.len() != 0 && l2.len()\
    \ != 0 && l1.get(i) == l2.get(i) {\n                i += 1;\n            }\n \
    \           result.push(l1.pop());\n            result.push(l2.pop());\n     \
    \   }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsecssiun.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    let mut i = 0;\n    while i < l1.len() && i < l2.len()\
    \ {\n        if l1[i] == l2[i] {\n            i += 1;\n        } else {\n    \
    \        l1.remove(&l1[i]);\n            l2.remove(&l2[i]);\n        }\n    }\n\
    \    l1.into_iter().cloned().collect()\n}\n\nfn main() {\n    let candidate =\
    \ common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1,\
    \ 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2,\
    \ 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3,\
    \ 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68_jrzit.rs:16:23\n   |\n\
    16 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp68_jrzit.rs:17:23\n\
    \   |\n17 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmp68_jrzit.rs:20:20\n     |\n20   |\
    \     l1.into_iter().cloned().collect()\n     |                    ^^^^^^ expected\
    \ reference, found `isize`\n     |\n     = note: expected reference `&_`\n   \
    \                  found type `isize`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp68_jrzit.rs:20:29\n \
    \  |\n20 |       l1.into_iter().cloned().collect()\n   |                     \
    \          ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut l3 = l1.clone();\n    let mut l4 = l2.clone();\n\
    \    while l3.len() != 0 || l4.len() != 0 {\n        if l3.len() == 0 {\n    \
    \        l3.push(0);\n            l4.push(0);\n        }\n        if l4.len()\
    \ == 0 {\n            l4.push(0);\n            l3.push(0);\n        }\n      \
    \  if l3[0] == l2[0] {\n            l3.pop();\n            l4.pop();\n       \
    \ } else {\n            l3.pop();\n            l4.pop();\n        }\n    }\n \
    \   l3.reverse();\n    l4.reverse();\n    l3\n}\n\nfn main() {\n    let candidate\
    \ = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7,\
    \ 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3,\
    \ 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8],\
    \ Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[1, 5, 653]`', /tmp/tmp1wfhe6x4.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.to_vec();\n    let mut\
    \ l2 = l2.to_vec();\n    let mut result = Vec::new();\n    while l1.len() != 0\
    \ || l2.len() != 0 {\n        if l1.len() == 0 {\n            result.push(l2.pop());\n\
    \        } else if l2.len() == 0 {\n            result.push(l1.pop());\n     \
    \   } else {\n            let mut l1_el = l1.pop();\n            let mut l2_el\
    \ = l2.pop();\n            while l1_el == l2_el {\n                l1_el = l1.pop();\n\
    \                l2_el = l2.pop();\n            }\n            result.push(l1_el);\n\
    \            result.push(l2_el);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7wkg9bne.rs:26:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: -1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    let mut l5 = l1.clone();\n    let mut l6 =\
    \ l2.clone();\n    while l3.len() != 0 || l4.len() != 0 || l5.len() != 0 || l6.len()\
    \ != 0 {\n        if l3.len() == 0 {\n            l5.pop();\n        }\n     \
    \   if l4.len() == 0 {\n            l6.pop();\n        }\n        if l5.len()\
    \ == 0 {\n            l3.pop();\n        }\n        if l6.len() == 0 {\n     \
    \       l4.pop();\n        }\n        if l3.len() != 0 || l4.len() != 0 || l5.len()\
    \ != 0 || l6.len() != 0 {\n            if l3.len() == 0 {\n                l5.pop();\n\
    \            }\n            if l4.len() == 0 {\n                l6.pop();\n  \
    \          }\n            if l5.len() == 0 {\n                l3.pop();\n    \
    \        }\n            if l6.len() == 0 {\n                l4.pop();\n      \
    \      }\n        }\n    }\n    l1.iter().cloned().collect()\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut i = 0;\n\
    \    while i < l1.len() && i < l2.len() {\n        if l1[i] == l2[i] {\n     \
    \       i += 1;\n        } else {\n            l1.remove(&l1[i]);\n          \
    \  l2.remove(&l2[i]);\n        }\n    }\n    l1.extend(l2.into_iter().cloned());\n\
    \    l1\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:14:23\n   |\n\
    14 |             l1.remove(&l1[i]);\n   |                       ^^^^^^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptxhn3jd_.rs:15:23\n\
    \   |\n15 |             l2.remove(&l2[i]);\n   |                       ^^^^^^\
    \ expected `usize`, found `&isize`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmptxhn3jd_.rs:18:30\n     |\n18   |\
    \     l1.extend(l2.into_iter().cloned());\n     |                            \
    \  ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `isize`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\nnote: required\
    \ by a bound in `extend`\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item == &_`\n   --> /tmp/tmptxhn3jd_.rs:18:15\n    |\n18  |  \
    \   l1.extend(l2.into_iter().cloned());\n    |        ------ ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected reference, found `isize`\n    |        |\n    |        required by\
    \ a bound introduced by this call\n    |\n    = note: expected reference `&_`\n\
    \                    found type `isize`\n    = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::vec::IntoIter<isize>>`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `Cloned<std::vec::IntoIter<isize>>`\n\
    note: required by a bound in `extend`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations:"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        let mut l1_iter\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n        let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \        if l1.len() == 0 {\n            l1 = l1_iter;\n        }\n        if\
    \ l2.len() == 0 {\n            l2 = l2_iter;\n        }\n        let mut l1_iter\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n        let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n\
    \        if l1.len() == 0 {\n            l1 = l1_iter;\n        }\n        if\
    \ l2.len() == 0 {\n            l2 = l2_iter;\n        }\n        if l1.len() ==\
    \ 1 {\n            if l2.len() == 1 {\n                result.push(l1.pop().unwrap());\n\
    \                result.push(l2.pop().unwrap());\n            } else {\n     \
    \           l1 = l1_iter;\n                l2 = l2_iter;\n            }\n    \
    \    } else if l2.len() == 1 {\n            l1 = l1_iter;\n            l2 = l2_iter;\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n            let\
    \ mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n            if l1.len()\
    \ == 1 {\n                l1 = l1_iter;\n            }\n            if l2.len()\
    \ == 1 {\n                l2 = l2_iter;\n            }\n            if l1.len()\
    \ == 2 {\n                if l2.len() == 2 {\n                    result.push(l1.pop().unwrap());\n\
    \                    result.push(l2.pop().unwrap());\n                } else {\n\
    \                    l1 = l1_iter;\n                    l2 = l2_iter;\n      \
    \          }\n            } else if l2.len() == 2 {\n                l1 = l1_iter;\n\
    \                l2 = l2_iter;\n            } else {\n                let mut\
    \ l1 = l1.iter().cloned().collect::<Vec<_>>();\n                let mut l2 = l2.iter().cloned().\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpm9glp0zj.rs:71:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n38 |         } else {\n   |\
    \                - unclosed delimiter\n...\n60 |             } else {\n   |  \
    \                  - this delimiter might not be properly closed...\n...\n63 |\
    \ }\n   | - ...as it matches this but it has different indentation\n...\n71 |\
    \ }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpm9glp0zj.rs:63:1\n\
    \   |\n63 | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpm9glp0zj.rs:62:49\n\
    \   |\n62 |                 let mut l2 = l2.iter().cloned().\n   |           \
    \                                      ^ help: add `;` here\n63 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm9glp0zj.rs:10:5\n  \
    \ |\n6  |   fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                              ---------- expected `Vec<isize>`\
    \ because of return type\n...\n10 | /     while l1.len() != 0 || l2.len() != 0\
    \ {\n11 | |         let mut l1_iter = l1.iter().cloned().collect::<Vec<_>>();\n\
    12 | |         let mut l2_iter = l2.iter().cloned().collect::<Vec<_>>();\n13 |\
    \ |         if l1.len() == 0 {\n...  |\n70 | |     assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n71 | | }\n   | |__^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(_,\
    \ y)| y == Some(1)).collect()\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `Option<{integer}>`\n  --> /tmp/tmpq0vvyqpm.rs:11:49\n\
    \   |\n11 |     l3.iter().zip(l4.iter()).filter(|&(_, y)| y == Some(1)).collect()\n\
    \   |                                                 ^^ no implementation for\
    \ `&isize == Option<{integer}>`\n   |\n   = help: the trait `PartialEq<Option<{integer}>>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `(&isize, &isize)`\n\
    \    --> /tmp/tmpq0vvyqpm.rs:11:61\n     |\n11   |     l3.iter().zip(l4.iter()).filter(|&(_,\
    \ y)| y == Some(1)).collect()\n     |                                        \
    \                     ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=(&isize, &isize)>`\n     |\n     = help: the trait\
    \ `FromIterator<(&isize, &isize)>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(*l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(*l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() > 0 && l2.len() > 0 {\n\
    \                if l1[0] < l2[0] {\n                    result.push(*l1.pop());\n\
    \                    i += 1;\n                } else {\n                    result.push(*l2.pop());\n\
    \                    i += 1;\n                }\n            }\n            while\
    \ l1.len() > 0 {\n                result.push(*l1.pop());\n                i +=\
    \ 1;\n            }\n            while l2.len() > 0 {\n                result.push(*l2.pop());\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpp67m15ei.rs:12:25\n\
    \   |\n12 |             result.push(*l2.pop());\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  -->\
    \ /tmp/tmpp67m15ei.rs:14:25\n   |\n14 |             result.push(*l1.pop());\n\
    \   |                         ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpp67m15ei.rs:21:33\n   |\n21 |        \
    \             result.push(*l1.pop());\n   |                                 ^^^^^^^^^\n\
    \nerror[E0614]: type `Option<isize>` cannot be dereferenced\n  --> /tmp/tmpp67m15ei.rs:24:33\n\
    \   |\n24 |                     result.push(*l2.pop());\n   |                \
    \                 ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmpp67m15ei.rs:29:29\n   |\n29 |                 result.push(*l1.pop());\n\
    \   |                             ^^^^^^^^^\n\nerror[E0614]: type `Option<isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmpp67m15ei.rs:33:29\n   |\n33 |        \
    \         result.push(*l2.pop());\n   |                             ^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = l1.clone();\n\
    \    let mut l4 = l2.clone();\n    while l1.len() != 0 || l2.len() != 0 {\n  \
    \      if l1.len() == 0 {\n            l3.pop();\n            l4.pop();\n    \
    \    }\n        if l2.len() == 0 {\n            l3.pop();\n            l4.pop();\n\
    \        }\n        if l1.len() == 0 && l2.len() == 0 {\n            break;\n\
    \        }\n        if l1.len() == 1 {\n            if l2.len() == 1 {\n     \
    \           l3.pop();\n                l4.pop();\n            }\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l2.len() == 1 {\n            l3.pop();\n\
    \            l4.pop();\n        }\n        if l1.len() == l2.len() {\n       \
    \     let mut i = l1.iter().cloned().collect::<Vec<_>>();\n            let mut\
    \ j = l2.iter().cloned().collect::<Vec<_>>();\n            while i.len() != 0\
    \ || j.len() != 0 {\n                if i.len() == 0 {\n                    j.pop();\n\
    \                    i.pop();\n                }\n                if j.len() ==\
    \ 0 {\n                    i.pop();\n                    j.pop();\n          \
    \      }\n                if i.len() == 1 && j.len() == 1 {\n                \
    \    i.pop();\n                    j.pop();\n                }\n             \
    \   if i.len() == j.len() {\n                    let mut k = i.iter().cloned().collect::<Vec<_>>();\n\
    \                    let mut l = j.iter().cloned().collect::<Vec<_>>();\n    \
    \                while k.len() != 0 || l.len() != 0 {\n                      \
    \  if k.len() == 0 {\n                            l.pop();\n                 \
    \           k.pop();\n                        }\n                        if l.len()\
    \ == 0 {\n                            k.pop();\n                            l.pop();\n\
    \                        }\n                        if k.len() == 1 && l.len()\
    \ == 1 {\n                            k.pop();\n                            l.pop();\n\
    \                        }\n                        if k.len() == l.len() {\n\
    \                            let mut m = k.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut n = l.iter().cloned().collect::<Vec<_>>();\n\
    \                            while m.len() != 0 || n.len() != 0 {\n          \
    \                      if m.len() == 0 {\n                                   \
    \ n.pop();\n                                    m.pop();\n                   \
    \             }\n                                if n.len() == 0 {\n         \
    \                           m.pop();\n                                    n.pop();\n\
    \                                }\n                                if m.len()\
    \ == 1 && \n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz2c7wrn2.rs:88:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n11 |     while l1.len() != 0 || l2.len() != 0 {\n   |                   \
    \                       - unclosed delimiter\n...\n35 |         if l1.len() ==\
    \ l2.len() {\n   |                                 - unclosed delimiter\n...\n\
    38 |             while i.len() != 0 || j.len() != 0 {\n   |                  \
    \                              - unclosed delimiter\n...\n51 |               \
    \  if i.len() == j.len() {\n   |                                       - unclosed\
    \ delimiter\n...\n54 |                     while k.len() != 0 || l.len() != 0\
    \ {\n   |                                                        - unclosed delimiter\n\
    ...\n67 |                         if k.len() == l.len() {\n   |              \
    \                                 - unclosed delimiter\n...\n70 |            \
    \                 while m.len() != 0 || n.len() != 0 {\n   |                 \
    \                                               - this delimiter might not be\
    \ properly closed...\n...\n80 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpz2c7wrn2.rs:80:1\n   |\n80 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpz2c7wrn2.rs:11:5\n   |\n6  |   fn\
    \ common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |               \
    \                                 ---------- expected `Vec<isize>` because of\
    \ return type\n...\n11 | /     while l1.len() != 0 || l2.len() != 0 {\n12 | |\
    \         if l1.len() == 0 {\n13 | |             l3.pop();\n14 | |           \
    \  l4.pop();\n...  |\n87 | |     assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n88 | | }\n   | |__^ expected struct `Vec`, found `()`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information abou"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    l3.iter().zip(l4.iter()).filter(|&(a,\
    \ b)| *a == *b).collect()\n}\n\nfn main() {\n    let candidate = common;\n   \
    \ assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(&isize, &isize)`\n    --> /tmp/tmpdzjy6r7c.rs:11:57\n\
    \     |\n11   |     l3.iter().zip(l4.iter()).filter(|&(a, b)| *a == *b).collect()\n\
    \     |                                                         ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(&isize,\
    \ &isize)>`\n     |\n     = help: the trait `FromIterator<(&isize, &isize)>` is\
    \ not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut l3 = Vec::new();\n\
    \    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() == 0 {\n      \
    \      l3.push(l2.pop());\n        } else if l2.len() == 0 {\n            l3.push(l1.pop());\n\
    \        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  let mut l3 = Vec::new();\n            while l1.len() > 0 || l2.len() > 0 {\n\
    \                if l1.len() == 0 {\n                    l3.push(l2.pop());\n\
    \                } else if l2.len() == 0 {\n                    l3.push(l1.pop());\n\
    \                } else {\n                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n  \
    \                  let mut l3 = Vec::new();\n                    while l1.len()\
    \ > 0 || l2.len() > 0 {\n                        if l1.len() == 0 {\n        \
    \                    l3.push(l2.pop());\n                        } else if l2.len()\
    \ == 0 {\n                            l3.push(l1.pop());\n                   \
    \     } else {\n                            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                            let mut l3 = Vec::new();\n                      \
    \      while l1.len() > 0 || l2.len() > 0 {\n                                if\
    \ l1.len() == 0 {\n                                    l3.push(l2.pop());\n  \
    \                              } else if l2.len() == 0 {\n                   \
    \                 l3.push(l1.pop());\n                                } else {\n\
    \                                    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \                                    let mut l3 = Vec::new();\n              \
    \                      while l1.len() > 0 || l2.len() > 0 {\n                \
    \                        if l1.len() == 0 {\n                                \
    \            l3.push(l2.pop());\n                                        } else\
    \ if l2.len() == 0 {\n                                            l3.push(l1.pop());\n\
    \                                        } else {\n                          \
    \                  let mut l1 = l1.\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpz4bgd6f7.rs:61:3\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                                       - unclosed delimiter\n\
    ...\n10 |     while l1.len() > 0 || l2.len() > 0 {\n   |                     \
    \                   - unclosed delimiter\n...\n15 |         } else {\n   |   \
    \             - unclosed delimiter\n...\n19 |             while l1.len() > 0 ||\
    \ l2.len() > 0 {\n   |                                                - unclosed\
    \ delimiter\n...\n24 |                 } else {\n   |                        -\
    \ unclosed delimiter\n...\n28 |                     while l1.len() > 0 || l2.len()\
    \ > 0 {\n   |                                                        - unclosed\
    \ delimiter\n...\n33 |                         } else {\n   |                \
    \                - unclosed delimiter\n...\n37 |                             while\
    \ l1.len() > 0 || l2.len() > 0 {\n   |                                       \
    \                         - unclosed delimiter\n...\n42 |                    \
    \             } else {\n   |                                        - unclosed\
    \ delimiter\n...\n46 |                                     while l1.len() > 0\
    \ || l2.len() > 0 {\n   |                                                    \
    \                    - unclosed delimiter\n...\n51 |                         \
    \                } else {\n   |                                              \
    \  - this delimiter might not be properly closed...\n52 |                    \
    \                         let mut l1 = l1.\n53 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n61 | }\n   |   ^\n\nerror: unexpected\
    \ token: `}`\n  --> /tmp/tmpz4bgd6f7.rs:53:1\n   |\n53 | }\n   | ^\n\nerror: expected\
    \ `;`, found `}`\n  --> /tmp/tmpz4bgd6f7.rs:52:61\n   |\n52 |                \
    \                             let mut l1 = l1.\n   |                         \
    \                                    ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz4bgd6f7.rs:10:5\n  \
    \ |\n6  |  "
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            while l1.len() > 0 && l2.len() > 0 {\n                if l1.front()\
    \ == l2.front() {\n                    l1.pop();\n                    l2.pop();\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            result.push(l1.pop());\n            result.push(l2.pop());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpg7nwngdi.rs:19:23\n   |\n19 |             \
    \    if l1.front() == l2.front() {\n   |                       ^^^^^ method not\
    \ found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for struct\
    \ `Vec<isize>` in the current scope\n  --> /tmp/tmpg7nwngdi.rs:19:37\n   |\n19\
    \ |                 if l1.front() == l2.front() {\n   |                      \
    \               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg7nwngdi.rs:30:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n30 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common\
    \ = Vec::new();\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          common.push(l1_el);\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeff3ouvf.rs:25:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     common\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    l1.sort_unstable();\n\
    \    l2.sort_unstable();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n\
    \    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.dedup();\n\
    \    l2.dedup();\n    l1.dedup();\n    l2.dedup();\n    l1.\n}\n\nfn main() {\n\
    \    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmppqnt3gbl.rs:88:1\n   |\n88\
    \ | }\n   | ^\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    let mut l4 = l2.clone();\n    l4.sort();\n    let mut l5 = l3.clone();\n\
    \    l5.sort();\n    let mut l6 = l4.clone();\n    l6.sort();\n    let mut l7\
    \ = l5.clone();\n    l7.sort();\n    let mut l8 = l6.clone();\n    l8.sort();\n\
    \    let mut l9 = l7.clone();\n    l9.sort();\n    let mut l10 = l8.clone();\n\
    \    l10.sort();\n    let mut l11 = l9.clone();\n    l11.sort();\n    let mut\
    \ l12 = l10.clone();\n    l12.sort();\n    let mut l13 = l11.clone();\n    l13.sort();\n\
    \    let mut l14 = l12.clone();\n    l14.sort();\n    let mut l15 = l13.clone();\n\
    \    l15.sort();\n    let mut l16 = l14.clone();\n    l16.sort();\n    let mut\
    \ l17 = l15.clone();\n    l17.sort();\n    let mut l18 = l16.clone();\n    l18.sort();\n\
    \    let mut l19 = l17.clone();\n    l19.sort();\n    let mut l20 = l18.clone();\n\
    \    l20.sort();\n    let mut l21 = l19.clone();\n    l21.sort();\n    let mut\
    \ l22 = l20.clone();\n    l22.sort();\n    let mut l23 = l21.clone();\n    l23.sort();\n\
    \    let mut l24 = l22.clone();\n    l24.sort();\n    let mut l25 = l23.clone();\n\
    \    l25.sort();\n    let mut l26 = l24.clone();\n    l26.sort();\n    let mut\
    \ l27 = l25.clone();\n    l27.sort();\n    let mut l28 = l26.clone();\n    l28.sort();\n\
    \    let mut l29 = l27.clone();\n    l29.sort();\n    let mut l30 = l28.clone();\n\
    \    l30.sort();\n    let mut l31 = l29.clone();\n    l31.sort();\n    let mut\
    \ l32 = l30.clone();\n    l32.sort();\n    let mut l33 = l31.clone();\n    l33.sort();\n\
    \    let mut l34 = l32.clone();\n    l34.sort();\n    let mut l35 = l33.clone();\n\
    \    l35.sort();\n    let mut l36 = l34.clone();\n    l36.sort();\n    let mut\
    \ l37 = l35.clone();\n    l37.sort\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0615]: attempted to take value of method `sort` on type `Vec<isize>`\n\
    \  --> /tmp/tmp4fsy5z3n.rs:76:9\n   |\n76 |     l37.sort\n   |         ^^^^ method,\
    \ not a field\n   |\nhelp: use parentheses to call the method\n   |\n76 |    \
    \ l37.sort()\n   |             ++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0615`.\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = vec![];\n    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() ==\
    \ 0 {\n            result.push(l2.pop());\n        } else if l2.len() == 0 {\n\
    \            result.push(l1.pop());\n        } else {\n            let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut i = 0;\n            while l1.len() != 0 && l2.len() != 0\
    \ && l1.front() == l2.front() {\n                l1.pop();\n                l2.pop();\n\
    \                i += 1;\n            }\n            result.push(l1.pop());\n\
    \            result.push(l2.pop());\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3, 34, 653,\
    \ 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp_3el2q2b.rs:19:56\n   |\n19 |             while\
    \ l1.len() != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |         \
    \                                               ^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `front` found for struct `Vec<isize>` in the current\
    \ scope\n  --> /tmp/tmp_3el2q2b.rs:19:70\n   |\n19 |             while l1.len()\
    \ != 0 && l2.len() != 0 && l1.front() == l2.front() {\n   |                  \
    \                                                    ^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_3el2q2b.rs:28:5\n\
    \   |\n6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |  \
    \                                            ---------- expected `Vec<isize>`\
    \ because of return type\n...\n28 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n       \
    \       found struct `Vec<Option<isize>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut result = vec![];\n    let mut l1\
    \ = l1.iter().cloned().collect::<Vec<_>>();\n    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n\
    \    while l1.len() != 0 || l2.len() != 0 {\n        if l1.len() == 0 {\n    \
    \        result.push(l2.pop());\n        } else if l2.len() == 0 {\n         \
    \   result.push(l1.pop());\n        } else {\n            let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \            let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n          \
    \  while l1.len() != 0 || l2.len() != 0 {\n                if l1.len() == 0 {\n\
    \                    result.push(l2.pop());\n                } else if l2.len()\
    \ == 0 {\n                    result.push(l1.pop());\n                } else {\n\
    \                    if l1.front() == l2.front() {\n                        l1.pop();\n\
    \                        l2.pop();\n                    } else {\n           \
    \             break;\n                    }\n                }\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = common;\n\
    \    assert_eq!(candidate(vec![1, 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653,\
    \ 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5, 3, 2, 8], vec![3,\
    \ 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], vec![3, 2, 4]),\
    \ vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2, 8], Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp8iehhom2.rs:24:27\n   |\n24 |             \
    \        if l1.front() == l2.front() {\n   |                           ^^^^^ method\
    \ not found in `Vec<isize>`\n\nerror[E0599]: no method named `front` found for\
    \ struct `Vec<isize>` in the current scope\n  --> /tmp/tmp8iehhom2.rs:24:41\n\
    \   |\n24 |                     if l1.front() == l2.front() {\n   |          \
    \                               ^^^^^ method not found in `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8iehhom2.rs:34:5\n   |\n6  | fn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n   |                                      \
    \        ---------- expected `Vec<isize>` because of return type\n...\n34 |  \
    \   result\n   |     ^^^^^^ expected `isize`, found enum `Option`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Vec<Option<isize>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut common:\
    \ Vec<isize> = vec![];\n    while l1.len() > 0 || l2.len() > 0 {\n        if l1.len()\
    \ == 0 {\n            l2.pop();\n        } else if l2.len() == 0 {\n         \
    \   l1.pop();\n        } else {\n            let mut l1_el = l1.pop();\n     \
    \       let mut l2_el = l2.pop();\n            while l1_el == l2_el {\n      \
    \          common.push(l1_el);\n                l1_el = l1.pop();\n          \
    \      l2_el = l2.pop();\n            }\n        }\n    }\n    common\n}\n\nfn\
    \ main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1, 4, 3,\
    \ 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n    assert_eq!(candidate(vec![5,\
    \ 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4, 3, 2,\
    \ 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2px6vmer.rs:19:29\n   |\n\
    19 |                 common.push(l1_el);\n   |                             ^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
- exit_code: 101
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l3 = l1.clone();\n    l3.sort();\n\
    \    l3.dedup();\n    l3.sort();\n    l3.dedup();\n    l3.sort();\n    l3.dedup();\n\
    \    l3\n}\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 2, 3, 4, 5, 34, 653]`,\n right: `[1, 5, 653]`', /tmp/tmphq3ge5cj.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010428
- exit_code: 1
  program: "/// Return sorted unique common elements for two lists.\n/// >>> common(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121])\n/// vec![1, 5, 653]\n\
    /// >>> common(vec![5, 3, 2, 8], vec![3, 2])\n/// vec![2, 3]\nfn common(l1: Vec<isize>,\
    \ l2: Vec<isize>) -> Vec<isize> {\n    let mut l1 = l1.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut l2 = l2.iter().cloned().collect::<Vec<_>>();\n    let mut result\
    \ = Vec::new();\n    while l1.len() != 0 || l2.len() != 0 {\n        let mut i\
    \ = 0;\n        while l1.len() != 0 && l2.len() != 0 && l1.get(i) == l2.get(i)\
    \ {\n            i += 1;\n        }\n        if l1.len() != 0 {\n            result.push(l1.get(i));\n\
    \            l1.remove(i);\n        }\n        if l2.len() != 0 {\n          \
    \  result.push(l2.get(i));\n            l2.remove(i);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = common;\n    assert_eq!(candidate(vec![1,\
    \ 4, 3, 34, 653, 2, 5], vec![5, 7, 1, 5, 9, 653, 121]), vec![1, 5, 653]);\n  \
    \  assert_eq!(candidate(vec![5, 3, 2, 8], vec![3, 2]), vec![2, 3]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], vec![3, 2, 4]), vec![2, 3, 4]);\n    assert_eq!(candidate(vec![4,\
    \ 3, 2, 8], Vec::<isize>::new()), Vec::<isize>::new());\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpenuwth7p.rs:24:5\n   |\n\
    6  | fn common(l1: Vec<isize>, l2: Vec<isize>) -> Vec<isize> {\n   |         \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n24 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<Option<&isize>>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010429
