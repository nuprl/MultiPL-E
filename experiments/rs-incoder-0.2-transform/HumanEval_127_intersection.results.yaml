language: rs
name: HumanEval_127_intersection
results:
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![];\n    intervals.push(interval1);\n\
    \    intervals.push(interval2);\n    let mut intersection = intervals.iter().filter(|&(start,\
    \ end)| *start < *end).collect::<Vec<_>>();\n    let mut prime = true;\n    for\
    \ &(start, end) in intersection {\n        if start >= end {\n            continue;\n\
    \        }\n        if prime {\n            if start % end != 0 {\n          \
    \      prime = false;\n            }\n        } else {\n            if end % start\
    \ != 0 {\n                prime = false;\n            }\n        }\n    }\n  \
    \  if prime {\n        return \"YES\".to_string();\n    } else {\n        return\
    \ \"NO\".to_string();\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpstgio1nh.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpstgio1nh.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpstgio1nh.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpstgio1nh.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpstgio1nh.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpstgio1nh.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpstgio1nh.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpstgio1nh.rs:52:25\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpstgio1nh.rs:53:17\n  \
    \ |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpstgio1nh.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpstgio1nh.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_end < interval2_start\
    \ {\n        interval1_end = interval2_start;\n        interval1_start = interval2_end;\n\
    \    }\n    if interval2_end < interval1_start {\n        interval2_end = interval1_start;\n\
    \        interval2_start = interval1_end;\n    }\n    if interval1_end >= interval2_end\
    \ {\n        intersection_end = interval2_end;\n        intersection_start = interval2_start;\n\
    \    }\n    if interval2_end >= interval1_end {\n        intersection_end = interval1_end;\n\
    \        intersection_start = interval1_start;\n    }\n    if interval1_end >\
    \ interval2_end {\n        intersection_end = interval1_end;\n        intersection_start\
    \ = interval2_start;\n    }\n    if interval2_end > interval1_end {\n        intersection_end\
    \ = interval2_end;\n        intersection_start = interval1_start;\n    }\n   \
    \ if interval1_start < interval2_start {\n        intersection_start = interval2_start;\n\
    \        intersection_end = interval1_end;\n    }\n    if interval2_start < interval1_start\
    \ {\n        intersection_start = interval1_start;\n        intersection_end =\
    \ interval2_end;\n    }\n    if interval1_start >= interval2_start {\n       \
    \ intersection_start = interval2_start;\n        intersection_end = interval1_end;\n\
    \    }\n    if interval2_start >= interval1_start {\n        intersection_start\
    \ = interval1_start;\n        intersection_end = interval2_end;\n    }\n    if\
    \ interval1_start > interval2_start {\n        intersection_start = interval2_start;\n\
    \        intersection_end = interval1_end;\n    }\n    if interval2_start > interval1_start\
    \ {\n        intersection_start = interval1_start;\n        intersection_end =\
    \ interval2_end;\n    }\n    if interval1_end < interval2_end {\n        intersection_end\
    \ = interval2_end;\n        intersection_start = interval1_start;\n    }\n   \
    \ if interval2_end < interval1_end {\n        intersection_end = interval1_end;\n\
    \        intersection_start = interval2_start;\n    }\n    if interval1_end >=\
    \ interval2_end {\n        intersection_end = interval2_end;\n        intersection_start\
    \ = interval1_start;\n    }\n    if interval2_end >= interval1_end {\n       \
    \ intersection_end = interval1_end;\n        intersection_start = interval2_start;\n\
    \    }\n    if interval1_end \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmp5not1x0x.rs:92:1\n   |\n\
    91 |     if interval1_end \n   |     -- this `if` expression has a condition,\
    \ but no block\n92 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmp5not1x0x.rs:96:17\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp5not1x0x.rs:96:25\n \
    \  |\n96 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5not1x0x.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5not1x0x.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5not1x0x.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5not1x0x.rs:98:25\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5not1x0x.rs:99:17\n  \
    \ |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5not1x0x.rs:99:25\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp5not1x0x.rs:100:17\n    |\n\
    100 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp5not1x0x.rs:100:25\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1[1] - interval1[0] + 1;\n \
    \   let mut interval2_len = interval2[1] - interval2[0] + 1;\n    if interval_len\
    \ == 0 || interval2_len == 0 {\n        return \"NO\";\n    }\n    if interval_len\
    \ == interval2_len {\n        let mut interval1_start = interval1[0];\n      \
    \  let mut interval1_end = interval1[1];\n        let mut interval2_start = interval2[0];\n\
    \        let mut interval2_end = interval2[1];\n        if interval1_start > interval2_end\
    \ {\n            interval1_end = interval2_end;\n        }\n        if interval1_end\
    \ < interval2_start {\n            interval1_start = interval2_start;\n      \
    \  }\n        if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval_len < interval2_len {\n        let mut interval1_start = interval1[0];\n\
    \        let mut interval1_end = interval1[1];\n        let mut interval2_start\
    \ = interval2[0];\n        let mut interval2_end = interval2[1];\n        if interval1_start\
    \ > interval2_end {\n            interval1_end = interval2_end;\n        }\n \
    \       if interval1_end < interval2_start {\n            interval1_start = interval2_start;\n\
    \        }\n        if interval1_start <= interval2_start && interval1_end >=\
    \ interval2_end {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;\n    }\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp91ofo3dl.rs:76:17\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp91ofo3dl.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp91ofo3dl.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp91ofo3dl.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp91ofo3dl.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp91ofo3dl.rs:78:25\n   |\n78 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp91ofo3dl.rs:79:17\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp91ofo3dl.rs:79:25\n   |\n79 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp91ofo3dl.rs:80:17\n  \
    \ |\n80 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp91ofo3dl.rs:80:25\n   |\n80 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp91ofo3dl.rs:81:17\n   |\n81 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut interval1_length = interval2_end - interval2_start;\n\
    \    let mut interval2_length = interval1_end - interval1_start;\n    let mut\
    \ interval1_prime = true;\n    let mut interval2_prime = true;\n    let mut prime_found\
    \ = false;\n    loop {\n        if interval1_start > interval1_end {\n       \
    \     interval1_prime = false;\n            interval1_start = interval1_end;\n\
    \            interval1_end = interval1_start + 1;\n        }\n        if interval2_start\
    \ > interval2_end {\n            interval2_prime = false;\n            interval2_start\
    \ = interval2_end;\n            interval2_end = interval2_start + 1;\n       \
    \ }\n        if intersection_start > intersection_end {\n            intersection_prime\
    \ = false;\n            intersection_start = intersection_end;\n            intersection_end\
    \ = intersection_start + 1;\n        }\n        if interval1_length == interval2_length\
    \ {\n            intersection_length = intersection_end - intersection_start;\n\
    \            interval1_length = interval1_end - interval1_start;\n           \
    \ interval2_length = interval2_end - interval2_start;\n            if interval1_length\
    \ == intersection_length {\n                if interval1_prime == interval2_prime\
    \ {\n                    if interval1_prime == true {\n                      \
    \  prime_found = true;\n                    }\n                }\n           \
    \ }\n        }\n        intersection_start = intersection_end;\n        intersection_end\
    \ = intersection_start + 1;\n        interval1_start = interval1_end;\n      \
    \  interval1_end = interval1_start + 1;\n        interval2_start = interval2_end;\n\
    \        interval2_end = interval2_start + 1;\n        interval1_length = interval2_end\
    \ - interval2_start;\n        interval2_length = interval1_end - interval1_start;\n\
    \    }\n    if prime_found == true {\n        if intersection_length == 1 {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    return\
    \ \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `intersection_prime` in this scope\n  -->\
    \ /tmp/tmp25kgol6_.rs:45:13\n   |\n45 |             intersection_prime = false;\n\
    \   |             ^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `intersection_end`\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmp25kgol6_.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp25kgol6_.rs:81:25\n   |\n81 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp25kgol6_.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp25kgol6_.rs:82:25\n   |\n82 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp25kgol6_.rs:83:17\n  \
    \ |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp25kgol6_.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp25kgol6_.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp25kgol6_.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp25kgol6_.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp25kgol6_.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |        "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_end > interval2_start {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval2_start = interval1_start;\n    }\n    if interval1_start < interval2_start\
    \ {\n        interval1_start = interval2_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_start > interval2_start\
    \ {\n        return \"NO\";\n    }\n    return \"YES\";\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_prdoebk.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_prdoebk.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_prdoebk.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_prdoebk.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_prdoebk.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_prdoebk.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_prdoebk.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_prdoebk.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_prdoebk.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_prdoebk.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_prdoebk.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n    if interval1_start < interval2_start {\n      \
    \  interval1_start = interval2_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n    if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start <= interval2_start {\n        return \"NO\";\n\
    \    }\n    if interval1_end >= interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start < interval2_start {\n        return \"YES\";\n    }\n\
    \    if interval1_end > interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_start <= interval2_start {\n        return \"YES\";\n    }\n    if\
    \ interval1_end >= interval2_end {\n        return \"YES\";\n    }\n    if interval1_start\
    \ < interval2_start {\n        return \"YES\";\n    }\n    if interval1_end >\
    \ interval2_end {\n        return \"YES\";\n    }\n    if interval1_start <= interval2_start\
    \ {\n        return \"YES\";\n    }\n    if interval1_end >= interval2_end {\n\
    \        return \"YES\";\n    }\n    if interval1_start < interval2_start {\n\
    \        return \"YES\";\n    }\n    if interval1_end > interval2_end {\n    \
    \    return \"YES\";\n    }\n    return \"YES\";\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxoewj61m.rs:81:17\n\
    \   |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxoewj61m.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxoewj61m.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxoewj61m.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxoewj61m.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxoewj61m.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxoewj61m.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxoewj61m.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxoewj61m.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxoewj61m.rs:85:25\n   |\n85 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxoewj61m.rs:86:17\n   |\n86 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut intersection_len\
    \ = interval1_len + interval2_len;\n    let mut prime_flag = false;\n    \n  \
    \  if interval1_len > interval2_len {\n        interval1_len = interval2_len;\n\
    \        interval2_len = interval1_len;\n        interval1_start = interval2[0];\n\
    \        interval1_end = interval2[1];\n    }\n    \n    if interval1_len == interval2_len\
    \ {\n        if interval1_start <= interval2_start {\n            interval1_start\
    \ = interval2_start;\n            interval1_end = interval2_end;\n        } else\
    \ {\n            interval2_start = interval1_start;\n            interval2_end\
    \ = interval1_end;\n        }\n    }\n    \n    if interval1_len == 1 {\n    \
    \    prime_flag = true;\n    }\n    \n    if interval2_len == 1 {\n        prime_flag\
    \ = true;\n    }\n    \n    if prime_flag {\n        if interval1_start <= interval2_start\
    \ {\n            intersection_len += 1;\n        } else {\n            intersection_len\
    \ += 1;\n        }\n    }\n    \n    if prime_flag {\n        if interval1_end\
    \ >= interval2_end {\n            intersection_len += 1;\n        } else {\n \
    \           intersection_len += 1;\n        }\n    }\n    \n    if prime_flag\
    \ {\n        if interval1_end >= interval2_end {\n            intersection_len\
    \ += 1;\n        } else {\n            intersection_len += 1;\n        }\n   \
    \ }\n    \n    if prime_flag {\n        if interval1_end >= interval2_end {\n\
    \            intersection_len += 1;\n        } else {\n            intersection_len\
    \ += 1;\n        }\n    }\n    \n    if prime_flag {\n        if interval1_end\
    \ >= interval2_end {\n            intersection_len += 1;\n        } else {\n \
    \           intersection_len += 1;\n        }\n    }\n    \n    if prime_flag\
    \ {\n        if interval1_end >= interval2_end {\n            intersection_len\
    \ += 1;\n        } else {\n            intersection_len += 1;\n        }\n   \
    \ }\n    \n    if prime_flag {\n        if interval1_end >= interval2_end {\n\
    \            intersection_len += 1;\n        } else {\n            intersection_len\
    \ += 1;\n        }\n    }\n    \n    if prime_flag {\n        if interval1_end\
    \ >= interval2_end {\n            intersection_len += 1;\n        } else {\n \
    \           intersection_len += 1;\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2tgvnugh.rs:129:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n111 |     if prime_flag {\n\
    \    |                   - unclosed delimiter\n...\n114 |         } else {\n \
    \   |                - this delimiter might not be properly closed...\n...\n117\
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n129\
    \ | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp2tgvnugh.rs:121:17\n    |\n121 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp2tgvnugh.rs:121:25\n    |\n121 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp2tgvnugh.rs:122:17\n    |\n122 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp2tgvnugh.rs:122:25\n    |\n122 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp2tgvnugh.rs:123:17\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp2tgvnugh.rs:123:25\n    |\n123 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp2tgvnugh.rs:124:17\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp2tgvnugh.rs:124:25\n    |\n124 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n\n    if\
    \ interval1_end < interval2_start {\n        interval1_start = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n\n    if interval1_end == interval2_end\
    \ {\n        if interval1_start == interval2_start {\n            return \"YES\"\
    .to_string();\n        } else {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n\n    let mut intersection_length = 0;\n    let mut interval1_length\
    \ = interval1_end - interval1_start;\n    let mut interval2_length = interval2_end\
    \ - interval2_start;\n\n    while interval1_length >= interval2_length {\n   \
    \     interval1_length -= interval2_length;\n        intersection_length += 1;\n\
    \    }\n\n    while interval2_length >= interval1_length {\n        interval2_length\
    \ -= interval1_length;\n        intersection_length += 1;\n    }\n\n    if intersection_length\
    \ == 2 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\".to_string();\n        } else {\n            return \"NO\".to_string();\n\
    \        }\n    }\n\n    if intersection_length == 1 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\".to_string();\n        } else\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n\n    if intersection_length\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb373f4h4.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb373f4h4.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb373f4h4.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb373f4h4.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb373f4h4.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb373f4h4.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb373f4h4.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb373f4h4.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb373f4h4.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb373f4h4.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb373f4h4.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_start == interval1_end {\n     \
    \   return \"NO\";\n    }\n    if interval1_start > interval2_end {\n        return\
    \ \"NO\";\n    }\n    if interval1_end < interval2_start {\n        return \"\
    NO\";\n    }\n    if interval1_start == interval1_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n    if interval1_start == interval1_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_start < interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start == interval1_end {\n        return \"NO\";\n    }\n  \
    \  if interval1_start > interval2_end {\n        return \"NO\";\n    }\n    if\
    \ interval1_end > interval2_start {\n        return \"NO\";\n    }\n    if interval1_start\
    \ == interval1_end {\n        return \"NO\";\n    }\n    if interval1_start >\
    \ interval2_end {\n        return \"NO\";\n    }\n    if interval1_end < interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_start == interval1_end {\n\
    \        return \"NO\";\n    }\n    if interval1_start < interval2_end {\n   \
    \     return \"NO\";\n    }\n    if interval1_start == interval1_end {\n     \
    \   return \"NO\";\n    }\n    if interval1_start < interval2_end {\n        return\
    \ \"NO\";\n    }\n    if interval1_start == interval1_end {\n        return \"\
    NO\";\n    }\n    if interval1_start > interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_end > interval2_start {\n        return \"NO\";\n \
    \   }\n    if interval1_start == interval1_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_start > interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n   \
    \ if interval1_start == interval1_end {\n        return \"NO\";\n    }\n    if\
    \ interval1_start < interval2_end \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpckpg9ida.rs:110:1\n    |\n\
    109 |     if interval1_start < interval2_end \n    |     -- this `if` expression\
    \ has a condition, but no block\n110 | }\n    | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpckpg9ida.rs:114:17\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpckpg9ida.rs:114:25\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpckpg9ida.rs:115:17\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpckpg9ida.rs:115:25\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpckpg9ida.rs:116:17\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpckpg9ida.rs:116:25\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpckpg9ida.rs:117:17\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpckpg9ida.rs:117:25\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpckpg9ida.rs:118:17\n\
    \    |\n118 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpckpg9ida.rs:118:25\n    |\n118 |     assert_eq!({left}, {right});\n\
    \    |    "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n\n    if interval1_start > interval1_end {\n    \
    \    return \"NO\";\n    }\n\n    if interval2_start > interval2_end {\n     \
    \   return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_start < interval2_start {\n  \
    \      return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n    \
    \    return \"NO\";\n    }\n\n    if interval1_end < interval2_end {\n       \
    \ return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n        return\
    \ \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n        return \"\
    NO\";\n    }\n\n    if interval1_end == interval2_end {\n        return \"NO\"\
    ;\n    }\n\n    if interval1_end < interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n   \
    \ }\n\n    if interval1_end > interval2_end {\n        return \"NO\";\n    }\n\
    \n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\n \
    \   if interval1_end < interval2_end {\n        return \"NO\";\n    }\n\n    if\
    \ interval1_end == interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end\
    \ > interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end ==\
    \ interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end < interval2_end\
    \ {\n        return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n\
    \        return \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n     \
    \   return \"NO\";\n    }\n\n    if interval1_end < interval2_end {\n        return\
    \ \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n        return \"\
    NO\";\n    }\n\n    if interval1_end > interval2_end {\n        return \"NO\"\
    ;\n    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end < interval2_end {\n        return \"NO\";\n   \
    \ }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\
    \n\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:146:17\n\
    \    |\n146 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ghhrbqo.rs:146:25\n    |\n146 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:147:17\n\
    \    |\n147 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ghhrbqo.rs:147:25\n    |\n147 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:148:17\n\
    \    |\n148 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ghhrbqo.rs:148:25\n    |\n148 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:149:17\n\
    \    |\n149 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ghhrbqo.rs:149:25\n    |\n149 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:150:17\n\
    \    |\n150 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ghhrbqo.rs:150:25\n    |\n150 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ghhrbqo.rs:151:17\n\
    \    |\n151 |     assert_eq!({left}, {right});\n    |                 ^^^^"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    \n    if interval1_start\
    \ > interval2_start {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval1_start = interval2_start;\n    }\n    \n\
    \    while interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start\
    \ += 1;\n        }\n        if interval1_end > interval2_end {\n            interval1_end\
    \ -= 1;\n        }\n        if interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n            intersection_length += 1;\n        }\n     \
    \   interval2_start += 1;\n        interval2_end -= 1;\n    }\n    \n    if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n        intersection_length\
    \ += 1;\n    }\n    \n    if intersection_length == 2 {\n        return \"YES\"\
    .to_string();\n    }\n    \n    if intersection_length == 1 {\n        return\
    \ \"NO\".to_string();\n    }\n    \n    if intersection_length == 0 {\n      \
    \  return \"NO\".to_string();\n    }\n    \n    return \"NO\".to_string();\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgy2ilgug.rs:71:17\n\
    \   |\n71 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgy2ilgug.rs:71:25\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgy2ilgug.rs:72:17\n   |\n72 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgy2ilgug.rs:72:25\n\
    \   |\n72 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgy2ilgug.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgy2ilgug.rs:73:25\n   |\n73 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgy2ilgug.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgy2ilgug.rs:74:25\n   |\n74 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgy2ilgug.rs:75:17\n  \
    \ |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgy2ilgug.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgy2ilgug.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1.0 > interval2.0\
    \ {\n        interval = interval2;\n    }\n    let mut start = interval.0;\n \
    \   let mut end = interval.1;\n    let mut intersect_len = 0;\n    let mut prime\
    \ = true;\n    while start < end {\n        if start % end != 0 {\n          \
    \  prime = false;\n            break;\n        }\n        intersect_len += 1;\n\
    \        start += 1;\n    }\n    if prime {\n        return String::from(\"YES\"\
    );\n    }\n    return String::from(\"NO\");\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsptmcza2.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsptmcza2.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsptmcza2.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsptmcza2.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsptmcza2.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsptmcza2.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsptmcza2.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsptmcza2.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsptmcza2.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsptmcza2.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsptmcza2.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n\n    if interval1_start > interval2_end {\n      \
    \  interval1_end = interval2_end;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_start = interval2_start;\n    }\n\n    if interval1_start\
    \ == interval1_end {\n        return String::from(\"NO\");\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        if interval1_end % interval1_start == 0 {\n     \
    \       return \"YES\";\n        }\n    }\n    if interval1_start > interval2_end\
    \ {\n        if interval1_end % interval1_start == 0 {\n            return \"\
    YES\";\n        }\n    }\n    if interval1_start < interval2_start {\n       \
    \ if interval1_end % interval1_start == 0 {\n            return \"YES\";\n   \
    \     }\n    }\n    if interval1_start > interval2_start {\n        if interval1_end\
    \ % interval1_start == 0 {\n            return \"YES\";\n        }\n    }\n\n\
    \    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpk_biuogt.rs:70:17\n\
    \   |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpk_biuogt.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpk_biuogt.rs:71:17\n   |\n71 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpk_biuogt.rs:71:25\n\
    \   |\n71 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpk_biuogt.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpk_biuogt.rs:72:25\n   |\n72 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpk_biuogt.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpk_biuogt.rs:73:25\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpk_biuogt.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpk_biuogt.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpk_biuogt.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1.0 > interval2.0\
    \ {\n        interval = interval2;\n    }\n    let mut len = 0;\n    while interval.0\
    \ != interval.1 {\n        len += 1;\n        interval.0 += 1;\n    }\n    if\
    \ len == 2 {\n        if interval1.0 < interval2.0 {\n            if interval1.0\
    \ > interval2.0 {\n                return String::from(\"NO\");\n            }\n\
    \            return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if len % 2 == 0 {\n        return String::from(\"NO\");\n \
    \   }\n    if len % 3 == 0 {\n        return String::from(\"YES\");\n    }\n \
    \   return String::from(\"NO\");\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpprc5yno3.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpprc5yno3.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpprc5yno3.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpprc5yno3.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpprc5yno3.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpprc5yno3.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpprc5yno3.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpprc5yno3.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpprc5yno3.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpprc5yno3.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpprc5yno3.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    if interval1_start\
    \ > interval2_end {\n        interval1_end = interval2_end;\n        interval2_start\
    \ = interval1_start;\n    }\n    if interval1_end < interval2_start {\n      \
    \  interval1_end = interval2_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        intersection_length\
    \ = interval1_end - interval2_start;\n    }\n    if intersection_length == 0 {\n\
    \        return \"NO\";\n    }\n    if intersection_length == 1 {\n        return\
    \ \"YES\";\n    }\n    if intersection_length == 2 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n    }\n    if intersection_length\
    \ == 3 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n    }\n    if intersection_length == 4 {\n   \
    \     if interval1_start == interval2_start {\n            return \"YES\";\n \
    \       }\n        if interval1_end == interval2_end {\n            return \"\
    YES\";\n        }\n    }\n    if intersection_length == 5 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n    }\n    if intersection_length\
    \ == 6 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n    }\n    if intersection_length == 7 {\n   \
    \     if interval1_start == interval2_start {\n            return \"YES\";\n \
    \       }\n        if interval1_end == interval2_end {\n            return \"\
    YES\";\n        }\n    }\n    if intersection_length == 8 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n    }\n    if intersection_length\
    \ == 9 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n    }\n    if intersection_length == 10 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        if interval1_end == interval2_end \n}\n\nfn main() {\n   \
    \ let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpld_5ztii.rs:124:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n107 |     if intersection_length\
    \ == 10 {\n    |                                  - this delimiter might not be\
    \ properly closed...\n...\n112 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n124 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpld_5ztii.rs:112:1\n    |\n111 |         if interval1_end == interval2_end\
    \ \n    |         -- this `if` expression has a condition, but no block\n112 |\
    \ }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpld_5ztii.rs:116:17\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpld_5ztii.rs:116:25\n    |\n116 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpld_5ztii.rs:117:17\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpld_5ztii.rs:117:25\n    |\n117 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpld_5ztii.rs:118:17\n    |\n118 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpld_5ztii.rs:118:25\n    |\n118 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpld_5ztii.rs:119:17\n    |\n119 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n            if interval1_start < interval2_start {\n   \
    \             interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \            }\n            if interval1_end > interval2_end {\n             \
    \   interval1_end, interval2_end = interval2_end, interval1_end;\n           \
    \ }\n            if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n                if interval1_start < interval2_start {\n                \
    \    interval1_start, interval2_start = interval2_start, interval1_start;\n  \
    \              }\n                if interval1_end > interval2_end {\n       \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \               }\n                if interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n                    if interval1_start < interval2_start\
    \ {\n                        interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n                    }\n                    if interval1_end\
    \ > interval2_end {\n                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n                   \
    \     if interval1_start < interval2_start {\n                            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n                      \
    \  }\n                        if interval1_end > interval2_end {\n           \
    \                 interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \                        }\n                        if interval1_start <= interval1_end\
    \ && interval2_start <= interval2_end {\n                            if interval1_start\
    \ < interval2_start {\n                                interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n                            }\n       \
    \                     if interval1_end > interval2_end {\n                   \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \                           }\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcmd5ob8p.rs:86:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n31 |     if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n38 |         if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n   |                                                                    \
    \             - unclosed delimiter\n...\n45 |             if interval1_start <=\
    \ interval1_end && interval2_start <= interval2_end {\n   |                  \
    \                                                                   - unclosed\
    \ delimiter\n...\n52 |                 if interval1_start <= interval1_end &&\
    \ interval2_start <= interval2_end {\n   |                                   \
    \                                                      - unclosed delimiter\n\
    ...\n59 |                     if interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n   |                                                   \
    \                                          - unclosed delimiter\n...\n66 |   \
    \                      if interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n   |                                                   \
    \                                              - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n86 | }\n   |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpcmd5ob8p.rs:26:40\n\
    \   |\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpcmd5ob8p."
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    loop {\n        if\
    \ interval1_end < interval2_start {\n            interval1_end = interval1_end\
    \ + 1;\n            interval2_start = interval2_start - 1;\n        } else {\n\
    \            interval1_start = interval1_start - 1;\n            interval2_end\
    \ = interval2_end + 1;\n        }\n        if interval1_start < interval2_end\
    \ {\n            intersection_length = intersection_length + 1;\n        }\n \
    \       if interval1_end == interval2_end {\n            break;\n        }\n \
    \   }\n    if intersection_length == 2 {\n        return \"YES\";\n    } else\
    \ {\n        return \"NO\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb9ejcmxu.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb9ejcmxu.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb9ejcmxu.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb9ejcmxu.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb9ejcmxu.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start < interval1.end && interval2.start < interval2.end\
    \ {\n        let mut interval = interval1;\n        let mut interval2 = interval2;\n\
    \        let mut i = 0;\n        let mut j = 0;\n        let mut k = 0;\n    \
    \    while i < interval.end && j < interval2.end {\n            if interval.start\
    \ < interval2.start {\n                i += 1;\n            } else if interval.end\
    \ > interval2.end {\n                j += 1;\n            } else {\n         \
    \       if interval.start <= interval2.start {\n                    i += 1;\n\
    \                } else {\n                    j += 1;\n                }\n  \
    \          }\n        }\n        if i == interval.end {\n            if j == interval2.end\
    \ {\n                return String::from(\"YES\");\n            }\n          \
    \  return String::from(\"NO\");\n        }\n        if j == interval2.end {\n\
    \            return String::from(\"NO\");\n        }\n        if interval.start\
    \ == interval2.start {\n            return String::from(\"YES\");\n        }\n\
    \        if interval.end == interval2.end {\n            return String::from(\"\
    NO\");\n        }\n        if interval.start > interval2.start {\n           \
    \ interval = interval2;\n        } else {\n            interval2 = interval;\n\
    \        }\n        let mut i = 0;\n        let mut j = 0;\n        let mut k\
    \ = 0;\n        while i < interval.end && j < interval2.end {\n            if\
    \ interval.start < interval2.start {\n                i += 1;\n            } else\
    \ if interval.end > interval2.end {\n                j += 1;\n            } else\
    \ {\n                if interval.start <= interval2.start {\n                \
    \    i += 1;\n                } else {\n                    j += 1;\n        \
    \        }\n            }\n        }\n        if i == interval.end {\n       \
    \     if j == interval2.end {\n                return String::from(\"YES\");\n\
    \            }\n            return String::from(\"NO\");\n        }\n        if\
    \ j == interval2.end {\n            return String::from(\"NO\");\n        }\n\
    \        if interval.start == interval2.start {\n            return String::from(\"\
    YES\");\n        }\n        if interval.end == interval2.end {\n            return\
    \ String::from(\"NO\");\n        }\n        if interval.start > interval2.start\
    \ {\n            interval = interval2;\n        } else {\n            interval2\
    \ = interval;\n        }\n        let mut i = 0;\n        let mut j = 0;\n   \
    \     let mut k = 0;\n        while i < interval.end && j < interval2.end {\n\
    \            if interval.start < interval2.start {\n                i += 1;\n\
    \            } else if interval.end > interval2.end {\n                j += 1;\n\
    \            } else {\n                if interval.start <= interval2.start {\n\
    \                    i += 1;\n                } else {\n                    j\
    \ += 1;\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphc345ak6.rs:121:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n21  |     if interval1.start <\
    \ interval1.end && interval2.start < interval2.end {\n    |                  \
    \                                                         - unclosed delimiter\n\
    ...\n99  |         while i < interval.end && j < interval2.end {\n    |      \
    \                                               - unclosed delimiter\n...\n104\
    \ |             } else {\n    |                    - unclosed delimiter\n...\n\
    107 |                 } else {\n    |                        - this delimiter\
    \ might not be properly closed...\n108 |                     j += 1;\n109 | }\n\
    \    | - ...as it matches this but it has different indentation\n...\n121 | }\n\
    \    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmphc345ak6.rs:113:17\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphc345ak6.rs:113:25\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphc345ak6.rs:114:17\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphc345ak6.rs:114:25\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmphc345ak6.rs:115:17\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmphc345ak6.rs:115:25\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_end < interval2_start {\n        return \"NO\";\n \
    \   }\n\n    if interval1_start > interval2_end {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start < interval2_end {\n        let mut interval1_length\
    \ = interval1_end - interval1_start;\n        let mut interval2_length = interval2_end\
    \ - interval2_start;\n\n        if interval1_length < interval2_length {\n   \
    \         interval1_length = interval2_length;\n        }\n\n        if interval1_length\
    \ == 1 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 2 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 3 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 4 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 5 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 6 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 7 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 8 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 9 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 10 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 11 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 12 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 13 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 14 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 15 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 16 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 17 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 18 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 19 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 20 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 21 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 22 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 100 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 200 {\n            return \"YES\";\n        }\n\n        if interval1_length\
    \ == 300 {\n            return \"\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmp_cd4o0s2.rs:147:20\n\
    \    |\n147 |               return \"\n    |  ____________________^\n148 | | }\n\
    149 | |\n150 | | fn main() {\n...   |\n159 | |     assert_eq!({left}, {right});\n\
    160 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut interval = interval1;\n    let\
    \ mut interval2 = interval2;\n    let mut len = 0;\n    while interval[0] < interval[1]\
    \ {\n        interval[0] = interval[0] + 1;\n        interval[1] = interval[1]\
    \ - 1;\n        len += 1;\n    }\n    if len % 2 == 0 {\n        return \"NO\"\
    ;\n    }\n    let mut prime = true;\n    for i in 2..len {\n        if interval[0]\
    \ % i == 0 || interval[1] % i == 0 {\n            prime = false;\n           \
    \ break;\n        }\n    }\n    if prime {\n        return \"YES\";\n    }\n \
    \   return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmphxz3b6_o.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphxz3b6_o.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphxz3b6_o.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphxz3b6_o.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphxz3b6_o.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphxz3b6_o.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphxz3b6_o.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphxz3b6_o.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphxz3b6_o.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphxz3b6_o.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphxz3b6_o.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval.0 = interval1[0]\
    \ < interval2[0] ? interval1[0] : interval2[0];\n        interval.1 = interval1[1]\
    \ > interval2[1] ? interval1[1] : interval2[1];\n        interval\n    } else\
    \ {\n        let mut interval = interval2;\n        interval.0 = interval1[0]\
    \ < interval2[0] ? interval1[0] : interval2[0];\n        interval.1 = interval1[1]\
    \ > interval2[1] ? interval1[1] : interval2[1];\n        interval\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `interval1`\n\
    \  --> /tmp/tmp8srd5rbr.rs:23:52\n   |\n23 |         interval.0 = interval1[0]\
    \ < interval2[0] ? interval1[0] : interval2[0];\n   |                        \
    \                            ^^^^^^^^^ expected one of `.`, `;`, `?`, `}`, or\
    \ an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found\
    \ `interval1`\n  --> /tmp/tmp8srd5rbr.rs:28:52\n   |\n28 |         interval.0\
    \ = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n   |         \
    \                                           ^^^^^^^^^ expected one of `.`, `;`,\
    \ `?`, `}`, or an operator\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8srd5rbr.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8srd5rbr.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8srd5rbr.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8srd5rbr.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8srd5rbr.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8srd5rbr.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8srd5rbr.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8srd5rbr.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n  "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start < interval1.end && interval2.start < interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut interval = interval;\n        interval.\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpnpf37wz0.rs:102:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n21  |     if interval1.start <\
    \ interval1.end && interval2.start < interval2.end {\n    |                  \
    \                                                         - this delimiter might\
    \ not be properly closed...\n...\n90  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n102 | }\n    |   ^\n\nerror: unexpected token:\
    \ `}`\n  --> /tmp/tmpnpf37wz0.rs:90:1\n   |\n90 | }\n   | ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnpf37wz0.rs:94:17\n   |\n94 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnpf37wz0.rs:94:25\n\
    \   |\n94 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnpf37wz0.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnpf37wz0.rs:95:25\n   |\n95 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnpf37wz0.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnpf37wz0.rs:96:25\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnpf37wz0.rs:97:17\n  \
    \ |\n97 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnpf37wz0.rs:97:25\n   |\n97 "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut interval1_is_prime = true;\n    let mut interval2_is_prime\
    \ = true;\n    while interval1_is_prime && interval2_is_prime {\n        if interval1_start\
    \ < interval2_start {\n            intersection_start = interval1_start;\n   \
    \         intersection_end = interval1_end;\n            intersection_length =\
    \ interval1_end - interval1_start;\n            interval1_is_prime = false;\n\
    \        } else {\n            intersection_start = interval2_start;\n       \
    \     intersection_end = interval2_end;\n            intersection_length = interval2_end\
    \ - interval2_start;\n            interval2_is_prime = false;\n        }\n   \
    \ }\n    if interval1_is_prime && interval2_is_prime {\n        if intersection_length\
    \ == 1 {\n            return \"YES\";\n        } else {\n            return \"\
    NO\";\n        }\n    }\n    if intersection_length == 1 {\n        return \"\
    NO\";\n    } else {\n        return \"YES\";\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbm5ovozj.rs:59:17\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbm5ovozj.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbm5ovozj.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbm5ovozj.rs:60:25\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbm5ovozj.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbm5ovozj.rs:61:25\n   |\n61 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbm5ovozj.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbm5ovozj.rs:62:25\n   |\n62 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbm5ovozj.rs:63:17\n  \
    \ |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbm5ovozj.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbm5ovozj.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1[1] - interval1[0] + 1;\n \
    \   let mut interval_len_2 = interval2[1] - interval2[0] + 1;\n    let mut intersection_len\
    \ = 0;\n    if interval_len > interval_len_2 {\n        interval_len = interval_len_2;\n\
    \    }\n    if interval_len == 0 {\n        return \"NO\";\n    }\n    if interval_len\
    \ == interval_len_2 {\n        intersection_len = interval_len;\n    } else {\n\
    \        intersection_len = interval_len / 2;\n    }\n    if interval1[0] < interval2[0]\
    \ {\n        let mut interval_start = interval1[0];\n        let mut interval_end\
    \ = interval1[1];\n        let mut interval_end_2 = interval2[1];\n        while\
    \ interval_start < interval_end_2 {\n            if interval_end > interval_end_2\
    \ {\n                interval_end = interval_end_2;\n            }\n         \
    \   if interval_end == interval_end_2 {\n                interval_end += 1;\n\
    \            }\n            if interval_end == interval_start_2 {\n          \
    \      interval_end += 1;\n            }\n            interval_end_2 -= 1;\n \
    \           interval_start += 1;\n        }\n    } else {\n        let mut interval_start\
    \ = interval1[1];\n        let mut interval_end = interval1[0];\n        let mut\
    \ interval_end_2 = interval2[0];\n        while interval_start < interval_end_2\
    \ {\n            if interval_end > interval_end_2 {\n                interval_end\
    \ = interval_end_2;\n            }\n            if interval_end == interval_end_2\
    \ {\n                interval_end += 1;\n            }\n            if interval_end\
    \ == interval_start_2 {\n                interval_end += 1;\n            }\n \
    \           interval_end_2 -= 1;\n            interval_start += 1;\n        }\n\
    \    }\n    if interval_start == interval_end {\n        return \"NO\";\n    }\n\
    \    if interval_start == interval_end_2 {\n        return \"NO\";\n    }\n  \
    \  if interval_start == interval_end_2 + 1 {\n        return \"YES\";\n    }\n\
    \    if interval_start == interval_end_2 - 1 {\n        return \"YES\";\n    }\n\
    \    if interval_start == interval_end_2 + interval_len {\n        return \"YES\"\
    ;\n    }\n    if interval_start == interval_end_2 - interval_len {\n        return\
    \ \"YES\";\n    }\n    if interval_start == interval_end_2 + interval_len {\n\
    \        return \"YES\";\n    }\n    if interval_start == interval_end_2 - interval_len\
    \ {\n        return \"YES\";\n    }\n    if interval_start == interval_end_2 +\
    \ interval_len + 1 {\n        return \"YES\";\n    }\n    if interval_start \n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpvofe2sfn.rs:98:1\n   |\n\
    97 |     if interval_start \n   |     -- this `if` expression has a condition,\
    \ but no block\n98 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `interval_start_2` in this scope\n  --> /tmp/tmpvofe2sfn.rs:46:32\n   |\n46\
    \ |             if interval_end == interval_start_2 {\n   |                  \
    \              ^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `interval_start`\n\nerror[E0425]: cannot find value `interval_start_2` in this\
    \ scope\n  --> /tmp/tmpvofe2sfn.rs:63:32\n   |\n63 |             if interval_end\
    \ == interval_start_2 {\n   |                                ^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `interval_start`\n\nerror[E0425]:\
    \ cannot find value `interval_start` in this scope\n  --> /tmp/tmpvofe2sfn.rs:70:8\n\
    \   |\n70 |     if interval_start == interval_end {\n   |        ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `interval_end` in\
    \ this scope\n  --> /tmp/tmpvofe2sfn.rs:70:26\n   |\n70 |     if interval_start\
    \ == interval_end {\n   |                          ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `interval_len`\n\nerror[E0425]: cannot\
    \ find value `interval_start` in this scope\n  --> /tmp/tmpvofe2sfn.rs:73:8\n\
    \   |\n73 |     if interval_start == interval_end_2 {\n   |        ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `interval_end_2`\
    \ in this scope\n  --> /tmp/tmpvofe2sfn.rs:73:26\n   |\n73 |     if interval_start\
    \ == interval_end_2 {\n   |                          ^^^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `interval_len_2`\n\nerror[E0425]: cannot\
    \ find value `interval_start` in this scope\n  --> /tmp/tmpvofe2sfn.rs:76:8\n\
    \   |\n76 |     if interval_start == interval_end_2 + 1 {\n   |        ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `interval_end_2`\
    \ in this scope\n  --> /tmp/tmpvofe2sfn.rs:76:26\n   |\n76 |     if interval_start\
    \ == interval_end_2 + 1 {\n   |                          ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n\n    if interval1_start > interval2_end {\n      \
    \  interval1_end = interval2_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_start = interval2_end;\n    }\n\n    if interval1_start\
    \ > interval1_end {\n        return \"NO\";\n    }\n\n    let mut interval1_length\
    \ = interval1_end - interval1_start;\n    let mut interval2_length = interval2_end\
    \ - interval2_start;\n\n    if interval1_length == interval2_length {\n      \
    \  return \"YES\";\n    }\n\n    if interval1_length < interval2_length {\n  \
    \      interval1_length = interval2_length;\n    }\n\n    if interval1_length\
    \ == 1 {\n        return \"NO\";\n    }\n\n    if interval1_length == 2 {\n  \
    \      return \"YES\";\n    }\n\n    if interval1_length == 3 {\n        return\
    \ \"YES\";\n    }\n\n    if interval1_length == 4 {\n        return \"YES\";\n\
    \    }\n\n    if interval1_length == 5 {\n        return \"YES\";\n    }\n\n \
    \   if interval1_length == 6 {\n        return \"YES\";\n    }\n\n    if interval1_length\
    \ == 7 {\n        return \"YES\";\n    }\n\n    if interval1_length == 8 {\n \
    \       return \"YES\";\n    }\n\n    if interval1_length == 9 {\n        return\
    \ \"YES\";\n    }\n\n    if interval1_length == 10 {\n        return \"YES\";\n\
    \    }\n\n    if interval1_length == 11 {\n        return \"YES\";\n    }\n\n\
    \    if interval1_length == 12 {\n        return \"YES\";\n    }\n\n    if interval1_length\
    \ == 13 {\n        return \"YES\";\n    }\n\n    if interval1_length == 14 {\n\
    \        return \"YES\";\n    }\n\n    if interval1_length == 15 {\n        return\
    \ \"YES\";\n    }\n\n    if interval1_length == 16 {\n        return \"YES\";\n\
    \    }\n\n    if interval1_length == 17 {\n        return \"YES\";\n    }\n\n\
    \    if interval1_length == 18 {\n        return \"YES\";\n    }\n\n    if interval1_length\
    \ == 19 {\n        return \"YES\";\n    }\n\n    if interval1_length == 20 {\n\
    \        return \"YES\";\n    }\n\n    if interval1_length == 21 {\n        return\
    \ \"YES\";\n    }\n\n    if interval1_length == 22 {\n        return \"YES\";\n\
    \    }\n\n    if interval1_length == 100 {\n        return \"YES\";\n    }\n\n\
    \    if interval1_length == \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpegu8970g.rs:148:1\n\
    \    |\n148 | }\n    | ^ expected expression\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n   --> /tmp/tmpegu8970g.rs:152:17\n    |\n152 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpegu8970g.rs:152:25\n\
    \    |\n152 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpegu8970g.rs:153:17\n    |\n153 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpegu8970g.rs:153:25\n\
    \    |\n153 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpegu8970g.rs:154:17\n    |\n154 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpegu8970g.rs:154:25\n\
    \    |\n154 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpegu8970g.rs:155:17\n    |\n155 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpegu8970g.rs:155:25\n\
    \    |\n155 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpegu8970g.rs:156:17\n    |\n156 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpegu8970g.rs:156:25\n\
    \    |\n156 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in th"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n\n    if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_end < interval2_end {\n    \
    \        interval1_end, interval2_end = interval2_end, interval1_end;\n      \
    \  }\n        if interval1_start <= interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ >= interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval2_start {\n\
    \            interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \        }\n        if interval1_end >= interval2_end {\n            interval1_end,\
    \ interval2_end = interval2_end, interval1_end;\n        }\n    }\n\n    if interval1_start\
    \ > interval1_end {\n        interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start, interval2_end\
    \ = interval2_end, interval2_start;\n    }\n\n    if interval1_start <= interval1_end\
    \ && interval2_start <= interval2_end {\n        if interval1_start < interval2_start\
    \ {\n            interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \        }\n        if interval1_end > interval2_end {\n            interval1_end,\
    \ interval2_end = interval2_end, interval1_end;\n        }\n        if interval1_end\
    \ < interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval2_start {\n\
    \            interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \        }\n        if interval1_end >= interval2_end {\n            interval1_end,\
    \ interval2_end = interval2_end, interval1_end;\n        }\n        if interval1_start\
    \ <= interval2_start {\n            interval1_start, interval2_start = interval\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkhlez4g4.rs:94:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n64 |     if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n80 |         if interval1_start <= interval2_start {\n   |              \
    \                                 - this delimiter might not be properly closed...\n\
    81 |             interval1_start, interval2_start = interval\n82 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n94 | }\n   |   ^\n\n\
    error: expected `:`, found `=`\n  --> /tmp/tmpkhlez4g4.rs:27:40\n   |\n27 |  \
    \       interval1_start, interval1_end = interval2_start, interval1_end;\n   |\
    \                                       -^\n   |                             \
    \          |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpkhlez4g4.rs:20:81\n   |\n20 | fn intersection(interval1: (isize,\
    \ isize), interval2: (isize, isize)) -> String {\n   |                       \
    \                                                          ^ unclosed delimiter\n\
    ...\n26 |     if interval1_start > interval2_start {\n   |                   \
    \       --------------- while parsing this struct\n27 |         interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n   |                      \
    \                                                  ^\n   |                   \
    \                                                     |\n   |                \
    \                                                        expected one of `,` or\
    \ `}`\n   |                                                                  \
    \      help: `}` may belong here\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpkhlez4g4.rs:26:26\n   |\n26 |       if interval1_sta"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    if interval1[0] < interval1[1] && interval2[0]\
    \ < interval2[1] {\n        let mut interval = interval1;\n        interval[0]\
    \ = interval1[1];\n        interval[1] = interval2[0];\n        interval = interval.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut prime = true;\n        for &i in interval {\n            if i\
    \ % 2 == 0 {\n                prime = false;\n                break;\n       \
    \     }\n        }\n        if prime {\n            return \"YES\";\n        }\n\
    \    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpphjdf_gb.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpphjdf_gb.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpphjdf_gb.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpphjdf_gb.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpphjdf_gb.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpphjdf_gb.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpphjdf_gb.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpphjdf_gb.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpphjdf_gb.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpphjdf_gb.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpphjdf_gb.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut interval1_length = interval2_end - interval2_start;\n\
    \    let mut interval2_length = interval1_end - interval1_start;\n    let mut\
    \ interval1_prime = true;\n    let mut interval2_prime = true;\n    let mut prime\
    \ = true;\n    while prime_checker(intersection_start, intersection_end) && prime_checker(interval1_start,\
    \ interval1_end) && prime_checker(interval2_start, interval2_end) {\n        if\
    \ intersection_start > interval1_end {\n            intersection_start = intersection_end;\n\
    \            intersection_end = interval1_end;\n            intersection_length\
    \ = interval1_end - intersection_start;\n            interval1_length = interval2_end\
    \ - intersection_start;\n            prime = false;\n        }\n        if intersection_end\
    \ < interval1_start {\n            intersection_start = intersection_end;\n  \
    \          intersection_end = interval1_start;\n            intersection_length\
    \ = interval1_end - intersection_start;\n            interval1_length = interval2_end\
    \ - intersection_start;\n            prime = false;\n        }\n        if intersection_end\
    \ > interval2_end {\n            intersection_start = intersection_end;\n    \
    \        intersection_end = interval2_end;\n            intersection_length =\
    \ interval2_end - intersection_start;\n            interval2_length = interval1_end\
    \ - intersection_start;\n            prime = false;\n        }\n        if intersection_start\
    \ < interval2_start {\n            intersection_start = intersection_end;\n  \
    \          intersection_end = interval2_start;\n            intersection_length\
    \ = interval2_end - intersection_start;\n            interval2_length = interval1_end\
    \ - intersection_start;\n            prime = false;\n        }\n        if intersection_length\
    \ == 0 {\n            prime = false;\n        }\n        if interval1_length ==\
    \ 0 {\n            prime = false;\n        }\n        if interval2_length == 0\
    \ {\n            prime = false;\n        }\n        if intersection_length ==\
    \ interval1_length && intersection_length == interval2_length {\n            prime\
    \ = true;\n        }\n        if intersection_length == interval1_length {\n \
    \           interval1_prime = false;\n        }\n        if intersection_length\
    \ == interval2_length {\n            interval2_prime = false;\n        }\n   \
    \ }\n    if prime_checker(intersection_start, intersection_end) {\n        if\
    \ interval1_prime && interval2_prime {\n            return String::from(\"YES\"\
    );\n        }\n        if interval1_prime {\n\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzn2ktho2.rs:99:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n81 |     if prime_checker(intersection_start,\
    \ intersection_end) {\n   |                                                  \
    \          - unclosed delimiter\n...\n85 |         if interval1_prime {\n   |\
    \                            - this delimiter might not be properly closed...\n\
    86 | \n87 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n99 | }\n   |   ^\n\nerror[E0425]: cannot find function `prime_checker` in\
    \ this scope\n  --> /tmp/tmpzn2ktho2.rs:33:11\n   |\n33 |     while prime_checker(intersection_start,\
    \ intersection_end) && prime_checker(interval1_start, interval1_end) && prime_checker(interval2...\n\
    \   |           ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `prime_checker` in this scope\n  --> /tmp/tmpzn2ktho2.rs:33:66\n\
    \   |\n33 |     while prime_checker(intersection_start, intersection_end) && prime_checker(interval1_start,\
    \ interval1_end) && prime_checker(interval2...\n   |                         \
    \                                         ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `prime_checker` in this scope\n  --> /tmp/tmpzn2ktho2.rs:33:115\n\
    \   |\n33 | ...rime_checker(interval1_start, interval1_end) && prime_checker(interval2_start,\
    \ interval2_end) {\n   |                                                    ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `prime_checker`\
    \ in this scope\n  --> /tmp/tmpzn2ktho2.rs:81:8\n   |\n81 |     if prime_checker(intersection_start,\
    \ intersection_end) {\n   |        ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzn2ktho2.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_end < interval2_start {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval2_start = interval1_start;\n    }\n\n    if interval1_start > interval2_end\
    \ {\n        interval1_start = interval2_start;\n        interval2_end = interval1_end;\n\
    \    }\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval2_end = interval1_end;\n    }\n\n    if\
    \ interval1_start == interval2_start {\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    let mut interval1_length = interval1_end - interval1_start + 1;\n    let\
    \ mut interval2_length = interval2_end - interval2_start + 1;\n\n    if interval1_length\
    \ == interval2_length {\n        if interval1_length == 1 {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n\n    if interval1_length\
    \ < interval2_length {\n        interval1_length = interval2_length;\n       \
    \ interval2_length = interval1_length;\n    }\n\n    if interval1_length == 2\
    \ {\n        if interval1_start == interval2_start {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";\n    }\n\n    if interval1_length == 3 {\n\
    \        if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        if interval1_end == interval2_end {\n            return \"\
    YES\";\n        }\n        return \"NO\";\n    }\n\n    if interval1_length ==\
    \ 4 {\n        if interval1_start == interval2_start {\n            return \"\
    YES\";\n        }\n        if interval1_end == interval2_end {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n        return \"NO\";\n    }\n\n    if interval1_length\
    \ == 5 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n        if interval1_end == interval2_end {\n\
    \            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    if interval1_length == 6 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpd5cn3439.rs:131:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n114 |     if interval1_length\
    \ == 6 {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n119 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n131 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpd5cn3439.rs:119:1\n    |\n118 |         if interval1_end == interval2_end\
    \ \n    |         -- this `if` expression has a condition, but no block\n119 |\
    \ }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpd5cn3439.rs:123:17\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpd5cn3439.rs:123:25\n    |\n123 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpd5cn3439.rs:124:17\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpd5cn3439.rs:124:25\n    |\n124 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpd5cn3439.rs:125:17\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpd5cn3439.rs:125:25\n    |\n125 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpd5cn3439.rs:126:17\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end = interval2_end;\n        interval2_start = interval1_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval1_start =\
    \ interval2_start;\n        interval2_end = interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end = interval2_end;\n        interval2_start\
    \ = interval1_start;\n    }\n    if interval1_start == interval2_start {\n   \
    \     if interval1_end == interval2_end {\n            return \"YES\";\n     \
    \   } else {\n            return \"NO\";\n        }\n    }\n    let mut interval1_length\
    \ = interval1_end - interval1_start + 1;\n    let mut interval2_length = interval2_end\
    \ - interval2_start + 1;\n    if interval1_length == interval2_length {\n    \
    \    if interval1_start < interval2_start {\n            interval1_length = interval2_start\
    \ - interval1_start + 1;\n        }\n        if interval1_end > interval2_end\
    \ {\n            interval1_length = interval2_end - interval1_start + 1;\n   \
    \     }\n    }\n    if interval1_length == 1 {\n        return \"NO\";\n    }\n\
    \    if interval1_length == 2 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval1_length == 3 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval1_length == 4 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_end < interval2_end\
    \ {\n            interval1_length = interval2_end - interval1_start + 1;\n   \
    \     }\n    }\n    if interval1_length == 5 {\n        if interval1_start ==\
    \ interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n        if interval1_end\
    \ < interval2_end {\n            interval1_length = interval2_end - interval\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5mxdjo6p.rs:112:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n91  |     if interval1_length\
    \ == 5 {\n    |                              - unclosed delimiter\n...\n98  |\
    \         if interval1_end < interval2_end {\n    |                          \
    \                - this delimiter might not be properly closed...\n99  |     \
    \        interval1_length = interval2_end - interval\n100 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n112 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `interval` in this scope\n  --> /tmp/tmp5mxdjo6p.rs:99:48\n\
    \   |\n99 |             interval1_length = interval2_end - interval\n   |    \
    \                                            ^^^^^^^^ help: a local variable with\
    \ a similar name exists: `interval1`\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmp5mxdjo6p.rs:104:17\n    |\n104 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp5mxdjo6p.rs:104:25\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp5mxdjo6p.rs:105:17\n    |\n105 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp5mxdjo6p.rs:105:25\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp5mxdjo6p.rs:106:17\n    |\n106 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp5mxdjo6p.rs:106:25\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |      "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        return \"NO\";\n \
    \   }\n    if interval1_end > interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start < interval2_end {\n        return \"NO\";\n    }\n   \
    \ if interval1_end == interval2_end {\n        return \"YES\";\n    }\n    let\
    \ mut interval1_length = interval1_end - interval1_start + 1;\n    let mut interval2_length\
    \ = interval2_end - interval2_start + 1;\n    if interval1_length == interval2_length\
    \ {\n        return \"YES\";\n    }\n    if interval1_length < interval2_length\
    \ {\n        interval1_length = interval2_length;\n    }\n    if interval1_length\
    \ == 2 {\n        return \"YES\";\n    }\n    if interval1_length == 3 {\n   \
    \     return \"YES\";\n    }\n    if interval1_length == 4 {\n        return \"\
    YES\";\n    }\n    if interval1_length == 5 {\n        return \"YES\";\n    }\n\
    \    if interval1_length == 6 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 7 {\n        return \"YES\";\n    }\n    if interval1_length == 8 {\n   \
    \     return \"YES\";\n    }\n    if interval1_length == 9 {\n        return \"\
    YES\";\n    }\n    if interval1_length == 10 {\n        return \"YES\";\n    }\n\
    \    if interval1_length == 11 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 12 {\n        return \"YES\";\n    }\n    if interval1_length == 13 {\n \
    \       return \"YES\";\n    }\n    if interval1_length == 14 {\n        return\
    \ \"YES\";\n    }\n    if interval1_length == 15 {\n        return \"YES\";\n\
    \    }\n    if interval1_length == 16 {\n        return \"YES\";\n    }\n    if\
    \ interval1_length == 17 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 18 {\n        return \"YES\";\n    }\n    if interval1_length == 19 {\n \
    \       return \"YES\";\n    }\n    if interval1_length == 20 {\n        return\
    \ \"YES\";\n    }\n    if interval1_length == 21 {\n        return \"YES\";\n\
    \    }\n    if interval1_length == 22 {\n        return \"YES\";\n    }\n    if\
    \ interval1_length == 100 {\n        return \"YES\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmpxs2x854s.rs:115:16\n\
    \    |\n115 |           return \"YES\n    |  ________________^\n116 | | }\n117\
    \ | |\n118 | | fn main() {\n...   |\n127 | |     assert_eq!({left}, {right});\n\
    128 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            return String::from(\"\
    NO\");\n        }\n        if interval1[1] > interval2[1] {\n            return\
    \ String::from(\"NO\");\n        }\n        let mut interval = interval1;\n  \
    \      let mut interval2 = interval2;\n        let mut len = 0;\n        while\
    \ interval[0] < interval[1] {\n            if interval[0] == interval2[0] {\n\
    \                len += 1;\n                interval[0] = interval1[1];\n    \
    \            interval[1] = interval2[1];\n            } else {\n             \
    \   len += 1;\n                interval[0] = interval[0];\n                interval[1]\
    \ = interval2[0];\n            }\n        }\n        if len % 2 == 0 {\n     \
    \       return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    return String::from(\"NO\");\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:52:17\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkfs3qlw0.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:53:17\n   |\n53 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:53:25\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkfs3qlw0.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:54:25\n   |\n54 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkfs3qlw0.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:55:25\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:56:17\n  \
    \ |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkfs3qlw0.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkfs3qlw0.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n\n    if interval1_start > interval1_end {\n        return\
    \ \"NO\";\n    }\n\n    if interval2_start > interval2_end {\n        return \"\
    NO\";\n    }\n\n    if interval1_start == interval1_end {\n        return \"NO\"\
    ;\n    }\n\n    if interval2_start == interval2_end {\n        return \"NO\";\n\
    \    }\n\n    if interval1_start < interval2_start {\n        return \"NO\";\n\
    \    }\n\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end > interval2_end {\n        return \"NO\";\n    }\n\
    \n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\n \
    \   if interval1_end < interval2_end {\n        return \"NO\";\n    }\n\n    if\
    \ interval1_end == interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end\
    \ < interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end ==\
    \ interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end < interval2_end\
    \ {\n        return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n\
    \        return \"NO\";\n    }\n\n    if interval1_end < interval2_end {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n     \
    \   return \"NO\";\n    }\n\n    if interval1_end < interval2_end {\n        return\
    \ \"NO\";\n    }\n\n    if interval1_end == interval2_end {\n        return \"\
    NO\";\n    }\n\n    if interval1_end < interval2_end {\n        return \"NO\"\
    ;\n    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end < interval2_end {\n        return \"NO\";\n   \
    \ }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\
    \n    if interval1_end < interval2_end {\n        return \"NO\";\n    }\n\n  \
    \  if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\n    if\
    \ interval1_end < interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end\
    \ == interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end \n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmptn0125fs.rs:27:40\n   |\n\
    27 |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmptn0125fs.rs:27:72\n   |\n26 |     if interval1_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n27\
    \ |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmptn0125fs.rs:26:26\n   |\n26 |       if interval1_start > interval2_end\
    \ {\n   |  __________________________^\n27 | |         interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n28 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n26 ~     if interval1_start > (interval2_end\
    \ {\n27 |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    28 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmptn0125fs.rs:30:40\n\
    \   |\n30 |         interval1_end, interval1_start = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmptn0125fs.rs:30:72\n   |\n29 |     if interval1_end < interval2_start\
    \ {\n   |                        --------------- while parsing this struct\n30\
    \ |         interval1_end, interval1_start = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmptn0125fs.rs:29:24\n   |\n29 |       if interval1_end < interval2_start\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    let mut intersection = interval1;\n    let mut intersection2 = interval2;\n\
    \    let mut intersection_length = interval1.0;\n    let mut intersection_length2\
    \ = interval2.0;\n    let mut interval_length = interval1.0;\n    let mut interval_length2\
    \ = interval2.0;\n    let mut prime = true;\n    while prime == true {\n     \
    \   if interval_length == interval_length2 {\n            prime = false;\n   \
    \     }\n        else {\n            intersection_length += interval_length;\n\
    \            intersection_length2 += interval_length2;\n            intersection\
    \ = intersection.0;\n            intersection2 = intersection2.0;\n          \
    \  interval_length = interval1.0;\n            interval_length2 = interval2.0;\n\
    \        }\n        if intersection_length == intersection_length2 {\n       \
    \     prime = false;\n        }\n        else {\n            intersection_length\
    \ += interval_length;\n            intersection_length2 += interval_length2;\n\
    \            intersection = intersection.0;\n            intersection2 = intersection2.0;\n\
    \            interval_length = interval1.0;\n            interval_length2 = interval2.0;\n\
    \        }\n    }\n    if prime == true {\n        String::from(\"YES\")\n   \
    \ }\n    else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpjarczmkz.rs:64:17\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjarczmkz.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjarczmkz.rs:65:17\n   |\n65 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjarczmkz.rs:65:25\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjarczmkz.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjarczmkz.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjarczmkz.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjarczmkz.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjarczmkz.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjarczmkz.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjarczmkz.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            return String::from(\"\
    YES\");\n        } else {\n            return String::from(\"NO\");\n        }\n\
    \    } else {\n        return String::from(\"NO\");\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_ctrs3nz.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_ctrs3nz.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_ctrs3nz.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_ctrs3nz.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_ctrs3nz.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1[1] - interval1[0] + 1;\n \
    \   let mut interval2_len = interval2[1] - interval2[0] + 1;\n    if interval_len\
    \ > interval2_len {\n        interval_len = interval2_len;\n    }\n    let mut\
    \ interval_start = interval1[0];\n    let mut interval_end = interval1[1];\n \
    \   let mut interval2_start = interval2[0];\n    let mut interval2_end = interval2[1];\n\
    \    if interval_end > interval2_end {\n        interval_end = interval2_end;\n\
    \    }\n    if interval_start < interval2_start {\n        interval_start = interval2_start;\n\
    \    }\n    if interval_start == interval_end {\n        return \"NO\";\n    }\n\
    \    if interval_start > interval_end {\n        return \"NO\";\n    }\n    if\
    \ interval_len == 1 {\n        return \"YES\";\n    }\n    if interval_len ==\
    \ 2 {\n        if interval_start == interval_end {\n            return \"YES\"\
    ;\n        }\n        if interval_start < interval_end {\n            return \"\
    YES\";\n        }\n    }\n    if interval_len % 2 == 0 {\n        if interval_start\
    \ == interval_end {\n            return \"YES\";\n        }\n        if interval_start\
    \ < interval_end {\n            return \"YES\";\n        }\n    }\n    let mut\
    \ interval_mid = (interval_start + interval_end) / 2;\n    let mut interval2_mid\
    \ = (interval2_start + interval2_end) / 2;\n    if interval_start == interval_end\
    \ {\n        return \"NO\";\n    }\n    if interval2_start == interval2_end {\n\
    \        return \"NO\";\n    }\n    if interval_start < interval_end {\n     \
    \   if interval_mid == interval2_mid {\n            return \"YES\";\n        }\n\
    \        if interval_mid < interval2_mid {\n            return \"YES\";\n    \
    \    }\n    }\n    if interval_start > interval_end {\n        if interval_mid\
    \ == interval2_mid {\n            return \"YES\";\n        }\n        if interval_mid\
    \ > interval2_mid {\n            return \"YES\";\n        }\n    }\n    if interval_start\
    \ < interval2_start {\n        if interval_mid == interval2_mid {\n          \
    \  return \"YES\";\n        }\n        if interval_mid < interval2_mid {\n   \
    \         return \"YES\";\n        }\n    }\n    if interval_start > interval2_end\
    \ {\n        if interval_mid == interval2_mid {\n            return \"YES\";\n\
    \        }\n        if interval_mid > interval2_mid {\n            return \"YES\"\
    ;\n        }\n    }\n    if interval_start == interval2_start {\n        if interval_mid\
    \ == interval2_\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxmpg7n1c.rs:115:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n101 |     if interval_start\
    \ == interval2_start {\n    |                                          - this\
    \ delimiter might not be properly closed...\n102 |         if interval_mid ==\
    \ interval2_\n103 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n115 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpxmpg7n1c.rs:103:1\n\
    \    |\n102 |         if interval_mid == interval2_\n    |         -- this `if`\
    \ expression has a condition, but no block\n103 | }\n    | ^ expected `{`\n\n\
    error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpxmpg7n1c.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpxmpg7n1c.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpxmpg7n1c.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpxmpg7n1c.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpxmpg7n1c.rs:109:17\n\
    \    |\n109 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpxmpg7n1c.rs:109:25\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpxmpg7n1c.rs:110:17\n\
    \    |\n110 |     assert_eq!({left}, {right});\n "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            String::from(\"NO\"\
    )\n        } else {\n            String::from(\"YES\")\n        }\n    } else\
    \ {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpc_1rstnr.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc_1rstnr.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpc_1rstnr.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpc_1rstnr.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpc_1rstnr.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpc_1rstnr.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpc_1rstnr.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpc_1rstnr.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpc_1rstnr.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc_1rstnr.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpc_1rstnr.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    if interval1[0] < interval1[1] && interval2[0]\
    \ < interval2[1] {\n        let mut interval = interval1;\n        interval[0]\
    \ = interval1[1];\n        interval[1] = interval2[0];\n        interval_length(interval)\n\
    \    } else if interval1[0] < interval1[1] && interval2[0] > interval2[1] {\n\
    \        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval2[1];\n        interval_length(interval)\n    }\
    \ else if interval1[0] > interval1[1] && interval2[0] < interval2[1] {\n     \
    \   let mut interval = interval2;\n        interval[0] = interval1[0];\n     \
    \   interval[1] = interval2[1];\n        interval_length(interval)\n    } else\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval1[1];\n        interval_length(interval)\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `interval_length` in this scope\n  -->\
    \ /tmp/tmp22h102m1.rs:28:9\n   |\n28 |         interval_length(interval)\n   |\
    \         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `interval_length` in this scope\n  --> /tmp/tmp22h102m1.rs:33:9\n \
    \  |\n33 |         interval_length(interval)\n   |         ^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `interval_length`\
    \ in this scope\n  --> /tmp/tmp22h102m1.rs:38:9\n   |\n38 |         interval_length(interval)\n\
    \   |         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `interval_length` in this scope\n  --> /tmp/tmp22h102m1.rs:43:9\n\
    \   |\n43 |         interval_length(interval)\n   |         ^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp22h102m1.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp22h102m1.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp22h102m1.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp22h102m1.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp22h102m1.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp22h102m1.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp22h102m1.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not fo"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n        interval2_start, interval2_end\
    \ = interval1_start, interval1_end;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \        interval2_start, interval2_end = interval1_start, interval1_end;\n  \
    \  }\n    if interval1_start <= interval2_end {\n        if interval1_end < interval2_start\
    \ {\n            interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \            interval2_start, interval2_end = interval1_start, interval1_end;\n\
    \        }\n        if interval1_end == interval2_end {\n            if interval1_start\
    \ == interval2_start {\n                return String::from(\"YES\");\n      \
    \      }\n            return String::from(\"NO\");\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_start, interval1_end = interval2_start,\
    \ interval1_end;\n            interval2_start, interval2_end = interval1_start,\
    \ interval1_end;\n        }\n    }\n    if interval1_start > interval2_end {\n\
    \        interval1_start, interval1_end = interval2_start, interval1_end;\n  \
    \      interval2_start, interval2_end = interval1_start, interval1_end;\n    }\n\
    \    if interval1_end < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n        interval2_start, interval2_end =\
    \ interval1_start, interval1_end;\n    }\n    if interval1_start <= interval2_start\
    \ {\n        if interval1_end < interval2_end {\n            interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n            interval2_start,\
    \ interval2_end = interval1_start, interval1_end;\n        }\n        if interval1_end\
    \ == interval2_end {\n            if interval1_start == interval2_start {\n  \
    \              return String::from(\"YES\");\n            }\n            return\
    \ String::from(\"NO\");\n        }\n        if interval1_end > interval2_end {\n\
    \            interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \            interval2_start, interval2_end = interval1_start, interval1_end;\n\
    \        }\n    }\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n        interval2_start, interval2_end\
    \ = interval1_start, interval1_end;\n    }\n    if interval1_end < interval2_end\
    \ \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpag8c7qb8.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpag8c7qb8.rs:26:72\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpag8c7qb8.rs:27:40\n\
    \   |\n27 |         interval2_start, interval2_end = interval1_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpag8c7qb8.rs:27:72\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 |         interval2_start, interval2_end = interval1_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpag8c7qb8.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n27 | |         interval2_start, interval2_end\
    \ = interval1_start, interval1_end;\n28 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval2_start\
    \ {\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 | "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_start {\n      \
    \  interval1_start = interval2_end;\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";\n    }\n    let mut interval1_length = interval1_end\
    \ - interval1_start + 1;\n    let mut interval2_length = interval2_end - interval2_start\
    \ + 1;\n    let mut intersection_length = interval1_length + interval2_length\
    \ - 1;\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ < interval2_start {\n            intersection_length = interval1_length + 1;\n\
    \        } else {\n            intersection_length = interval2_length + 1;\n \
    \       }\n    }\n    if intersection_length == 2 {\n        if interval1_start\
    \ < interval2_start {\n            intersection_length += 1;\n        } else {\n\
    \            intersection_length += 1;\n        }\n    }\n    if intersection_length\
    \ == 1 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n    if intersection_length\
    \ == 0 {\n        return \"NO\";\n    }\n    if intersection_length == 2 {\n \
    \       if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if intersection_length == 1 {\n\
    \        if interval1_start < interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if intersection_length == 0 {\n\
    \        return \"NO\";\n    }\n    if intersection_length == 3 {\n        if\
    \ interval1_start == interval2_start {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if intersection_length == 2 {\n        if\
    \ interval1_start < interval2_start {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if intersection_length == 1 {\n        if\
    \ interval1_start < interval2_start {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if intersection_length == 0 {\n        return\
    \ \"NO\";\n    }\n    if intersection_length == 4 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpxrz4w4us.rs:122:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n105 |     if intersection_length\
    \ == 4 {\n    |                                 - this delimiter might not be\
    \ properly closed...\n...\n110 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n122 | }\n    |   ^\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpxrz4w4us.rs:114:17\n    |\n114 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpxrz4w4us.rs:114:25\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpxrz4w4us.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpxrz4w4us.rs:115:25\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpxrz4w4us.rs:116:17\n    |\n116 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpxrz4w4us.rs:116:25\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpxrz4w4us.rs:117:17\n    |\n117 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpxrz4w4us.rs:117:25\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end = interval2_end;\n        interval1_start\
    \ = interval2_start;\n    }\n\n    if interval1_start > interval1_end {\n    \
    \    return \"NO\";\n    }\n\n    if interval2_start > interval2_end {\n     \
    \   return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n   \
    \     return \"YES\";\n    }\n\n    if interval1_start < interval2_start {\n \
    \       return \"NO\";\n    }\n\n    if interval1_end < interval2_end {\n    \
    \    return \"NO\";\n    }\n\n    let mut interval1_length = interval1_end - interval1_start\
    \ + 1;\n    let mut interval2_length = interval2_end - interval2_start + 1;\n\n\
    \    if interval1_length > interval2_length {\n        interval1_length = interval2_length;\n\
    \    }\n\n    if interval1_length == 1 {\n        return \"YES\";\n    }\n\n \
    \   if interval1_length == 2 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    if interval1_length == 3 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    if interval1_length == 4 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_start == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    if interval1_length == 5 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_start == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_start\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n\n\
    \    if interval1_length == 6 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_start == interval2_end\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_start\
    \ {\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwc4cts7b.rs:135:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n112 |     if interval1_length\
    \ == 6 {\n    |                              - unclosed delimiter\n...\n122 |\
    \         if interval1_end == interval2_start {\n    |                       \
    \                      - this delimiter might not be properly closed...\n123 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n135\
    \ | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwc4cts7b.rs:127:17\n    |\n127 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwc4cts7b.rs:127:25\n    |\n127 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwc4cts7b.rs:128:17\n    |\n128 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwc4cts7b.rs:128:25\n    |\n128 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwc4cts7b.rs:129:17\n    |\n129 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwc4cts7b.rs:129:25\n    |\n129 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwc4cts7b.rs:130:17\n    |\n130 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwc4cts7b.rs:130:25\n    |\n130 |\
    \   "
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n\n    if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval2_start &&\
    \ interval1_end >= interval2_end {\n            if interval1_start < interval2_start\
    \ {\n                interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \            }\n            if interval1_end > interval2_end {\n             \
    \   interval1_end, interval2_end = interval2_end, interval1_end;\n           \
    \ }\n            if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n                if interval1_start < interval2_start {\n                \
    \    interval1_start, interval2_start = interval2_start, interval1_start;\n  \
    \              }\n                if interval1_end > interval2_end {\n       \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \               }\n                if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n                    if interval1_start < interval2_start\
    \ {\n                        interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n                    }\n                    if interval1_end\
    \ > interval2_end {\n                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n                   \
    \     if interval1_start < interval2_start {\n                            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n                      \
    \  }\n                        if interval1_end > interval2_end {\n           \
    \                 interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \                        }\n                        if interval1_start <= interval2_start\
    \ && interval1_end >= interval2_end {\n                            if interval1_start\
    \ < interval2_start {\n                                interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n                            }\n       \
    \                     if interval1_end > interval2_end {\n                   \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \                           }\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5j7dccah.rs:88:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n33 |     if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n40 |         if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n   |                                                                    \
    \             - unclosed delimiter\n...\n47 |             if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n   |                  \
    \                                                                   - unclosed\
    \ delimiter\n...\n54 |                 if interval1_start <= interval2_start &&\
    \ interval1_end >= interval2_end {\n   |                                     \
    \                                                    - unclosed delimiter\n...\n\
    61 |                     if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n   |                                                   \
    \                                          - unclosed delimiter\n...\n68 |   \
    \                      if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n   |                                                   \
    \                                              - this delimiter might not be properly\
    \ closed...\n...\n76 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n88 | }\n   |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmp5j7dccah.rs:27:40\n\
    \   |\n27 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmp5j7dccah."
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut interval = interval1;\n    let\
    \ mut interval2 = interval2;\n    let mut prime = true;\n    loop {\n        if\
    \ interval[0] >= interval[1] {\n            interval = interval2;\n          \
    \  interval2 = interval1;\n            prime = false;\n        }\n        if prime\
    \ {\n            if interval[0] < interval[1] {\n                interval[0] =\
    \ interval[0] + 1;\n            } else {\n                interval[1] = interval[1]\
    \ - 1;\n            }\n        } else {\n            if interval[0] < interval[1]\
    \ {\n                interval[0] = interval[0] + 1;\n            } else {\n  \
    \              interval[1] = interval[1] - 1;\n            }\n        }\n    \
    \    if interval[0] >= interval[1] {\n            break;\n        }\n    }\n \
    \   if prime {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:58:17\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0y7n8jd.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpv0y7n8jd.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpv0y7n8jd.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:61:25\n   |\n61 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:62:17\n  \
    \ |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0y7n8jd.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv0y7n8jd.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_end < interval2_end\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_start < interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    let mut interval1_length\
    \ = interval1_end - interval1_start + 1;\n    let mut interval2_length = interval2_end\
    \ - interval2_start + 1;\n    let mut intersection_length = interval1_length +\
    \ interval2_length;\n    if intersection_length == 2 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 1 {\n        return String::from(\"\
    YES\");\n    }\n    if intersection_length == \n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n   --> /tmp/tmpuzvguf1h.rs:101:1\n\
    \    |\n101 | }\n    | ^ expected expression\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n   --> /tmp/tmpuzvguf1h.rs:105:17\n    |\n105 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpuzvguf1h.rs:105:25\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpuzvguf1h.rs:106:17\n    |\n106 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpuzvguf1h.rs:106:25\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpuzvguf1h.rs:107:17\n    |\n107 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpuzvguf1h.rs:107:25\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpuzvguf1h.rs:108:17\n    |\n108 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpuzvguf1h.rs:108:25\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpuzvguf1h.rs:109:17\n    |\n109 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpuzvguf1h.rs:109:25\n\
    \    |\n109 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in th"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    \n    if interval1.0 > interval2.0 {\n        interval = interval2;\n   \
    \     interval2 = interval1;\n    }\n    \n    if interval1.1 == interval2.1 {\n\
    \        return String::from(\"NO\");\n    }\n    \n    if interval1.1 > interval2.1\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.2 > interval2.2 {\n        interval = interval1;\n     \
    \   interval1 = interval2;\n    }\n    \n    if interval1.3 == interval2.3 {\n\
    \        return String::from(\"NO\");\n    }\n    \n    if interval1.3 > interval2.3\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.4 > interval2.4 {\n        interval = interval1;\n     \
    \   interval1 = interval2;\n    }\n    \n    if interval1.5 > interval2.5 {\n\
    \        interval = interval1;\n        interval1 = interval2;\n    }\n    \n\
    \    if interval1.6 > interval2.6 {\n        interval = interval1;\n        interval1\
    \ = interval2;\n    }\n    \n    if interval1.7 > interval2.7 {\n        interval\
    \ = interval1;\n        interval1 = interval2;\n    }\n    \n    if interval1.8\
    \ > interval2.8 {\n        interval = interval1;\n        interval1 = interval2;\n\
    \    }\n    \n    if interval1.9 > interval2.9 {\n        interval = interval1;\n\
    \        interval1 = interval2;\n    }\n    \n    if interval1.10 > interval2.10\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.11 > interval2.11 {\n        interval = interval1;\n   \
    \     interval1 = interval2;\n    }\n    \n    if interval1.12 > interval2.12\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.13 > interval2.13 {\n        interval = interval1;\n   \
    \     interval1 = interval2;\n    }\n    \n    if interval1.14 > interval2.14\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.15 > interval2.15 {\n        interval = interval1;\n   \
    \     interval1 = interval2;\n    }\n    \n    if interval1.16 > interval2.16\
    \ {\n        interval = interval1;\n        interval1 = interval2;\n    }\n  \
    \  \n    if interval1.17 > interval2.17 {\n        interval = interval1;\n   \
    \     interval1 = interval\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp017y_55e.rs:132:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n117 |     if interval1.17\
    \ > interval2.17 {\n    |                                    - this delimiter\
    \ might not be properly closed...\n...\n120 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n132 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp017y_55e.rs:124:17\n    |\n\
    124 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp017y_55e.rs:124:25\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp017y_55e.rs:125:17\n\
    \    |\n125 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp017y_55e.rs:125:25\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp017y_55e.rs:126:17\n\
    \    |\n126 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp017y_55e.rs:126:25\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp017y_55e.rs:127:17\n\
    \    |\n127 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp017y_55e.rs:127:25\n    |\n127 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ canno"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\".to_string();\n        } else\
    \ {\n            return \"NO\".to_string();\n        }\n    }\n    let mut interval1_length\
    \ = interval1_end - interval1_start + 1;\n    let mut interval2_length = interval2_end\
    \ - interval2_start + 1;\n    if interval1_length > interval2_length {\n     \
    \   interval1_length, interval2_length = interval2_length, interval1_length;\n\
    \    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ < interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n        if interval1_start < interval2_end {\n            interval1_start,\
    \ interval2_end = interval2_end, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_start {\n            interval1_end, interval2_start = interval2_start,\
    \ interval1_end;\n        }\n        if interval1_start == interval1_end {\n \
    \           if interval2_start == interval2_end {\n                return \"YES\"\
    .to_string();\n            } else {\n                return \"NO\".to_string();\n\
    \            }\n        }\n    }\n    if interval1_length < interval2_length {\n\
    \        interval1_length, interval2_length = interval2_length, interval1_length;\n\
    \    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ < interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n        if interval1_start < interval2_end {\n            interval1_start,\
    \ interval2_end = interval2_end, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpe9e_8okf.rs:96:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n73 |     if interval1_length\
    \ == interval2_length {\n   |                                             - this\
    \ delimiter might not be properly closed...\n...\n84 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n96 | }\n   |   ^\n\nerror: expected\
    \ `:`, found `=`\n  --> /tmp/tmpe9e_8okf.rs:26:42\n   |\n26 |         interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n   |                  \
    \                       -^\n   |                                         |\n \
    \  |                                         help: replace equals symbol with\
    \ a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n  --> /tmp/tmpe9e_8okf.rs:20:81\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       ^ unclosed delimiter\n...\n25 |     if interval1_start\
    \ > interval2_start {\n   |                          --------------- while parsing\
    \ this struct\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n   |                                                     \
    \                       ^\n   |                                              \
    \                              |\n   |                                       \
    \                                     expected one of `,` or `}`\n   |       \
    \                                                                     help: `}`\
    \ may belong here\n\nerror: struct literals are not allowed here\n  --> /tmp/tmpe9e_8okf.rs:25:26\n\
    \   |\n25 |       if interval1_start > interval2_start {\n   |  __________________________^\n\
    26 | |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    27 | |     }\n   | |_____^\n   |\nhelp: surround the struct literal with parenthes"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start > interval2.start {\n        let (start,\
    \ end) = interval1;\n        intersection(interval2, (start, end - 1))\n    }\
    \ else if interval1.end < interval2.end {\n        let (start, end) = interval1;\n\
    \        intersection((start, end - 1), interval2)\n    } else {\n        let\
    \ (start, end) = interval1;\n        let (end1, end2) = interval2;\n        if\
    \ start < end1 {\n            if end < end2 {\n                return \"NO\";\n\
    \            }\n            return \"YES\";\n        }\n        if start > end2\
    \ {\n            return \"NO\";\n        }\n        return \"YES\";\n    }\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:45:17\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd4jbo5ld.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpd4jbo5ld.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpd4jbo5ld.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd4jbo5ld.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpd4jbo5ld.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval2[0];\n        interval\n    } else {\n       \
    \ let mut interval = interval2;\n        interval[0] = interval2[0];\n       \
    \ interval[1] = interval1[1];\n        interval\n    }\n    let mut prime = true;\n\
    \    for i in interval {\n        if i % 2 == 0 {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if prime {\n        \"YES\"\n    }\
    \ else {\n        \"NO\"\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `interval` in this scope\n  --> /tmp/tmptkp_3kri.rs:33:14\n\
    \   |\n33 |     for i in interval {\n   |              ^^^^^^^^ help: a local\
    \ variable with a similar name exists: `interval1`\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmptkp_3kri.rs:48:17\n   |\n48 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptkp_3kri.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptkp_3kri.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptkp_3kri.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptkp_3kri.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptkp_3kri.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptkp_3kri.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptkp_3kri.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptkp_3kri.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptkp_3kri.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this s"
  stdout: ''
  timestamp: 1659805578
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_end == interval2_end\
    \ {\n        if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    let mut interval1_length\
    \ = interval1_end - interval1_start + 1;\n    let mut interval2_length = interval2_end\
    \ - interval2_start + 1;\n    let mut intersection_length = interval1_length +\
    \ interval2_length;\n    if interval1_length == interval2_length {\n        if\
    \ interval1_start == interval2_start {\n            return String::from(\"YES\"\
    );\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_length\
    \ < interval2_length {\n        intersection_length = interval1_length;\n    }\
    \ else {\n        intersection_length = interval2_length;\n    }\n    if intersection_length\
    \ == 2 {\n        if interval1_start == interval2_start {\n            return\
    \ String::from(\"YES\");\n        }\n        return String::from(\"NO\");\n  \
    \  }\n    if intersection_length == 1 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 0 {\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 2 {\n        if interval1_start ==\
    \ interval2_start {\n            return String::from(\"YES\");\n        }\n  \
    \      return String::from(\"NO\");\n    }\n    if intersection_length == 1 {\n\
    \        if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if intersection_length\
    \ == 0 {\n        return String::from(\"NO\");\n    }\n    if intersection_length\
    \ == 2 {\n        if interval1_start == interval2_start {\n            return\
    \ String::from(\"YES\");\n        }\n        return String::from(\"NO\");\n  \
    \  }\n    if intersection_length == 1 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if intersection_length == 0 {\n        return \n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp6iln3ae.rs:109:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n95  |     if intersection_length\
    \ == 0 {\n    |                                 - this delimiter might not be\
    \ properly closed...\n96  |         return \n97  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n109 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp6iln3ae.rs:101:17\n\
    \    |\n101 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp6iln3ae.rs:101:25\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp6iln3ae.rs:102:17\n\
    \    |\n102 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp6iln3ae.rs:102:25\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp6iln3ae.rs:103:17\n\
    \    |\n103 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp6iln3ae.rs:103:25\n    |\n103 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp6iln3ae.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp6iln3ae.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_end = interval2_end;\n        interval2_start = interval1_start;\n\
    \    }\n    if interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\";\n\
    \        } else {\n            return \"NO\";\n        }\n    }\n    if interval1_end\
    \ == interval2_end {\n        if interval1_end == interval2_end {\n          \
    \  return \"YES\";\n        } else {\n            return \"NO\";\n        }\n\
    \    }\n    if interval1_end < interval2_end {\n        let mut interval1_length\
    \ = interval1_end - interval1_start;\n        let mut interval2_length = interval2_end\
    \ - interval2_start;\n        if interval1_length == interval2_length {\n    \
    \        if interval1_length == 2 {\n                return \"YES\";\n       \
    \     } else {\n                return \"NO\";\n            }\n        }\n   \
    \     if interval1_length < interval2_length {\n            let mut interval1_length\
    \ = interval1_end - interval1_start;\n            let mut interval2_length = interval2_end\
    \ - interval2_start;\n            if interval1_length == interval2_length {\n\
    \                return \"YES\";\n            } else {\n                return\
    \ \"NO\";\n            }\n        }\n    }\n    if interval1_end > interval2_end\
    \ {\n        let mut interval1_length = interval1_end - interval1_start;\n   \
    \     let mut interval2_length = interval2_end - interval2_start;\n        if\
    \ interval1_length == interval2_length {\n            if interval1_length == 2\
    \ {\n                return \"YES\";\n            } else {\n                return\
    \ \"NO\";\n            }\n        }\n        if interval1_length < interval2_length\
    \ {\n            let mut interval1_length = interval1_end - interval1_start;\n\
    \            let mut interval2_length = interval2_end - interval2_start;\n   \
    \         if interval1_length == interval2_length {\n                return \"\
    YES\";\n            } else {\n                return \"NO\";\n            }\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkw6u0jff.rs:99:17\n\
    \   |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkw6u0jff.rs:99:25\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmpkw6u0jff.rs:100:17\n    |\n\
    100 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmpkw6u0jff.rs:100:25\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpkw6u0jff.rs:101:17\n\
    \    |\n101 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpkw6u0jff.rs:101:25\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpkw6u0jff.rs:102:17\n\
    \    |\n102 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpkw6u0jff.rs:102:25\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpkw6u0jff.rs:103:17\n\
    \    |\n103 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpkw6u0jff.rs:103:25\n    |\n103 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpkw6u0jff.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        if interval1_end <\
    \ interval2_start {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_end == interval2_end {\n   \
    \         if interval1_start == interval2_start {\n                return String::from(\"\
    YES\");\n            }\n            return String::from(\"NO\");\n        }\n\
    \        let mut interval1_len = interval1_end - interval1_start + 1;\n      \
    \  let mut interval2_len = interval2_end - interval2_start + 1;\n        let mut\
    \ i = 0;\n        while i < interval1_len && i < interval2_len {\n           \
    \ if interval1_start == interval2_start {\n                if interval1_end ==\
    \ interval2_end {\n                    return String::from(\"YES\");\n       \
    \         }\n                return String::from(\"NO\");\n            }\n   \
    \         if interval1_start < interval2_start {\n                interval1_start\
    \ += 1;\n            } else {\n                interval2_start += 1;\n       \
    \     }\n            i += 1;\n        }\n        if interval1_len > interval2_len\
    \ {\n            interval1_len = interval2_len;\n        }\n        if interval1_len\
    \ == interval2_len {\n            if interval1_start == interval2_start {\n  \
    \              return String::from(\"YES\");\n            }\n            return\
    \ String::from(\"NO\");\n        }\n    }\n    return String::from(\"NO\");\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp4h0gump6.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp4h0gump6.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp4h0gump6.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp4h0gump6.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp4h0gump6.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp4h0gump6.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut interval1_len = interval1[1] -\
    \ interval1[0] + 1;\n    let mut interval2_len = interval2[1] - interval2[0] +\
    \ 1;\n    let mut intersection_len = 0;\n    let mut interval1_start = interval1[0];\n\
    \    let mut interval1_end = interval1[1];\n    let mut interval2_start = interval2[0];\n\
    \    let mut interval2_end = interval2[1];\n    while interval1_start <= interval1_end\
    \ && interval2_start <= interval2_end {\n        if interval1_start <= interval2_start\
    \ {\n            interval1_len += 1;\n            interval1_start += 1;\n    \
    \    } else {\n            interval2_len += 1;\n            interval2_start +=\
    \ 1;\n        }\n        intersection_len += 1;\n    }\n    if interval1_start\
    \ > interval1_end {\n        interval1_len -= 1;\n        interval1_end += 1;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_len -= 1;\n\
    \        interval2_end += 1;\n    }\n    if interval1_len == 0 || interval2_len\
    \ == 0 {\n        return \"NO\";\n    }\n    if intersection_len == 0 {\n    \
    \    return \"NO\";\n    }\n    if interval1_len == interval2_len {\n        return\
    \ \"YES\";\n    }\n    if interval1_len > interval2_len {\n        return \"NO\"\
    ;\n    }\n    if interval1_len < interval2_len {\n        return \"YES\";\n  \
    \  }\n    let mut interval1_prime = true;\n    let mut interval2_prime = true;\n\
    \    let mut prime_len = interval1_len + interval2_len - 1;\n    while prime_len\
    \ > 0 {\n        if interval1_prime == true && interval2_prime == true {\n   \
    \         if interval1_len % prime_len == 0 && interval2_len % prime_len == 0\
    \ {\n                return \"YES\";\n            }\n        }\n        if interval1_prime\
    \ == true {\n            interval1_prime &= interval1_len % prime_len == 0;\n\
    \            interval1_len -= 1;\n        }\n        if interval2_prime == true\
    \ {\n            interval2_prime &= interval2_len % prime_len == 0;\n        \
    \    interval2_len -= 1;\n        }\n        prime_len -= 1;\n    }\n    return\
    \ \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5ri40arn.rs:88:17\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5ri40arn.rs:88:25\n   |\n88 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5ri40arn.rs:89:17\n   |\n89 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5ri40arn.rs:89:25\n\
    \   |\n89 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5ri40arn.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5ri40arn.rs:90:25\n   |\n90 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5ri40arn.rs:91:17\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5ri40arn.rs:91:25\n   |\n91 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5ri40arn.rs:92:17\n  \
    \ |\n92 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5ri40arn.rs:92:25\n   |\n92 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5ri40arn.rs:93:17\n   |\n93 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_end == interval2_end\
    \ {\n        if interval1_start == interval2_start {\n            return \"NO\"\
    ;\n        }\n        return \"YES\";\n    }\n    let mut interval1_length = interval1_end\
    \ - interval1_start + 1;\n    let mut interval2_length = interval2_end - interval2_start\
    \ + 1;\n    if interval1_length > interval2_length {\n        interval1_length\
    \ = interval2_length;\n    }\n    if interval1_length == 2 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        return\
    \ \"NO\";\n    }\n    if interval1_length == 3 && interval2_length == 3 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        if interval1_end == interval2_end {\n            return \"\
    YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_length == 3\
    \ && interval2_length == 2 {\n        if interval1_start == interval2_start {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    if\
    \ interval1_length == 3 && interval2_length == 1 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        return\
    \ \"NO\";\n    }\n    if interval1_length == 3 && interval2_length == 0 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 3 && interval2_length\
    \ == -1 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_length\
    \ == 3 && interval2_length == -2 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval1_length == 3 && interval2_length == -3 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        return\
    \ \"NO\";\n    }\n    if interval1_length == 3 && interval2_length == -4 {\n \
    \       if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 3 && interval2_length\
    \ == -5 {\n        if interval1_start \n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwdn3yt2b.rs:115:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n101 |     if interval1_length\
    \ == 3 && interval2_length == -5 {\n    |                                    \
    \                    - this delimiter might not be properly closed...\n102 | \
    \        if interval1_start \n103 | }\n    | - ...as it matches this but it has\
    \ different indentation\n...\n115 | }\n    |   ^\n\nerror: expected `{`, found\
    \ `}`\n   --> /tmp/tmpwdn3yt2b.rs:103:1\n    |\n102 |         if interval1_start\
    \ \n    |         -- this `if` expression has a condition, but no block\n103 |\
    \ }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpwdn3yt2b.rs:107:17\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwdn3yt2b.rs:107:25\n    |\n107 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwdn3yt2b.rs:108:17\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwdn3yt2b.rs:108:25\n    |\n108 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwdn3yt2b.rs:109:17\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpwdn3yt2b.rs:109:25\n    |\n109 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpwdn3yt2b.rs:110:17\n    |\n110 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval1_start = interval2_start;\n    }\n\n    if interval1_start <=\
    \ interval1_end && interval2_start <= interval2_end {\n        let mut intersection_length\
    \ = interval1_end - interval1_start;\n        if interval1_start <= interval2_start\
    \ {\n            intersection_length += interval2_end - interval2_start;\n   \
    \     }\n        if intersection_length == 2 {\n            return \"YES\".to_string();\n\
    \        }\n        if intersection_length == 1 {\n            return \"NO\".to_string();\n\
    \        }\n        if intersection_length == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpw3sxyemd.rs:56:17\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpw3sxyemd.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpw3sxyemd.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpw3sxyemd.rs:57:25\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpw3sxyemd.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpw3sxyemd.rs:58:25\n   |\n58 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpw3sxyemd.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpw3sxyemd.rs:59:25\n   |\n59 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpw3sxyemd.rs:60:17\n  \
    \ |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpw3sxyemd.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpw3sxyemd.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut interval1_len = interval1[1] -\
    \ interval1[0] + 1;\n    let mut interval2_len = interval2[1] - interval2[0] +\
    \ 1;\n    let mut intersection_len = interval1_len + interval2_len;\n    let mut\
    \ prime = true;\n    let mut prime_len = prime_len = interval1_len + interval2_len;\n\
    \    let mut prime_start = interval1[0];\n    let mut prime_end = interval1[1];\n\
    \    let mut prime_len = prime_len = interval1_len + interval2_len;\n    let mut\
    \ prime_start = interval1[0];\n    let mut prime_end = interval1[1];\n    let\
    \ mut prime_len = prime_len = interval1_len + interval2_len;\n    let mut prime_start\
    \ = interval1[0];\n    let mut prime_end = interval1[1];\n    let mut prime_len\
    \ = prime_len = interval1_len + interval2_len;\n    let mut prime_start = interval1[0];\n\
    \    let mut prime_end = interval1[1];\n    let mut prime_len = prime_len = interval1_len\
    \ + interval2_len;\n    let mut prime_start = interval1[0];\n    let mut prime_end\
    \ = interval1[1];\n    let mut prime_len = prime_len = interval1_len + interval2_len;\n\
    \    let mut prime_start = interval1[0];\n    let mut prime_end = interval1[1];\n\
    \    let mut prime_len = prime_len = interval1_len + interval2_len;\n    let mut\
    \ prime_start = interval1[0];\n    let mut prime_end = interval1[1];\n    let\
    \ mut prime_len = prime_len = interval1_len + interval2_len;\n    let mut prime_start\
    \ = interval1[0];\n    let mut prime_end = interval1[1];\n    let mut prime_len\
    \ = prime_len = interval1_len + interval2_len;\n    let mut prime_start = interval1[0];\n\
    \    let mut prime_end = interval1[1];\n    let mut prime_len = prime_len = interval1_len\
    \ + interval2_len;\n    let mut prime_start = interval1[0];\n    let mut prime_end\
    \ = interval1[1];\n    let mut prime_len = prime_len = interval1_len + interval2_len;\n\
    \    let mut prime_start = interval1[0];\n    let mut prime_end = interval1[1];\n\
    \    let mut prime_len = prime_len = interval1_len + interval2_len;\n    let mut\
    \ prime_start = interval1[0];\n    let mut prime_end = \n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpsef9xw1y.rs:64:1\n\
    \   |\n64 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `prime_len`\
    \ in this scope\n  --> /tmp/tmpsef9xw1y.rs:28:25\n   |\n28 |     let mut prime_len\
    \ = prime_len = interval1_len + interval2_len;\n   |                         ^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsef9xw1y.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsef9xw1y.rs:68:25\n   |\n68 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsef9xw1y.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsef9xw1y.rs:69:25\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsef9xw1y.rs:70:17\n  \
    \ |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsef9xw1y.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsef9xw1y.rs:71:17\n   |\n71 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsef9xw1y.rs:71:25\n\
    \   |\n71 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsef9xw1y.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  -"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    let mut length = 0;\n    while interval.start < interval.end && interval2.start\
    \ < interval2.end {\n        if interval.start < interval2.start {\n         \
    \   interval = interval2;\n            interval2 = interval1;\n        }\n   \
    \     interval = interval2;\n        interval2 = interval1;\n        length +=\
    \ 1\n    }\n    if interval.start == interval.end {\n        if interval2.start\
    \ == interval2.end {\n            return \"NO\"\n        } else {\n          \
    \  return \"YES\"\n        }\n    } else {\n        if length == 2 {\n       \
    \     return \"YES\"\n        } else {\n            return \"NO\"\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpaxj4x6te.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxj4x6te.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaxj4x6te.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaxj4x6te.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaxj4x6te.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaxj4x6te.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaxj4x6te.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaxj4x6te.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaxj4x6te.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaxj4x6te.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaxj4x6te.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start <= interval1.end && interval2.start <= interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut intersection = interval;\n        intersection.start = intersection.end;\n\
    \        intersection.end = intersection.start;\n        let mut prime = true;\n\
    \        for i in 1..=interval.end {\n            if intersection.start == i {\n\
    \                prime = false;\n                break;\n            }\n     \
    \   }\n        for i in 1..=interval2.end {\n            if intersection.start\
    \ == i {\n                prime = false;\n                break;\n           \
    \ }\n        }\n        if prime {\n            return \"YES\";\n        }\n \
    \       return \"NO\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsu66v6dy.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsu66v6dy.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsu66v6dy.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsu66v6dy.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsu66v6dy.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsu66v6dy.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsu66v6dy.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsu66v6dy.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsu66v6dy.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsu66v6dy.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsu66v6dy.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start >= interval1.end || interval2.start >= interval2.end\
    \ {\n        return \"NO\";\n    }\n    let mut interval = interval1;\n    interval.start\
    \ = interval.end;\n    interval.end = interval.start;\n    if interval1.start\
    \ < interval2.start {\n        interval.start = interval2.start;\n    }\n    if\
    \ interval1.end > interval2.end {\n        interval.end = interval2.end;\n   \
    \ }\n    if interval.start == interval.end {\n        return \"NO\";\n    }\n\
    \    if interval.start > interval.end {\n        return \"NO\";\n    }\n    let\
    \ mut prime = true;\n    for i in 1..interval.end {\n        if interval1.start\
    \ <= i && i <= interval2.end {\n            if !prime {\n                prime\
    \ = false;\n            }\n        } else {\n            prime = true;\n     \
    \   }\n    }\n    if prime {\n        return \"YES\";\n    }\n    return \"NO\"\
    ;\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:57:17\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8lb7qtqi.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8lb7qtqi.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8lb7qtqi.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:60:25\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:61:17\n  \
    \ |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8lb7qtqi.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8lb7qtqi.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_length = 0;\n    let mut interval_start =\
    \ interval1[0];\n    let mut interval_end = interval1[1];\n    let mut interval_start_2\
    \ = interval2[0];\n    let mut interval_end_2 = interval2[1];\n\n    if interval_start\
    \ > interval_end {\n        interval_start = interval_end;\n    }\n    if interval_start_2\
    \ > interval_end_2 {\n        interval_start_2 = interval_end_2;\n    }\n\n  \
    \  if interval_start < interval_start_2 {\n        interval_length = interval_end\
    \ - interval_start;\n    } else {\n        interval_length = interval_end_2 -\
    \ interval_start_2;\n    }\n\n    if interval_length == 2 {\n        if interval_start\
    \ == interval_end {\n            return \"YES\";\n        }\n        if interval_start\
    \ == interval_start_2 {\n            return \"YES\";\n        }\n        if interval_end\
    \ == interval_end_2 {\n            return \"YES\";\n        }\n    }\n\n    if\
    \ interval_length == 1 {\n        if interval_start == interval_end {\n      \
    \      return \"YES\";\n        }\n        if interval_start == interval_start_2\
    \ {\n            return \"YES\";\n        }\n        if interval_end == interval_end_2\
    \ {\n            return \"YES\";\n        }\n    }\n\n    if interval_length ==\
    \ 0 {\n        return \"NO\";\n    }\n\n    if interval_length == 2 {\n      \
    \  if interval_start == interval_end {\n            return \"YES\";\n        }\n\
    \        if interval_start == interval_start_2 {\n            return \"YES\";\n\
    \        }\n        if interval_end == interval_end_2 {\n            return \"\
    YES\";\n        }\n    }\n\n    if interval_length == 1 {\n        if interval_start\
    \ == interval_end {\n            return \"YES\";\n        }\n        if interval_start\
    \ == interval_start_2 {\n            return \"YES\";\n        }\n        if interval_end\
    \ == interval_end_2 {\n            return \"YES\";\n        }\n    }\n\n    if\
    \ interval_length == 3 {\n        if interval_start == interval_end {\n      \
    \      return \"YES\";\n        }\n        if interval_start == interval_start_2\
    \ {\n            return \"YES\";\n        }\n        if interval_end == interval_end_2\
    \ {\n            return \"YES\";\n        }\n    }\n\n    if interval_length ==\
    \ 4 {\n        if interval_start == interval_end {\n            return \"YES\"\
    ;\n        }\n        if interval_start == interval_start_2 {\n            return\
    \ \"YES\";\n        }\n        if interval_end == interval_end_2 {\n         \
    \   return \"YES\";\n        }\n    }\n\n    if interval_length == 5 {\n     \
    \   if interval_start == interval_end {\n            return \"YES\";\n       \
    \ }\n        if interval_\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzfjr95iu.rs:133:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n116 |     if interval_length\
    \ == 5 {\n    |                             - this delimiter might not be properly\
    \ closed...\n...\n121 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n133 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   -->\
    \ /tmp/tmpzfjr95iu.rs:121:1\n    |\n120 |         if interval_\n    |        \
    \ -- this `if` expression has a condition, but no block\n121 | }\n    | ^ expected\
    \ `{`\n\nerror[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpzfjr95iu.rs:125:17\n\
    \    |\n125 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpzfjr95iu.rs:125:25\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpzfjr95iu.rs:126:17\n\
    \    |\n126 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpzfjr95iu.rs:126:25\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpzfjr95iu.rs:127:17\n\
    \    |\n127 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpzfjr95iu.rs:127:25\n    |\n127 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpzfjr95iu.rs:128:17\n\
    \    |\n128 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start < interval1.end && interval2.start < interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        interval = interval2;\n     \
    \   interval.start = interval.end;\n        interval.end = interval.start;\n \
    \       let mut interval_len = interval.end - interval.start + 1;\n        let\
    \ mut prime_numbers = vec![false; interval_len];\n        let mut prime_numbers_len\
    \ = prime_numbers.len();\n        let mut prime_numbers_len2 = prime_numbers_len\
    \ * prime_numbers_len;\n        let mut prime_numbers_len3 = prime_numbers_len2\
    \ * prime_numbers_len;\n        let mut prime_numbers_len4 = prime_numbers_len3\
    \ * prime_numbers_len;\n        let mut prime_numbers_len5 = prime_numbers_len4\
    \ * prime_numbers_len;\n        let mut prime_numbers_len6 = prime_numbers_len5\
    \ * prime_numbers_len;\n        let mut prime_numbers_len7 = prime_numbers_len6\
    \ * prime_numbers_len;\n        let mut prime_numbers_len8 = prime_numbers_len7\
    \ * prime_numbers_len;\n        let mut prime_numbers_len9 = prime_numbers_len8\
    \ * prime_numbers_len;\n        let mut prime_numbers_len10 = prime_numbers_len9\
    \ * prime_numbers_len;\n        let mut prime_numbers_len11 = prime_numbers_len10\
    \ * prime_numbers_len;\n        let mut prime_numbers_len12 = prime_numbers_len11\
    \ * prime_numbers_len;\n        let mut prime_numbers_len13 = prime_numbers_len12\
    \ * prime_numbers_len;\n        let mut prime_numbers_len14 = prime_numbers_len13\
    \ * prime_numbers_len;\n        let mut prime_numbers_len15 = prime_numbers_len14\
    \ * prime_numbers_len;\n        let mut prime_numbers_len16 = prime_numbers_len15\
    \ * prime_numbers_len;\n        let mut prime_numbers_len17 = prime_numbers_len16\
    \ * prime_numbers_len;\n        let mut prime_numbers_len18 = prime_numbers_len17\
    \ * prime_numbers_len;\n        let mut prime_numbers_len19 = prime_numbers_len18\
    \ * prime_numbers_len;\n        let mut prime_numbers_len20 = prime_numbers_len19\
    \ * prime_\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpie68_f49.rs:62:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n21 |     if interval1.start < interval1.end\
    \ && interval2.start < interval2.end {\n   |                                 \
    \                                          - this delimiter might not be properly\
    \ closed...\n...\n50 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n62 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpie68_f49.rs:49:67\n\
    \   |\n49 |         let mut prime_numbers_len20 = prime_numbers_len19 * prime_\n\
    \   |                                                                   ^ help:\
    \ add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `prime_` in this scope\n  --> /tmp/tmpie68_f49.rs:49:61\n   |\n49 |        \
    \ let mut prime_numbers_len20 = prime_numbers_len19 * prime_\n   |           \
    \                                                  ^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpie68_f49.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpie68_f49.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpie68_f49.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpie68_f49.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpie68_f49.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ va"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    if interval1_len\
    \ < interval2_len {\n        interval1_len = interval2_len;\n        interval2_start\
    \ = interval1[0];\n        interval2_end = interval1[1];\n    }\n    if interval1_len\
    \ == interval2_len {\n        if interval1_start <= interval2_start {\n      \
    \      interval1_start = interval2_start;\n            interval1_end = interval2_end;\n\
    \        } else {\n            interval1_start = interval1[0];\n            interval1_end\
    \ = interval1[1];\n        }\n    }\n    if interval1_len % interval2_len == 0\
    \ {\n        let mut interval1_prime = true;\n        let mut interval2_prime\
    \ = true;\n        for _ in 0..interval1_len {\n            if interval1_start\
    \ + interval1_len % interval2_len != interval2_start {\n                interval1_prime\
    \ = false;\n                break;\n            }\n            interval1_len -=\
    \ 1;\n        }\n        for _ in 0..interval2_len {\n            if interval2_start\
    \ + interval2_len % interval1_len != interval1_end {\n                interval2_prime\
    \ = false;\n                break;\n            }\n            interval2_len -=\
    \ 1;\n        }\n        if interval1_prime && interval2_prime {\n           \
    \ return \"YES\";\n        }\n        return \"NO\";\n    }\n    return \"NO\"\
    ;\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmppx7ho9ky.rs:68:17\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppx7ho9ky.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppx7ho9ky.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmppx7ho9ky.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmppx7ho9ky.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmppx7ho9ky.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmppx7ho9ky.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmppx7ho9ky.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmppx7ho9ky.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppx7ho9ky.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppx7ho9ky.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        if interval1_end <\
    \ interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n    }\n    if interval1_start <= interval2_end {\n        if interval1_end\
    \ < interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n    }\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        if interval1_end <\
    \ interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n    }\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        if interval1_end <\
    \ interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end > interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n    }\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end \n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpi461r8c3.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmpi461r8c3.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpi461r8c3.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpi461r8c3.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmpi461r8c3.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmpi461r8c3.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n\
    \    if interval1_end < interval1_start {\n        return \"NO\";\n    }\n   \
    \ if interval1_start == interval1_end {\n        return \"NO\";\n    }\n    if\
    \ interval2_start == interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start <= interval2_end && interval1_end >= interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_start >= interval2_start\
    \ && interval1_end <= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ >= interval2_end && interval1_end <= interval2_start {\n        return \"NO\"\
    ;\n    }\n    if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start >= interval2_start\
    \ && interval1_end <= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start >= interval2_start && interval1_end <= interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start <= interval2_start\
    \ && interval1_end >= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ >= interval2_start && interval1_end <= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start >= interval2_start\
    \ && interval1_end <= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start >= interval2_start && interval1_end <= interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start \n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpvfdwuxjh.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpvfdwuxjh.rs:26:72\n   |\n25 |     if interval1_start > interval1_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpvfdwuxjh.rs:25:26\n   |\n25 |       if interval1_start > interval1_end\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval1_end\
    \ {\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpvfdwuxjh.rs:29:40\n\
    \   |\n29 |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpvfdwuxjh.rs:29:72\n   |\n28 |     if interval2_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n29\
    \ |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpvfdwuxjh.rs:28:26\n   |\n28 |       if interval2_start > interval2_end\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start >= interval1.end || interval2.start >= interval2.end\
    \ {\n        return \"NO\";\n    }\n    let mut interval = interval1;\n    if\
    \ interval1.start < interval1.end {\n        interval = interval2;\n    }\n  \
    \  let mut count = 0;\n    let mut start = interval.start;\n    let mut end =\
    \ interval.end;\n    while start < end {\n        if start % interval1.start ==\
    \ 0 && end % interval1.end == 0 {\n            count += 1;\n        }\n      \
    \  start += 1;\n        end += 1;\n    }\n    if count % 2 == 0 {\n        return\
    \ \"YES\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8_03px6f.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8_03px6f.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8_03px6f.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8_03px6f.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8_03px6f.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8_03px6f.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8_03px6f.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8_03px6f.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8_03px6f.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8_03px6f.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8_03px6f.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_1 = interval1;\n    let mut interval_2 = interval2;\n\
    \    let mut interval_1_end = interval1.0;\n    let mut interval_2_end = interval2.0;\n\
    \    let mut interval_1_start = interval1.1;\n    let mut interval_2_start = interval2.1;\n\
    \    let mut interval_1_len = interval1.1;\n    let mut interval_2_len = interval2.1;\n\
    \    let mut interval_1_prime = true;\n    let mut interval_2_prime = true;\n\
    \    let mut prime_length = 0;\n    loop {\n        if interval_1_end >= interval_2_start\
    \ {\n            if interval_1_end <= interval_2_end {\n                if interval_1_end\
    \ == interval_2_end {\n                    if interval_1_end == interval_2_end\
    \ {\n                        if interval_1_end == interval_2_end {\n         \
    \                   if interval_1_end == interval_2_end {\n                  \
    \              prime_length += 1;\n                                interval_1_prime\
    \ = true;\n                                interval_2_prime = true;\n        \
    \                    } else {\n                                prime_length +=\
    \ 2;\n                                interval_1_prime = true;\n             \
    \                   interval_2_prime = false;\n                            }\n\
    \                        } else {\n                            prime_length +=\
    \ 2;\n                            interval_1_prime = true;\n                 \
    \           interval_2_prime = false;\n                        }\n           \
    \         } else {\n                        prime_length += 2;\n             \
    \           interval_1_prime = true;\n                        interval_2_prime\
    \ = false;\n                    }\n                } else {\n                \
    \    prime_length += 2;\n                    interval_1_prime = true;\n      \
    \              interval_2_prime = false;\n                }\n            } else\
    \ {\n                prime_length += 2;\n                interval_1_prime = true;\n\
    \                interval_2_prime = false;\n            }\n        } else {\n\
    \            prime_length += 2;\n            interval_1_prime = true;\n      \
    \      interval_2_prime = false;\n        }\n        if interval_1_end < interval_2_start\
    \ {\n            interval_1_end = interval_1_end + 1;\n            interval_1_len\
    \ = interval_1_len + 1;\n        } else {\n            interval_2_start = interval_2_start\
    \ + 1;\n            interval_2_len = interval_2_len + 1;\n        }\n        if\
    \ interval_1_end == interval_2_end {\n            prime_length += 1;\n       \
    \     interval_1_prime = true;\n            interval_2_prime = true;\n       \
    \ }\n        if interval_1_end > interval_2_end {\n            interval_1_end\
    \ = interval_1_end - 1;\n            interval_1_len = interval_1_len - 1;\n  \
    \      } else {\n            interval_2_end = interval_2_end - 1;\n          \
    \  interval_2_len = interval_2_len - \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpky0h_arv.rs:102:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n32  |     loop {\n    |  \
    \        - unclosed delimiter\n...\n87  |         } else {\n    |            \
    \    - this delimiter might not be properly closed...\n...\n90  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n102 | }\n    |   ^\n\n\
    error: expected expression, found `}`\n  --> /tmp/tmpky0h_arv.rs:90:1\n   |\n\
    90 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left` in\
    \ this scope\n  --> /tmp/tmpky0h_arv.rs:94:17\n   |\n94 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpky0h_arv.rs:94:25\n \
    \  |\n94 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpky0h_arv.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpky0h_arv.rs:95:25\n   |\n95 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpky0h_arv.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpky0h_arv.rs:96:25\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpky0h_arv.rs:97:17\n  \
    \ |\n97 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpky0h_arv.rs:97:25\n   |\n97 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659821547
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![];\n    intervals.push(interval1);\n\
    \    intervals.push(interval2);\n    let mut intervals_iter = intervals.iter();\n\
    \    let mut start = intervals_iter.next().unwrap();\n    let mut end = intervals_iter.next().unwrap();\n\
    \    let mut length = 0;\n    while start != end {\n        if start.0 > end.0\
    \ {\n            intervals_iter.next();\n            start = intervals_iter.next().unwrap();\n\
    \        } else {\n            intervals_iter.next();\n            end = intervals_iter.next().unwrap();\n\
    \        }\n        length = length + start.1 - end.0;\n    }\n    if length ==\
    \ 2 {\n        return \"YES\".to_string();\n    } else {\n        return \"NO\"\
    .to_string();\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmprw10o_mm.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprw10o_mm.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmprw10o_mm.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmprw10o_mm.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprw10o_mm.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprw10o_mm.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprw10o_mm.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprw10o_mm.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprw10o_mm.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprw10o_mm.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmprw10o_mm.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut result = String::from(\"NO\");\n        for (a, b) in interval1.iter().zip(interval2.iter())\
    \ {\n            if a < b {\n                result.push_str(\"NO\");\n      \
    \          break;\n            }\n            if a == b {\n                result.push_str(\"\
    YES\");\n                break;\n            }\n        }\n        result\n  \
    \  } else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmg8mrtqq.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        let mut interval2 = interval2;\n\
    \        let mut length = 0;\n        while interval[0] < interval[1] && interval2[0]\
    \ < interval2[1] {\n            interval[0] = interval[0] + 1;\n            interval2[0]\
    \ = interval2[0] + 1;\n            length = length + 1;\n        }\n        if\
    \ interval[0] == interval[1] && interval2[0] == interval2[1] {\n            if\
    \ length == 2 {\n                return String::from(\"YES\");\n            }\n\
    \            if length == 1 {\n                return String::from(\"NO\");\n\
    \            }\n        }\n    }\n    return String::from(\"NO\");\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmi5svizo.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmi5svizo.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmi5svizo.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmi5svizo.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmi5svizo.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmi5svizo.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmi5svizo.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmi5svizo.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmi5svizo.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmi5svizo.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmi5svizo.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval_length = interval1_end - interval1_start;\n\
    \    let mut interval2_length = interval2_end - interval2_start;\n    if interval1_end\
    \ < interval2_start {\n        interval1_start = interval2_end;\n        interval1_end\
    \ = interval2_start;\n    }\n    if interval2_end < interval1_start {\n      \
    \  interval2_start = interval1_end;\n        interval2_end = interval1_start;\n\
    \    }\n    if interval1_end == interval2_end {\n        interval_length += 1;\n\
    \    }\n    if interval2_end == interval1_end {\n        interval2_length += 1;\n\
    \    }\n    if interval_length == interval2_length {\n        return \"NO\";\n\
    \    }\n    if interval_length < interval2_length {\n        return \"NO\";\n\
    \    }\n    if interval_length == interval2_length {\n        return \"YES\";\n\
    \    }\n    if interval1_start <= interval2_start {\n        interval1_start =\
    \ interval2_start;\n        interval1_end = interval2_end;\n    }\n    if interval1_start\
    \ <= interval2_end {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end >= interval2_end {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n    if interval2_start\
    \ <= interval1_end {\n        interval2_start = interval1_start;\n        interval2_end\
    \ = interval1_end;\n    }\n    if interval2_start <= interval1_end {\n       \
    \ interval2_start = interval1_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_end >= interval2_end {\n        interval1_start = interval2_start;\n\
    \        interval1_end = interval2_end;\n    }\n    if interval2_end >= interval1_end\
    \ {\n        interval2_start = interval1_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_end < interval2_end {\n        interval1_start = interval2_end;\n\
    \        interval1_end = interval2_start;\n    }\n    if interval2_end < interval1_start\
    \ {\n        interval2_start = interval1_end;\n        interval2_end = interval1_start;\n\
    \    }\n    if interval1_end == interval2_end {\n        interval_length += 1;\n\
    \    }\n    if interval2_end == interval1_end {\n        interval2_length += 1;\n\
    \    }\n    if interval_length == interval2_length {\n        return \"NO\";\n\
    \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp3mvvm548.rs:107:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n92  |     if interval_length\
    \ == interval2_length {\n    |                                            - this\
    \ delimiter might not be properly closed...\n...\n95  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n107 | }\n    |   ^\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3mvvm548.rs:99:17\n  \
    \ |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3mvvm548.rs:99:25\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp3mvvm548.rs:100:17\n    |\n\
    100 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp3mvvm548.rs:100:25\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3mvvm548.rs:101:17\n\
    \    |\n101 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3mvvm548.rs:101:25\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3mvvm548.rs:102:17\n\
    \    |\n102 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3mvvm548.rs:102:25\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start > interval1.end {\n        interval1.swap(&interval2);\n\
    \    }\n    if interval2.start > interval2.end {\n        interval2.swap(&interval1);\n\
    \    }\n    if interval1.start > interval2.start {\n        return \"NO\";\n \
    \   }\n    if interval1.end < interval2.end {\n        return \"NO\";\n    }\n\
    \    if interval1.start == interval2.start {\n        return \"NO\";\n    }\n\
    \    if interval1.end == interval2.end {\n        return \"NO\";\n    }\n    let\
    \ mut prime_numbers = vec![];\n    let mut prime_numbers_count = vec![];\n   \
    \ let mut prime_numbers_count_index = vec![];\n    let mut prime_numbers_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index = vec![];\n   \
    \ let mut prime_numbers_count_index_count_index_count = vec![];\n    let mut prime_numbers_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index\
    \ = vec![];\n    let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec!\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmpx5r_pvyt.rs:59:1\n\
    \   |\n58 |     let mut prime_numbers_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count_index_count\
    \ = vec!\n   |                                                               \
    \                                                                            \
    \        - expected one of `(`, `[`, or `{`\n59 | }\n   | ^ unexpected token\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:63:17\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx5r_pvyt.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx5r_pvyt.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx5r_pvyt.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:66:25\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx5r_pvyt.rs:67:17\n  \
    \ |\n67 |     assert_eq!({left}, {"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    while interval1_start <= interval1_end\
    \ && interval2_start <= interval2_end {\n        if interval1_start < interval1_end\
    \ {\n            intersection_start = interval1_start;\n        }\n        if\
    \ interval2_start < interval2_end {\n            intersection_end = interval2_start;\n\
    \        }\n        if intersection_start <= intersection_end {\n            interval1_start\
    \ += 1;\n        } else {\n            interval2_start += 1;\n        }\n    }\n\
    \    if interval1_start <= interval1_end {\n        intersection_start = interval1_start;\n\
    \    }\n    if interval2_start <= interval2_end {\n        intersection_end =\
    \ interval2_start;\n    }\n    if intersection_start <= intersection_end {\n \
    \       if interval1_end > interval2_end {\n            intersection_end = interval1_end;\n\
    \        }\n        if intersection_end > interval1_end {\n            intersection_end\
    \ = interval2_end;\n        }\n        if intersection_end == interval1_end {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    return\
    \ \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:63:17\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnv6d5wyb.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnv6d5wyb.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnv6d5wyb.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:66:25\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:67:17\n  \
    \ |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnv6d5wyb.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnv6d5wyb.rs:68:17\n   |\n68 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return String::from(\"YES\");\n        }\n \
    \       return String::from(\"NO\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \    }\n    if interval1_end < interval2_start {\n        interval1_end, interval1_start\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return String::from(\"\
    NO\");\n        }\n        return String::from(\"YES\");\n    }\n    if interval1_start\
    \ < interval2_end {\n        interval1_start, interval1_end = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_end > interval2_start {\n        interval1_end,\
    \ interval1_start = interval2_end, interval1_start;\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval1_start < interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ > interval2_start {\n        interval1_end, interval1_start = interval2_end,\
    \ interval1_start;\n    }\n    if interval1_start == interval1_end {\n       \
    \ if interval2_start == interval2_end {\n            return String::from(\"NO\"\
    );\n        }\n        return String::from(\"YES\");\n    }\n    if interval1_start\
    \ < interval2_end {\n        interval1_start, interval1_end = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_end > interval2_start {\n        interval1_end,\
    \ interval1_start = interval2_end, interval1_start;\n    }\n\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpsfhyuddu.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpsfhyuddu.rs:26:72\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpsfhyuddu.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval2_start\
    \ {\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpsfhyuddu.rs:29:40\n\
    \   |\n29 |         interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpsfhyuddu.rs:29:72\n   |\n28 |     if interval1_end < interval2_end\
    \ {\n   |                        ------------- while parsing this struct\n29 |\
    \         interval1_end, interval1_start = interval2_end, interval1_start;\n \
    \  |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpsfhyuddu.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.0 {\n        let tmp = interval1;\n\
    \        interval1 = interval2;\n        interval2 = tmp;\n    }\n    let mut\
    \ interval1_start = interval1.0;\n    let mut interval1_end = interval1.1;\n \
    \   let mut interval2_start = interval2.0;\n    let mut interval2_end = interval2.1;\n\
    \    let mut interval1_len = interval1_end - interval1_start;\n    let mut interval2_len\
    \ = interval2_end - interval2_start;\n    let mut intersection_len = interval1_len\
    \ + interval2_len;\n    let mut prime_numbers = vec![true; intersection_len];\n\
    \    let mut prime_numbers_len = prime_numbers.len();\n    let mut prime_numbers_start\
    \ = interval1_start;\n    let mut prime_numbers_end = interval1_end;\n    let\
    \ mut prime_numbers_start = interval2_start;\n    let mut prime_numbers_end =\
    \ interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n    let\
    \ mut prime_numbers_start = interval1_start;\n    let mut prime_numbers_end =\
    \ interval1_end;\n    let mut prime_numbers_start = interval2_start;\n    let\
    \ mut prime_numbers_end = interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_start = interval1_start;\n    let mut prime_numbers_end\
    \ = interval1_end;\n    let mut prime_numbers_start = interval2_start;\n    let\
    \ mut prime_numbers_end = interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_start = interval1_start;\n    let mut prime_numbers_end\
    \ = interval1_end;\n    let mut prime_numbers_start = interval2_start;\n    let\
    \ mut prime_numbers_end = interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_start = interval1_start;\n    let mut prime_numbers_end\
    \ = interval1_end;\n    let mut prime_numbers_start = interval2_start;\n    let\
    \ mut prime_numbers_end = interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut prime_numbers_start = interval1_start;\n    let mut prime_numbers_end\
    \ = interval1_end;\n    let mut prime_numbers_start = interval2_start;\n    let\
    \ mut prime_numbers_end = interval2_end;\n    let mut prime_numbers_len = prime_numbers.len();\n\
    \    let mut \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmphl7ulobh.rs:66:1\n\
    \   |\n66 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmphl7ulobh.rs:70:17\n   |\n70 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmphl7ulobh.rs:70:25\n \
    \  |\n70 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphl7ulobh.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphl7ulobh.rs:71:25\n   |\n71 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphl7ulobh.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphl7ulobh.rs:72:25\n   |\n72 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphl7ulobh.rs:73:17\n  \
    \ |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphl7ulobh.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphl7ulobh.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphl7ulobh.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphl7ulobh.rs:75:17\n   |\n75 |     "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n        interval1_end = interval1[0];\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start = interval2_end;\n        interval2_end\
    \ = interval2[0];\n    }\n    if interval1_start > interval2_start {\n       \
    \ interval1_start = interval2_start;\n        interval1_end = interval2[0];\n\
    \    }\n    if interval1_end < interval2_end {\n        interval1_end = interval2_end;\n\
    \        interval1_start = interval2[0];\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_start = interval2_end;\n        interval1_end = interval2[0];\n\
    \    }\n    if interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval1_start = interval2[0];\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    .to_string();\n        }\n        return \"NO\".to_string();\n    }\n    if interval2_start\
    \ == interval2_end {\n        return \"NO\".to_string();\n    }\n    if interval1_start\
    \ > interval2_start {\n        if interval1_end < interval2_end {\n          \
    \  return \"YES\".to_string();\n        }\n        return \"NO\".to_string();\n\
    \    }\n    if interval1_end < interval2_end {\n        return \"NO\".to_string();\n\
    \    }\n    if interval1_start < interval2_start {\n        if interval1_end >\
    \ interval2_end {\n            return \"YES\".to_string();\n        }\n      \
    \  return \"NO\".to_string();\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    .to_string();\n        }\n        return \"NO\".to_string();\n    }\n    if interval2_start\
    \ == interval2_end {\n        return \"NO\".to_string();\n    }\n    if interval1_start\
    \ > interval2_start {\n        if interval1_end < interval2_end {\n          \
    \  return \"YES\".to_string();\n        }\n        return \"NO\".to_string();\n\
    \    }\n    if interval1_end < interval2_end {\n        return \"NO\".to_string();\n\
    \    }\n    if interval1_start < interval2_start {\n        if interval1_end >\
    \ interval2_end {\n            return \"YES\".to_string();\n        }\n      \
    \  return \"NO\".to_string();\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp6bb8s8df.rs:111:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n97  |     if interval1_start\
    \ == interval1_end {\n    |                                         - this delimiter\
    \ might not be properly closed...\n98  |         if interval2_start == interval\n\
    99  | }\n    | - ...as it matches this but it has different indentation\n...\n\
    111 | }\n    |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmp6bb8s8df.rs:99:1\n\
    \   |\n98 |         if interval2_start == interval\n   |         -- this `if`\
    \ expression has a condition, but no block\n99 | }\n   | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp6bb8s8df.rs:103:17\n\
    \    |\n103 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp6bb8s8df.rs:103:25\n    |\n103 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp6bb8s8df.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp6bb8s8df.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp6bb8s8df.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp6bb8s8df.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp6bb8s8df.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |   "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n        return \"YES\".to_string();\n    }\n    if interval1_start\
    \ <= interval2_end && interval1_end >= interval2_start {\n        return \"NO\"\
    .to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpv0lbuldf.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0lbuldf.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv0lbuldf.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpv0lbuldf.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpv0lbuldf.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv0lbuldf.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpv0lbuldf.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpv0lbuldf.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv0lbuldf.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv0lbuldf.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv0lbuldf.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start <= interval2_end {\n        if interval1_end >=\
    \ interval2_start {\n            if interval1_end <= interval2_end {\n       \
    \         if interval1_start <= interval2_end {\n                    if interval1_end\
    \ >= interval2_start {\n                        if interval1_end <= interval2_end\
    \ {\n                            if interval1_start <= interval2_end {\n     \
    \                           if interval1_end >= interval2_start {\n          \
    \                          if interval1_end <= interval2_end {\n             \
    \                           if interval1_start <= interval2_end {\n          \
    \                                  if interval1_end >= interval2_start {\n   \
    \                                             if interval1_end <= interval2_end\
    \ {\n                                                    if interval1_start <=\
    \ interval2_end {\n                                                        if\
    \ interval1_end >= interval2_start {\n                                       \
    \                     return \"YES\".to_string();\n                          \
    \                              }\n                                           \
    \         }\n                                                }\n             \
    \                               }\n                                        }\n\
    \                                    }\n                                }\n  \
    \                          }\n                        }\n                    }\n\
    \                }\n            }\n        }\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp3bl07g_0.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp3bl07g_0.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp3bl07g_0.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp3bl07g_0.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp3bl07g_0.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp3bl07g_0.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![];\n    intervals.push(interval1);\n\
    \    intervals.push(interval2);\n    let mut intersection = intervals.iter().filter(|&(_,\
    \ end)| end > 0).collect::<Vec<_>>();\n    let mut prime = true;\n    for &(start,\
    \ end) in intersection {\n        if start > end {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if prime {\n        return \"YES\"\
    .to_string();\n    } else {\n        return \"NO\".to_string();\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6ym5n6wx.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6ym5n6wx.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6ym5n6wx.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6ym5n6wx.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6ym5n6wx.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    if interval1[0] < interval1[1] && interval2[0]\
    \ < interval2[1] {\n        let mut interval = interval1;\n        interval.0\
    \ = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n        interval.1\
    \ = interval1[0] < interval2[0] ? interval1[1] : interval2[1];\n        let mut\
    \ interval2 = interval1;\n        interval2.0 = interval1[0] < interval2[0] ?\
    \ interval1[0] : interval2[0];\n        interval2.1 = interval1[0] < interval2[0]\
    \ ? interval1[1] : interval2[1];\n        let mut interval3 = interval1;\n   \
    \     interval3.0 = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n\
    \        interval3.1 = interval1[0] < interval2[0] ? interval1[1] : interval2[1];\n\
    \        let mut interval4 = interval1;\n        interval4.0 = interval1[0] <\
    \ interval2[0] ? interval1[0] : interval2[0];\n        interval4.1 = interval1[0]\
    \ < interval2[0] ? interval1[1] : interval2[1];\n        let mut interval5 = interval1;\n\
    \        interval5.0 = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n\
    \        interval5.1 = interval1[0] < interval2[0] ? interval1[1] : interval2[1];\n\
    \        let mut interval6 = interval1;\n        interval6.0 = interval1[0] <\
    \ interval2[0] ? interval1[0] : interval2[0];\n        interval6.1 = interval1[0]\
    \ < interval2[0] ? interval1[1] : interval2[1];\n        let mut interval7 = interval1;\n\
    \        interval7.0 = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n\
    \        interval7.1 = interval1[0] < interval2[0] ? interval1[1] : interval2[1];\n\
    \        let mut interval8 = interval1;\n        interval8.0 = interval1[0] <\
    \ interval2[0] ? interval1[0] : interval2[0];\n        interval8.1 = interval1[0]\
    \ < interval2[0] ? interval1[1] : interval2[1];\n        let mut interval9 = interval1;\n\
    \        interval9.0 = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n\
    \        interval9.1 = interval1[0] < interval2[0] ? interval1[1] : interval2[1];\n\
    \        let mut interval10 = interval1;\n        interval10.0 = interval1[0]\
    \ < interval2[0] ? interval1[0] : interval2[0];\n        interval10.1 = interval1[0]\
    \ < interval2[0] ? \n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1teuhwzz.rs:67:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n24 |     if interval1[0] <\
    \ interval1[1] && interval2[0] < interval2[1] {\n   |                        \
    \                                           - this delimiter might not be properly\
    \ closed...\n...\n55 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n67 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `interval1`\n  --> /tmp/tmp1teuhwzz.rs:20:81\n   |\n20 | fn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n   |               \
    \                                                                  ^ unclosed\
    \ delimiter\n...\n26 |         interval.0 = interval1[0] < interval2[0] ? interval1[0]\
    \ : interval2[0];\n   |                                                   -^^^^^^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n   |                   \
    \                                |\n   |                                     \
    \              help: `}` may belong here\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp1teuhwzz.rs:59:17\n   |\n59 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp1teuhwzz.rs:59:25\n \
    \  |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1teuhwzz.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1teuhwzz.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1teuhwzz.rs:61:17\n   |\n61"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n\n    if interval1_start < interval1_end {\n      \
    \  if interval1_end < interval2_end {\n            if interval1_end < interval2_start\
    \ {\n                return String::from(\"NO\");\n            }\n           \
    \ return String::from(\"YES\");\n        }\n        return String::from(\"NO\"\
    );\n    }\n    return String::from(\"NO\");\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpf42_8t89.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpf42_8t89.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpf42_8t89.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpf42_8t89.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpf42_8t89.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpf42_8t89.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpf42_8t89.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpf42_8t89.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpf42_8t89.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpf42_8t89.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpf42_8t89.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start > interval1.end {\n        let (start, end)\
    \ = interval1;\n        intersection(end, start)\n    } else if interval2.start\
    \ > interval2.end {\n        let (start, end) = interval2;\n        intersection(start,\
    \ end)\n    } else {\n        let (start, end) = interval1;\n        let (end2,\
    \ start2) = interval2;\n        if start > end {\n            let (start, end)\
    \ = interval1;\n            intersection(end, start)\n        } else if start2\
    \ > end2 {\n            let (start, end) = interval1;\n            intersection(start,\
    \ end)\n        } else {\n            let (start, end) = interval1;\n        \
    \    let (end2, start2) = interval2;\n            if start > end2 {\n        \
    \        let (start, end) = interval1;\n                intersection(end, start)\n\
    \            } else if start2 > end {\n                let (start, end) = interval1;\n\
    \                intersection(start, end)\n            } else {\n            \
    \    let (start, end) = interval1;\n                let (end2, start2) = interval2;\n\
    \                if start > end2 {\n                    let (start, end) = interval1;\n\
    \                    intersection(end, start)\n                } else if start2\
    \ > end {\n                    let (start, end) = interval1;\n               \
    \     intersection(start, end)\n                } else {\n                   \
    \ let (start, end) = interval1;\n                    let (end2, start2) = interval2;\n\
    \                    if start > end2 {\n                        let (start, end)\
    \ = interval1;\n                        intersection(end, start)\n           \
    \         } else if start2 > end {\n                        let (start, end) =\
    \ interval1;\n                        intersection(start, end)\n             \
    \       } else {\n                        let (start, end) = interval1;\n    \
    \                    let (end2, start2) = interval2;\n                       \
    \ if start > end2 {\n                            let (start, end) = interval1;\n\
    \                            intersection(end, start)\n                      \
    \  } else if start2 > end {\n                            let (start, end) = interval1;\n\
    \                            intersection(start, end)\n                      \
    \  } else {\n                            let (start, end) = interval1;\n     \
    \                       let (end2, start2) = interval2;\n                    \
    \        if start > end2 {\n                                let (start, end) =\
    \ interval1;\n                                intersection(end, start)\n     \
    \                       } else if start2 > end {\n                           \
    \     let (start, end) = interval1;\n                                intersection(start,\
    \ end)\n                            } else {\n                               \
    \ let (start, end) = interval1;\n                                let (end2, start2)\
    \ = interval2;\n                                if start > end2 {\n          \
    \                          let (start, end) = interval1;\n                   \
    \                 intersection(end, start)\n                                }\
    \ else if start2 > end {\n                                    let (start, end)\
    \ = interval1;\n                                    intersection(start, end)\n\
    \                                } else {\n                                  \
    \  let (start, end) = interval1;\n                                    let (end2,\
    \ start2) = \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpi4y9u804.rs:105:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n27  |     } else {\n    |\
    \            - unclosed delimiter\n...\n36  |         } else {\n    |        \
    \        - unclosed delimiter\n...\n45  |             } else {\n    |        \
    \            - unclosed delimiter\n...\n54  |                 } else {\n    |\
    \                        - unclosed delimiter\n...\n63  |                    \
    \ } else {\n    |                            - unclosed delimiter\n...\n72  |\
    \                         } else {\n    |                                - unclosed\
    \ delimiter\n...\n81  |                             } else {\n    |          \
    \                          - unclosed delimiter\n...\n90  |                  \
    \               } else {\n    |                                        - this\
    \ delimiter might not be properly closed...\n...\n93  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n105 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n  --> /tmp/tmpi4y9u804.rs:93:1\n   |\n93 | }\n   | ^\
    \ expected expression\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi4y9u804.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi4y9u804.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi4y9u804.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi4y9u804.rs:98:25\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi4y9u804.rs:99:1"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_len = interval1_end\
    \ - interval1_start;\n    let mut interval1_len = interval2_end - interval2_start;\n\
    \    let mut interval2_len = interval1_end - interval1_start;\n    let mut interval1_prime\
    \ = true;\n    let mut interval2_prime = true;\n    \n    while interval1_len\
    \ > 0 && interval2_len > 0 {\n        if interval1_start < interval2_start {\n\
    \            intersection_start = interval1_start;\n            intersection_end\
    \ = interval1_end;\n            intersection_len += 1;\n            interval1_len\
    \ -= 1;\n        } else {\n            intersection_start = interval2_start;\n\
    \            intersection_end = interval2_end;\n            intersection_len +=\
    \ 1;\n            interval2_len -= 1;\n        }\n    }\n    \n    if interval1_len\
    \ > 0 {\n        interval1_prime = false;\n    }\n    \n    if interval2_len >\
    \ 0 {\n        interval2_prime = false;\n    }\n    \n    if intersection_len\
    \ == 1 {\n        if interval1_prime && interval2_prime {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n    \n    if intersection_len\
    \ == 2 {\n        if interval1_prime && interval2_prime {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n    \n    if intersection_len\
    \ > 2 {\n        if interval1_prime && interval2_prime {\n            return \"\
    YES\";\n        }\n        return \"NO\";\n    }\n    \n    if intersection_len\
    \ == 2 {\n        if interval1_prime {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    \n    if intersection_len > 2 {\n        if\
    \ interval1_prime {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    \n    if intersection_len == 1 {\n        if interval1_prime\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   \n    if intersection_len > 1 {\n        if interval1_prime {\n          \
    \  return \"YES\";\n        }\n        return \"NO\";\n    }\n    \n    return\
    \ \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:109:17\n\
    \    |\n109 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpa8ves75t.rs:109:25\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:110:17\n\
    \    |\n110 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpa8ves75t.rs:110:25\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:111:17\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpa8ves75t.rs:111:25\n    |\n111 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:112:17\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpa8ves75t.rs:112:25\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:113:17\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpa8ves75t.rs:113:25\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpa8ves75t.rs:114:17\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                 ^^^^"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    interval.0 = interval.0\
    \ > interval.1 ? *interval.0 : *interval.1;\n    interval.1 = interval.0 > interval.1\
    \ ? *interval.1 : *interval.0;\n    if interval.0 > interval.1 {\n        interval.0\
    \ = interval.0 > interval.1 ? *interval.0 : *interval.1;\n        interval.1 =\
    \ interval.0 > interval.1 ? *interval.1 : *interval.0;\n    }\n    let mut interval\
    \ = interval2;\n    interval.0 = interval.0 > interval.1 ? *interval.0 : *interval.1;\n\
    \    interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n    if\
    \ interval.0 > interval.1 {\n        interval.0 = interval.0 > interval.1 ? *interval.0\
    \ : *interval.1;\n        interval.1 = interval.0 > interval.1 ? *interval.1 :\
    \ *interval.0;\n    }\n    if interval.0 > interval.1 {\n        interval.0 =\
    \ interval.0 > interval.1 ? *interval.0 : *interval.1;\n        interval.1 = interval.0\
    \ > interval.1 ? *interval.1 : *interval.0;\n    }\n    if interval.0 > interval.1\
    \ {\n        interval.0 = interval.0 > interval.1 ? *interval.0 : *interval.1;\n\
    \        interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n \
    \   }\n    if interval.0 > interval.1 {\n        interval.0 = interval.0 > interval.1\
    \ ? *interval.0 : *interval.1;\n        interval.1 = interval.0 > interval.1 ?\
    \ *interval.1 : *interval.0;\n    }\n    if interval.0 > interval.1 {\n      \
    \  interval.0 = interval.0 > interval.1 ? *interval.0 : *interval.1;\n       \
    \ interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n    }\n \
    \   if interval.0 > interval.1 {\n        interval.0 = interval.0 > interval.1\
    \ ? *interval.0 : *interval.1;\n        interval.1 = interval.0 > interval.1 ?\
    \ *interval.1 : *interval.0;\n    }\n    if interval.0 > interval.1 {\n      \
    \  interval.0 = interval.0 > interval.1 ? *interval.0 : *interval.1;\n       \
    \ interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n    }\n \
    \   if interval.0 > interval.1 {\n        interval.0 = interval.0 > interval.1\
    \ ? *interval.0 : *interval.1;\n        interval.1 = interval.0 > interval.1 ?\
    \ *interval.1 : *interval.0;\n    }\n    if interval.0 > interval.1 {\n      \
    \  interval.0 = interval.0 > interval.1 ? *interval.0 : *interval.1;\n       \
    \ interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpww0bpvq4.rs:79:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n63 |     if interval.0 > interval.1\
    \ {\n   |                                - this delimiter might not be properly\
    \ closed...\n...\n67 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n79 | }\n   |   ^\n\nerror: expected mut or const in raw pointer type\n  -->\
    \ /tmp/tmpww0bpvq4.rs:22:58\n   |\n22 |     interval.0 = interval.0 > interval.1\
    \ ? *interval.0 : *interval.1;\n   |                                         \
    \                 ^ expected mut or const in raw pointer type\n   |\n   = help:\
    \ use `*mut T` or `*const T` as appropriate\n\nerror: casts cannot be followed\
    \ by a field access\n  --> /tmp/tmpww0bpvq4.rs:22:45\n   |\n22 |     interval.0\
    \ = interval.0 > interval.1 ? *interval.0 : *interval.1;\n   |               \
    \                              ^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp: try surrounding\
    \ the expression in parentheses\n   |\n22 |     interval.0 = interval.0 > interval.1\
    \ ? *(interval.0 : *interval).1;\n   |                                       \
    \      +                      +\n\nerror: expected mut or const in raw pointer\
    \ type\n  --> /tmp/tmpww0bpvq4.rs:23:58\n   |\n23 |     interval.1 = interval.0\
    \ > interval.1 ? *interval.1 : *interval.0;\n   |                            \
    \                              ^ expected mut or const in raw pointer type\n \
    \  |\n   = help: use `*mut T` or `*const T` as appropriate\n\nerror: casts cannot\
    \ be followed by a field access\n  --> /tmp/tmpww0bpvq4.rs:23:45\n   |\n23 | \
    \    interval.1 = interval.0 > interval.1 ? *interval.1 : *interval.0;\n   | \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^\n   |\nhelp:\
    \ try surrounding the expression in parentheses\n   |\n23 |     interval.1 = interval.0\
    \ > interval.1 ? *(interval.1 : *interval).0;\n   |                          \
    \                   +                      +\n\ner"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    interval.0 = interval.0\
    \ > interval.1 as isize;\n    interval.1 = interval.1 > interval.0 as isize;\n\
    \    if interval.0 == interval.1 {\n        return \"NO\".to_string();\n    }\n\
    \    let mut interval = interval2;\n    interval.0 = interval.0 > interval.1 as\
    \ isize;\n    interval.1 = interval.1 > interval.0 as isize;\n    if interval.0\
    \ == interval.1 {\n        return \"NO\".to_string();\n    }\n    let mut interval\
    \ = interval1;\n    interval.0 = interval.0 > interval.1 as isize;\n    interval.1\
    \ = interval.1 > interval.0 as isize;\n    if interval.0 == interval.1 {\n   \
    \     return \"NO\".to_string();\n    }\n    let mut interval = interval2;\n \
    \   interval.0 = interval.0 > interval.1 as isize;\n    interval.1 = interval.1\
    \ > interval.0 as isize;\n    if interval.0 == interval.1 {\n        return \"\
    NO\".to_string();\n    }\n    let mut interval = interval1;\n    interval.0 =\
    \ interval.0 > interval.1 as isize;\n    interval.1 = interval.1 > interval.0\
    \ as isize;\n    if interval.0 == interval.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut interval = interval2;\n    interval.0 = interval.0 > interval.1\
    \ as isize;\n    interval.1 = interval.1 > interval.0 as isize;\n    if interval.0\
    \ == interval.1 {\n        return \"NO\".to_string();\n    }\n    let mut interval\
    \ = interval1;\n    interval.0 = interval.0 > interval.1 as isize;\n    interval.1\
    \ = interval.1 > interval.0 as isize;\n    if interval.0 == interval.1 {\n   \
    \     return \"NO\".to_string();\n    }\n    let mut interval = interval2;\n \
    \   interval.0 = interval.0 > interval.1 as isize;\n    interval.1 = interval.1\
    \ > interval.0 as isize;\n    if interval.0 == interval.1 {\n        return \"\
    NO\".to_string();\n    }\n    let mut interval = interval1;\n    interval.0 =\
    \ interval.0 > interval.1 as isize;\n    interval.1 = interval.1 > interval.0\
    \ as isize;\n    if interval.0 == interval.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut interval = interval2;\n    interval.0 = interval.0 > interval.1\
    \ as isize;\n    interval.1 = interval.1 > interval.0 as isize;\n    if interval.0\
    \ == interval.1 {\n        return \"NO\".to_string();\n    }\n    let mut interval\
    \ = interval1;\n    interval.0 = interval.0 > interval.1 as isize;\n    interval.1\
    \ = interval.1 > interval.0 as isize;\n    if interval.0 == interval.1 {\n   \
    \     return \"NO\".to_string();\n    }\n    let mut interval = interval\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp0ff479qo.rs:87:32\n   |\n\
    87 |     let mut interval = interval\n   |                                ^ help:\
    \ add `;` here\n88 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmp0ff479qo.rs:92:17\n   |\n92 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp0ff479qo.rs:92:25\n \
    \  |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0ff479qo.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0ff479qo.rs:93:25\n   |\n93 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0ff479qo.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0ff479qo.rs:94:25\n   |\n94 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0ff479qo.rs:95:17\n  \
    \ |\n95 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0ff479qo.rs:95:25\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0ff479qo.rs:96:17\n   |\n96 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0ff479qo.rs:96:25\n\
    \   |\n96 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut len = 0;\n    let mut start1 =\
    \ interval1[0];\n    let mut end1 = interval1[1];\n    let mut start2 = interval2[0];\n\
    \    let mut end2 = interval2[1];\n    while start1 <= end1 && start2 <= end2\
    \ {\n        if start1 < start2 {\n            start1 += 1;\n        } else {\n\
    \            start2 += 1;\n        }\n        len += 1;\n    }\n    if len ==\
    \ 1 {\n        return \"YES\";\n    }\n    if len % 2 == 0 {\n        return \"\
    NO\";\n    }\n    return \"YES\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpznsjskl8.rs:48:17\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpznsjskl8.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpznsjskl8.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpznsjskl8.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpznsjskl8.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpznsjskl8.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpznsjskl8.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpznsjskl8.rs:51:25\n   |\n51 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpznsjskl8.rs:52:17\n  \
    \ |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpznsjskl8.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpznsjskl8.rs:53:17\n   |\n53 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval1_start = interval2_start;\n    }\n\n    if interval1_start > interval1_end\
    \ {\n        return \"NO\";\n    }\n\n    if interval2_start > interval2_end {\n\
    \        return \"NO\";\n    }\n\n    if interval1_start == interval1_end {\n\
    \        return \"YES\";\n    }\n\n    if interval2_start == interval2_end {\n\
    \        return \"YES\";\n    }\n\n    let mut interval1_length = interval1_end\
    \ - interval1_start + 1;\n    let mut interval2_length = interval2_end - interval2_start\
    \ + 1;\n\n    if interval1_length == interval2_length {\n        if interval1_length\
    \ == 1 {\n            return \"YES\";\n        }\n        return \"NO\";\n   \
    \ }\n\n    if interval1_length < interval2_length {\n        interval1_length\
    \ = interval2_length;\n    }\n\n    if interval1_length == 2 {\n        return\
    \ \"YES\";\n    }\n\n    let mut interval1_prime = true;\n    let mut interval2_prime\
    \ = true;\n\n    for i in 1..interval1_length {\n        if interval1_start %\
    \ i == 0 {\n            interval1_prime = false;\n        }\n    }\n\n    for\
    \ i in 1..interval2_length {\n        if interval2_start % i == 0 {\n        \
    \    interval2_prime = false;\n        }\n    }\n\n    if interval1_prime && interval2_prime\
    \ {\n        return \"YES\";\n    }\n\n    return \"NO\";\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpw2xi3et3.rs:94:17\n\
    \   |\n94 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpw2xi3et3.rs:94:25\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpw2xi3et3.rs:95:17\n   |\n95 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpw2xi3et3.rs:95:25\n\
    \   |\n95 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpw2xi3et3.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpw2xi3et3.rs:96:25\n   |\n96 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpw2xi3et3.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpw2xi3et3.rs:97:25\n   |\n97 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpw2xi3et3.rs:98:17\n  \
    \ |\n98 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpw2xi3et3.rs:98:25\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpw2xi3et3.rs:99:17\n   |\n99 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start <= interval2_end\
    \ {\n        if interval1_end >= interval2_start {\n            if interval1_end\
    \ > interval2_end {\n                interval1_end = interval2_end;\n        \
    \        interval2_start = interval1_start;\n            }\n            if interval1_end\
    \ == interval2_end {\n                return String::from(\"YES\");\n        \
    \    }\n        }\n    }\n    return String::from(\"NO\");\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpeeddejed.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeeddejed.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeeddejed.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpeeddejed.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpeeddejed.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpeeddejed.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpeeddejed.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpeeddejed.rs:52:25\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpeeddejed.rs:53:17\n  \
    \ |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeeddejed.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeeddejed.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            String::from(\"YES\"\
    )\n        } else {\n            String::from(\"NO\")\n        }\n    } else {\n\
    \        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpion5eukp.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpion5eukp.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpion5eukp.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpion5eukp.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpion5eukp.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpion5eukp.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpion5eukp.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpion5eukp.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpion5eukp.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpion5eukp.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpion5eukp.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_start > interval1_end\
    \ {\n        interval1_start = interval1_end;\n        interval1_end = interval1_start;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start = interval2_end;\n\
    \        interval2_end = interval2_start;\n    }\n    if interval1_start > interval2_start\
    \ {\n        intersection_start = interval1_start;\n        intersection_end =\
    \ interval2_start;\n    }\n    if interval1_end < interval2_end {\n        intersection_start\
    \ = interval1_end;\n        intersection_end = interval2_end;\n    }\n    if intersection_start\
    \ > intersection_end {\n        intersection_start = intersection_end;\n     \
    \   intersection_end = intersection_start;\n    }\n    if intersection_start ==\
    \ intersection_end {\n        return \"NO\";\n    }\n    if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n        return \"YES\"\
    ;\n    }\n    if interval1_start >= interval2_start && interval1_end <= interval2_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start <= interval2_start\
    \ && interval1_end >= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ >= interval2_start && interval1_end <= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start >= interval2_start\
    \ && interval1_end <= interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_start <= interval2_start && interval1_end >= interval2_end {\n   \
    \     return \"NO\";\n    }\n    if interval1_start >= interval2_start && interval1_end\
    \ <= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n        return \"YES\"\
    ;\n    }\n    if interval1_start >= interval2_start && interval1_end <= interval2_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start <= interval2_start\
    \ && interval1_end >= interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ >= interval2_start && interval1_end <= interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start <= interval2_start \n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmptw0991pg.rs:87:1\n   |\n\
    86 |     if interval1_start <= interval2_start \n   |     -- this `if` expression\
    \ has a condition, but no block\n87 | }\n   | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptw0991pg.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptw0991pg.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptw0991pg.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptw0991pg.rs:92:25\n\
    \   |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptw0991pg.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptw0991pg.rs:93:25\n   |\n93 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptw0991pg.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptw0991pg.rs:94:25\n   |\n94 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptw0991pg.rs:95:17\n  \
    \ |\n95 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptw0991pg.rs:95:25\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\ner"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] {\n        if interval2[0] <\
    \ interval2[1] {\n            if interval1[0] < interval2[0] {\n             \
    \   if interval1[1] > interval2[1] {\n                    return \"NO\";\n   \
    \             }\n                return \"YES\";\n            }\n            return\
    \ \"NO\";\n        }\n        return \"NO\";\n    }\n    return \"NO\";\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpakqrrwr6.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpakqrrwr6.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpakqrrwr6.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpakqrrwr6.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpakqrrwr6.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpakqrrwr6.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpakqrrwr6.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpakqrrwr6.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpakqrrwr6.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpakqrrwr6.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpakqrrwr6.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_start {\n      \
    \  interval1_start = interval2_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n    if interval1_start ==\
    \ interval1_end {\n        if interval2_start == interval2_end {\n           \
    \ return String::from(\"YES\");\n        }\n        return String::from(\"NO\"\
    );\n    }\n    let mut interval1_length = interval1_end - interval1_start + 1;\n\
    \    let mut interval2_length = interval2_end - interval2_start + 1;\n    let\
    \ mut intersection_length = interval1_length + interval2_length;\n    if interval1_length\
    \ == interval2_length {\n        if interval1_start < interval2_start {\n    \
    \        interval1_length = interval2_start - interval1_start + 1;\n        }\n\
    \        if interval1_end > interval2_end {\n            interval1_length = interval2_end\
    \ - interval1_start + 1;\n        }\n    }\n    if interval1_length == 0 {\n \
    \       return String::from(\"NO\");\n    }\n    if interval2_length == 0 {\n\
    \        return String::from(\"NO\");\n    }\n    if interval1_length < interval2_length\
    \ {\n        intersection_length = interval1_length;\n    }\n    if interval1_length\
    \ == interval2_length {\n        if interval1_start < interval2_start {\n    \
    \        intersection_length = interval2_start - interval1_start + 1;\n      \
    \  }\n        if interval1_end > interval2_end {\n            intersection_length\
    \ = interval2_end - interval1_start + 1;\n        }\n    }\n    if intersection_length\
    \ == 2 {\n        if interval1_start < interval2_start {\n            intersection_length\
    \ = interval2_start - interval1_start + 1;\n        }\n        if interval1_end\
    \ > interval2_end {\n            intersection_length = interval2_end - interval1_start\
    \ + 1;\n        }\n    }\n    if intersection_length == 1 {\n        if interval1_start\
    \ < interval2_start {\n            intersection_length = interval2_start - interval1_start\
    \ + 1;\n        }\n        if interval1_end > interval2_end {\n            intersection_length\
    \ = interval2_end - interval1_start + 1;\n        }\n    }\n    if intersection_length\
    \ == 0 {\n        return String::from(\"NO\");\n    }\n    if \n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp2m8q4xu6.rs:91:1\n\
    \   |\n91 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp2m8q4xu6.rs:95:17\n   |\n95 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:95:25\n \
    \  |\n95 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2m8q4xu6.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:96:25\n   |\n96 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2m8q4xu6.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:97:25\n   |\n97 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:98:17\n  \
    \ |\n98 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2m8q4xu6.rs:98:25\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:99:17\n   |\n99 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2m8q4xu6.rs:99:25\n\
    \   |\n99 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmp2m8q4xu6.rs:100:17\n    |\n100 | "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval1[1];\n        interval = interval2;\n        interval[0]\
    \ = interval2[0];\n        interval[1] = interval2[1];\n        let mut i = 0;\n\
    \        let mut j = 0;\n        let mut len = 0;\n        while i < interval[0]\
    \ && j < interval[1] {\n            if interval[i] < interval[j] {\n         \
    \       i += 1;\n            } else {\n                j += 1;\n            }\n\
    \            len += 1;\n        }\n        if len == 2 {\n            if interval[0]\
    \ == interval[1] {\n                return String::from(\"YES\");\n          \
    \  } else {\n                return String::from(\"NO\");\n            }\n   \
    \     }\n    }\n    String::from(\"NO\")\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp0jb6ygof.rs:52:17\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0jb6ygof.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0jb6ygof.rs:53:17\n   |\n53 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0jb6ygof.rs:53:25\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0jb6ygof.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0jb6ygof.rs:54:25\n   |\n54 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0jb6ygof.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0jb6ygof.rs:55:25\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0jb6ygof.rs:56:17\n  \
    \ |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0jb6ygof.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0jb6ygof.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut interval_length = interval1_end\
    \ - interval1_start;\n    let mut interval_length2 = interval2_end - interval2_start;\n\
    \    let mut prime_number: isize = 1;\n    let mut prime_number2: isize = 1;\n\
    \    let mut prime_number3: isize = 1;\n    let mut prime_number4: isize = 1;\n\
    \    let mut prime_number5: isize = 1;\n    let mut prime_number6: isize = 1;\n\
    \    let mut prime_number7: isize = 1;\n    let mut prime_number8: isize = 1;\n\
    \    let mut prime_number9: isize = 1;\n    let mut prime_number10: isize = 1;\n\
    \    let mut prime_number11: isize = 1;\n    let mut prime_number12: isize = 1;\n\
    \    let mut prime_number13: isize = 1;\n    let mut prime_number14: isize = 1;\n\
    \    let mut prime_number15: isize = 1;\n    let mut prime_number16: isize = 1;\n\
    \    let mut prime_number17: isize = 1;\n    let mut prime_number18: isize = 1;\n\
    \    let mut prime_number19: isize = 1;\n    let mut prime_number20: isize = 1;\n\
    \    let mut prime_number21: isize = 1;\n    let mut prime_number22: isize = 1;\n\
    \    let mut prime_number23: isize = 1;\n    let mut prime_number24: isize = 1;\n\
    \    let mut prime_number25: isize = 1;\n    let mut prime_number26: isize = 1;\n\
    \    let mut prime_number27: isize = 1;\n    let mut prime_number28: isize = 1;\n\
    \    let mut prime_number29: isize = 1;\n    let mut prime_number30: isize = 1;\n\
    \    let mut prime_number31: isize = 1;\n    let mut prime_number32: isize = 1;\n\
    \    let mut prime_number33: isize = 1;\n    let mut prime_number34: isize = 1;\n\
    \    let mut prime_number35: isize = 1;\n    let mut prime_number36: isize\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwu1cugaz.rs:64:34\n   |\n\
    64 |     let mut prime_number36: isize\n   |                                 \
    \ ^ help: add `;` here\n65 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwu1cugaz.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwu1cugaz.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwu1cugaz.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwu1cugaz.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwu1cugaz.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwu1cugaz.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwu1cugaz.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwu1cugaz.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwu1cugaz.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwu1cugaz.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E042"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut intersection_len\
    \ = interval1_len + interval2_len;\n    let mut prime_number: isize = 1;\n   \
    \ let mut prime_number_flag = true;\n    let mut prime_number_flag2 = true;\n\
    \    let mut prime_number_flag3 = true;\n    let mut prime_number_flag4 = true;\n\
    \    let mut prime_number_flag5 = true;\n    let mut prime_number_flag6 = true;\n\
    \    let mut prime_number_flag7 = true;\n    let mut prime_number_flag8 = true;\n\
    \    let mut prime_number_flag9 = true;\n    let mut prime_number_flag10 = true;\n\
    \    let mut prime_number_flag11 = true;\n    let mut prime_number_flag12 = true;\n\
    \    let mut prime_number_flag13 = true;\n    let mut prime_number_flag14 = true;\n\
    \    let mut prime_number_flag15 = true;\n    let mut prime_number_flag16 = true;\n\
    \    let mut prime_number_flag17 = true;\n    let mut prime_number_flag18 = true;\n\
    \    let mut prime_number_flag19 = true;\n    let mut prime_number_flag20 = true;\n\
    \    let mut prime_number_flag21 = true;\n    let mut prime_number_flag22 = true;\n\
    \    let mut prime_number_flag23 = true;\n    let mut prime_number_flag24 = true;\n\
    \    let mut prime_number_flag25 = true;\n    let mut prime_number_flag26 = true;\n\
    \    let mut prime_number_flag27 = true;\n    let mut prime_number_flag28 = true;\n\
    \    let mut prime_number_flag29 = true;\n    let mut prime_number_flag30 = true;\n\
    \    let mut prime_number_flag31 = true;\n    let mut prime_number_flag32 = true;\n\
    \    let mut prime_number_flag33 = true;\n    let mut prime_number_flag34 = true;\n\
    \    let mut prime_number_flag35 = true;\n    let mut prime_number_flag36 = true;\n\
    \    let mut prime_number_flag37 = true;\n    let mut prime_number_flag38 = true;\n\
    \    let mut prime_number_flag39 = true;\n    let mut prime_number_flag40 = true;\n\
    \    let mut prime_number_flag41 = true;\n    let mut prime_number_flag42 = \n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp37gh8emq.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp37gh8emq.rs:75:17\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:75:25\n \
    \  |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp37gh8emq.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp37gh8emq.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp37gh8emq.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp37gh8emq.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp37gh8emq.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:79:25\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp37gh8emq.rs:80:17\n   |\n80 |     "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end = interval2_end;\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_start > interval1_end {\n      \
    \  return \"NO\";\n    }\n    let mut interval1_length = interval1_end - interval1_start;\n\
    \    let mut interval2_length = interval2_end - interval2_start;\n    if interval1_length\
    \ == interval2_length {\n        return \"YES\";\n    }\n    if interval1_length\
    \ < interval2_length {\n        interval1_length = interval2_length;\n       \
    \ interval2_length = interval1_length;\n    }\n    if interval1_length == 1 {\n\
    \        return \"YES\";\n    }\n    if interval2_length == 1 {\n        return\
    \ \"YES\";\n    }\n    let mut prime_number: isize = 1;\n    let mut prime_number_counter:\
    \ isize = 1;\n    let mut prime_number_counter2: isize = 1;\n    let mut prime_number_counter3:\
    \ isize = 1;\n    let mut prime_number_counter4: isize = 1;\n    let mut prime_number_counter5:\
    \ isize = 1;\n    let mut prime_number_counter6: isize = 1;\n    let mut prime_number_counter7:\
    \ isize = 1;\n    let mut prime_number_counter8: isize = 1;\n    let mut prime_number_counter9:\
    \ isize = 1;\n    let mut prime_number_counter10: isize = 1;\n    let mut prime_number_counter11:\
    \ isize = 1;\n    let mut prime_number_counter12: isize = 1;\n    let mut prime_number_counter13:\
    \ isize = 1;\n    let mut prime_number_counter14: isize = 1;\n    let mut prime_number_counter15:\
    \ isize = 1;\n    let mut prime_number_counter16: isize = 1;\n    let mut prime_number_counter17:\
    \ isize = 1;\n    let mut prime_number_counter18: isize = 1;\n    let mut prime_number_counter19:\
    \ isize = 1;\n    let mut prime_number_counter20: isize = 1;\n    let mut prime_number_counter21:\
    \ isize = 1;\n    let mut prime_number_counter22: isize = 1;\n    let mut prime_number_counter23:\
    \ isize = 1;\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpsrcso_3c.rs:79:17\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsrcso_3c.rs:79:25\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsrcso_3c.rs:80:17\n   |\n80 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsrcso_3c.rs:80:25\n\
    \   |\n80 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsrcso_3c.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsrcso_3c.rs:81:25\n   |\n81 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsrcso_3c.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsrcso_3c.rs:82:25\n   |\n82 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsrcso_3c.rs:83:17\n  \
    \ |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsrcso_3c.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsrcso_3c.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1[1] - interval1[0] + 1;\n \
    \   let mut interval2_len = interval2[1] - interval2[0] + 1;\n    let mut intersection_len\
    \ = 0;\n    let mut is_prime = true;\n    \n    if interval_len > interval2_len\
    \ {\n        interval_len = interval2_len;\n    }\n    \n    for _ in 0..interval_len\
    \ {\n        intersection_len += 1;\n    }\n    \n    for _ in 0..interval2_len\
    \ {\n        intersection_len += 1;\n    }\n    \n    if intersection_len == interval_len\
    \ {\n        return \"YES\";\n    }\n    \n    if intersection_len % 2 == 0 {\n\
    \        is_prime = false;\n    }\n    \n    if is_prime {\n        return \"\
    NO\";\n    }\n    \n    return \"NO\";\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpskx3id4o.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpskx3id4o.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpskx3id4o.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpskx3id4o.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpskx3id4o.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpskx3id4o.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpskx3id4o.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpskx3id4o.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpskx3id4o.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpskx3id4o.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpskx3id4o.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_1 = interval1.0;\n    let mut interval_2 =\
    \ interval2.0;\n    let mut interval_3 = interval1.0;\n    let mut interval_4\
    \ = interval2.0;\n    let mut interval_5 = interval1.0;\n    let mut interval_6\
    \ = interval2.0;\n    let mut interval_7 = interval1.0;\n    let mut interval_8\
    \ = interval2.0;\n    let mut interval_9 = interval1.0;\n    let mut interval_10\
    \ = interval2.0;\n    let mut interval_11 = interval1.0;\n    let mut interval_12\
    \ = interval2.0;\n    let mut interval_13 = interval1.0;\n    let mut interval_14\
    \ = interval2.0;\n    let mut interval_15 = interval1.0;\n    let mut interval_16\
    \ = interval2.0;\n    let mut interval_17 = interval1.0;\n    let mut interval_18\
    \ = interval2.0;\n    let mut interval_19 = interval1.0;\n    let mut interval_20\
    \ = interval2.0;\n    let mut interval_21 = interval1.0;\n    let mut interval_22\
    \ = interval2.0;\n    let mut interval_23 = interval1.0;\n    let mut interval_24\
    \ = interval2.0;\n    let mut interval_25 = interval1.0;\n    let mut interval_26\
    \ = interval2.0;\n    let mut interval_27 = interval1.0;\n    let mut interval_28\
    \ = interval2.0;\n    let mut interval_29 = interval1.0;\n    let mut interval_30\
    \ = interval2.0;\n    let mut interval_31 = interval1.0;\n    let mut interval_32\
    \ = interval2.0;\n    let mut interval_33 = interval1.0;\n    let mut interval_34\
    \ = interval2.0;\n    let mut interval_35 = interval1.0;\n    let mut interval_36\
    \ = interval2.0;\n    let mut interval_37 = interval1.0;\n    let mut interval_38\
    \ = interval2.0;\n    let mut interval_39 = interval1.0;\n    let mut interval_40\
    \ = interval2.0;\n    let mut interval_41 = interval1.0;\n    let mut interval_42\
    \ = interval2.0;\n    let mut interval_43 = interval1.0;\n    let mut interval_44\
    \ = interval2.0;\n    let mut interval_45 = interval1.0;\n    let mut interval_46\
    \ = interval2.0;\n    let mut interval_47 = interval1.0;\n    let mut interval_48\
    \ = interval2.0;\n    let mu\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_jbyrtoe.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:74:17\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_jbyrtoe.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  -"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 > interval2.0 {\n        let tmp = interval1;\n\
    \        interval1 = interval2;\n        interval2 = tmp;\n    }\n    if interval1.1\
    \ == interval2.1 {\n        if interval1.0 <= interval2.0 {\n            return\
    \ \"NO\".to_string();\n        }\n        return \"YES\".to_string();\n    }\n\
    \    let mut interval = interval1;\n    let mut interval2 = interval2;\n    let\
    \ mut interval3 = interval1;\n    let mut interval4 = interval2;\n    let mut\
    \ interval5 = interval1;\n    let mut interval6 = interval2;\n    let mut interval7\
    \ = interval1;\n    let mut interval8 = interval2;\n    let mut interval9 = interval1;\n\
    \    let mut interval10 = interval2;\n    let mut interval11 = interval1;\n  \
    \  let mut interval12 = interval2;\n    let mut interval13 = interval1;\n    let\
    \ mut interval14 = interval2;\n    let mut interval15 = interval1;\n    let mut\
    \ interval16 = interval2;\n    let mut interval17 = interval1;\n    let mut interval18\
    \ = interval2;\n    let mut interval19 = interval1;\n    let mut interval20 =\
    \ interval2;\n    let mut interval21 = interval1;\n    let mut interval22 = interval2;\n\
    \    let mut interval23 = interval1;\n    let mut interval24 = interval2;\n  \
    \  let mut interval25 = interval1;\n    let mut interval26 = interval2;\n    let\
    \ mut interval27 = interval1;\n    let mut interval28 = interval2;\n    let mut\
    \ interval29 = interval1;\n    let mut interval30 = interval2;\n    let mut interval31\
    \ = interval1;\n    let mut interval32 = interval2;\n    let mut interval33 =\
    \ interval1;\n    let mut interval34 = interval2;\n    let mut interval35 = interval1;\n\
    \    let mut interval36 = interval2;\n    let mut interval37 = interval1;\n  \
    \  let mut interval38 = interval2;\n    let mut interval39 = interval1;\n    let\
    \ mut interval40 = interval2;\n    let mut interval41 = interval1;\n    let mut\
    \ interval42 = interval2;\n    let mut interval43 = interval1;\n    let mut interval44\
    \ = interval2;\n    let mut interval45 = interval1;\n    let mut interval46 =\
    \ interval2;\n    let mut interval47 = interval1;\n    let mut interval48 = interval2;\n\
    \    let mut interval49 = interval1;\n    let mut interval50 = interval2;\n  \
    \  let mut interval51 = interval1;\n    let mut interval5\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpjqq38_ow.rs:83:22\n   |\n\
    83 |     let mut interval5\n   |                      ^ help: add `;` here\n84\
    \ | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpjqq38_ow.rs:88:17\n   |\n88 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjqq38_ow.rs:88:25\n   |\n88 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjqq38_ow.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjqq38_ow.rs:89:25\n   |\n89 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjqq38_ow.rs:90:17\n  \
    \ |\n90 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjqq38_ow.rs:90:25\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjqq38_ow.rs:91:17\n   |\n91 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjqq38_ow.rs:91:25\n\
    \   |\n91 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjqq38_ow.rs:92:17\n   |\n92 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjqq38_ow.rs:92:25\n   |\n92 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `l"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\";\n        } else {\n        \
    \    return \"NO\";\n        }\n    }\n    if interval1_start < interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_end > interval2_end {\n \
    \       return \"NO\";\n    }\n    if interval1_start < interval2_end {\n    \
    \    return \"YES\";\n    }\n    if interval1_end > interval2_start {\n      \
    \  return \"YES\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpc1g4m_xy.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpc1g4m_xy.rs:26:72\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpc1g4m_xy.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval2_start\
    \ {\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpc1g4m_xy.rs:29:40\n\
    \   |\n29 |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpc1g4m_xy.rs:29:72\n   |\n28 |     if interval1_end < interval2_end\
    \ {\n   |                        ------------- while parsing this struct\n29 |\
    \         interval1_start, interval1_end = interval2_end, interval1_start;\n \
    \  |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpc1g4m_xy.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_end < interval1_start {\n        interval1_end, interval1_start\
    \ = interval1_start, interval1_end;\n    }\n    if interval2_end < interval2_start\
    \ {\n        interval2_end, interval2_start = interval2_start, interval2_end;\n\
    \    }\n    if interval1_end == interval2_end {\n        if interval1_start ==\
    \ interval2_start {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    if interval1_end == interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start == interval2_start {\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    if interval1_start == interval2_start {\n        return \"NO\"\
    ;\n    }\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n    if interval1_start < interval2_start {\n        if interval1_end ==\
    \ interval2_end {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;\n    }\n    if interval1_start < interval2_start {\n        return \"NO\";\n\
    \    }\n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_end < interval2_end {\n        return \"NO\";\n    }\n    if\
    \ interval1_end < interval2_end {\n        return \"NO\";\n    }\n    return \"\
    YES\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp3hmf9klp.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmp3hmf9klp.rs:26:72\n   |\n25 |     if interval1_start > interval1_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp3hmf9klp.rs:25:26\n   |\n25 |       if interval1_start > interval1_end\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval1_end\
    \ {\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmp3hmf9klp.rs:29:40\n\
    \   |\n29 |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmp3hmf9klp.rs:29:72\n   |\n28 |     if interval2_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n29\
    \ |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp3hmf9klp.rs:28:26\n   |\n28 |       if interval2_start > interval2_end\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    if interval1_start\
    \ > interval2_start {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval1_start = interval2_start;\n    }\n    if\
    \ interval1_start <= interval1_end {\n        intersection_length += 1;\n    }\n\
    \    if interval2_start <= interval2_end {\n        intersection_length += 1;\n\
    \    }\n    if intersection_length == 2 {\n        if interval1_start == interval1_end\
    \ {\n            if interval2_start == interval2_end {\n                return\
    \ String::from(\"YES\");\n            }\n            return String::from(\"NO\"\
    );\n        }\n        return String::from(\"NO\");\n    }\n    if intersection_length\
    \ == 1 {\n        if interval1_start == interval1_end {\n            return String::from(\"\
    NO\");\n        }\n        return String::from(\"YES\");\n    }\n    if intersection_length\
    \ == 0 {\n        return String::from(\"NO\");\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpk5yqvtns.rs:62:17\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpk5yqvtns.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpk5yqvtns.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpk5yqvtns.rs:63:25\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpk5yqvtns.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpk5yqvtns.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpk5yqvtns.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpk5yqvtns.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpk5yqvtns.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpk5yqvtns.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpk5yqvtns.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start == interval1_end {\n        return\
    \ \"NO\";\n    }\n    if interval2_start == interval2_end {\n        return \"\
    NO\";\n    }\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ > interval2_end {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start == interval1_end {\n        return \"NO\";\n  \
    \  }\n    if interval2_start == interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start == interval1_end {\n        return \"NO\";\n  \
    \  }\n    if interval2_start == interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start < interval2_start {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmps7jv9hxq.rs:99:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     if interval1_start\
    \ < interval2_start {\n   |                                          - this delimiter\
    \ might not be properly closed...\n86 |         interval\n87 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error: expected `:`, found `=`\n  --> /tmp/tmps7jv9hxq.rs:26:40\n   |\n26 |  \
    \       interval1_start, interval1_end = interval2_end, interval1_start;\n   |\
    \                                       -^\n   |                             \
    \          |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmps7jv9hxq.rs:20:81\n   |\n20 | fn intersection(interval1: (isize,\
    \ isize), interval2: (isize, isize)) -> String {\n   |                       \
    \                                                          ^ unclosed delimiter\n\
    ...\n25 |     if interval1_start > interval2_end {\n   |                     \
    \     ------------- while parsing this struct\n26 |         interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n   |                                    \
    \                                    ^\n   |                                 \
    \                                       |\n   |                              \
    \                                          expected one of `,` or `}`\n   |  \
    \                                                                      help: `}`\
    \ may belong here\n\nerror: struct literals are not allowed here\n  --> /tmp/tmps7jv9hxq.rs:25:26\n\
    \   |\n25 |       if interval1_start > interval2_end {\n   |  __________________________^\n\
    26 | |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    27 | |     }\n   | |_____^\n   |\nhelp: surround the struct literal with parentheses\n\
    \   |\n25 ~     if interval"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n\n    let mut prime = true;\n    let mut prime_length\
    \ = 1;\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    while prime_length < interval1_end - interval1_start\
    \ && prime_length < interval2_end - interval2_start {\n        if interval1_start\
    \ < interval2_start {\n            if interval1_end < interval2_end {\n      \
    \          if interval1_end < interval2_end {\n                    if interval1_end\
    \ < interval2_end {\n                        if interval1_end < interval2_end\
    \ {\n                            if interval1_end < interval2_end {\n        \
    \                        prime = false;\n                                prime_length\
    \ += 1;\n                            }\n                        }\n          \
    \          }\n                }\n            }\n        }\n\n        if interval1_start\
    \ < interval2_start {\n            if interval1_end < interval2_end {\n      \
    \          if interval1_end < interval2_end {\n                    if interval1_end\
    \ < interval2_end {\n                        if interval1_end < interval2_end\
    \ {\n                            if interval1_end < interval2_end {\n        \
    \                        prime = false;\n                                prime_length\
    \ += 1;\n                            }\n                        }\n          \
    \          }\n                }\n            }\n        }\n\n        interval1_start\
    \ += 1;\n        interval1_end += 1;\n        interval2_start += 1;\n        interval2_end\
    \ += 1;\n    }\n\n    if prime_length == interval1_end - interval1_start && prime_length\
    \ == interval2_end - interval2_start {\n        if prime_length == interval1_end\
    \ - interval1_start {\n            return \"YES\";\n        }\n        if prime_length\
    \ == interval2_end - interval2_start {\n            return \"YES\";\n        }\n\
    \    }\n\n    if prime_length == interval1_end - interval1_start {\n        return\
    \ \"YES\";\n    }\n    if prime_length == interval2_end - interval2_start {\n\
    \        return \"YES\";\n    }\n\n    return \"NO\";\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:90:17\n\
    \   |\n90 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjg4cnv7t.rs:90:25\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:91:17\n   |\n91 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:91:25\n\
    \   |\n91 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjg4cnv7t.rs:92:17\n   |\n92 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:92:25\n   |\n92 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjg4cnv7t.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:93:25\n   |\n93 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:94:17\n  \
    \ |\n94 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjg4cnv7t.rs:94:25\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjg4cnv7t.rs:95:17\n   |\n95 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[1];\n\
    \        interval[1] = interval2[0];\n        interval\n    } else {\n       \
    \ let mut interval = interval2;\n        interval[0] = interval2[1];\n       \
    \ interval[1] = interval1[0];\n        interval\n    }\n    let mut interval =\
    \ interval1;\n    let mut interval2 = interval2;\n    let mut interval3 = interval1;\n\
    \    let mut interval4 = interval2;\n    let mut interval5 = interval1;\n    let\
    \ mut interval6 = interval2;\n    let mut interval7 = interval1;\n    let mut\
    \ interval8 = interval2;\n    let mut interval9 = interval1;\n    let mut interval10\
    \ = interval2;\n    let mut interval11 = interval1;\n    let mut interval12 =\
    \ interval2;\n    let mut interval13 = interval1;\n    let mut interval14 = interval2;\n\
    \    let mut interval15 = interval1;\n    let mut interval16 = interval2;\n  \
    \  let mut interval17 = interval1;\n    let mut interval18 = interval2;\n    let\
    \ mut interval19 = interval1;\n    let mut interval20 = interval2;\n    let mut\
    \ interval21 = interval1;\n    let mut interval22 = interval2;\n    let mut interval23\
    \ = interval1;\n    let mut interval24 = interval2;\n    let mut interval25 =\
    \ interval1;\n    let mut interval26 = interval2;\n    let mut interval27 = interval1;\n\
    \    let mut interval28 = interval2;\n    let mut interval29 = interval1;\n  \
    \  let mut interval30 = interval2;\n    let mut interval31 = interval1;\n    let\
    \ mut interval32 = interval2;\n    let mut interval33 = interval1;\n    let mut\
    \ interval34 = interval2;\n    let mut interval35 = interval1;\n    let mut interval36\
    \ = interval2;\n    let mut interval37 = interval1;\n    let mut interval38 =\
    \ interval2;\n    let mut interval39 = interval1;\n    let mut interval40 = interval2;\n\
    \    let mut interval41 = interval1;\n    let mut interval42 = interval2;\n  \
    \  let mut interval43 = interval1;\n    let mut interval44 = interval2;\n    let\
    \ mut interval45 = interval1;\n    let mut interval46 = interval2;\n    let mut\
    \ interval47 = interval1;\n    let mut interval48 = interval2;\n    let mut interval49\
    \ = interval1;\n    let mut interval50 = interval2;\n    let mu\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpotw0_qyh.rs:82:11\n   |\n\
    82 |     let mu\n   |           ^ help: add `;` here\n83 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpotw0_qyh.rs:87:17\n\
    \   |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpotw0_qyh.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpotw0_qyh.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpotw0_qyh.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpotw0_qyh.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpotw0_qyh.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpotw0_qyh.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpotw0_qyh.rs:90:25\n   |\n90 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpotw0_qyh.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpotw0_qyh.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  -"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start > interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_end < interval2_start {\n\
    \        return \"NO\";\n    }\n    if interval1_start == interval2_start {\n\
    \        return \"YES\";\n    }\n    if interval1_end == interval2_end {\n   \
    \     return \"YES\";\n    }\n    let mut interval1_length = interval1_end - interval1_start\
    \ + 1;\n    let mut interval2_length = interval2_end - interval2_start + 1;\n\
    \    if interval1_length == interval2_length {\n        return \"YES\";\n    }\n\
    \    if interval1_length < interval2_length {\n        interval1_length = interval2_length;\n\
    \    }\n    if interval1_length == 2 {\n        if interval1_start % 2 == 0 &&\
    \ interval2_start % 2 == 0 {\n            return \"YES\";\n        }\n       \
    \ return \"NO\";\n    }\n    if interval1_length == 3 {\n        if interval1_start\
    \ % 3 == 0 && interval2_start % 3 == 0 {\n            return \"YES\";\n      \
    \  }\n        return \"NO\";\n    }\n    if interval1_length == 4 {\n        if\
    \ interval1_start % 4 == 0 && interval2_start % 4 == 0 {\n            return \"\
    YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_length == 5\
    \ {\n        if interval1_start % 5 == 0 && interval2_start % 5 == 0 {\n     \
    \       return \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_length\
    \ == 6 {\n        if interval1_start % 6 == 0 && interval2_start % 6 == 0 {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    if\
    \ interval1_length == 7 {\n        if interval1_start % 7 == 0 && interval2_start\
    \ % 7 == 0 {\n            return \"YES\";\n        }\n        return \"NO\";\n\
    \    }\n    if interval1_length == 8 {\n        if interval1_start % 8 == 0 &&\
    \ interval2_start % 8 == 0 {\n            return \"YES\";\n        }\n       \
    \ return \"NO\";\n    }\n    if interval1_length == 9 {\n        if interval1_start\
    \ % 9 == 0 && interval2_start % 9 == 0 {\n            return \"YES\";\n      \
    \  }\n        return \"NO\";\n    }\n    if interval1_length == 10 {\n       \
    \ if interval1_start % \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp5aj3m8qd.rs:115:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n101 |     if interval1_length\
    \ == 10 {\n    |                               - this delimiter might not be properly\
    \ closed...\n102 |         if interval1_start % \n103 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n115 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmp5aj3m8qd.rs:103:1\n    |\n103 | }\n  \
    \  | ^ expected expression\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmp5aj3m8qd.rs:107:17\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp5aj3m8qd.rs:107:25\n    |\n107 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp5aj3m8qd.rs:108:17\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp5aj3m8qd.rs:108:25\n    |\n108 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp5aj3m8qd.rs:109:17\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp5aj3m8qd.rs:109:25\n    |\n109 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp5aj3m8qd.rs:110:17\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp5aj3m8qd"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_start {\n      \
    \  interval1_start = interval2_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_end < interval2_start\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        return String::from(\"NO\");\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end < interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end < interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end < interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_end < interval2_start\
    \ {\n        return String::from(\"YES\");\n    }\n    if interval1_start > interval2_end\
    \ {\n        return String\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpp4m4t60k.rs:108:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n94  |     if interval1_start\
    \ > interval2_end {\n    |                                        - this delimiter\
    \ might not be properly closed...\n95  |         return String\n96  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n108 | }\n   \
    \ |   ^\n\nerror[E0423]: expected value, found struct `String`\n   --> /tmp/tmpp4m4t60k.rs:95:16\n\
    \    |\n95  |           return String\n    |                  ^^^^^^ help: use\
    \ struct literal syntax instead: `String { vec: val }`\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmpp4m4t60k.rs:100:17\n    |\n\
    100 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmpp4m4t60k.rs:100:25\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp4m4t60k.rs:101:17\n\
    \    |\n101 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp4m4t60k.rs:101:25\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp4m4t60k.rs:102:17\n\
    \    |\n102 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpp4m4t60k.rs:102:25\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpp4m4t60k.rs:103:17\n\
    \    |\n103 |     assert_eq!({left}, {right});\n    |             "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    let mut prime_numbers\
    \ = vec![];\n    loop {\n        if interval1_start > interval2_end {\n      \
    \      break;\n        }\n        if interval1_end < interval2_start {\n     \
    \       break;\n        }\n        if interval1_start <= interval2_end {\n   \
    \         if interval1_end >= interval2_start {\n                intersection_length\
    \ += 1;\n            }\n        }\n        if intersection_length == 2 {\n   \
    \         prime_numbers.push(interval1_start);\n        }\n        if intersection_length\
    \ == 3 {\n            prime_numbers.push(interval1_end);\n        }\n        if\
    \ intersection_length == 4 {\n            prime_numbers.push(interval2_start);\n\
    \        }\n        if intersection_length == 5 {\n            prime_numbers.push(interval2_end);\n\
    \        }\n        interval1_start += 1;\n        interval1_end += 1;\n     \
    \   interval2_start += 1;\n        interval2_end += 1;\n    }\n    if prime_numbers.contains(&interval1_start)\
    \ {\n        return \"YES\";\n    }\n    if prime_numbers.contains(&interval1_end)\
    \ {\n        return \"YES\";\n    }\n    if prime_numbers.contains(&interval2_start)\
    \ {\n        return \"YES\";\n    }\n    if prime_numbers.contains(&interval2_end)\
    \ {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6shk2sl1.rs:73:17\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6shk2sl1.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6shk2sl1.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6shk2sl1.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6shk2sl1.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6shk2sl1.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6shk2sl1.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6shk2sl1.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6shk2sl1.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6shk2sl1.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6shk2sl1.rs:78:17\n   |\n78 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n        interval.0\
    \ = interval.1;\n        interval.1 = interval.0;\n        interval.0 = interval.1;\n\
    \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpzg4xp0ib.rs:117:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n21  |     if interval1[0] < interval1[1]\
    \ && interval2[0] < interval2[1] {\n    |                                    \
    \                               - this delimiter might not be properly closed...\n\
    ...\n105 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n117 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpzg4xp0ib.rs:109:17\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpzg4xp0ib.rs:109:25\n    |\n109 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpzg4xp0ib.rs:110:17\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpzg4xp0ib.rs:110:25\n    |\n110 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpzg4xp0ib.rs:111:17\n    |\n111 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpzg4xp0ib.rs:111:25\n    |\n111 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpzg4xp0ib.rs:112:17\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpzg4xp0ib.rs:112:25\n    |\n112 |\
    \     assert_eq!({left}, {right});\n    |                 "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start <= interval2_end {\n        if interval1_end >= interval2_start\
    \ {\n            if interval1_end <= interval2_end {\n                if interval1_start\
    \ <= interval2_start {\n                    if interval1_end >= interval2_end\
    \ {\n                        if interval1_end == interval2_end {\n           \
    \                 return String::from(\"YES\");\n                        }\n \
    \                       return String::from(\"NO\");\n                    }\n\
    \                    return String::from(\"NO\");\n                }\n       \
    \         return String::from(\"NO\");\n            }\n            return String::from(\"\
    NO\");\n        }\n        return String::from(\"NO\");\n    }\n    return String::from(\"\
    NO\");\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmprdxrhwl9.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmprdxrhwl9.rs:26:72\n   |\n25 |     if interval1_start > interval1_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmprdxrhwl9.rs:25:26\n   |\n25 |       if interval1_start > interval1_end\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval1_end\
    \ {\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmprdxrhwl9.rs:29:40\n\
    \   |\n29 |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmprdxrhwl9.rs:29:72\n   |\n28 |     if interval2_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n29\
    \ |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmprdxrhwl9.rs:28:26\n   |\n28 |       if interval2_start > interval2_end\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1.0 > interval2.1\
    \ {\n        interval = interval2;\n    }\n    let mut start = interval.0;\n \
    \   let mut end = interval.1;\n    let mut length = 0;\n    while start < end\
    \ {\n        start += 1;\n        end += 1;\n        length +=1;\n    }\n    if\
    \ length == 2 {\n        if start == end {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\
    \ == 3 {\n        if start == end {\n            return String::from(\"YES\");\n\
    \        }\n        if start == end + 1 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\
    \ == 4 {\n        if start == end {\n            return String::from(\"YES\");\n\
    \        }\n        if start == end + 1 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 2 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\
    \ == 5 {\n        if start == end {\n            return String::from(\"YES\");\n\
    \        }\n        if start == end + 1 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 2 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 3 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\
    \ == 6 {\n        if start == end {\n            return String::from(\"YES\");\n\
    \        }\n        if start == end + 1 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 2 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 3 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 4 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\
    \ == 7 {\n        if start == end {\n            return String::from(\"YES\");\n\
    \        }\n        if start == end + 1 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 2 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 3 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 4 {\n            return String::from(\"\
    YES\");\n        }\n        if start == end + 5 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if length\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpa4hhkip9.rs:115:1\n    |\n\
    114 |     if length\n    |     -- this `if` expression has a condition, but no\
    \ block\n115 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpa4hhkip9.rs:119:17\n    |\n119 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpa4hhkip9.rs:119:25\n\
    \    |\n119 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpa4hhkip9.rs:120:17\n    |\n120 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpa4hhkip9.rs:120:25\n\
    \    |\n120 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpa4hhkip9.rs:121:17\n    |\n121 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpa4hhkip9.rs:121:25\n\
    \    |\n121 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpa4hhkip9.rs:122:17\n    |\n122 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpa4hhkip9.rs:122:25\n\
    \    |\n122 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpa4hhkip9.rs:123:17\n    |\n123 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpa4hhkip9.rs:123:25\n\
    \    |\n123 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start <= interval1.end && interval2.start <= interval2.end\
    \ {\n        let mut intersection = interval1;\n        intersection.start = min(interval1.start,\
    \ interval2.start);\n        intersection.end = max(interval1.end, interval2.end);\n\
    \        if intersection.end == intersection.start {\n            String::from(\"\
    NO\")\n        } else {\n            String::from(\"YES\")\n        }\n    } else\
    \ {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpwj67anez.rs:23:30\n\
    \   |\n23 |         intersection.start = min(interval1.start, interval2.start);\n\
    \   |                              ^^^\n...\n35 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n23 |         intersection.start = main(interval1.start,\
    \ interval2.start);\n   |                              ~~~~\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find\
    \ function `max` in this scope\n  --> /tmp/tmpwj67anez.rs:24:28\n   |\n24 |  \
    \       intersection.end = max(interval1.end, interval2.end);\n   |          \
    \                  ^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpwj67anez.rs:37:17\n   |\n37 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwj67anez.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwj67anez.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwj67anez.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwj67anez.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwj67anez.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwj67anez.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start == interval1_end {\n        if interval2_start ==\
    \ interval2_end {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;\n    }\n    if interval2_start == interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start == interval1_end {\n        if interval2_start ==\
    \ interval2_end {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;\n    }\n    if interval2_start == interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start == interval1_end {\n        if interval\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1m_xld2e.rs:99:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n85 |     if interval1_start\
    \ == interval1_end {\n   |                                         - this delimiter\
    \ might not be properly closed...\n86 |         if interval\n87 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n99 | }\n   |   ^\n\n\
    error: expected `:`, found `=`\n  --> /tmp/tmp1m_xld2e.rs:26:40\n   |\n26 |  \
    \       interval1_start, interval1_end = interval1_end, interval1_start;\n   |\
    \                                       -^\n   |                             \
    \          |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmp1m_xld2e.rs:20:81\n   |\n20 | fn intersection(interval1: (isize,\
    \ isize), interval2: (isize, isize)) -> String {\n   |                       \
    \                                                          ^ unclosed delimiter\n\
    ...\n25 |     if interval1_start > interval1_end {\n   |                     \
    \     ------------- while parsing this struct\n26 |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n   |                                    \
    \                                    ^\n   |                                 \
    \                                       |\n   |                              \
    \                                          expected one of `,` or `}`\n   |  \
    \                                                                      help: `}`\
    \ may belong here\n\nerror: struct literals are not allowed here\n  --> /tmp/tmp1m_xld2e.rs:25:26\n\
    \   |\n25 |       if interval1_start > interval1_end {\n   |  __________________________^\n\
    26 | |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 | |     }\n   | |_____^\n   |\nhelp: surround the struct literal with parentheses\n\
    \   |\n25 ~     if interva"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            let mut interval =\
    \ interval1;\n            interval[0] = interval2[0];\n            interval[1]\
    \ = interval2[1];\n            return interval.to_string();\n        }\n     \
    \   let mut interval = interval1;\n        interval[0] = interval1[1];\n     \
    \   interval[1] = interval2[1];\n        return interval.to_string();\n    }\n\
    \    if interval1[0] < interval1[1] && interval2[0] > interval2[1] {\n       \
    \ let mut interval = interval1;\n        interval[0] = interval1[0];\n       \
    \ interval[1] = interval2[1];\n        return interval.to_string();\n    }\n \
    \   if interval1[0] > interval1[1] && interval2[0] < interval2[1] {\n        let\
    \ mut interval = interval1;\n        interval[0] = interval1[0];\n        interval[1]\
    \ = interval2[0];\n        return interval.to_string();\n    }\n    if interval1[0]\
    \ > interval1[1] && interval2[0] > interval2[1] {\n        return \"NO\".to_string();\n\
    \    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpojp8twtz.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpojp8twtz.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpojp8twtz.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpojp8twtz.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpojp8twtz.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpojp8twtz.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpojp8twtz.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpojp8twtz.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpojp8twtz.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpojp8twtz.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpojp8twtz.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start > interval2_end {\n        return \"NO\";\n \
    \   }\n    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n\
    \n    if interval1_start < interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n\n    if interval1_start == interval2_start {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start < interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_end;\n    }\n    if interval1_end > interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n\n    if interval1_start == interval2_start {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start < interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_end;\n    }\n    if interval1_end > interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n\n    if interval1_start == interval2_start {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start < interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_end;\n    }\n    if interval1_end > interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n\n    if interval1_start == interval2_start {\n        return \"NO\";\n\
    \    }\n\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start < interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_end;\n    }\n    if interval1_end > interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n\n\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpxt2j6g1r.rs:27:42\n   |\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmpxt2j6g1r.rs:27:76\n   |\n26 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpxt2j6g1r.rs:26:26\n   |\n26 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n27 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n28 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n26 ~     if interval1_start\
    \ > (interval2_start {\n27 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n28 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpxt2j6g1r.rs:30:38\n   |\n30 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmpxt2j6g1r.rs:30:68\n   |\n29 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n30 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmpxt2j6g1r.rs:29:24\n   |\n29 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1.0;\n    let mut interval_end\
    \ = interval1.1;\n    let mut interval_start = interval2.0;\n    let mut interval_end_2\
    \ = interval2.1;\n\n    if interval_end < interval_start {\n        interval_len\
    \ = interval_end;\n        interval_end = interval_start;\n        interval_start\
    \ = interval_len;\n    }\n\n    if interval_end < interval_end_2 {\n        interval_len\
    \ = interval_end_2;\n        interval_end = interval_start_2;\n        interval_start\
    \ = interval_len;\n    }\n\n    if interval_len == interval_end {\n        if\
    \ interval_len == interval_start {\n            return \"NO\";\n        } else\
    \ {\n            return \"YES\";\n        }\n    } else {\n        if interval_len\
    \ == interval_start {\n            return \"NO\";\n        } else {\n        \
    \    return \"YES\";\n        }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `interval_start_2` in this scope\n  -->\
    \ /tmp/tmpdf3xd4pk.rs:34:24\n   |\n34 |         interval_end = interval_start_2;\n\
    \   |                        ^^^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `interval_start`\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpdf3xd4pk.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdf3xd4pk.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdf3xd4pk.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdf3xd4pk.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdf3xd4pk.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |  "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start < interval1.end && interval2.start < interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        let mut interval2 = interval2;\n\
    \        interval2.start = interval2.end;\n        interval2.end = interval2.start;\n\
    \        let mut intersection = interval;\n        intersection.start = intersection.end;\n\
    \        intersection.end = intersection.start;\n        let mut prime = true;\n\
    \        let mut prime2 = true;\n        let mut prime3 = true;\n        let mut\
    \ prime4 = true;\n        let mut prime5 = true;\n        let mut prime6 = true;\n\
    \        let mut prime7 = true;\n        let mut prime8 = true;\n        let mut\
    \ prime9 = true;\n        let mut prime10 = true;\n        let mut prime11 = true;\n\
    \        let mut prime12 = true;\n        let mut prime13 = true;\n        let\
    \ mut prime14 = true;\n        let mut prime15 = true;\n        let mut prime16\
    \ = true;\n        let mut prime17 = true;\n        let mut prime18 = true;\n\
    \        let mut prime19 = true;\n        let mut prime20 = true;\n        let\
    \ mut prime21 = true;\n        let mut prime22 = true;\n        let mut prime23\
    \ = true;\n        let mut prime24 = true;\n        let mut prime25 = true;\n\
    \        let mut prime26 = true;\n        let mut prime27 = true;\n        let\
    \ mut prime28 = true;\n        let mut prime29 = true;\n        let mut prime30\
    \ = true;\n        let mut prime31 = true;\n        let mut prime32 = true;\n\
    \        let mut prime33 = true;\n        let mut prime34 = true;\n        let\
    \ mut prime35 = true;\n        let mut prime36 = true;\n        let mut prime37\
    \ = true;\n        let mut prime38 = true;\n        let mut prime39 = true;\n\
    \        let mut prime40 = true;\n        let mut prime41 = true;\n        let\
    \ mut prime42 = true;\n        let mut prime43 = true;\n        let mut prime44\
    \ = true;\n        let mut prime45 = true;\n        let mut prime46 = true;\n\
    \        let mut prime47 = true;\n        let mut prime48 = true;\n        let\
    \ mut prime49 = true;\n        let mut prime50 = true;\n        let mut prime51\
    \ = true;\n        let mut prime52 = true;\n        let mut prime53 = true;\n\
    \        let mut prime54 = true;\n        let mut prime55 = true;\n        let\
    \ mut prime56 = true;\n        let mut prime57 = true;\n        let mut prime58\
    \ = true;\n        let mut prime59 = true;\n        let mut prime\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpfvr9nks_.rs:103:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n21  |     if interval1.start <\
    \ interval1.end && interval2.start < interval2.end {\n    |                  \
    \                                                         - this delimiter might\
    \ not be properly closed...\n...\n91  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n103 | }\n    |   ^\n\nerror: expected `;`, found\
    \ `}`\n  --> /tmp/tmpfvr9nks_.rs:90:22\n   |\n90 |         let mut prime\n   |\
    \                      ^ help: add `;` here\n91 | }\n   | - unexpected token\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfvr9nks_.rs:95:17\n\
    \   |\n95 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfvr9nks_.rs:95:25\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfvr9nks_.rs:96:17\n   |\n96 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfvr9nks_.rs:96:25\n\
    \   |\n96 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfvr9nks_.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfvr9nks_.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfvr9nks_.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\n"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval2[0];\n        interval\n    } else {\n       \
    \ let mut interval = interval2;\n        interval[0] = interval2[0];\n       \
    \ interval[1] = interval1[1];\n        interval\n    }\n    let mut prime = true;\n\
    \    let mut prime_length = 1;\n    let mut prime_length2 = 1;\n    let mut prime_length3\
    \ = 1;\n    let mut prime_length4 = 1;\n    let mut prime_length5 = 1;\n    let\
    \ mut prime_length6 = 1;\n    let mut prime_length7 = 1;\n    let mut prime_length8\
    \ = 1;\n    let mut prime_length9 = 1;\n    let mut prime_length10 = 1;\n    let\
    \ mut prime_length11 = 1;\n    let mut prime_length12 = 1;\n    let mut prime_length13\
    \ = 1;\n    let mut prime_length14 = 1;\n    let mut prime_length15 = 1;\n   \
    \ let mut prime_length16 = 1;\n    let mut prime_length17 = 1;\n    let mut prime_length18\
    \ = 1;\n    let mut prime_length19 = 1;\n    let mut prime_length20 = 1;\n   \
    \ let mut prime_length21 = 1;\n    let mut prime_length22 = 1;\n    let mut prime_length23\
    \ = 1;\n    let mut prime_length24 = 1;\n    let mut prime_length25 = 1;\n   \
    \ let mut prime_length26 = 1;\n    let mut prime_length27 = 1;\n    let mut prime_length28\
    \ = 1;\n    let mut prime_length29 = 1;\n    let mut prime_length30 = 1;\n   \
    \ let mut prime_length31 = 1;\n    let mut prime_length32 = 1;\n    let mut prime_length33\
    \ = 1;\n    let mut prime_length34 = 1;\n    let mut prime_length35 = 1;\n   \
    \ let mut prime_length36 = 1;\n    let mut prime_length37 = 1;\n    let mut prime_length38\
    \ = 1;\n    let mut prime_length39 = 1;\n    let mut prime_length40 = 1;\n   \
    \ let mut prime_length41 = 1;\n    let mut prime_length42 = 1;\n    let mut prime_length43\
    \ = 1;\n    let mut prime_length44 = 1;\n    let mut prime_length45 = 1;\n   \
    \ let mut prime_length46 = 1;\n    let mut prime_length47 = 1;\n    let mut prime_length48\
    \ = 1;\n    let mu\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpluin_llw.rs:81:11\n   |\n\
    81 |     let mu\n   |           ^ help: add `;` here\n82 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpluin_llw.rs:86:17\n\
    \   |\n86 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpluin_llw.rs:86:25\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpluin_llw.rs:87:17\n   |\n87 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpluin_llw.rs:87:25\n\
    \   |\n87 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpluin_llw.rs:88:17\n   |\n88 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpluin_llw.rs:88:25\n   |\n88 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpluin_llw.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpluin_llw.rs:89:25\n   |\n89 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpluin_llw.rs:90:17\n  \
    \ |\n90 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpluin_llw.rs:90:25\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  -"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    loop {\n        if\
    \ interval1_end < interval2_start {\n            interval1_end = interval1_end\
    \ + 1;\n        } else {\n            interval2_start = interval2_start + 1;\n\
    \        }\n        if interval1_end > interval2_end {\n            interval1_end\
    \ = interval1_end - 1;\n        } else {\n            interval2_end = interval2_end\
    \ - 1;\n        }\n        intersection_length = intersection_length + 1;\n  \
    \      if interval1_end == interval2_end {\n            break;\n        }\n  \
    \  }\n    if intersection_length == 2 {\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        } else {\n            return \"NO\"\
    ;\n        }\n    } else {\n        return \"NO\";\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgwy1jiom.rs:55:17\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgwy1jiom.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgwy1jiom.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgwy1jiom.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgwy1jiom.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgwy1jiom.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgwy1jiom.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgwy1jiom.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgwy1jiom.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgwy1jiom.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgwy1jiom.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut interval_length = interval2_end - interval2_start;\n\
    \    while interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval1_end {\n            intersection_start\
    \ = interval1_start;\n            intersection_end = interval1_end;\n        \
    \    intersection_length += 1;\n        }\n        if interval2_start < interval2_end\
    \ {\n            intersection_start = interval2_start;\n            intersection_end\
    \ = interval2_end;\n            intersection_length += 1;\n        }\n       \
    \ interval1_start += 1;\n        interval1_end += 1;\n        interval2_start\
    \ += 1;\n        interval2_end += 1;\n    }\n    if intersection_length == interval_length\
    \ {\n        if intersection_start == intersection_end {\n            if interval1_start\
    \ == interval1_end {\n                return String::from(\"YES\");\n        \
    \    }\n            if interval2_start == interval2_end {\n                return\
    \ String::from(\"YES\");\n            }\n        }\n        if intersection_start\
    \ == intersection_end {\n            return String::from(\"NO\");\n        }\n\
    \    }\n    return String::from(\"NO\");\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfir7henl.rs:63:17\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfir7henl.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfir7henl.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfir7henl.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfir7henl.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfir7henl.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfir7henl.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfir7henl.rs:66:25\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfir7henl.rs:67:17\n  \
    \ |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfir7henl.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfir7henl.rs:68:17\n   |\n68 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![interval1, interval2];\n    let mut\
    \ start = interval1[0];\n    let mut end = interval1[1];\n    let mut intersection\
    \ = vec![start, end];\n    let mut prime = true;\n    let mut prime_length = prime_length(&intersection);\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime_length + prime_length;\n\
    \    let mut prime_length = prime_length + prime_length;\n    let mut prime_length\
    \ = prime_length + prime_length;\n    let mut prime_length = prime\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt2hw6k8t.rs:59:33\n   |\n\
    59 |     let mut prime_length = prime\n   |                                 ^\
    \ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find function `prime_length` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:26:28\n\
    \   |\n26 |     let mut prime_length = prime_length(&intersection);\n   |    \
    \                        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:64:17\n  \
    \ |\n64 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt2hw6k8t.rs:64:25\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:65:17\n   |\n65 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:65:25\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt2hw6k8t.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt2hw6k8t.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt2hw6k8t.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_end < interval2_start {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval2_start = interval1_start;\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_start = interval2_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start =\
    \ interval2_start;\n        interval2_end = interval1_end;\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval2_start\
    \ == interval2_end {\n        return \"NO\";\n    }\n    if interval1_start <\
    \ interval2_start {\n        return \"NO\";\n    }\n    if interval1_start > interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_end < interval2_end {\n \
    \       return \"NO\";\n    }\n    if interval1_end > interval2_end {\n      \
    \  return \"NO\";\n    }\n    if interval1_start == interval2_start {\n      \
    \  if interval1_end == interval2_end {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if interval1_end == interval2_end {\n    \
    \    return \"NO\";\n    }\n    if interval1_start < interval2_end {\n       \
    \ return \"NO\";\n    }\n    if interval1_start > interval2_end {\n        return\
    \ \"NO\";\n    }\n    if interval1_end < interval2_start {\n        return \"\
    NO\";\n    }\n    if interval1_end > interval2_start {\n        return \"NO\"\
    ;\n    }\n    if interval1_start == interval2_start {\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    if interval1_end == interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start < interval2_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_start > interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n   \
    \ if interval1_end > interval2_start {\n        return \"NO\";\n    }\n    if\
    \ interval1_start == interval2_start {\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpl_hyzbv9.rs:120:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n104 |     if interval1_start\
    \ == interval2_start {\n    |                                           - unclosed\
    \ delimiter\n105 |         if interval1_end == interval2_end {\n    |        \
    \                                   - this delimiter might not be properly closed...\n\
    ...\n108 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n120 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpl_hyzbv9.rs:112:17\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpl_hyzbv9.rs:112:25\n    |\n112 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpl_hyzbv9.rs:113:17\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpl_hyzbv9.rs:113:25\n    |\n113 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpl_hyzbv9.rs:114:17\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpl_hyzbv9.rs:114:25\n    |\n114 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpl_hyzbv9.rs:115:17\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpl_hyzbv9.rs"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = 0;\n    let mut intersection_end\
    \ = 0;\n    \n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    \n    if interval1_start > interval2_end {\n  \
    \      interval1_start = interval2_end;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end = interval2_start;\n    }\n    \n    if interval1_start\
    \ > interval1_end {\n        intersection_start = interval1_start;\n        intersection_end\
    \ = interval1_end;\n    } else {\n        intersection_start = interval2_start;\n\
    \        intersection_end = interval2_end;\n    }\n    \n    if intersection_start\
    \ > intersection_end {\n        return \"NO\";\n    }\n    \n    if interval1_start\
    \ == interval1_end {\n        return \"NO\";\n    }\n    \n    if interval1_start\
    \ == interval2_start {\n        return \"YES\";\n    }\n    \n    if interval1_end\
    \ == interval2_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"YES\";\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ > interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"YES\";\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ > interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"YES\";\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ > interval1_end {\n        return \"YES\";\n    }\n    \n    if interval1_start\
    \ < interval2_start {\n        return \"YES\";\n    }\n    \n    if interval1_end\
    \ > interval2_end {\n        return \"YES\";\n    }\n\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:126:17\n\
    \    |\n126 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpf6l2i4ot.rs:126:25\n    |\n126 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:127:17\n\
    \    |\n127 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpf6l2i4ot.rs:127:25\n    |\n127 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:128:17\n\
    \    |\n128 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpf6l2i4ot.rs:128:25\n    |\n128 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:129:17\n\
    \    |\n129 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpf6l2i4ot.rs:129:25\n    |\n129 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:130:17\n\
    \    |\n130 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpf6l2i4ot.rs:130:25\n    |\n130 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpf6l2i4ot.rs:131:17\n\
    \    |\n131 |     assert_eq!({left}, {right});\n    |                 ^^^^"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_start {\n      \
    \  interval1_start = interval2_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n    if interval1_end == interval2_end\
    \ {\n        if interval1_start == interval2_start {\n            return \"NO\"\
    ;\n        } else {\n            return \"YES\";\n        }\n    }\n    let mut\
    \ interval1_length = interval1_end - interval1_start + 1;\n    let mut interval2_length\
    \ = interval2_end - interval2_start + 1;\n    if interval1_length == interval2_length\
    \ {\n        if interval1_start == interval2_start {\n            return \"NO\"\
    ;\n        } else {\n            return \"YES\";\n        }\n    }\n    if interval1_length\
    \ < interval2_length {\n        interval1_length = interval2_length;\n    }\n\
    \    let mut interval1_prime = true;\n    let mut interval2_prime = true;\n  \
    \  if interval1_length == 2 {\n        if interval2_length == 2 {\n          \
    \  if interval1_start == interval2_start {\n                return \"NO\";\n \
    \           } else {\n                return \"YES\";\n            }\n       \
    \ }\n        if interval2_length == 3 {\n            if interval1_start == interval2_start\
    \ {\n                return \"NO\";\n            } else {\n                return\
    \ \"YES\";\n            }\n        }\n    }\n    if interval1_length == 3 {\n\
    \        if interval2_length == 2 {\n            if interval1_start == interval2_start\
    \ {\n                return \"NO\";\n            } else {\n                return\
    \ \"YES\";\n            }\n        }\n        if interval2_length == 3 {\n   \
    \         if interval1_start == interval2_start {\n                return \"NO\"\
    ;\n            } else {\n                return \"YES\";\n            }\n    \
    \    }\n    }\n    if interval1_length == 4 {\n        if interval2_length ==\
    \ 3 {\n            if interval1_start == interval2_start {\n                return\
    \ \"NO\";\n            } else {\n                return \"YES\";\n           \
    \ }\n        }\n        if interval2_length == 4 {\n            if interval1_start\
    \ == interval2_start {\n                return \"NO\";\n            } else {\n\
    \                return \"YES\";\n            }\n        }\n    }\n    if interval1_length\
    \ == 5 {\n        if interval2_length == 4 {\n            if interval1_start ==\
    \ interval2_start {\n                return \"NO\";\n            } else {\n  \
    \              return \"YES\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_j7398of.rs:124:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n106 |     if interval1_length\
    \ == 5 {\n    |                              - unclosed delimiter\n107 |     \
    \    if interval2_length == 4 {\n    |                                  - unclosed\
    \ delimiter\n...\n110 |             } else {\n    |                    - this\
    \ delimiter might not be properly closed...\n111 |                 return \"YES\"\
    ;\n112 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    124 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n \
    \  --> /tmp/tmp_j7398of.rs:116:17\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp_j7398of.rs:116:25\n    |\n116 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp_j7398of.rs:117:17\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp_j7398of.rs:117:25\n    |\n117 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp_j7398of.rs:118:17\n    |\n118 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp_j7398of.rs:118:25\n    |\n118 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp_j7398of.rs:119:17\n    |\n119 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: c"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_end < interval2_start {\n        interval1_end, interval2_start\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\".to_string();\n\
    \        }\n        return \"NO\".to_string();\n    }\n    if interval1_end ==\
    \ interval2_end {\n        return \"NO\".to_string();\n    }\n    if interval1_start\
    \ < interval2_end {\n        let mut interval1_length = interval1_end - interval1_start\
    \ + 1;\n        let mut interval2_length = interval2_end - interval2_start + 1;\n\
    \        let mut intersection_length = interval1_length + interval2_length - 1;\n\
    \        let mut prime_number: isize = 2;\n        while intersection_length >=\
    \ prime_number {\n            if interval1_start < interval2_start {\n       \
    \         interval1_length += 1;\n            } else {\n                interval2_length\
    \ += 1;\n            }\n            intersection_length -= prime_number;\n   \
    \         prime_number += 2;\n        }\n        if intersection_length == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpe01ysnc5.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpe01ysnc5.rs:26:72\n   |\n25 |     if interval1_start > interval1_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpe01ysnc5.rs:25:26\n   |\n25 |       if interval1_start > interval1_end\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval1_end\
    \ {\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpe01ysnc5.rs:29:40\n\
    \   |\n29 |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpe01ysnc5.rs:29:72\n   |\n28 |     if interval2_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n29\
    \ |         interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpe01ysnc5.rs:28:26\n   |\n28 |       if interval2_start > interval2_end\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    if interval1_start\
    \ > interval2_start {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval1_start = interval2_start;\n    }\n    if\
    \ interval1_start < interval1_end {\n        intersection_length = interval1_end\
    \ - interval1_start + 1;\n    }\n    if intersection_length == 2 {\n        if\
    \ interval1_start == interval1_end {\n            return \"YES\".to_string();\n\
    \        }\n        if interval2_start == interval2_end {\n            return\
    \ \"YES\".to_string();\n        }\n        if interval1_start < interval2_start\
    \ {\n            return \"NO\".to_string();\n        }\n        if interval1_end\
    \ > interval2_end {\n            return \"NO\".to_string();\n        }\n     \
    \   if interval1_start < interval1_end {\n            return \"YES\".to_string();\n\
    \        }\n        if interval1_start == interval1_end {\n            return\
    \ \"YES\".to_string();\n        }\n        if interval2_start == interval2_end\
    \ {\n            return \"YES\".to_string();\n        }\n        if interval1_start\
    \ < interval2_start {\n            return \"NO\".to_string();\n        }\n   \
    \     if interval1_end > interval2_end {\n            return \"NO\".to_string();\n\
    \        }\n        if interval1_start < interval1_end {\n            return \"\
    YES\".to_string();\n        }\n        if interval1_start == interval1_end {\n\
    \            return \"YES\".to_string();\n        }\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\".to_string();\n        }\n   \
    \     if interval1_start < interval2_start {\n            return \"NO\".to_string();\n\
    \        }\n        if interval1_end > interval2_end {\n            return \"\
    NO\".to_string();\n        }\n        if interval1_start < interval1_end {\n \
    \           return \"YES\".to_string();\n        }\n        if interval1_start\
    \ == interval1_end {\n            return \"YES\".to_string();\n        }\n   \
    \     if interval2_start == interval2_end {\n            return \"YES\".to_string();\n\
    \        }\n        if interval1_start < interval2_start {\n            return\
    \ \"NO\".to_string();\n        }\n        if interval1_end > interval2_end {\n\
    \            return \"NO\".to_string();\n        }\n        if interval1_start\
    \ < interval1_end {\n            return \"YES\".to_string();\n        }\n    \
    \    if interval1_start == interval1_end {\n            return \"YES\".to_string();\n\
    \        }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmppsf6mzad.rs:113:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n37  |     if intersection_length\
    \ == 2 {\n    |                                 - this delimiter might not be\
    \ properly closed...\n...\n101 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n113 | }\n    |   ^\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmppsf6mzad.rs:105:17\n    |\n105 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmppsf6mzad.rs:105:25\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmppsf6mzad.rs:106:17\n    |\n106 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmppsf6mzad.rs:106:25\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmppsf6mzad.rs:107:17\n    |\n107 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmppsf6mzad.rs:107:25\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmppsf6mzad.rs:108:17\n    |\n108 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmppsf6mzad.rs:108:25\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_start > interval1_end\
    \ {\n        interval1_start = interval1_end;\n        interval1_end = interval1_start;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start = interval2_end;\n\
    \        interval2_end = interval2_start;\n    }\n    if interval1_start > interval2_start\
    \ {\n        intersection_start = interval2_start;\n        intersection_end =\
    \ interval2_end;\n    }\n    if interval1_end < interval2_end {\n        intersection_start\
    \ = interval1_start;\n        intersection_end = interval1_end;\n    }\n    if\
    \ intersection_start > intersection_end {\n        return \"NO\";\n    }\n   \
    \ if interval1_start == interval1_end {\n        if interval2_start == interval2_end\
    \ {\n            if interval1_start == interval1_end {\n                return\
    \ \"YES\";\n            }\n            return \"NO\";\n        }\n        return\
    \ \"NO\";\n    }\n    if interval2_start == interval2_end {\n        return \"\
    NO\";\n    }\n    if interval1_start == interval2_start {\n        return \"NO\"\
    ;\n    }\n    if interval1_end == interval2_end {\n        return \"NO\";\n  \
    \  }\n    if intersection_start == intersection_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start == intersection_start {\n        return \"YES\"\
    ;\n    }\n    if interval1_end == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval2_start == intersection_start {\n        return \"YES\"\
    ;\n    }\n    if interval2_end == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval1_start == intersection_start {\n        return \"YES\"\
    ;\n    }\n    if interval1_end == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval2_start == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval2_end == intersection_start {\n        return \"YES\";\n\
    \    }\n    if interval1_start == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval1_end == intersection_start {\n        return \"YES\";\n\
    \    }\n    if interval2_start == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval2_end == intersection_start {\n        return \"YES\";\n\
    \    }\n    if interval1_start == intersection_end {\n        return \"YES\";\n\
    \    }\n    if interval1_\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpkaws9llu.rs:107:1\n    |\n\
    106 |     if interval1_\n    |     -- this `if` expression has a condition, but\
    \ no block\n107 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpkaws9llu.rs:111:17\n    |\n111 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpkaws9llu.rs:111:25\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpkaws9llu.rs:112:17\n    |\n112 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpkaws9llu.rs:112:25\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpkaws9llu.rs:113:17\n    |\n113 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpkaws9llu.rs:113:25\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpkaws9llu.rs:114:17\n    |\n114 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpkaws9llu.rs:114:25\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpkaws9llu.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpkaws9llu.rs:115:25\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                        \
    \ ^"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut interval1_prime\
    \ = true;\n    let mut interval2_prime = true;\n    \n    while interval1_len\
    \ > 0 || interval2_len > 0 {\n        if interval1_len > 0 {\n            if interval1_start\
    \ >= interval2_start {\n                interval1_start -= interval1_len;\n  \
    \              interval1_len = 0;\n            } else {\n                interval1_len\
    \ -= interval2_len;\n                interval2_len = 0;\n            }\n     \
    \   }\n        if interval2_len > 0 {\n            if interval2_start >= interval1_start\
    \ {\n                interval2_start -= interval2_len;\n                interval2_len\
    \ = 0;\n            } else {\n                interval2_len -= interval1_len;\n\
    \                interval1_len = 0;\n            }\n        }\n    }\n    if interval1_len\
    \ == 0 && interval2_len == 0 {\n        return \"NO\";\n    }\n    if interval1_len\
    \ == 0 {\n        return \"YES\";\n    }\n    if interval2_len == 0 {\n      \
    \  return \"YES\";\n    }\n    if interval1_len > 0 && interval2_len > 0 && interval1_len\
    \ == interval2_len {\n        return \"YES\";\n    }\n    if interval1_len > 0\
    \ && interval2_len > 0 && interval1_len < interval2_len {\n        return \"NO\"\
    ;\n    }\n    if interval1_len < interval2_len {\n        return \"NO\";\n   \
    \ }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpngm84s2s.rs:73:17\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpngm84s2s.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpngm84s2s.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpngm84s2s.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpngm84s2s.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpngm84s2s.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpngm84s2s.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpngm84s2s.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpngm84s2s.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpngm84s2s.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpngm84s2s.rs:78:17\n   |\n78 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_end > interval2_start {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n\n    if\
    \ interval1_end > interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval2_start = interval1_start;\n    }\n\n    if interval1_start < interval2_start\
    \ {\n        interval1_start = interval2_start;\n        interval2_end = interval1_end;\n\
    \    }\n\n    if interval1_start < interval2_end {\n        interval1_start =\
    \ interval2_start;\n        interval2_end = interval1_end;\n    }\n\n    if interval1_start\
    \ == interval2_start {\n        if interval1_end == interval2_end {\n        \
    \    return \"YES\";\n        }\n        return \"NO\";\n    }\n\n    if interval1_end\
    \ == interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_start\
    \ == interval2_start {\n        return \"YES\";\n    }\n\n    if interval1_end\
    \ == interval2_end {\n        return \"YES\";\n    }\n\n    if interval1_start\
    \ < interval2_start {\n        return \"NO\";\n    }\n\n    if interval1_end >\
    \ interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_start < interval2_end\
    \ {\n        return \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n\
    \        return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n\
    \        return \"YES\";\n    }\n\n    if interval1_end == interval2_end {\n \
    \       return \"YES\";\n    }\n\n    if interval1_start < interval2_start {\n\
    \        return \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n \
    \       return \"YES\";\n    }\n\n    if interval1_end == interval2_end {\n  \
    \      return \"YES\";\n    }\n\n    if interval1_start < interval2_start {\n\
    \        return \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n \
    \       return \"YES\";\n    }\n\n    if interval1_end == interval2_end {\n  \
    \      return \"YES\";\n    }\n\n    if interval1_start < interval2_start {\n\
    \        return \"NO\";\n    }\n\n    if interval1_end > interval2_end {\n   \
    \     return \"NO\";\n    }\n\n    if interval1_start == interval2_start {\n \
    \       return \"YES\";\n    }\n\n    if interval1_end == interval2_end \n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpt7h2dznn.rs:134:1\n    |\n\
    133 |     if interval1_end == interval2_end \n    |     -- this `if` expression\
    \ has a condition, but no block\n134 | }\n    | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpt7h2dznn.rs:138:17\n\
    \    |\n138 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpt7h2dznn.rs:138:25\n    |\n138 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpt7h2dznn.rs:139:17\n\
    \    |\n139 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpt7h2dznn.rs:139:25\n    |\n139 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpt7h2dznn.rs:140:17\n\
    \    |\n140 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpt7h2dznn.rs:140:25\n    |\n140 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpt7h2dznn.rs:141:17\n\
    \    |\n141 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpt7h2dznn.rs:141:25\n    |\n141 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpt7h2dznn.rs:142:17\n\
    \    |\n142 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpt7h2dznn.rs:142:25\n    |\n142 |     assert_eq!({left}, {right});\n\
    \    |     "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_end > interval2_end\
    \ {\n        interval1_end = interval2_end;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_start < interval2_start {\n        interval1_start =\
    \ interval2_start;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end == interval2_end {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        } else {\n           \
    \ return String::from(\"NO\");\n        }\n    }\n    let mut interval1_len =\
    \ interval1_end - interval1_start + 1;\n    let mut interval2_len = interval2_end\
    \ - interval2_start + 1;\n    let mut common_len = interval1_len + interval2_len\
    \ - 2;\n    if common_len == 2 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        } else {\n           \
    \ return String::from(\"NO\");\n        }\n    }\n    if common_len == 1 {\n \
    \       if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        } else {\n            return String::from(\"NO\");\n        }\n\
    \    }\n    if common_len == 0 {\n        return String::from(\"NO\");\n    }\n\
    \    if common_len == -1 {\n        return String::from(\"NO\");\n    }\n    if\
    \ common_len == -2 {\n        return String::from(\"NO\");\n    }\n    if common_len\
    \ == -3 {\n        return String::from(\"NO\");\n    }\n    if common_len == -4\
    \ {\n        return String::from(\"NO\");\n    }\n    if common_len == -5 {\n\
    \        return String::from(\"NO\");\n    }\n    if common_len == -6 {\n    \
    \    return String::from(\"NO\");\n    }\n    if common_len == -7 {\n        return\
    \ String::from(\"NO\");\n    }\n    if common_len == -8 {\n        return String::from(\"\
    NO\");\n    }\n    if common_len == -9 {\n        return String::from(\"NO\");\n\
    \    }\n    if common_len == -10 {\n        return String::from(\"NO\");\n   \
    \ }\n    if common_len == -11 {\n        return String::from(\"NO\");\n\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqyvzhycf.rs:113:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n98  |     if common_len ==\
    \ -11 {\n    |                          - this delimiter might not be properly\
    \ closed...\n...\n101 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n113 | }\n    |   ^\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpqyvzhycf.rs:105:17\n    |\n105 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpqyvzhycf.rs:105:25\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpqyvzhycf.rs:106:17\n    |\n106 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpqyvzhycf.rs:106:25\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpqyvzhycf.rs:107:17\n    |\n107 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpqyvzhycf.rs:107:25\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpqyvzhycf.rs:108:17\n    |\n108 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpqyvzhycf.rs:108:25\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start <= interval1.end && interval2.start <= interval2.end\
    \ {\n        let mut interval = interval1;\n        let mut interval2 = interval2;\n\
    \        let mut count = 0;\n        while interval.start <= interval.end && interval2.start\
    \ <= interval2.end {\n            if interval.start < interval2.start {\n    \
    \            interval.start = interval.start + 1;\n                count += 1;\n\
    \            } else {\n                interval2.start = interval2.start + 1;\n\
    \                count += 1;\n            }\n        }\n        if interval.start\
    \ <= interval.end {\n            interval.end = interval.start + 1;\n        \
    \    count += 1;\n        }\n        if interval2.start <= interval2.end {\n \
    \           interval2.end = interval2.start + 1;\n            count += 1;\n  \
    \      }\n        if count % 2 == 0 {\n            return \"YES\";\n        }\
    \ else {\n            return \"NO\";\n        }\n    } else {\n        return\
    \ \"NO\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp37obkwx5.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp37obkwx5.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp37obkwx5.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp37obkwx5.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp37obkwx5.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp37obkwx5.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp37obkwx5.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp37obkwx5.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp37obkwx5.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp37obkwx5.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp37obkwx5.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start < interval1.end && interval2.start < interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        interval.start += 1;\n      \
    \  interval.end += 1;\n        let mut interval2 = interval2;\n        interval2.start\
    \ = interval2.end;\n        interval2.end = interval2.start;\n        interval2.start\
    \ += 1;\n        interval2.end += 1;\n        let mut interval = interval;\n \
    \       let mut interval2 = interval2;\n        let mut prime = true;\n      \
    \  let mut prime2 = true;\n        let mut prime3 = true;\n        let mut prime4\
    \ = true;\n        let mut prime5 = true;\n        let mut prime6 = true;\n  \
    \      let mut prime7 = true;\n        let mut prime8 = true;\n        let mut\
    \ prime9 = true;\n        let mut prime10 = true;\n        let mut prime11 = true;\n\
    \        let mut prime12 = true;\n        let mut prime13 = true;\n        let\
    \ mut prime14 = true;\n        let mut prime15 = true;\n        let mut prime16\
    \ = true;\n        let mut prime17 = true;\n        let mut prime18 = true;\n\
    \        let mut prime19 = true;\n        let mut prime20 = true;\n        let\
    \ mut prime21 = true;\n        let mut prime22 = true;\n        let mut prime23\
    \ = true;\n        let mut prime24 = true;\n        let mut prime25 = true;\n\
    \        let mut prime26 = true;\n        let mut prime27 = true;\n        let\
    \ mut prime28 = true;\n        let mut prime29 = true;\n        let mut prime30\
    \ = true;\n        let mut prime31 = true;\n        let mut prime32 = true;\n\
    \        let mut prime33 = true;\n        let mut prime34 = true;\n        let\
    \ mut prime35 = true;\n        let mut prime36 = true;\n        let mut prime37\
    \ = true;\n        let mut prime38 = true;\n        let mut prime39 = true;\n\
    \        let mut prime40 = true;\n        let mut prime41 = true;\n        let\
    \ mut prime42 = true;\n        let mut prime43 = true;\n        let mut prime44\
    \ = true;\n        let mut prime45 = true;\n        let mut prime46 = true;\n\
    \        let mut prime47 = true;\n        let mut prime48 = true;\n        let\
    \ mut prime49 = true;\n        let mut prime50 = true;\n        let mut prime51\
    \ = true;\n        let mut prime52 = true;\n        let mut prime53 = true;\n\
    \        let mut prime54 = true;\n        let mut prime55 = true;\n        let\
    \ mut prime56 = true;\n        let mut prime57 = true;\n\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp68z2h4o3.rs:104:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n21  |     if interval1.start <\
    \ interval1.end && interval2.start < interval2.end {\n    |                  \
    \                                                         - this delimiter might\
    \ not be properly closed...\n...\n92  | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n104 | }\n    |   ^\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp68z2h4o3.rs:96:17\n   |\n96 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp68z2h4o3.rs:96:25\n\
    \   |\n96 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp68z2h4o3.rs:97:17\n   |\n97 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp68z2h4o3.rs:97:25\n   |\n97 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp68z2h4o3.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp68z2h4o3.rs:98:25\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp68z2h4o3.rs:99:17\n  \
    \ |\n99 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp68z2h4o3.rs:99:25\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_end < interval1_start {\n        interval1_end, interval1_start\
    \ = interval1_start, interval1_end;\n    }\n    if interval2_end < interval2_start\
    \ {\n        interval2_end, interval2_start = interval2_start, interval2_end;\n\
    \    }\n    if interval1_end == interval2_end {\n        if interval1_start ==\
    \ interval2_start {\n            return String::from(\"YES\");\n        }\n  \
    \      return String::from(\"NO\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_end == interval2_start {\n        \
    \    return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval2_start == interval2_end {\n        if interval1_end\
    \ == interval1_start {\n            return String::from(\"YES\");\n        }\n\
    \        return String::from(\"NO\");\n    }\n    if interval1_start == interval2_start\
    \ {\n        if interval1_end == interval2_end {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_end == interval2_start {\n        \
    \    return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval2_start == interval2_end {\n        if interval1_end\
    \ == interval1_start {\n            return String::from(\"YES\");\n        }\n\
    \        return String::from(\"NO\");\n    }\n    let mut interval1_len = interval1_end\
    \ - interval1_start;\n    let mut interval2_len = interval2_end - interval2_start;\n\
    \    if interval1_len > interval2_len {\n\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpl4nmhcbe.rs:101:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n87  |     if interval1_len\
    \ > interval2_len {\n    |                                      - this delimiter\
    \ might not be properly closed...\n88  | \n89  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n101 | }\n    |   ^\n\nerror: expected\
    \ `:`, found `=`\n  --> /tmp/tmpl4nmhcbe.rs:26:40\n   |\n26 |         interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n   |                      \
    \                 -^\n   |                                       |\n   |     \
    \                                  help: replace equals symbol with a colon: `:`\n\
    \nerror: expected one of `,` or `}`, found `;`\n  --> /tmp/tmpl4nmhcbe.rs:20:81\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       ^ unclosed delimiter\n...\n25 |     if interval1_start\
    \ > interval1_end {\n   |                          ------------- while parsing\
    \ this struct\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                                                        ^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ one of `,` or `}`\n   |                                                    \
    \                    help: `}` may belong here\n\nerror: struct literals are not\
    \ allowed here\n  --> /tmp/tmpl4nmhcbe.rs:25:26\n   |\n25 |       if interval1_start\
    \ > interval1_end {\n   |  __________________________^\n26 | |         interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n27 | |     }\n   | |_____^\n\
    \   |\nhelp: surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (i"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    while interval1_start < interval1_end\
    \ && interval2_start < interval2_end {\n        if interval1_start < interval2_start\
    \ {\n            intersection_start = interval1_start;\n        }\n        if\
    \ interval1_end > interval2_end {\n            intersection_end = interval1_end;\n\
    \        }\n        if intersection_start > intersection_end {\n            intersection_start\
    \ = intersection_end;\n        }\n        interval1_start += 1;\n        interval1_end\
    \ += 1;\n        interval2_start += 1;\n        interval2_end += 1;\n    }\n \
    \   if interval1_start == interval1_end {\n        if interval2_start == interval2_end\
    \ {\n            return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if intersection_start == intersection_end {\n        return\
    \ String::from(\"NO\");\n    }\n    if interval1_start == interval1_end {\n  \
    \      return String::from(\"NO\");\n    }\n    if interval2_start == interval2_end\
    \ {\n        return String::from(\"YES\");\n    }\n    if intersection_start <\
    \ intersection_end {\n        return String::from(\"YES\");\n    }\n    return\
    \ String::from(\"NO\");\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2mepz7tb.rs:65:17\n\
    \   |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2mepz7tb.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2mepz7tb.rs:66:17\n   |\n66 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2mepz7tb.rs:66:25\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2mepz7tb.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2mepz7tb.rs:67:25\n   |\n67 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2mepz7tb.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2mepz7tb.rs:68:25\n   |\n68 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2mepz7tb.rs:69:17\n  \
    \ |\n69 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2mepz7tb.rs:69:25\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2mepz7tb.rs:70:17\n   |\n70 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start,\
    \ interval1_end = interval1_end, interval1_start;\n    }\n    if interval2_start\
    \ > interval2_end {\n        interval2_start, interval2_end = interval2_end, interval2_start;\n\
    \    }\n    if interval1_start > interval2_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n\
    \    if interval1_end == interval2_end {\n        return \"YES\";\n    }\n   \
    \ let mut interval1_length = interval1_end - interval1_start + 1;\n    let mut\
    \ interval2_length = interval2_end - interval2_start + 1;\n    if interval1_length\
    \ == interval2_length {\n        return \"YES\";\n    }\n    if interval1_length\
    \ < interval2_length {\n        interval1_length = interval2_length;\n    }\n\
    \    if interval1_length == 2 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n    }\n    if interval1_length ==\
    \ 3 {\n        if interval1_start == interval2_start {\n            return \"\
    YES\";\n        }\n        if interval1_end == interval2_end {\n            return\
    \ \"YES\";\n        }\n    }\n    if interval1_length == 4 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n    }\n    if interval1_length\
    \ == 5 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n    }\n    if interval1_length == 6 {\n      \
    \  if interval1_start == interval2_start {\n            return \"YES\";\n    \
    \    }\n        if interval1_end == interval2_end {\n            return \"YES\"\
    ;\n        }\n    }\n    if interval1_length == 7 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        }\n    }\n    if interval1_length\
    \ == 8 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        if interval1_end == interval2_end {\n         \
    \   return \"YES\";\n        }\n    }\n    if interval1_length == 9 {\n      \
    \  if interval1_start == interval2_start {\n            return \"YES\";\n\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpondim2oe.rs:120:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n104 |     if interval1_length\
    \ == 9 {\n    |                              - unclosed delimiter\n105 |     \
    \    if interval1_start == interval2_start {\n    |                          \
    \                     - this delimiter might not be properly closed...\n...\n\
    108 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    120 | }\n    |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpondim2oe.rs:26:40\n\
    \   |\n26 |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpondim2oe.rs:20:81\n   |\n20 | fn intersection(interval1: (isize,\
    \ isize), interval2: (isize, isize)) -> String {\n   |                       \
    \                                                          ^ unclosed delimiter\n\
    ...\n25 |     if interval1_start > interval1_end {\n   |                     \
    \     ------------- while parsing this struct\n26 |         interval1_start, interval1_end\
    \ = interval1_end, interval1_start;\n   |                                    \
    \                                    ^\n   |                                 \
    \                                       |\n   |                              \
    \                                          expected one of `,` or `}`\n   |  \
    \                                                                      help: `}`\
    \ may belong here\n\nerror: struct literals are not allowed here\n  --> /tmp/tmpondim2oe.rs:25:26\n\
    \   |\n25 |       if interval1_start > interval1_end {\n   |  __________________________^\n\
    26 | |         interval1_start, interval1_end = interval1_end, interval1_start;\n\
    27 | |     "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start <= interval2_end {\n        if interval1_end\
    \ >= interval2_start {\n            if interval1_end < interval2_end {\n     \
    \           return String::from(\"YES\");\n            } else {\n            \
    \    return String::from(\"NO\");\n            }\n        } else {\n         \
    \   return String::from(\"NO\");\n        }\n    } else {\n        return String::from(\"\
    NO\");\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp3p6hc7gq.rs:27:42\n   |\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp3p6hc7gq.rs:27:76\n   |\n26 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp3p6hc7gq.rs:26:26\n   |\n26 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n27 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n28 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n26 ~     if interval1_start\
    \ > (interval2_start {\n27 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n28 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp3p6hc7gq.rs:30:38\n   |\n30 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp3p6hc7gq.rs:30:68\n   |\n29 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n30 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp3p6hc7gq.rs:29:24\n   |\n29 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            if interval1_start < interval1_end {\n     \
    \           return String::from(\"YES\");\n            }\n            return String::from(\"\
    NO\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    if interval1_start < interval1_end {\n                return String::from(\"\
    NO\");\n            }\n            return String::from(\"YES\");\n        }\n\
    \        return String::from(\"YES\");\n    }\n    if interval1_start > interval2_start\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \    }\n    if interval1_end < interval2_end {\n        interval1_end, interval1_start\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_start > interval2_end\
    \ {\n        interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \    }\n    if interval1_end < interval2_start {\n        interval1_end, interval1_start\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            if interval1_start\
    \ < interval1_end {\n                return String::from(\"YES\");\n         \
    \   }\n            return String::from(\"NO\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            if interval1_start < interval1_end {\n     \
    \           return String::from(\"NO\");\n            }\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"YES\");\n    }\n    if interval1_start\
    \ > interval2_start {\n        interval1_start, interval1_end = interval2_start,\
    \ interval1_end;\n\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpn1984itw.rs:100:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n85  |     if interval1_start\
    \ > interval2_start {\n    |                                          - this delimiter\
    \ might not be properly closed...\n...\n88  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n100 | }\n    |   ^\n\nerror: expected\
    \ `:`, found `=`\n  --> /tmp/tmpn1984itw.rs:26:40\n   |\n26 |         interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n   |                      \
    \                 -^\n   |                                       |\n   |     \
    \                                  help: replace equals symbol with a colon: `:`\n\
    \nerror: expected one of `,` or `}`, found `;`\n  --> /tmp/tmpn1984itw.rs:20:81\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       ^ unclosed delimiter\n...\n25 |     if interval1_start\
    \ > interval2_start {\n   |                          --------------- while parsing\
    \ this struct\n26 |         interval1_start, interval1_end = interval2_start,\
    \ interval1_end;\n   |                                                       \
    \                 ^\n   |                                                    \
    \                    |\n   |                                                 \
    \                       expected one of `,` or `}`\n   |                     \
    \                                                   help: `}` may belong here\n\
    \nerror: struct literals are not allowed here\n  --> /tmp/tmpn1984itw.rs:25:26\n\
    \   |\n25 |       if interval1_start > interval2_start {\n   |  __________________________^\n\
    26 | |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 | |     }\n   | |_____^\n   |\nhelp: surround the struct literal with parentheses\n\
    \   |\n25 ~     if interval1"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval_length = interval1_end - interval1_start\
    \ + interval2_end - interval2_start;\n    let mut interval_length_prime = true;\n\
    \    let mut interval_length_prime_prime = true;\n    let mut interval_length_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime = true;\n    let\
    \ mut interval_length_prime_prime_prime_prime_prime = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n    let mut interval_length_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime_prime\
    \ = true;\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpwuykyihx.rs:50:17\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwuykyihx.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwuykyihx.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwuykyihx.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwuykyihx.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwuykyihx.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwuykyihx.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwuykyihx.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwuykyihx.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwuykyihx.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwuykyihx.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_start > interval1_end\
    \ {\n        interval1_start = interval1_end;\n        interval1_end = interval1_start;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start = interval2_end;\n\
    \        interval2_end = interval2_start;\n    }\n    if interval1_start > interval2_start\
    \ {\n        intersection_start = interval2_start;\n        intersection_end =\
    \ interval2_end;\n    }\n    if interval1_end < interval2_end {\n        intersection_start\
    \ = interval1_start;\n        intersection_end = interval1_end;\n    }\n    if\
    \ intersection_start > intersection_end {\n        return \"NO\";\n    }\n   \
    \ if interval1_start == interval1_end {\n        return \"NO\";\n    }\n    if\
    \ interval2_start == interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ < interval2_start {\n        return \"NO\";\n    }\n    if interval1_end > interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start < interval2_end {\n\
    \        return \"NO\";\n    }\n    if interval1_end > interval2_start {\n   \
    \     return \"NO\";\n    }\n    if interval1_start == interval1_end {\n     \
    \   return \"NO\";\n    }\n    if interval2_start == interval2_end {\n       \
    \ return \"NO\";\n    }\n    if interval1_start < interval2_start {\n        return\
    \ \"NO\";\n    }\n    if interval1_end > interval2_end {\n        return \"NO\"\
    ;\n    }\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n    if interval1_end > interval2_start {\n        return \"NO\";\n    }\n\
    \    if interval1_start == interval1_end {\n        return \"NO\";\n    }\n  \
    \  if interval2_start == interval2_end {\n        return \"NO\";\n    }\n    if\
    \ interval1_start < interval2_start {\n        return \"NO\";\n    }\n    if interval1_end\
    \ > interval2_end {\n        return \"NO\";\n    }\n    if interval1_start < interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_end > interval2_start {\n\
    \        return \"NO\";\n    }\n    if interval1_start == interval1_end {\n  \
    \      return \"NO\";\n    }\n    if interval2_start == interval2_end {\n    \
    \    return \"NO\";\n    }\n    if interval1_start \n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpgtjkxej_.rs:107:1\n    |\n\
    106 |     if interval1_start \n    |     -- this `if` expression has a condition,\
    \ but no block\n107 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n   --> /tmp/tmpgtjkxej_.rs:111:17\n    |\n111 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpgtjkxej_.rs:111:25\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpgtjkxej_.rs:112:17\n    |\n112 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpgtjkxej_.rs:112:25\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpgtjkxej_.rs:113:17\n    |\n113 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpgtjkxej_.rs:113:25\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpgtjkxej_.rs:114:17\n    |\n114 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpgtjkxej_.rs:114:25\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpgtjkxej_.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpgtjkxej_.rs:115:25\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                    "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n\n    if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval2_start &&\
    \ interval1_end >= interval2_end {\n            if interval1_start < interval2_end\
    \ {\n                interval1_start, interval2_end = interval2_end, interval1_start;\n\
    \            }\n            if interval1_end > interval2_start {\n           \
    \     interval1_end, interval2_start = interval2_start, interval1_end;\n     \
    \       }\n            if interval1_start <= interval2_end && interval1_end >=\
    \ interval2_start {\n                if interval1_start < interval2_end {\n  \
    \                  interval1_start, interval2_end = interval2_end, interval1_start;\n\
    \                }\n                if interval1_end > interval2_start {\n   \
    \                 interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \                }\n                if interval1_start <= interval2_end && interval1_end\
    \ >= interval2_start {\n                    if interval1_start < interval2_end\
    \ {\n                        interval1_start, interval2_end = interval2_end, interval1_start;\n\
    \                    }\n                    if interval1_end > interval2_start\
    \ {\n                        interval1_end, interval2_start = interval2_start,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval2_end && interval1_end >= interval2_start {\n                   \
    \     if interval1_start < interval2_end {\n                            interval1_start,\
    \ interval2_end = interval2_end, interval1_start;\n                        }\n\
    \                        if interval1_end > interval2_start {\n              \
    \              interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \                        }\n                        if interval1_start <= interval2_end\
    \ && interval1_end >= interval2_start {\n                            if interval1_start\
    \ < interval2_end {\n                                interval1_start, interval2_end\
    \ = interval2_end, interval1_start;\n                            }\n         \
    \                   if interval1_end > interval2_start {\n                   \
    \             interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \                            }\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu9zu09zo.rs:88:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n33 |     if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n40 |         if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n   |                                                                    \
    \             - unclosed delimiter\n...\n47 |             if interval1_start <=\
    \ interval2_end && interval1_end >= interval2_start {\n   |                  \
    \                                                                   - unclosed\
    \ delimiter\n...\n54 |                 if interval1_start <= interval2_end &&\
    \ interval1_end >= interval2_start {\n   |                                   \
    \                                                      - unclosed delimiter\n\
    ...\n61 |                     if interval1_start <= interval2_end && interval1_end\
    \ >= interval2_start {\n   |                                                 \
    \                                            - unclosed delimiter\n...\n68 | \
    \                        if interval1_start <= interval2_end && interval1_end\
    \ >= interval2_start {\n   |                                                 \
    \                                                - this delimiter might not be\
    \ properly closed...\n...\n76 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n88 | }\n   |   ^\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpu9zu09zo.rs:27:40\n   |\n27 |         interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n   |                                    \
    \   -^\n   |                                       |\n   |                   \
    \                    help: replace equals symbol with a colon: `:`\n\nerror: expected\
    \ one of `,` or `}`, found `;`\n  --> /tmp/tmpu9zu09zo."
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1.0 > interval2.0\
    \ {\n        interval = interval2;\n    }\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let mut interval_len = interval.1;\n\
    \    let mut interval_start = interval.0;\n    let mut interval_end = interval.1;\n\
    \    let mut interval_len = interval.1;\n    let mut interval_start = interval.0;\n\
    \    let mut interval_end = interval.1;\n    let \n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpofynqmb7.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpofynqmb7.rs:84:17\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpofynqmb7.rs:84:25\n \
    \  |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpofynqmb7.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpofynqmb7.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpofynqmb7.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpofynqmb7.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpofynqmb7.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpofynqmb7.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpofynqmb7.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpofynqmb7.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpofynqmb7.rs:89:17\n   |\n89 |     assert"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval1[1];\n        interval = interval2;\n        interval[0]\
    \ = interval2[0];\n        interval[1] = interval2[1];\n        if interval[0]\
    \ > interval[1] {\n            interval[0] = interval[1];\n            interval[1]\
    \ = interval[0];\n        }\n        let mut len = 0;\n        for &i in interval\
    \ {\n            if i == interval[0] {\n                len += 1;\n          \
    \  }\n            if i == interval[1] {\n                len += 1;\n         \
    \   }\n        }\n        if len == 2 {\n            return \"YES\";\n       \
    \ }\n        if len % 2 == 0 {\n            return \"NO\";\n        }\n      \
    \  return \"NO\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmposh9_8yt.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmposh9_8yt.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmposh9_8yt.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmposh9_8yt.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmposh9_8yt.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmposh9_8yt.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmposh9_8yt.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmposh9_8yt.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmposh9_8yt.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmposh9_8yt.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmposh9_8yt.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n\n    if interval1_start > interval2_start {\n    \
    \    interval1_start = interval2_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n\n    if interval1_start >\
    \ interval2_start {\n        interval1_start = interval2_start;\n    }\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \  }\n\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\";\n        } else {\n        \
    \    return \"NO\";\n        }\n    }\n\n    if interval1_start < interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"NO\"\
    ;\n        } else {\n            return \"YES\";\n        }\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        if interval1_end == interval2_end {\n           \
    \ return \"NO\";\n        } else {\n            return \"YES\";\n        }\n \
    \   }\n\n    if interval1_start == interval2_start {\n        if interval1_end\
    \ == interval2_end {\n            return \"YES\";\n        } else {\n        \
    \    return \"NO\";\n        }\n    }\n\n    if interval1_start == interval2_end\
    \ {\n        if interval1_end == interval2_end {\n            return \"YES\";\n\
    \        } else {\n            return \"NO\";\n        }\n    }\n\n    if interval1_start\
    \ < interval2_end {\n        if interval1_end == interval2_end {\n           \
    \ return \"NO\";\n        } else {\n            return \"YES\";\n        }\n \
    \   }\n\n    if interval1_start == interval2_end {\n        if interval1_end <\
    \ interval2_end {\n            return \"NO\";\n        } else {\n            return\
    \ \"YES\";\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3yos5s36.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:107:17\n\
    \    |\n107 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3yos5s36.rs:107:25\n    |\n107 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:108:17\n\
    \    |\n108 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3yos5s36.rs:108:25\n    |\n108 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:109:17\n\
    \    |\n109 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3yos5s36.rs:109:25\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:110:17\n\
    \    |\n110 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp3yos5s36.rs:110:25\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp3yos5s36.rs:111:17\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                 ^^^^"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start == interval1_end\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    .to_string();\n        } else {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n    let mut interval1_len = interval1_end - interval1_start + 1;\n\
    \    let mut interval2_len = interval2_end - interval2_start + 1;\n    if interval1_len\
    \ > interval2_len {\n        interval1_len = interval2_len;\n    }\n    if interval1_len\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    if interval1_len == 2\
    \ {\n        if interval2_start == interval2_end {\n            return \"YES\"\
    .to_string();\n        } else {\n            return \"NO\".to_string();\n    \
    \    }\n    }\n    let mut interval1_mid = interval1_start + interval1_len / 2;\n\
    \    let mut interval2_mid = interval2_start + interval2_len / 2;\n    if interval1_mid\
    \ < interval2_mid {\n        interval1_mid = interval2_mid;\n    }\n    if interval1_mid\
    \ == interval2_mid {\n        if interval1_start == interval1_end {\n        \
    \    return \"YES\".to_string();\n        } else {\n            return \"NO\"\
    .to_string();\n        }\n    }\n    if interval1_mid > interval2_mid {\n    \
    \    interval1_mid = interval2_mid;\n    }\n    if interval1_mid % 2 == 0 {\n\
    \        if interval1_mid < interval2_mid {\n            interval1_mid = interval2_mid;\n\
    \        }\n    }\n    if interval1_mid % 2 == 1 {\n        if interval1_mid >\
    \ interval2_mid {\n            interval1_mid = interval2_mid;\n        }\n   \
    \ }\n    if interval1_mid % 3 == 0 {\n        if interval1_mid < interval2_mid\
    \ {\n            interval1_mid = interval2_mid;\n        }\n    }\n    if interval1_mid\
    \ % 3 == 1 {\n        if interval1_mid > interval2_mid {\n            interval1_mid\
    \ = interval2_mid;\n        }\n    }\n    if interval1_mid % 5 == 0 {\n      \
    \  if interval1_mid < interval2_mid {\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp7jcvuvub.rs:104:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n90  |     if interval1_mid\
    \ % 5 == 0 {\n    |                               - unclosed delimiter\n91  |\
    \         if interval1_mid < interval2_mid {\n    |                          \
    \                - this delimiter might not be properly closed...\n92  | }\n \
    \   | - ...as it matches this but it has different indentation\n...\n104 | }\n\
    \    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7jcvuvub.rs:96:17\n\
    \   |\n96 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jcvuvub.rs:96:25\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7jcvuvub.rs:97:17\n   |\n97 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7jcvuvub.rs:97:25\n\
    \   |\n97 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7jcvuvub.rs:98:17\n   |\n98 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7jcvuvub.rs:98:25\n   |\n98 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7jcvuvub.rs:99:17\n   |\n99 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7jcvuvub.rs:99:25\n   |\n99 |     assert_eq!({left},\
    \ {right});\n   |            "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start <= interval2_end {\n        if interval1_end\
    \ >= interval2_start {\n            if interval1_end > interval2_end {\n     \
    \           interval1_end, interval2_end = interval2_end, interval1_end;\n   \
    \         }\n            if interval1_start <= interval2_end {\n             \
    \   if interval1_start < interval2_start {\n                    interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n                }\n   \
    \             if interval1_end >= interval2_end {\n                    interval1_end,\
    \ interval2_end = interval2_end, interval1_end;\n                }\n         \
    \       if interval1_start <= interval2_end {\n                    if interval1_end\
    \ < interval2_end {\n                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval2_end {\n                        if interval1_end < interval2_end\
    \ {\n                            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                        }\n                        if interval1_start\
    \ <= interval2_end {\n                            if interval1_end < interval2_end\
    \ {\n                                interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                            }\n                            if\
    \ interval1_start <= interval2_end {\n                                if interval1_end\
    \ < interval2_end {\n                                    interval1_end, interval2_end\
    \ = interval2_end, interval1_end;\n                                }\n       \
    \                         if interval1_start <= interval2_end {\n            \
    \                        if interval1_end < interval2_end {\n                \
    \                        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \                                    }\n                                    if\
    \ interval1_start <= interval2_end {\n                                       \
    \ if interval1_end < interval2_end {\n                                       \
    \     interval1_end, interval2_end = interval2_end, interval1_end;\n         \
    \                               }\n                                        if\
    \ interval1_start <= interval2_end {\n                                       \
    \     if interval1_end < interval2_end {\n                                   \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \                                           }\n                              \
    \              if interval1_start <= interval2_end {\n                       \
    \                         if interval1_end < interval2_end {\n               \
    \                                     interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                                                }\n        \
    \                                        if interval1_start <= interval2_end {\n\
    \                                \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnko4hpbv.rs:91:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n33 |     if interval1_start\
    \ <= interval2_end {\n   |                                         - unclosed\
    \ delimiter\n34 |         if interval1_end >= interval2_start {\n   |        \
    \                                     - unclosed delimiter\n...\n38 |        \
    \     if interval1_start <= interval2_end {\n   |                            \
    \                     - unclosed delimiter\n...\n45 |                 if interval1_start\
    \ <= interval2_end {\n   |                                                   \
    \  - unclosed delimiter\n...\n49 |                     if interval1_start <= interval2_end\
    \ {\n   |                                                         - unclosed delimiter\n\
    ...\n53 |                         if interval1_start <= interval2_end {\n   |\
    \                                                             - unclosed delimiter\n\
    ...\n57 |                             if interval1_start <= interval2_end {\n\
    \   |                                                                 - unclosed\
    \ delimiter\n...\n61 |                                 if interval1_start <= interval2_end\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n65 |                                     if interval1_start\
    \ <= interval2_end {\n   |                                                   \
    \                      - unclosed delimiter\n...\n69 |                       \
    \                  if interval1_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n73 |                                             if interval1_start <= interval2_end\
    \ {\n   |                                                                    \
    \             - unclosed delimiter\n...\n77 |                                \
    \        "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_end < interval2_start {\n        return \"NO\";\n   \
    \ }\n    if interval1_start > interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start == interval2_start {\n        if interval1_end == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   let mut interval1_len = interval1_end - interval1_start + 1;\n    let mut\
    \ interval2_len = interval2_end - interval2_start + 1;\n    if interval1_len >\
    \ interval2_len {\n        interval1_len = interval2_len;\n    }\n    if interval1_len\
    \ == 1 {\n        return \"YES\";\n    }\n    let mut prime_number: isize = 1;\n\
    \    let mut prime_number_len: isize = 1;\n    let mut prime_number_len2: isize\
    \ = 1;\n    let mut prime_number_len3: isize = 1;\n    let mut prime_number_len4:\
    \ isize = 1;\n    let mut prime_number_len5: isize = 1;\n    let mut prime_number_len6:\
    \ isize = 1;\n    let mut prime_number_len7: isize = 1;\n    let mut prime_number_len8:\
    \ isize = 1;\n    let mut prime_number_len9: isize = 1;\n    let mut prime_number_len10:\
    \ isize = 1;\n    let mut prime_number_len11: isize = 1;\n    let mut prime_number_len12:\
    \ isize = 1;\n    let mut prime_number_len13: isize = 1;\n    let mut prime_number_len14:\
    \ isize = 1;\n    let mut prime_number_len15: isize = 1;\n    let mut prime_number_len16:\
    \ isize = 1;\n    let mut prime_number_len17: isize = 1;\n    let mut prime_number_len18:\
    \ isize = 1;\n    let mut prime_number_len19: isize = 1;\n    let mut prime_number_len20:\
    \ isize = 1;\n    let mut prime_number_len21: isize = 1;\n    let mut prime_number_len22:\
    \ isize = 1;\n    let mut \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp59_oc3kw.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp59_oc3kw.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp59_oc3kw.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp59_oc3kw.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp59_oc3kw.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp59_oc3kw.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval1_end {\n        interval1_start\
    \ = interval1_end;\n    }\n    if interval2_start > interval2_end {\n        interval2_start\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_start {\n      \
    \  interval1_start = interval2_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end = interval2_end;\n    }\n    if interval1_end == interval2_end\
    \ {\n        if interval1_start == interval2_start {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";\n    }\n    let mut interval1_length = interval1_end\
    \ - interval1_start + 1;\n    let mut interval2_length = interval2_end - interval2_start\
    \ + 1;\n    let mut interval1_prime = true;\n    let mut interval2_prime = true;\n\
    \    if interval1_length == interval2_length {\n        if interval1_start ==\
    \ interval2_start {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    if interval1_length < interval2_length {\n        interval1_prime\
    \ = false;\n        interval2_prime = false;\n    } else {\n        interval1_prime\
    \ = true;\n        interval2_prime = true;\n    }\n    if interval1_prime && interval2_prime\
    \ {\n        if interval1_start == interval2_start {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";\n    }\n    if interval1_length == 2 {\n\
    \        if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 3 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 4 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 5 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 6 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 7 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 8 {\n  \
    \      if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_length == 9 {\n  \
    \      if interval1_start \n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9jj7fu1g.rs:122:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n108 |     if interval1_length\
    \ == 9 {\n    |                              - this delimiter might not be properly\
    \ closed...\n109 |         if interval1_start \n110 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n122 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmp9jj7fu1g.rs:110:1\n    |\n109 |         if interval1_start\
    \ \n    |         -- this `if` expression has a condition, but no block\n110 |\
    \ }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmp9jj7fu1g.rs:114:17\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp9jj7fu1g.rs:114:25\n    |\n114 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp9jj7fu1g.rs:115:17\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp9jj7fu1g.rs:115:25\n    |\n115 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp9jj7fu1g.rs:116:17\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmp9jj7fu1g.rs:116:25\n    |\n116 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmp9jj7fu1g.rs:117:17\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.0 < interval2.0 {\n        let mut interval =\
    \ interval1;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \    }\n    if interval1.1 < interval2.1 {\n        let mut interval = interval2;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n \
    \   if interval1.0 < interval2.0 {\n        let mut interval = interval1;\n  \
    \      interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        let mut interval = interval2;\n    \
    \    interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n    if\
    \ interval1.0 < interval2.0 {\n        let mut interval = interval1;\n       \
    \ interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n    if interval1.1\
    \ < interval2.1 {\n        let mut interval = interval2;\n        interval.0 =\
    \ interval.1;\n        interval.1 = interval.0;\n    }\n    if interval1.0 < interval2.0\
    \ {\n        let mut interval = interval1;\n        interval.0 = interval.1;\n\
    \        interval.1 = interval.0;\n    }\n    if interval1.1 < interval2.1 {\n\
    \        let mut interval = interval2;\n        interval.0 = interval.1;\n   \
    \     interval.1 = interval.0;\n    }\n    if interval1.0 < interval2.0 {\n  \
    \      let mut interval = interval1;\n        interval.0 = interval.1;\n     \
    \   interval.1 = interval.0;\n    }\n    if interval1.1 < interval2.1 {\n    \
    \    let mut interval = interval2;\n        interval.0 = interval.1;\n       \
    \ interval.1 = interval.0;\n    }\n    if interval1.0 < interval2.0 {\n      \
    \  let mut interval = interval1;\n        interval.0 = interval.1;\n        interval.1\
    \ = interval.0;\n    }\n    if interval1.1 < interval2.1 {\n        let mut interval\
    \ = interval2;\n        interval.0 = interval.1;\n        interval.1 = interval.0;\n\
    \    }\n    if interval1.0 < interval2.0 {\n        let mut interval = interval1;\n\
    \        interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n \
    \   if interval1.1 < interval2.1 {\n        let mut interval = interval2;\n  \
    \      interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n   \
    \ if interval1.0 < interval2.0 {\n        let mut interval = interval1;\n    \
    \    interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n    if\
    \ interval1.1 < interval2.1 {\n        let mut interval = interval2;\n       \
    \ interval.0 = interval.1;\n        interval.1 = interval.0;\n    }\n    if interval1.0\
    \ < interval2.0 {\n        let mut interval = interval1;\n        interval.0 =\
    \ interval.1;\n        interval.1 = interval.0;\n    }\n    if interval\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpq0iwmjuu.rs:107:1\n    |\n\
    106 |     if interval\n    |     -- this `if` expression has a condition, but\
    \ no block\n107 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpq0iwmjuu.rs:111:17\n    |\n111 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpq0iwmjuu.rs:111:25\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpq0iwmjuu.rs:112:17\n    |\n112 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpq0iwmjuu.rs:112:25\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpq0iwmjuu.rs:113:17\n    |\n113 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpq0iwmjuu.rs:113:25\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpq0iwmjuu.rs:114:17\n    |\n114 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpq0iwmjuu.rs:114:25\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpq0iwmjuu.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpq0iwmjuu.rs:115:25\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_len = interval1_end\
    \ - interval1_start;\n    let mut interval1_len = interval2_end - interval2_start;\n\
    \    let mut interval2_len = interval1_end - interval1_start;\n    while interval1_len\
    \ > 0 && interval2_len > 0 {\n        if interval1_start < interval2_start {\n\
    \            intersection_start = interval1_start;\n            intersection_len\
    \ = interval1_len;\n            interval1_len -= 1;\n        } else {\n      \
    \      intersection_start = interval2_start;\n            intersection_len = interval2_len;\n\
    \            interval2_len -= 1;\n        }\n        if intersection_end > interval1_end\
    \ {\n            intersection_end = interval1_end;\n            intersection_len\
    \ += 1;\n        } else {\n            intersection_end = interval2_end;\n   \
    \         intersection_len += 1;\n        }\n    }\n    if interval1_len > 0 {\n\
    \        intersection_start = interval1_start;\n        intersection_len = interval1_len;\n\
    \    }\n    if interval2_len > 0 {\n        intersection_end = interval2_end;\n\
    \        intersection_len += 1;\n    }\n    if intersection_len == 2 {\n     \
    \   if intersection_start == intersection_end {\n            return \"YES\";\n\
    \        } else {\n            return \"NO\";\n        }\n    } else {\n     \
    \   return \"NO\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:69:17\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi9ueqmh4.rs:69:25\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:70:17\n   |\n70 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:70:25\n\
    \   |\n70 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi9ueqmh4.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:71:25\n   |\n71 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi9ueqmh4.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:72:25\n   |\n72 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:73:17\n  \
    \ |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi9ueqmh4.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi9ueqmh4.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start <= interval1.end && interval2.start <= interval2.end\
    \ {\n        let mut interval = interval1;\n        interval.start = interval.end;\n\
    \        interval.end = interval.start;\n        interval = interval2;\n     \
    \   interval.start = interval.end;\n        interval.end = interval.start;\n \
    \       let mut intersection = interval;\n        let mut count = 0;\n       \
    \ while intersection.start <= intersection.end {\n            if intersection.start\
    \ == intersection.end {\n                count += 1;\n                intersection.start\
    \ += 1;\n                intersection.end += 1;\n            } else {\n      \
    \          intersection.start += 1;\n                intersection.end += 1;\n\
    \            }\n        }\n        if count % 2 == 0 {\n            return \"\
    YES\";\n        } else {\n            return \"NO\";\n        }\n    } else {\n\
    \        return \"NO\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqpqehf0z.rs:52:17\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqpqehf0z.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqpqehf0z.rs:53:17\n   |\n53 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqpqehf0z.rs:53:25\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqpqehf0z.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqpqehf0z.rs:54:25\n   |\n54 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqpqehf0z.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqpqehf0z.rs:55:25\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqpqehf0z.rs:56:17\n  \
    \ |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqpqehf0z.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqpqehf0z.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut interval1_prime\
    \ = true;\n    let mut interval2_prime = true;\n    \n    while interval1_len\
    \ > 0 && interval2_len > 0 {\n        if interval1_start < interval2_start {\n\
    \            interval1_start += interval1_len;\n            interval1_prime =\
    \ false;\n        } else {\n            interval2_start += interval2_len;\n  \
    \          interval2_prime = false;\n        }\n        interval1_len -= 1;\n\
    \        interval2_len -= 1;\n    }\n    \n    if interval1_len > 0 {\n      \
    \  interval1_start += interval1_len;\n        interval1_prime = false;\n    }\n\
    \    if interval2_len > 0 {\n        interval2_start += interval2_len;\n     \
    \   interval2_prime = false;\n    }\n    \n    if interval1_prime && interval2_prime\
    \ {\n        return \"YES\".to_string();\n    }\n    \n    if interval1_prime\
    \ && !interval2_prime {\n        return \"NO\".to_string();\n    }\n    \n   \
    \ if !interval1_prime && interval2_prime {\n        return \"NO\".to_string();\n\
    \    }\n    \n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmphw2gl6uk.rs:68:17\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphw2gl6uk.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphw2gl6uk.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphw2gl6uk.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphw2gl6uk.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphw2gl6uk.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphw2gl6uk.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphw2gl6uk.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphw2gl6uk.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphw2gl6uk.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphw2gl6uk.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start > interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end < interval2_start {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start == interval1_end {\n        return \"YES\";\n \
    \   }\n\n    if interval2_start == interval2_end {\n        return \"YES\";\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ > interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end > interval2_start {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start == interval1_end {\n        return \"YES\";\n \
    \   }\n\n    if interval2_start == interval2_end {\n        return \"YES\";\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ > interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end > interval2_start {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start == interval1_end {\n        return \"YES\";\n \
    \   }\n\n    if interval2_start == interval2_end {\n        return \"YES\";\n\
    \    }\n\n    if interval1_start < interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ > interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start < interval2_end {\n        return \"NO\";\n \
    \   }\n\n    if interval1_end > interval2_start {\n        return \"NO\";\n  \
    \  }\n\n    if interval1_start == interval1_end {\n        return \"YES\";\n \
    \   }\n\n    if interval2_start == interval2_end {\n        return \"YES\";\n\
    \    }\n\n    if interval1_start < interval2_start \n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp1nl8v508.rs:27:42\n   |\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp1nl8v508.rs:27:76\n   |\n26 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp1nl8v508.rs:26:26\n   |\n26 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n27 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n28 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n26 ~     if interval1_start\
    \ > (interval2_start {\n27 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n28 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp1nl8v508.rs:30:38\n   |\n30 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp1nl8v508.rs:30:68\n   |\n29 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n30 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp1nl8v508.rs:29:24\n   |\n29 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_length = interval1_end - interval1_start;\n\
    \    let mut interval2_length = interval2_end - interval2_start;\n    if interval1_end\
    \ > interval2_start {\n        interval1_start = interval2_end;\n        interval1_end\
    \ = interval2_start;\n        interval1_length = interval2_end - interval2_start;\n\
    \    }\n    if interval2_end > interval1_start {\n        interval2_start = interval1_end;\n\
    \        interval2_end = interval1_start;\n        interval2_length = interval1_end\
    \ - interval1_start;\n    }\n    if interval1_length == interval2_length {\n \
    \       if interval1_start <= interval2_start {\n            interval1_length\
    \ = interval2_end - interval2_start;\n        } else {\n            interval2_length\
    \ = interval1_end - interval1_start;\n        }\n    }\n    if interval1_length\
    \ == interval2_length {\n        if interval1_start <= interval2_start {\n   \
    \         interval1_length = interval2_end - interval2_start;\n        } else\
    \ {\n            interval2_length = interval1_end - interval1_start;\n       \
    \ }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n            interval2_length = interval1_end - interval1_start;\n\
    \        }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n            interval2_length = interval1_end - interval1_start;\n\
    \        }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n            interval2_length = interval1_end - interval1_start;\n\
    \        }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n            interval2_length = interval1_end - interval1_start;\n\
    \        }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n            interval2_length = interval1_end - interval1_start;\n\
    \        }\n    }\n    if interval1_length == interval2_length {\n        if interval1_start\
    \ <= interval2_start {\n            interval1_length = interval2_end - interval2_start;\n\
    \        } else {\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpipj_3rr2.rs:102:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n86  |     if interval1_length\
    \ == interval2_length {\n    |                                             - unclosed\
    \ delimiter\n...\n89  |         } else {\n    |                - this delimiter\
    \ might not be properly closed...\n90  | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n102 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpipj_3rr2.rs:94:17\n   |\n94 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpipj_3rr2.rs:94:25\n\
    \   |\n94 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpipj_3rr2.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpipj_3rr2.rs:95:25\n   |\n95 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpipj_3rr2.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpipj_3rr2.rs:96:25\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpipj_3rr2.rs:97:17\n  \
    \ |\n97 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpipj_3rr2.rs:97:25\n   |\n97 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ n"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start > interval2_end {\n        return \"NO\";\n \
    \   }\n    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n\
    \n    if interval1_start == interval1_end {\n        return \"NO\";\n    }\n\n\
    \    if interval1_start < interval2_start {\n        return \"NO\";\n    }\n\n\
    \    if interval1_end > interval2_end {\n        return \"NO\";\n    }\n\n   \
    \ if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n   \
    \ if interval1_end > interval2_start {\n        return \"YES\";\n    }\n\n   \
    \ if interval1_start == interval2_start {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end == interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_end > interval2_start {\n        return \"YES\";\n    }\n\n \
    \   if interval1_start == interval2_end {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end == interval2_start {\n        return \"YES\";\n    }\n\n\
    \    if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end > interval2_end {\n        return \"YES\";\n    }\n\n  \
    \  if interval1_start == interval2_start {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end == interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_end > interval2_start {\n        return \"YES\";\n    }\n\n \
    \   if interval1_start == interval2_end {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end == interval2_start {\n        return \"YES\";\n    }\n\n\
    \    if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end > interval2_end {\n        return \"YES\";\n    }\n\n  \
    \  if interval1_start == interval2_start {\n        return \"YES\";\n    }\n\n\
    \    if interval1_end == interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\n \
    \   if interval1_end \n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmp870qqw4p.rs:27:42\n   |\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmp870qqw4p.rs:27:76\n   |\n26 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmp870qqw4p.rs:26:26\n   |\n26 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n27 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n28 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n26 ~     if interval1_start\
    \ > (interval2_start {\n27 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n28 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmp870qqw4p.rs:30:38\n   |\n30 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmp870qqw4p.rs:30:68\n   |\n29 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n30 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmp870qqw4p.rs:29:24\n   |\n29 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    let mut interval1_length\
    \ = interval1_end - interval1_start;\n    let mut interval2_length = interval2_end\
    \ - interval2_start;\n    while interval1_start <= interval1_end && interval2_start\
    \ <= interval2_end {\n        if interval1_start < interval1_end {\n         \
    \   if interval2_start < interval2_end {\n                if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n                    intersection_length\
    \ += 1;\n                }\n            }\n            interval1_start += 1;\n\
    \        }\n        if interval2_start < interval2_end {\n            interval2_start\
    \ += 1;\n        }\n    }\n    if interval1_start > interval1_end {\n        interval1_length\
    \ = interval1_end - interval1_start;\n    }\n    if interval2_start > interval2_end\
    \ {\n        interval2_length = interval2_end - interval2_start;\n    }\n    if\
    \ intersection_length == 0 {\n        return \"NO\";\n    }\n    if interval1_length\
    \ == interval2_length {\n        return \"YES\";\n    }\n    if interval1_length\
    \ < interval2_length {\n        return \"NO\";\n    }\n    return \"YES\";\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpipg6sb0e.rs:61:17\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpipg6sb0e.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpipg6sb0e.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpipg6sb0e.rs:62:25\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpipg6sb0e.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpipg6sb0e.rs:63:25\n   |\n63 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpipg6sb0e.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpipg6sb0e.rs:64:25\n   |\n64 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpipg6sb0e.rs:65:17\n  \
    \ |\n65 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpipg6sb0e.rs:65:25\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpipg6sb0e.rs:66:17\n   |\n66 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start == interval1_end {\n        if\
    \ interval2_start == interval2_end {\n            return String::from(\"YES\"\
    );\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_start\
    \ < interval2_start {\n        return String::from(\"NO\");\n    }\n    if interval1_end\
    \ > interval2_end {\n        return String::from(\"NO\");\n    }\n    let mut\
    \ interval1_length = interval1_end - interval1_start + 1;\n    let mut interval2_length\
    \ = interval2_end - interval2_start + 1;\n    if interval1_length > interval2_length\
    \ {\n        interval1_length = interval2_length;\n    }\n    if interval1_length\
    \ == 2 {\n        if interval1_start == interval1_end {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_length\
    \ == 3 {\n        if interval1_start == interval1_end {\n            return String::from(\"\
    YES\");\n        }\n        if interval2_start == interval2_end {\n          \
    \  return String::from(\"YES\");\n        }\n        return String::from(\"NO\"\
    );\n    }\n    if interval1_length == 4 {\n        if interval1_start == interval1_end\
    \ {\n            return String::from(\"YES\");\n        }\n        if interval2_start\
    \ == interval2_end {\n            return String::from(\"YES\");\n        }\n \
    \       if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_length\
    \ == 5 {\n        if interval1_start == interval1_end {\n            return String::from(\"\
    YES\");\n        }\n        if interval2_start == interval2_end {\n          \
    \  return String::from(\"YES\");\n        }\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        if interval2_\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx49sabvr.rs:104:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n81  |     if interval1_length\
    \ == 5 {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n92  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n104 | }\n    |   ^\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpx49sabvr.rs:26:40\n   |\n26 |         interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n   |                                    \
    \   -^\n   |                                       |\n   |                   \
    \                    help: replace equals symbol with a colon: `:`\n\nerror: expected\
    \ one of `,` or `}`, found `;`\n  --> /tmp/tmpx49sabvr.rs:20:81\n   |\n20 | fn\
    \ intersection(interval1: (isize, isize), interval2: (isize, isize)) -> String\
    \ {\n   |                                                                    \
    \             ^ unclosed delimiter\n...\n25 |     if interval1_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                                                        ^\n\
    \   |                                                                        |\n\
    \   |                                                                        expected\
    \ one of `,` or `}`\n   |                                                    \
    \                    help: `}` may belong here\n\nerror: struct literals are not\
    \ allowed here\n  --> /tmp/tmpx49sabvr.rs:25:26\n   |\n25 |       if interval1_start\
    \ > interval2_end {\n   |  __________________________^\n26 | |         interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n27 | |     }\n   | |_____^\n\
    \   |\nhelp: surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_end {\n26 |"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            let mut result = String::from(\"\
    NO\");\n            for i in interval1.iter() {\n                if i == interval2[0]\
    \ {\n                    result.push_str(\"YES\");\n                    break;\n\
    \                }\n            }\n            return result;\n        }\n   \
    \     let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[1] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[1] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[0] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[1] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[0] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[1] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[0] {\n                result.push_str(\"YES\"\
    );\n                break;\n            }\n        }\n        return result;\n\
    \    }\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1] {\n\
    \        let mut result = String::from(\"NO\");\n        for i in interval1.iter()\
    \ {\n            if i == interval2[1]\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp98lwvmfk.rs:117:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n101 |     if interval1[0]\
    \ < interval1[1] && interval2[0] < interval2[1] {\n    |                     \
    \                                              - unclosed delimiter\n102 |   \
    \      let mut result = String::from(\"NO\");\n103 |         for i in interval1.iter()\
    \ {\n    |                                   - this delimiter might not be properly\
    \ closed...\n104 |             if i == interval2[1]\n105 | }\n    | - ...as it\
    \ matches this but it has different indentation\n...\n117 | }\n    |   ^\n\nerror:\
    \ expected `{`, found `}`\n   --> /tmp/tmp98lwvmfk.rs:105:1\n    |\n104 |    \
    \         if i == interval2[1]\n    |             -- this `if` expression has\
    \ a condition, but no block\n105 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp98lwvmfk.rs:109:17\n    |\n\
    109 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp98lwvmfk.rs:109:25\n    |\n109 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp98lwvmfk.rs:110:17\n\
    \    |\n110 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp98lwvmfk.rs:110:25\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp98lwvmfk.rs:111:17\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp98lwvmfk.rs:111:25\n    |\n111 |     assert_eq!({left}, {right"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n\n    if interval1_start > interval2_end {\n      \
    \  interval1_end = interval2_end;\n    }\n\n    if interval1_end < interval2_start\
    \ {\n        interval1_start = interval2_start;\n    }\n\n    if interval1_start\
    \ == interval1_end {\n        return \"NO\";\n    }\n\n    if interval1_start\
    \ < interval2_start {\n        return \"NO\";\n    }\n\n    if interval1_end >\
    \ interval2_end {\n        return \"NO\";\n    }\n\n    if interval1_end == interval2_end\
    \ {\n        return \"NO\";\n    }\n\n    if interval1_start < interval2_end {\n\
    \        return \"YES\";\n    }\n\n    if interval1_end > interval2_end {\n  \
    \      return \"YES\";\n    }\n\n    if interval1_end == interval2_end {\n   \
    \     return \"YES\";\n    }\n\n    if interval1_start == interval2_start {\n\
    \        return \"YES\";\n    }\n\n    if interval1_end < interval2_end {\n  \
    \      return \"YES\";\n    }\n\n    if interval1_end == interval2_end {\n   \
    \     return \"YES\";\n    }\n\n    if interval1_end > interval2_end {\n     \
    \   return \"YES\";\n    }\n\n    return \"YES\";\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptvui8ezc.rs:90:17\n\
    \   |\n90 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptvui8ezc.rs:90:25\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptvui8ezc.rs:91:17\n   |\n91 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptvui8ezc.rs:91:25\n\
    \   |\n91 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptvui8ezc.rs:92:17\n   |\n92 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptvui8ezc.rs:92:25\n   |\n92 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptvui8ezc.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptvui8ezc.rs:93:25\n   |\n93 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptvui8ezc.rs:94:17\n  \
    \ |\n94 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptvui8ezc.rs:94:25\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptvui8ezc.rs:95:17\n   |\n95 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            let mut start = interval1[0];\n\
    \            let mut end = interval1[1];\n            while start < end {\n  \
    \              let mut start = interval2[0];\n                let mut end = interval2[1];\n\
    \                while start < end {\n                    if start == end {\n\
    \                        break;\n                    }\n                    start\
    \ += 1;\n                    end += 1;\n                }\n                if\
    \ start == end {\n                    break;\n                }\n            \
    \    start += 1;\n                end += 1;\n            }\n            if start\
    \ == end {\n                return String::from(\"YES\");\n            }\n   \
    \     }\n    }\n    String::from(\"NO\")\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpnc0eso0r.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnc0eso0r.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnc0eso0r.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnc0eso0r.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnc0eso0r.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnc0eso0r.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnc0eso0r.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnc0eso0r.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnc0eso0r.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnc0eso0r.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnc0eso0r.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_len = interval1.1;\n    let mut interval_start\
    \ = interval1.0;\n    let mut interval_end = interval2.0;\n    let mut interval_len\
    \ = interval_len - 1;\n    let mut interval_start = interval_start - 1;\n    let\
    \ mut interval_end = interval_end - 1;\n    let mut interval_len = interval_len\
    \ - 1;\n    let mut interval_start = interval_start - 1;\n    let mut interval_end\
    \ = interval_end - 1;\n    let mut interval_len = interval_len - 1;\n    let mut\
    \ interval_start = interval_start - 1;\n    let mut interval_end = interval_end\
    \ - 1;\n    let mut interval_len = interval_len - 1;\n    let mut interval_start\
    \ = interval_start - 1;\n    let mut interval_end = interval_end - 1;\n    let\
    \ mut interval_len = interval_len - 1;\n    let mut interval_start = interval_start\
    \ - 1;\n    let mut interval_end = interval_end - 1;\n    let mut interval_len\
    \ = interval_len - 1;\n    let mut interval_start = interval_start - 1;\n    let\
    \ mut interval_end = interval_end - 1;\n    let mut interval_len = interval_len\
    \ - 1;\n    let mut interval_start = interval_start - 1;\n    let mut interval_end\
    \ = interval_end - 1;\n    let mut interval_len = interval_len - 1;\n    let mut\
    \ interval_start = interval_start - 1;\n    let mut interval_end = interval_end\
    \ - 1;\n    let mut interval_len = interval_len - 1;\n    let mut interval_start\
    \ = interval_start - 1;\n    let mut interval_end = interval_end - 1;\n    let\
    \ mut interval_len = interval_len - 1;\n    let mut interval_start = interval_start\
    \ - 1;\n    let mut interval_end = interval_end - 1;\n    let mut interval_len\
    \ = interval_len - 1;\n    let mut interval_start = interval_start - 1;\n    let\
    \ mut interval_end = interval_end - 1;\n    let mut interval_len = interval_len\
    \ - 1;\n    let mut interval_start = interval_start - 1;\n    let mut interval_end\
    \ = interval_end - 1;\n    let mut interval_len = interval_len - 1;\n    let mut\
    \ interval_start = interval_start - 1;\n    let mut interval_end = interval_end\
    \ - 1;\n    let mut interval_len = interval_len - 1;\n    let mut interval_start\
    \ = interval_start - 1;\n    let mut interval_end = interval_end - 1;\n    let\
    \ mut interval_len = \n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpui649per.rs:67:1\n\
    \   |\n67 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpui649per.rs:71:17\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpui649per.rs:71:25\n \
    \  |\n71 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpui649per.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpui649per.rs:72:25\n   |\n72 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpui649per.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpui649per.rs:73:25\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpui649per.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpui649per.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpui649per.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpui649per.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpui649per.rs:76:17\n   |\n76 |     "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    if interval1[0] > interval2[0] {\n        interval = interval2;\n       \
    \ interval2 = interval1;\n    }\n    let mut intersection = interval1;\n    if\
    \ interval1[1] < interval2[1] {\n        intersection = interval2;\n    }\n  \
    \  if intersection[0] == intersection[1] {\n        return \"NO\";\n    }\n  \
    \  let mut prime = true;\n    for i in 1..=intersection[0] {\n        if interval[0]\
    \ % i == 0 || interval[1] % i == 0 {\n            prime = false;\n           \
    \ break;\n        }\n    }\n    if prime {\n        return \"YES\";\n    }\n \
    \   return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp90rfdcd_.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp90rfdcd_.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp90rfdcd_.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp90rfdcd_.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp90rfdcd_.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp90rfdcd_.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp90rfdcd_.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp90rfdcd_.rs:52:25\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp90rfdcd_.rs:53:17\n  \
    \ |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp90rfdcd_.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp90rfdcd_.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start <= interval2_end {\n        if interval1_end\
    \ < interval2_start {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_end == interval2_end {\n   \
    \         if interval1_start == interval2_start {\n                return String::from(\"\
    YES\");\n            }\n            return String::from(\"NO\");\n        }\n\
    \        if interval1_end > interval2_end {\n            interval1_end, interval2_end\
    \ = interval2_end, interval1_end;\n        }\n        if interval1_start < interval2_start\
    \ {\n            interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \        }\n        if interval1_start == interval2_start {\n            if interval1_end\
    \ == interval2_end {\n                return String::from(\"YES\");\n        \
    \    }\n            return String::from(\"NO\");\n        }\n        if interval1_start\
    \ > interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end < interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n        if interval1_end == interval2_end {\n            if interval1_start\
    \ == interval2_start {\n                return String::from(\"YES\");\n      \
    \      }\n            return String::from(\"NO\");\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start < interval2_start {\n\
    \            interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \        }\n        if interval1_start == interval2_start {\n            if interval1_end\
    \ == interval2_end {\n                return String::from(\"YES\");\n        \
    \    }\n            return String::from(\"NO\");\n        }\n        if interval1_start\
    \ > interval2_start {\n            interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n        }\n        if interval1_end < interval2_end {\n  \
    \          interval1_end, interval2_end = interval2_end, interval1_end;\n    \
    \    }\n        if interval1_end == interval2_end {\n            if interval1_start\
    \ == interval\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmph_yj4e_8.rs:100:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n34  |     if interval1_start\
    \ <= interval2_end {\n    |                                         - unclosed\
    \ delimiter\n...\n86  |         if interval1_end == interval2_end {\n    |   \
    \                                        - this delimiter might not be properly\
    \ closed...\n87  |             if interval1_start == interval\n88  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n100 | }\n   \
    \ |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmph_yj4e_8.rs:27:42\n \
    \  |\n27 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmph_yj4e_8.rs:20:81\n   |\n20 | fn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n   |               \
    \                                                                  ^ unclosed\
    \ delimiter\n...\n26 |     if interval1_start > interval2_start {\n   |      \
    \                    --------------- while parsing this struct\n27 |         interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n   |                  \
    \                                                          ^\n   |           \
    \                                                                 |\n   |    \
    \                                                                        expected\
    \ one of `,` or `}`\n   |                                                    \
    \                        help: `}` may belong here\n\nerror: struct literals are\
    \ not allowed here\n  --> /tmp/tmph_yj4e_8.rs:26:26\n   |\n26 |       if interval1_start\
    \ > interval2_start {\n   |  ____________________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    let mut intersection = interval1;\n    let mut interval_len = interval1.1;\n\
    \    let mut interval2_len = interval2.1;\n    let mut prime = true;\n    loop\
    \ {\n        if interval_len > interval2_len {\n            interval = interval2;\n\
    \            interval_len = interval2.1;\n        } else {\n            interval\
    \ = interval1;\n            interval_len = interval1.1;\n        }\n        if\
    \ interval_len == interval2_len {\n            if interval[0] < interval[1] {\n\
    \                prime = false;\n            }\n        }\n        if prime {\n\
    \            intersection = interval;\n            break;\n        }\n    }\n\
    \    if prime {\n        String::from(\"YES\")\n    } else {\n        String::from(\"\
    NO\")\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp0e63ye_6.rs:54:17\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0e63ye_6.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0e63ye_6.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp0e63ye_6.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp0e63ye_6.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp0e63ye_6.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp0e63ye_6.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp0e63ye_6.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp0e63ye_6.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp0e63ye_6.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp0e63ye_6.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut intersection = interval1;\n  \
    \  intersection[0] = min(interval1[0], interval2[0]);\n    intersection[1] = max(interval1[1],\
    \ interval2[1]);\n    if intersection[0] >= intersection[1] {\n        return\
    \ \"NO\";\n    }\n    let mut prime = true;\n    for i in 1..=interval1[0] {\n\
    \        if interval1[1] % i == 0 {\n            prime = false;\n        }\n \
    \   }\n    for i in 1..=interval2[0] {\n        if interval2[1] % i == 0 {\n \
    \           prime = false;\n        }\n    }\n    if prime {\n        return \"\
    YES\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpoq9k93kk.rs:25:23\n\
    \   |\n25 |     intersection[0] = min(interval1[0], interval2[0]);\n   |     \
    \                  ^^^\n...\n47 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n25 |     intersection[0] = main(interval1[0], interval2[0]);\n   |    \
    \                   ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this scope\n\
    \  --> /tmp/tmpoq9k93kk.rs:26:23\n   |\n26 |     intersection[1] = max(interval1[1],\
    \ interval2[1]);\n   |                       ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpoq9k93kk.rs:49:17\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoq9k93kk.rs:49:25\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoq9k93kk.rs:50:17\n   |\n50 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoq9k93kk.rs:50:25\n\
    \   |\n50 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoq9k93kk.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoq9k93kk.rs:51:25\n   |\n51 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoq9k93kk.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this s"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start < interval1_end {\n        return \"NO\".to_string();\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ < interval2_end {\n            return \"YES\".to_string();\n        }\n    \
    \    return \"NO\".to_string();\n    }\n    if interval2_start < interval2_end\
    \ {\n        return \"NO\".to_string();\n    }\n    return \"YES\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpvvqxbprz.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpvvqxbprz.rs:26:72\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpvvqxbprz.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval2_start, interval1_end;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval2_start\
    \ {\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpvvqxbprz.rs:29:40\n\
    \   |\n29 |         interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpvvqxbprz.rs:29:72\n   |\n28 |     if interval1_end < interval2_end\
    \ {\n   |                        ------------- while parsing this struct\n29 |\
    \         interval1_end, interval1_start = interval2_end, interval1_start;\n \
    \  |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpvvqxbprz.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut prime_numbers = Vec::new();\n    let mut prime_numbers_length\
    \ = prime_numbers.len();\n    let mut prime_numbers_counter = 0;\n    let mut\
    \ prime_numbers_counter2 = 0;\n    let mut prime_numbers_counter3 = 0;\n    let\
    \ mut prime_numbers_counter4 = 0;\n    let mut prime_numbers_counter5 = 0;\n \
    \   let mut prime_numbers_counter6 = 0;\n    let mut prime_numbers_counter7 =\
    \ 0;\n    let mut prime_numbers_counter8 = 0;\n    let mut prime_numbers_counter9\
    \ = 0;\n    let mut prime_numbers_counter10 = 0;\n    let mut prime_numbers_counter11\
    \ = 0;\n    let mut prime_numbers_counter12 = 0;\n    let mut prime_numbers_counter13\
    \ = 0;\n    let mut prime_numbers_counter14 = 0;\n    let mut prime_numbers_counter15\
    \ = 0;\n    let mut prime_numbers_counter16 = 0;\n    let mut prime_numbers_counter17\
    \ = 0;\n    let mut prime_numbers_counter18 = 0;\n    let mut prime_numbers_counter19\
    \ = 0;\n    let mut prime_numbers_counter20 = 0;\n    let mut prime_numbers_counter21\
    \ = 0;\n    let mut prime_numbers_counter22 = 0;\n    let mut prime_numbers_counter23\
    \ = 0;\n    let mut prime_numbers_counter24 = 0;\n    let mut prime_numbers_counter25\
    \ = 0;\n    let mut prime_numbers_counter26 = 0;\n    let mut prime_numbers_counter27\
    \ = 0;\n    let mut prime_numbers_counter28 = 0;\n    let mut prime_numbers_counter29\
    \ = 0;\n    let mut prime_numbers_counter30 = 0;\n    let mut prime_numbers_counter31\
    \ = 0;\n    let mut prime_numbers_counter32 = 0;\n    let mut prime_numbers_counter33\
    \ = 0;\n    let mut prime_numbers_counter34 = 0;\n    let mut prime_numbers_counter35\
    \ = 0;\n    let mut prime_numbers_counter36 = 0;\n    let mut prime_numbers_counter37\
    \ = 0;\n    let mut prime_numbers_counter38 = 0;\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:72:17\n\
    \   |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzcl2ua3m.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzcl2ua3m.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzcl2ua3m.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzcl2ua3m.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzcl2ua3m.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut len = 0;\n    let mut start =\
    \ interval1[0];\n    let mut end = interval1[1];\n    while start < interval1[1]\
    \ && end < interval2[1] {\n        if start < end {\n            len += 1;\n \
    \       }\n        start += 1;\n        end += 1;\n    }\n    if len == 2 {\n\
    \        if start == end {\n            return \"YES\";\n        }\n        if\
    \ start == interval1[1] {\n            return \"YES\";\n        }\n        if\
    \ end == interval2[1] {\n            return \"YES\";\n        }\n    }\n    if\
    \ len % 2 == 0 {\n        return \"NO\";\n    }\n    if len == 1 {\n        return\
    \ \"YES\";\n    }\n    if len == 0 {\n        return \"NO\";\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:58:17\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeuo5ac3k.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpeuo5ac3k.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpeuo5ac3k.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:61:25\n   |\n61 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:62:17\n  \
    \ |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeuo5ac3k.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeuo5ac3k.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval2_start = interval1_start;\n    }\n    if\
    \ interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_start > interval2_start\
    \ {\n        interval1_start = interval2_start;\n    }\n    if interval1_end <\
    \ interval2_end {\n        interval1_end = interval2_end;\n    }\n    if interval1_start\
    \ == interval1_end {\n        if interval2_start == interval2_end {\n        \
    \    return \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_start\
    \ < interval2_start {\n        return \"NO\";\n    }\n    if interval1_end > interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start < interval2_end {\n\
    \        return \"YES\";\n    }\n    if interval1_end > interval2_end {\n    \
    \    return \"YES\";\n    }\n    if interval1_start == interval1_end {\n     \
    \   if interval2_start == interval2_end {\n            return \"YES\";\n     \
    \   }\n        return \"NO\";\n    }\n    if interval1_start < interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_end > interval2_end {\n \
    \       return \"NO\";\n    }\n    if interval1_start < interval2_end {\n    \
    \    return \"YES\";\n    }\n    if interval1_end > interval2_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return \"YES\";\n        }\n        return \"\
    NO\";\n    }\n    if interval1_start < interval2_start {\n        return \"NO\"\
    ;\n    }\n    if interval1_end > interval2_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_start < interval2_end {\n        return \"YES\";\n    }\n\
    \    if interval1_end > interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_start == interval1_end {\n        if interval2_start == interval2_end\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval1_start < interval2_start {\n        return \"NO\";\n    }\n  \
    \  if interval1_end > interval2_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ < interval2_end {\n        return \"YES\";\n    }\n    if interval1_end > interval2_end\
    \ \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpv53w02na.rs:109:1\n    |\n\
    108 |     if interval1_end > interval2_end \n    |     -- this `if` expression\
    \ has a condition, but no block\n109 | }\n    | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpv53w02na.rs:113:17\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpv53w02na.rs:113:25\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpv53w02na.rs:114:17\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpv53w02na.rs:114:25\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpv53w02na.rs:115:17\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpv53w02na.rs:115:25\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpv53w02na.rs:116:17\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpv53w02na.rs:116:25\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpv53w02na.rs:117:17\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpv53w02na.rs:117:25\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |      "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_1 = interval1.0;\n    let mut interval_2 =\
    \ interval2.0;\n    let mut interval_3 = interval1.0;\n    let mut interval_4\
    \ = interval2.0;\n    let mut interval_5 = interval1.0;\n    let mut interval_6\
    \ = interval2.0;\n    let mut interval_7 = interval1.0;\n    let mut interval_8\
    \ = interval2.0;\n    let mut interval_9 = interval1.0;\n    let mut interval_10\
    \ = interval2.0;\n    let mut interval_11 = interval1.0;\n    let mut interval_12\
    \ = interval2.0;\n    let mut interval_13 = interval1.0;\n    let mut interval_14\
    \ = interval2.0;\n    let mut interval_15 = interval1.0;\n    let mut interval_16\
    \ = interval2.0;\n    let mut interval_17 = interval1.0;\n    let mut interval_18\
    \ = interval2.0;\n    let mut interval_19 = interval1.0;\n    let mut interval_20\
    \ = interval2.0;\n    let mut interval_21 = interval1.0;\n    let mut interval_22\
    \ = interval2.0;\n    let mut interval_23 = interval1.0;\n    let mut interval_24\
    \ = interval2.0;\n    let mut interval_25 = interval1.0;\n    let mut interval_26\
    \ = interval2.0;\n    let mut interval_27 = interval1.0;\n    let mut interval_28\
    \ = interval2.0;\n    let mut interval_29 = interval1.0;\n    let mut interval_30\
    \ = interval2.0;\n    let mut interval_31 = interval1.0;\n    let mut interval_32\
    \ = interval2.0;\n    let mut interval_33 = interval1.0;\n    let mut interval_34\
    \ = interval2.0;\n    let mut interval_35 = interval1.0;\n    let mut interval_36\
    \ = interval2.0;\n    let mut interval_37 = interval1.0;\n    let mut interval_38\
    \ = interval2.0;\n    let mut interval_39 = interval1.0;\n    let mut interval_40\
    \ = interval2.0;\n    let mut interval_41 = interval1.0;\n    let mut interval_42\
    \ = interval2.0;\n    let mut interval_43 = interval1.0;\n    let mut interval_44\
    \ = interval2.0;\n    let mut interval_45 = interval1.0;\n    let mut interval_46\
    \ = interval2.0;\n    let mut interval_47 = interval1.0;\n    let mut interval_48\
    \ = interval2.0;\n    let mu\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_jbyrtoe.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:74:17\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_jbyrtoe.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_jbyrtoe.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_jbyrtoe.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  -"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_len = interval1_end\
    \ - interval1_start;\n    let mut interval1_len = interval2_end - interval2_start;\n\
    \    let mut interval2_len = interval1_end - interval1_start;\n    let mut prime_found\
    \ = false;\n    \n    while interval1_len > 0 || interval2_len > 0 {\n       \
    \ if interval1_len > 0 {\n            if interval1_start >= interval2_start {\n\
    \                interval1_start -= interval2_start;\n                interval1_len\
    \ -= interval2_len;\n            } else {\n                interval1_len -= interval2_len;\n\
    \            }\n        }\n        if interval2_len > 0 {\n            if interval2_start\
    \ >= interval1_start {\n                interval2_start -= interval1_start;\n\
    \                interval2_len -= interval1_len;\n            } else {\n     \
    \           interval2_len -= interval1_len;\n            }\n        }\n      \
    \  if interval1_len == 0 && interval2_len == 0 {\n            break;\n       \
    \ }\n        if interval1_len == 0 {\n            interval1_start = intersection_start;\n\
    \            interval1_end = intersection_end;\n            interval1_len = intersection_len;\n\
    \            prime_found = true;\n            break;\n        }\n        if interval2_len\
    \ == 0 {\n            interval2_start = intersection_start;\n            interval2_end\
    \ = intersection_end;\n            interval2_len = intersection_len;\n       \
    \     prime_found = true;\n            break;\n        }\n        if interval1_start\
    \ >= interval2_start {\n            intersection_start -= interval1_start;\n \
    \           intersection_end -= interval1_start;\n            intersection_len\
    \ -= interval1_len;\n        } else {\n            intersection_start -= interval2_start;\n\
    \            intersection_end -= interval2_start;\n            intersection_len\
    \ -= interval2_len;\n        }\n    }\n    if prime_found {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5c7bikay.rs:85:17\n\
    \   |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5c7bikay.rs:85:25\n   |\n85 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5c7bikay.rs:86:17\n   |\n86 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5c7bikay.rs:86:25\n\
    \   |\n86 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5c7bikay.rs:87:17\n   |\n87 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5c7bikay.rs:87:25\n   |\n87 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5c7bikay.rs:88:17\n   |\n88 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5c7bikay.rs:88:25\n   |\n88 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5c7bikay.rs:89:17\n  \
    \ |\n89 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5c7bikay.rs:89:25\n   |\n89 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5c7bikay.rs:90:17\n   |\n90 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    let mut intersection_length = interval1_end\
    \ - interval1_start;\n    let mut interval1_length = interval2_end - interval2_start;\n\
    \    let mut interval2_length = interval1_end - interval1_start;\n    if interval1_start\
    \ > interval2_start {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n        interval1_length = interval2_end - interval2_start;\n\
    \    }\n    if interval1_end > interval2_end {\n        interval1_length = interval2_end\
    \ - interval2_start;\n        interval2_start = interval1_start;\n        interval2_end\
    \ = interval1_end;\n    }\n    if interval1_length > interval2_length {\n    \
    \    interval1_length = interval2_length;\n        interval2_start = interval1_start;\n\
    \        interval2_end = interval1_end;\n    }\n    if interval1_length == 0 {\n\
    \        return \"NO\";\n    }\n    if interval2_length == 0 {\n        return\
    \ \"NO\";\n    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            if interval1_length == 1 {\n               \
    \ return \"YES\";\n            }\n            return \"NO\";\n        }\n    \
    \    return \"NO\";\n    }\n    if interval2_start == interval2_end {\n      \
    \  return \"NO\";\n    }\n    if interval1_length == 1 {\n        if interval2_length\
    \ == 1 {\n            return \"YES\";\n        }\n        return \"NO\";\n   \
    \ }\n    if interval2_length == 1 {\n        return \"NO\";\n    }\n    if interval1_length\
    \ == 2 {\n        if interval2_length == 2 {\n            return \"YES\";\n  \
    \      }\n        return \"NO\";\n    }\n    if interval2_length == 2 {\n    \
    \    return \"NO\";\n    }\n    if interval1_length == 3 {\n        if interval2_length\
    \ == 3 {\n            return \"YES\";\n        }\n        return \"NO\";\n   \
    \ }\n    if interval2_length == 3 {\n        return \"NO\";\n    }\n    if interval1_length\
    \ == 4 {\n        if interval2_length == 4 {\n            return \"YES\";\n  \
    \      }\n        return \"NO\";\n    }\n    if interval2_length == 4 {\n    \
    \    return \"NO\";\n    }\n    if interval1_length == 5 {\n        if interval2_length\
    \ == 5 {\n            return \"YES\";\n        }\n        return \"NO\";\n   \
    \ }\n    if interval2_length == 5 {\n        return \"NO\";\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpq59dv0nr.rs:122:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n108 |     if interval2_length\
    \ == 5 {\n    |                              - this delimiter might not be properly\
    \ closed...\n109 |         return \"NO\";\n110 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n122 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmpq59dv0nr.rs:114:17\n    |\n\
    114 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmpq59dv0nr.rs:114:25\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpq59dv0nr.rs:115:17\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpq59dv0nr.rs:115:25\n    |\n115 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpq59dv0nr.rs:116:17\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpq59dv0nr.rs:116:25\n    |\n116 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpq59dv0nr.rs:117:17\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpq59dv0nr.rs:117:25\n    |\n117 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] >= interval1[1] || interval2[0] >= interval2[1]\
    \ {\n        return \"NO\";\n    }\n    let mut interval = interval1;\n    let\
    \ mut interval2 = interval2;\n    let mut length = 0;\n    while interval[0] <\
    \ interval1[1] && interval2[0] < interval2[1] {\n        if interval[0] < interval2[0]\
    \ {\n            interval[0] = interval2[0];\n        } else {\n            interval[1]\
    \ = interval2[1];\n        }\n        length += 1;\n        interval = interval1;\n\
    \        interval2 = interval2;\n    }\n    if interval[0] >= interval1[1] ||\
    \ interval2[0] >= interval2[1] {\n        return \"NO\";\n    }\n    if length\
    \ == 1 {\n        return \"YES\";\n    }\n    if length == 2 {\n        return\
    \ \"YES\";\n    }\n    if length == 3 {\n        return \"YES\";\n    }\n    if\
    \ length == 4 {\n        return \"YES\";\n    }\n    if length == 5 {\n      \
    \  return \"YES\";\n    }\n    if length == 6 {\n        return \"YES\";\n   \
    \ }\n    if length == 7 {\n        return \"YES\";\n    }\n    if length == 8\
    \ {\n        return \"YES\";\n    }\n    if length == 9 {\n        return \"YES\"\
    ;\n    }\n    if length == 10 {\n        return \"YES\";\n    }\n    if length\
    \ == 11 {\n        return \"YES\";\n    }\n    if length == 12 {\n        return\
    \ \"YES\";\n    }\n    if length == 13 {\n        return \"YES\";\n    }\n   \
    \ if length == 14 {\n        return \"YES\";\n    }\n    if length == 15 {\n \
    \       return \"YES\";\n    }\n    if length == 16 {\n        return \"YES\"\
    ;\n    }\n    if length == 17 {\n        return \"YES\";\n    }\n    if length\
    \ == 18 {\n        return \"YES\";\n    }\n    if length == 19 {\n        return\
    \ \"YES\";\n    }\n    if length == 20 {\n        return \"YES\";\n    }\n   \
    \ if length == 21 {\n        return \"YES\";\n    }\n    if length == 22 {\n \
    \       return \"YES\";\n    }\n    if length == 100 {\n        return \"YES\"\
    ;\n    }\n    if length == 200 {\n        return \"YES\";\n    }\n    if length\
    \ == 300 {\n        return \"YES\";\n    }\n    if length == 400 {\n        return\
    \ \"YES\";\n    }\n    if length == 500 {\n        return \"YES\";\n    }\n  \
    \  if length == 600 {\n        return \"YES\";\n    }\n    if length == 700 {\n\
    \        return \"YES\";\n    }\n    if length == 800 {\n        return \"YES\"\
    ;\n    }\n    if length == 900 {\n        return \"YES\";\n    }\n    if length\
    \ == 1000 {\n        return \"YES\";\n    }\n    if length == 2000 {\n       \
    \ return \"YES\";\n\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpw0qzhuz6.rs:151:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n136 |     if length == 2000\
    \ {\n    |                       - this delimiter might not be properly closed...\n\
    ...\n139 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n151 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpw0qzhuz6.rs:143:17\n    |\n143 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpw0qzhuz6.rs:143:25\n    |\n143 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpw0qzhuz6.rs:144:17\n    |\n144 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpw0qzhuz6.rs:144:25\n    |\n144 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpw0qzhuz6.rs:145:17\n    |\n145 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpw0qzhuz6.rs:145:25\n    |\n145 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpw0qzhuz6.rs:146:17\n    |\n146 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpw0qzhuz6.rs:146:25\n    |\n146 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in thi"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_end {\n        interval1_end\
    \ = interval2_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_end\
    \ = interval2_start;\n    }\n    if interval1_end < interval2_start {\n      \
    \  interval1_start = interval2_end;\n    }\n    if interval1_start == interval1_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start > interval2_end {\n\
    \        return \"NO\";\n    }\n    if interval1_end < interval2_start {\n   \
    \     return \"NO\";\n    }\n    if interval1_start == interval2_start {\n   \
    \     return \"YES\";\n    }\n    if interval1_start == interval2_end {\n    \
    \    return \"YES\";\n    }\n    if interval1_end == interval2_end {\n       \
    \ return \"YES\";\n    }\n    if interval1_start < interval2_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_end > interval2_start {\n        return \"\
    YES\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmest7n35.rs:66:17\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmest7n35.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmest7n35.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmest7n35.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmest7n35.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmest7n35.rs:68:25\n   |\n68 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmest7n35.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmest7n35.rs:69:25\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmest7n35.rs:70:17\n  \
    \ |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmest7n35.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmest7n35.rs:71:17\n   |\n71 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start > interval2_end {\n        interval1_start,\
    \ interval1_end = interval2_end, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_start {\n        interval1_end, interval1_start = interval2_start,\
    \ interval1_end;\n    }\n    if interval1_start \n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpjmg1dk1b.rs:26:40\n   |\n\
    26 |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpjmg1dk1b.rs:26:72\n   |\n25 |     if interval1_start > interval2_end\
    \ {\n   |                          ------------- while parsing this struct\n26\
    \ |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpjmg1dk1b.rs:25:26\n   |\n25 |       if interval1_start > interval2_end\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval1_end\
    \ = interval2_end, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp: surround\
    \ the struct literal with parentheses\n   |\n25 ~     if interval1_start > (interval2_end\
    \ {\n26 |         interval1_start, interval1_end = interval2_end, interval1_start;\n\
    27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpjmg1dk1b.rs:29:40\n\
    \   |\n29 |         interval1_end, interval1_start = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpjmg1dk1b.rs:29:72\n   |\n28 |     if interval1_end < interval2_start\
    \ {\n   |                        --------------- while parsing this struct\n29\
    \ |         interval1_end, interval1_start = interval2_start, interval1_end;\n\
    \   |                                                                        ^\
    \ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpjmg1dk1b.rs:28:24\n   |\n28 |       if interval1_end < interval2_start\
    \ {\n   |  ______________________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1.0 > interval2.0\
    \ {\n        interval = interval2;\n    }\n    if interval1.0 < interval2.0 {\n\
    \        interval = interval1;\n    }\n    if interval.0 == interval1.0 {\n  \
    \      return String::from(\"NO\");\n    }\n    if interval.0 == interval2.0 {\n\
    \        return String::from(\"NO\");\n    }\n    let mut prime = true;\n    let\
    \ mut i = 1;\n    while prime && i <= interval.0 + 1 {\n        if interval.0\
    \ + i == interval1.0 {\n            prime = false;\n        }\n        if interval.0\
    \ + i == interval2.0 {\n            prime = false;\n        }\n        i += 1;\n\
    \    }\n    if prime {\n        return String::from(\"YES\");\n    }\n    return\
    \ String::from(\"NO\");\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2v0a5boe.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2v0a5boe.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2v0a5boe.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2v0a5boe.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2v0a5boe.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2v0a5boe.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2v0a5boe.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2v0a5boe.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2v0a5boe.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2v0a5boe.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2v0a5boe.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1.start <= interval2.start && interval1.end >= interval2.end\
    \ {\n        if interval1.start <= interval2.end {\n            if interval1.end\
    \ >= interval2.start {\n                if interval1.end >= interval2.end {\n\
    \                    if interval1.start <= interval2.start {\n               \
    \         if interval1.end <= interval2.end {\n                            if\
    \ interval1.start <= interval2.end {\n                                if interval1.end\
    \ <= interval2.start {\n                                    if interval1.start\
    \ <= interval2.end {\n                                        if interval1.end\
    \ <= interval2.end {\n                                            if interval1.start\
    \ <= interval2.end {\n                                                if interval1.end\
    \ <= interval2.start {\n                                                    if\
    \ interval1.end <= interval2.end {\n                                         \
    \               if interval1.start <= interval2.end {\n                      \
    \                                      if interval1.end <= interval2.start {\n\
    \                                                                if interval1.end\
    \ <= interval2.end {\n                                                       \
    \             if interval1.start <= interval2.end {\n                        \
    \                                                if interval1.end <= interval2.start\
    \ {\n                                                                        \
    \    if interval1.end <= interval2.end {\n                                   \
    \                                             if interval1.start <= interval2.end\
    \ {\n                                                                        \
    \            if interval1.end <= interval2.start {\n                         \
    \                                                               if interval1.end\
    \ <= interval2.end {\n                                                       \
    \                                     if interval1.start <= interval2.end {\n\
    \                                                                            \
    \                    if interval1.end <= interval2.start {\n                 \
    \                                                                            \
    \       if interval1.end <= interval2.end {\n                                \
    \                                                                        if interval1.start\
    \ <= interval2.end {\n                                                       \
    \                                                     if interval1.end <= interval2.start\
    \ {\n                                                                        \
    \                                        if interval1.end <= interval2.end {\n\
    \                                                                            \
    \                                        if interval1.start <= interval2.end {\n\
    \                                                                            \
    \                                            if interval1.end <= interval2.start\
    \ {\n                                                                        \
    \                                                    if interval1.end <= interval2.end\
    \ {\n                                                                        \
    \                                                                        if interval1.start\
    \ <= interval2.end {\n                                                       \
    \                                                                            \
    \                 if interval1.end <= interval2.start {\n                    \
    \                                                                            \
    \                                                        if interval1.end <= interval2.end\
    \ {\n                                                                        \
    \                                                                            \
    \        if interval1.start <= interval2.end {\n                             \
    \                                                                            \
    \                                                       if interval1.end <= interval2.start\
    \ {\n                                                                        \
    \                                                                            \
    \                if interval1.end <= interval2.end {\n                       \
    \                                                                            \
    \                                                                     if interval1.start\
    \ <= interval2.end {\n                                                       \
    \                                                                            \
    \                                         if interval1.end <= interval2.start\
    \ {\n                                                                        \
    \                                                                            \
    \                            if interval1.end <= interval2.end {\n           \
    \                                                                            \
    \                                                                            \
    \                 if interval1.start <= interval2.end {\n                    \
    \                                                                            \
    \                                                                            \
    \            if interval1.end <= interval2.start {\n                         \
    \                                                                            \
    \                                                                            \
    \           if interval1.end <= interval2.end {\n                            \
    \                                                                            \
    \                                                                            \
    \                            if interval1.start <= interval2.end \n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpf7rtvgrn.rs:77:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n21 |     if interval1.start <= interval2.start\
    \ && interval1.end >= interval2.end {\n   |                                  \
    \                                           - unclosed delimiter\n22 |       \
    \  if interval1.start <= interval2.end {\n   |                               \
    \              - unclosed delimiter\n23 |             if interval1.end >= interval2.start\
    \ {\n   |                                                 - unclosed delimiter\n\
    24 |                 if interval1.end >= interval2.end {\n   |               \
    \                                    - unclosed delimiter\n25 |              \
    \       if interval1.start <= interval2.start {\n   |                        \
    \                                   - unclosed delimiter\n26 |               \
    \          if interval1.end <= interval2.end {\n   |                         \
    \                                  - unclosed delimiter\n27 |                \
    \             if interval1.start <= interval2.end {\n   |                    \
    \                                             - unclosed delimiter\n28 |     \
    \                            if interval1.end <= interval2.start {\n   |     \
    \                                                                - unclosed delimiter\n\
    29 |                                     if interval1.start <= interval2.end {\n\
    \   |                                                                        \
    \ - unclosed delimiter\n30 |                                         if interval1.end\
    \ <= interval2.end {\n   |                                                   \
    \                        - unclosed delimiter\n31 |                          \
    \                   if interval1.start <= interval2.end {\n   |              \
    \                                                                   - unclosed\
    \ delimiter\n32 |                    "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut intersection_len\
    \ = interval1_len + interval2_len;\n    if interval1_len > interval2_len {\n \
    \       interval1_len = interval2_len;\n        interval2_start = interval1[0];\n\
    \        interval2_end = interval1[1];\n    }\n    if interval2_len > interval1_len\
    \ {\n        interval2_len = interval1_len;\n        interval1_start = interval2[0];\n\
    \        interval1_end = interval2[1];\n    }\n    if interval1_len == interval2_len\
    \ {\n        if interval1_start <= interval2_start {\n            interval1_start\
    \ = interval2_start;\n            interval1_end = interval2_end;\n        } else\
    \ {\n            interval2_start = interval1_start;\n            interval2_end\
    \ = interval1_end;\n        }\n    }\n    if interval1_len > 1 {\n        interval1_len\
    \ = interval1_len / 2;\n    }\n    if interval2_len > 1 {\n        interval2_len\
    \ = interval2_len / 2;\n    }\n    if interval1_len == 1 {\n        if interval2_len\
    \ == 1 {\n            if interval1_start == interval2_start {\n              \
    \  return String::from(\"YES\");\n            }\n            return String::from(\"\
    NO\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval2_len\
    \ == 1 {\n        return String::from(\"NO\");\n    }\n    if interval1_len ==\
    \ interval2_len {\n        if interval1_start <= interval2_start {\n         \
    \   interval1_start = interval2_start;\n            interval1_end = interval2_end;\n\
    \        } else {\n            interval2_start = interval1_start;\n          \
    \  interval2_end = interval1_end;\n        }\n    }\n    if interval1_len > interval2_len\
    \ {\n        interval1_len = interval2_len;\n        interval2_start = interval1[0];\n\
    \        interval2_end = interval1[1];\n    }\n    if interval2_len > interval1_len\
    \ {\n        interval2_len = interval1_len;\n        interval1_start = interval2[0];\n\
    \        interval1_end = interval2[1];\n    }\n    if interval1_len == interval2_len\
    \ {\n        if interval1_start <= interval2_start {\n            interval1_start\
    \ = interval2_start;\n            interval1_end = interval2_end;\n        } else\
    \ {\n            interval2_start = interval1_start;\n            interval2_end\
    \ = interval1_end;\n        }\n    }\n    if interval1_len > \n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpyphdj3_c.rs:94:1\n\
    \   |\n94 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpyphdj3_c.rs:98:17\n   |\n98 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpyphdj3_c.rs:98:25\n \
    \  |\n98 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyphdj3_c.rs:99:17\n   |\n99 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyphdj3_c.rs:99:25\n   |\n99 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpyphdj3_c.rs:100:17\n    |\n100 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpyphdj3_c.rs:100:25\n    |\n100 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpyphdj3_c.rs:101:17\n    |\n101 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpyphdj3_c.rs:101:25\n    |\n101 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpyphdj3_c.rs:102:17\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpyphdj3_c.rs:102:25\n    |\n102 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpy"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n    if interval1_start > interval2_start {\n        interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n    }\n    if interval1_end < interval2_end\
    \ {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n  \
    \  }\n    if interval1_start == interval1_end {\n        if interval2_start ==\
    \ interval2_end {\n            return \"YES\";\n        }\n        return \"NO\"\
    ;\n    }\n    if interval2_start == interval2_end {\n        return \"NO\";\n\
    \    }\n    if interval1_start < interval2_start {\n        return \"NO\";\n \
    \   }\n    if interval1_end > interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start < interval2_end {\n        return \"YES\";\n    }\n  \
    \  if interval1_end > interval2_start {\n        return \"YES\";\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpobmhm3b2.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmpobmhm3b2.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpobmhm3b2.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpobmhm3b2.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmpobmhm3b2.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmpobmhm3b2.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_length = interval1_end - interval1_start;\n\
    \    let mut interval2_length = interval2_end - interval2_start;\n    if interval1_start\
    \ > interval2_start {\n        interval1_start = interval2_start;\n        interval1_end\
    \ = interval2_end;\n        interval1_length = interval2_end - interval2_start;\n\
    \    }\n    if interval1_end < interval2_end {\n        interval1_end = interval2_end;\n\
    \        interval1_length = interval2_end - interval2_start;\n    }\n    if interval1_length\
    \ == interval2_length {\n        if interval1_start == interval1_end {\n     \
    \       return \"YES\";\n        } else {\n            return \"NO\";\n      \
    \  }\n    }\n    if interval1_length < interval2_length {\n        interval1_length\
    \ = interval2_length;\n    }\n    if interval1_length == 2 {\n        if interval1_start\
    \ == interval1_end {\n            return \"YES\";\n        } else {\n        \
    \    return \"NO\";\n        }\n    }\n    if interval1_length == 3 {\n      \
    \  if interval1_start == interval1_end {\n            return \"YES\";\n      \
    \  } else {\n            return \"NO\";\n        }\n    }\n    if interval1_length\
    \ == 4 {\n        if interval1_start == interval1_end {\n            return \"\
    YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n    if\
    \ interval1_length == 5 {\n        if interval1_start == interval1_end {\n   \
    \         return \"YES\";\n        } else {\n            return \"NO\";\n    \
    \    }\n    }\n    if interval1_length == 6 {\n        if interval1_start == interval1_end\
    \ {\n            return \"YES\";\n        } else {\n            return \"NO\"\
    ;\n        }\n    }\n    if interval1_length == 7 {\n        if interval1_start\
    \ == interval1_end {\n            return \"YES\";\n        } else {\n        \
    \    return \"NO\";\n        }\n    }\n    if interval1_length == 8 {\n      \
    \  if interval1_start == interval1_end {\n            return \"YES\";\n      \
    \  } else {\n            return \"NO\";\n        }\n    }\n    if interval1_length\
    \ == 9 {\n        if interval1_start == interval1_end {\n            return \"\
    YES\";\n        } else {\n            return \"NO\";\n        }\n    }\n    if\
    \ interval1_length == 10 {\n        if interval1_start == interval1_end {\n  \
    \          return \"YES\";\n        } else {\n            return \"NO\";\n   \
    \     }\n    }\n    if interval1_length == 11 {\n        if interval1_start ==\
    \ interval1_end {\n            return \"YES\";\n        } else {\n           \
    \ return \"NO\";\n        }\n    }\n    if interval1_length == 12 {\n        if\
    \ interval1_start == \n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjn099xle.rs:130:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n116 |     if interval1_length\
    \ == 12 {\n    |                               - this delimiter might not be properly\
    \ closed...\n117 |         if interval1_start == \n118 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n130 | }\n    |   ^\n\nerror: expected\
    \ expression, found `}`\n   --> /tmp/tmpjn099xle.rs:118:1\n    |\n118 | }\n  \
    \  | ^ expected expression\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \   --> /tmp/tmpjn099xle.rs:122:17\n    |\n122 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpjn099xle.rs:122:25\n    |\n122 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpjn099xle.rs:123:17\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpjn099xle.rs:123:25\n    |\n123 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpjn099xle.rs:124:17\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpjn099xle.rs:124:25\n    |\n124 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpjn099xle.rs:125:17\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpjn099xl"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            let mut interval =\
    \ interval1;\n            interval[0] = interval2[0];\n            interval[1]\
    \ = interval2[1];\n            return interval_length(interval);\n        } else\
    \ {\n            let mut interval = interval2;\n            interval[0] = interval1[0];\n\
    \            interval[1] = interval1[1];\n            return interval_length(interval);\n\
    \        }\n    } else {\n        return \"NO\";\n    }\n}\n\nfn main() {\n  \
    \  let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `interval_length` in this scope\n  -->\
    \ /tmp/tmpcluv6hhn.rs:26:20\n   |\n26 |             return interval_length(interval);\n\
    \   |                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `interval_length` in this scope\n  --> /tmp/tmpcluv6hhn.rs:31:20\n\
    \   |\n31 |             return interval_length(interval);\n   |              \
    \      ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmpcluv6hhn.rs:40:17\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpcluv6hhn.rs:40:25\n \
    \  |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcluv6hhn.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcluv6hhn.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcluv6hhn.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcluv6hhn.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcluv6hhn.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcluv6hhn.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcluv6hhn.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |    "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![interval1, interval2];\n    let mut\
    \ intersection = interval1;\n    let mut prime = true;\n    let mut prime_length\
    \ = 1;\n    let mut prime_start = 0;\n    let mut prime_end = 0;\n    let mut\
    \ prime_end2 = interval1.1;\n    let mut prime_end3 = interval1.2;\n    let mut\
    \ prime_end4 = interval1.3;\n    let mut prime_end5 = interval1.4;\n    let mut\
    \ prime_end6 = interval1.5;\n    let mut prime_end7 = interval1.6;\n    let mut\
    \ prime_end8 = interval1.7;\n    let mut prime_end9 = interval1.8;\n    let mut\
    \ prime_end10 = interval1.9;\n    let mut prime_end11 = interval1.10;\n    let\
    \ mut prime_end12 = interval1.11;\n    let mut prime_end13 = interval1.12;\n \
    \   let mut prime_end14 = interval1.13;\n    let mut prime_end15 = interval1.14;\n\
    \    let mut prime_end16 = interval1.15;\n    let mut prime_end17 = interval1.16;\n\
    \    let mut prime_end18 = interval1.17;\n    let mut prime_end19 = interval1.18;\n\
    \    let mut prime_end20 = interval1.19;\n    let mut prime_end21 = interval1.20;\n\
    \    let mut prime_end22 = interval1.21;\n    let mut prime_end23 = interval1.22;\n\
    \    let mut prime_end24 = interval1.23;\n    let mut prime_end25 = interval1.24;\n\
    \    let mut prime_end26 = interval1.25;\n    let mut prime_end27 = interval1.26;\n\
    \    let mut prime_end28 = interval1.27;\n    let mut prime_end29 = interval1.28;\n\
    \    let mut prime_end30 = interval1.29;\n    let mut prime_end31 = interval1.30;\n\
    \    let mut prime_end32 = interval1.31;\n    let mut prime_end33 = interval1.32;\n\
    \    let mut prime_end34 = interval1.33;\n    let mut prime_end35 = interval1.34;\n\
    \    let mut prime_end36 = interval1.35;\n    let mut prime_end37 = interval1.36;\n\
    \    let mut prime_end38 = interval1.37;\n    let mut prime_end39 = interval1.38;\n\
    \n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:70:17\n\
    \   |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmqwoqqyc.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:71:17\n   |\n71 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:71:25\n\
    \   |\n71 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmqwoqqyc.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:72:25\n   |\n72 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmqwoqqyc.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:73:25\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmqwoqqyc.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmqwoqqyc.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n\n    if interval1_start <= interval2_end {\n        if interval1_end\
    \ >= interval2_start {\n            if interval1_end > interval2_end {\n     \
    \           interval1_end, interval2_end = interval2_end, interval1_end;\n   \
    \         }\n            if interval1_start <= interval2_start {\n           \
    \     if interval1_end <= interval2_end {\n                    if interval1_end\
    \ < interval2_end {\n                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval2_start {\n                        if interval1_end <= interval2_end\
    \ {\n                            if interval1_end < interval2_end {\n        \
    \                        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \                            }\n                            if interval1_start\
    \ <= interval2_start {\n                                if interval1_end <= interval2_end\
    \ {\n                                    if interval1_end < interval2_end {\n\
    \                                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                                    }\n                    \
    \                if interval1_start <= interval2_start {\n                   \
    \                     if interval1_end <= interval2_end {\n                  \
    \                          if interval1_end < interval2_end {\n              \
    \                                  interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                                            }\n            \
    \                                if interval1_start <= interval2_start {\n   \
    \                                             if interval1_end <= interval2_end\
    \ {\n                                                    if interval1_end < interval2_end\
    \ {\n                                                        interval1_end, interval2_end\
    \ = interval2_end, interval1_end;\n                                          \
    \          }\n                                                    if interval1_start\
    \ <= interval2_start {\n                                                     \
    \   if interval1_end <= interval2_end {\n                                    \
    \                        if interval1_end < interval2_end {\n                \
    \                                                interval1_end, interval2_end\
    \ = interval2_end, interval1_end;\n                                          \
    \                  }\n                                                       \
    \ }\n                                                    }\n                 \
    \                               }\n                                          \
    \  }\n                                        }\n                            \
    \        }\n                                }\n                            }\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n\n    if interval1_end >= interval2_start {\n     \
    \   if interval1_end > interval2_end {\n            interval1_end, interval2_end\
    \ = interval2_end, interval1_end;\n        }\n        if interval1_start <= interval2_start\
    \ {\n            if interval1_\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphpq8ci2n.rs:101:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n83  |     if interval1_end\
    \ >= interval2_start {\n    |                                         - unclosed\
    \ delimiter\n...\n87  |         if interval1_start <= interval2_start {\n    |\
    \                                               - this delimiter might not be\
    \ properly closed...\n88  |             if interval1_\n89  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n101 | }\n    |   ^\n\n\
    error: expected `:`, found `=`\n  --> /tmp/tmphpq8ci2n.rs:27:42\n   |\n27 |  \
    \       interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmphpq8ci2n.rs:20:81\n   |\n20 | fn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n   |               \
    \                                                                  ^ unclosed\
    \ delimiter\n...\n26 |     if interval1_start > interval2_start {\n   |      \
    \                    --------------- while parsing this struct\n27 |         interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n   |                  \
    \                                                          ^\n   |           \
    \                                                                 |\n   |    \
    \                                                                        expected\
    \ one of `,` or `}`\n   |                                                    \
    \                        help: `}` may belong here\n\nerror: struct literals are\
    \ not allowed here\n  --> /tmp/tmphpq8ci2n.rs:26:26\n   |\n26 |       if interval1_start\
    \ > interval2_start {\n   |  __________________________^\n2"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    if interval1_len\
    \ == interval2_len {\n        if interval1_start <= interval2_start {\n      \
    \      interval1_start = interval2_start;\n            interval1_len = interval2_len;\n\
    \        } else {\n            interval2_start = interval1_start;\n          \
    \  interval2_len = interval1_len;\n        }\n    }\n    if interval1_len > interval2_len\
    \ {\n        interval1_len = interval2_len;\n    }\n    if interval1_len == 1\
    \ {\n        if interval1_start == interval2_start {\n            return \"YES\"\
    ;\n        }\n        return \"NO\";\n    }\n    if interval1_len == 2 {\n   \
    \     if interval1_start == interval2_start {\n            return \"YES\";\n \
    \       }\n        return \"NO\";\n    }\n    if interval1_len == 3 {\n      \
    \  if interval1_start == interval2_start {\n            return \"YES\";\n    \
    \    }\n        return \"NO\";\n    }\n    if interval1_len == 4 {\n        if\
    \ interval1_start == interval2_start {\n            return \"YES\";\n        }\n\
    \        return \"NO\";\n    }\n    if interval1_len == 5 {\n        if interval1_start\
    \ == interval2_start {\n            return \"YES\";\n        }\n        return\
    \ \"NO\";\n    }\n    if interval1_len == 6 {\n        if interval1_start == interval2_start\
    \ {\n            return \"YES\";\n        }\n        return \"NO\";\n    }\n \
    \   if interval1_len == 7 {\n        if interval1_start == interval2_start {\n\
    \            return \"YES\";\n        }\n        return \"NO\";\n    }\n    if\
    \ interval1_len == 8 {\n        if interval1_start == interval2_start {\n    \
    \        return \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_len\
    \ == 9 {\n        if interval1_start == interval2_start {\n            return\
    \ \"YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_len ==\
    \ 10 {\n        if interval1_start == interval2_start {\n            return \"\
    YES\";\n        }\n        return \"NO\";\n    }\n    if interval1_len == 11 {\n\
    \        if interval1_start == interval2_start {\n            return \"YES\";\n\
    \        }\n        return \"NO\";\n    }\n    if interval1_len == 12 {\n    \
    \    if interval1_start == interval2_start {\n            return \"YES\";\n  \
    \      }\n        return \"NO\";\n    }\n    if interval1_len == 13 {\n      \
    \  if interval1_start == interval2_start {\n            return \"YES\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmpo1jumfu4.rs:113:20\n\
    \    |\n113 |               return \"YES\n    |  ____________________^\n114 |\
    \ | }\n115 | |\n116 | | fn main() {\n...   |\n125 | |     assert_eq!({left}, {right});\n\
    126 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    let mut interval2 = interval2;\n\
    \    let mut interval_len = interval1.0;\n    let mut interval2_len = interval2.0;\n\
    \    let mut interval_end = interval1.0;\n    let mut interval2_end = interval2.0;\n\
    \    let mut interval_start = interval1.0;\n    let mut interval2_start = interval2.0;\n\
    \    let mut interval_mid = interval1.0;\n    let mut interval2_mid = interval2.0;\n\
    \    let mut interval_mid2 = interval1.0;\n    let mut interval2_mid2 = interval2.0;\n\
    \    let mut interval_mid3 = interval1.0;\n    let mut interval2_mid3 = interval2.0;\n\
    \    let mut interval_mid4 = interval1.0;\n    let mut interval2_mid4 = interval2.0;\n\
    \    let mut interval_mid5 = interval1.0;\n    let mut interval2_mid5 = interval2.0;\n\
    \    let mut interval_mid6 = interval1.0;\n    let mut interval2_mid6 = interval2.0;\n\
    \    let mut interval_mid7 = interval1.0;\n    let mut interval2_mid7 = interval2.0;\n\
    \    let mut interval_mid8 = interval1.0;\n    let mut interval2_mid8 = interval2.0;\n\
    \    let mut interval_mid9 = interval1.0;\n    let mut interval2_mid9 = interval2.0;\n\
    \    let mut interval_mid10 = interval1.0;\n    let mut interval2_mid10 = interval2.0;\n\
    \    let mut interval_mid11 = interval1.0;\n    let mut interval2_mid11 = interval2.0;\n\
    \    let mut interval_mid12 = interval1.0;\n    let mut interval2_mid12 = interval2.0;\n\
    \    let mut interval_mid13 = interval1.0;\n    let mut interval2_mid13 = interval2.0;\n\
    \    let mut interval_mid14 = interval1.0;\n    let mut interval2_mid14 = interval2.0;\n\
    \    let mut interval_mid15 = interval1.0;\n    let mut interval2_mid15 = interval2.0;\n\
    \    let mut interval_mid16 = interval1.0;\n    let mut interval2_mid16 = interval2.0;\n\
    \    let mut interval_mid17 = interval1.0;\n    let mut interval2_mid17 = interval2.0;\n\
    \    let mut interval_mid18 = interval1.0;\n    let mut interval2_mid18 = interval2.0;\n\
    \    let mut interval_mid19 = interval1.0;\n    let mut interval2_mid19 = interval2.0;\n\
    \    let mut interval\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxrx_mir5.rs:67:21\n   |\n\
    67 |     let mut interval\n   |                     ^ help: add `;` here\n68 |\
    \ }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpxrx_mir5.rs:72:17\n   |\n72 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxrx_mir5.rs:72:25\n   |\n72 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxrx_mir5.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxrx_mir5.rs:73:25\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxrx_mir5.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxrx_mir5.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxrx_mir5.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxrx_mir5.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxrx_mir5.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxrx_mir5.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `lef"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        return \"NO\";\n   \
    \ }\n    if interval1_end < interval2_start {\n        return \"NO\";\n    }\n\
    \    if interval1_start == interval1_end {\n        return \"NO\";\n    }\n  \
    \  if interval1_start < interval2_start {\n        return \"NO\";\n    }\n   \
    \ if interval1_end > interval2_end {\n        return \"NO\";\n    }\n    let mut\
    \ interval1_length = interval1_end - interval1_start + 1;\n    let mut interval2_length\
    \ = interval2_end - interval2_start + 1;\n    if interval1_length == interval2_length\
    \ {\n        return \"YES\";\n    }\n    if interval1_length < interval2_length\
    \ {\n        interval1_length = interval2_length;\n    }\n    if interval1_length\
    \ == 1 {\n        return \"YES\";\n    }\n    if interval1_length == 2 {\n   \
    \     return \"YES\";\n    }\n    if interval1_length == 3 {\n        return \"\
    YES\";\n    }\n    if interval1_length == 4 {\n        return \"YES\";\n    }\n\
    \    if interval1_length == 5 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 6 {\n        return \"YES\";\n    }\n    if interval1_length == 7 {\n   \
    \     return \"YES\";\n    }\n    if interval1_length == 8 {\n        return \"\
    YES\";\n    }\n    if interval1_length == 9 {\n        return \"YES\";\n    }\n\
    \    if interval1_length == 10 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 11 {\n        return \"YES\";\n    }\n    if interval1_length == 12 {\n \
    \       return \"YES\";\n    }\n    if interval1_length == 13 {\n        return\
    \ \"YES\";\n    }\n    if interval1_length == 14 {\n        return \"YES\";\n\
    \    }\n    if interval1_length == 15 {\n        return \"YES\";\n    }\n    if\
    \ interval1_length == 16 {\n        return \"YES\";\n    }\n    if interval1_length\
    \ == 17 {\n        return \"YES\";\n    }\n    if interval1_length == 18 {\n \
    \       return \"YES\";\n    }\n    if interval1_length == 19 {\n        return\
    \ \"YES\";\n    }\n    if interval1_length == 20 {\n        return \"YES\";\n\
    \    }\n    if interval1_length == 21 {\n        return \"\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmplsujut05.rs:115:16\n\
    \    |\n115 |           return \"\n    |  ________________^\n116 | | }\n117 |\
    \ |\n118 | | fn main() {\n...   |\n127 | |     assert_eq!({left}, {right});\n\
    128 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut interval = interval1;\n        interval[0] = interval1[0];\n\
    \        interval[1] = interval1[1];\n        interval = interval2;\n        interval[0]\
    \ = interval2[0];\n        interval[1] = interval2[1];\n        let mut intersection\
    \ = interval;\n        let mut length = 1;\n        while intersection[0] < intersection[1]\
    \ {\n            if interval[0] < intersection[0] {\n                intersection[0]\
    \ = interval[0];\n            } else {\n                intersection[0] = intersection[0];\n\
    \            }\n            if interval[1] > intersection[1] {\n             \
    \   intersection[1] = interval[1];\n            } else {\n                intersection[1]\
    \ = intersection[1];\n            }\n            length += 1;\n        }\n   \
    \     if length == 2 {\n            return \"YES\";\n        }\n        return\
    \ \"NO\";\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9ks0_2qa.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9ks0_2qa.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9ks0_2qa.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9ks0_2qa.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9ks0_2qa.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    let mut intersection_len\
    \ = interval1_len + interval2_len;\n    let mut prime_number: isize = 1;\n   \
    \ let mut prime_number_flag = true;\n    let mut prime_number_flag2 = true;\n\
    \    let mut prime_number_flag3 = true;\n    let mut prime_number_flag4 = true;\n\
    \    let mut prime_number_flag5 = true;\n    let mut prime_number_flag6 = true;\n\
    \    let mut prime_number_flag7 = true;\n    let mut prime_number_flag8 = true;\n\
    \    let mut prime_number_flag9 = true;\n    let mut prime_number_flag10 = true;\n\
    \    let mut prime_number_flag11 = true;\n    let mut prime_number_flag12 = true;\n\
    \    let mut prime_number_flag13 = true;\n    let mut prime_number_flag14 = true;\n\
    \    let mut prime_number_flag15 = true;\n    let mut prime_number_flag16 = true;\n\
    \    let mut prime_number_flag17 = true;\n    let mut prime_number_flag18 = true;\n\
    \    let mut prime_number_flag19 = true;\n    let mut prime_number_flag20 = true;\n\
    \    let mut prime_number_flag21 = true;\n    let mut prime_number_flag22 = true;\n\
    \    let mut prime_number_flag23 = true;\n    let mut prime_number_flag24 = true;\n\
    \    let mut prime_number_flag25 = true;\n    let mut prime_number_flag26 = true;\n\
    \    let mut prime_number_flag27 = true;\n    let mut prime_number_flag28 = true;\n\
    \    let mut prime_number_flag29 = true;\n    let mut prime_number_flag30 = true;\n\
    \    let mut prime_number_flag31 = true;\n    let mut prime_number_flag32 = true;\n\
    \    let mut prime_number_flag33 = true;\n    let mut prime_number_flag34 = true;\n\
    \    let mut prime_number_flag35 = true;\n    let mut prime_number_flag36 = true;\n\
    \    let mut prime_number_flag37 = true;\n    let mut prime_number_flag38 = true;\n\
    \    let mut prime_number_flag39 = true;\n    let mut prime_number_flag40 = true;\n\
    \    let mut prime_number_flag41 = true;\n    let mut prime_number_flag42 = \n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp37gh8emq.rs:71:1\n\
    \   |\n71 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp37gh8emq.rs:75:17\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:75:25\n \
    \  |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp37gh8emq.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp37gh8emq.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp37gh8emq.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp37gh8emq.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp37gh8emq.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp37gh8emq.rs:79:25\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp37gh8emq.rs:80:17\n   |\n80 |     "
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_start > interval2_end {\n        interval1_start, interval2_end\
    \ = interval2_end, interval1_start;\n    }\n    if interval1_end < interval2_start\
    \ {\n        interval1_end, interval2_start = interval2_start, interval1_end;\n\
    \    }\n    if interval1_start == interval1_end {\n        if interval2_start\
    \ == interval2_end {\n            return String::from(\"YES\");\n        }\n \
    \       return String::from(\"NO\");\n    }\n    let mut interval1_length = interval1_end\
    \ - interval1_start;\n    let mut interval2_length = interval2_end - interval2_start;\n\
    \    if interval1_length == interval2_length {\n        return String::from(\"\
    YES\");\n    }\n    if interval1_length < interval2_length {\n        interval1_length,\
    \ interval2_length = interval2_length, interval1_length;\n    }\n    if interval1_length\
    \ == 2 {\n        if interval2_length == 2 {\n            return String::from(\"\
    YES\");\n        }\n        return String::from(\"NO\");\n    }\n    if interval1_length\
    \ == 3 && interval2_length == 3 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval1_length == 3 && interval2_length == 4 {\n     \
    \   if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        }\n        if interval1_end == interval2_end {\n            return\
    \ String::from(\"YES\");\n        }\n        return String::from(\"NO\");\n  \
    \  }\n    if interval1_length == 4 && interval2_length == 3 {\n        if interval1_start\
    \ == interval2_start {\n            return String::from(\"YES\");\n        }\n\
    \        if interval1_end == interval2_end {\n            return String::from(\"\
    YES\");\n        }\n        if interval1_end == interval2_start + 1 {\n      \
    \      return String::from(\"YES\");\n        }\n        return String::from(\"\
    NO\");\n    }\n    if interval1_length == 4 && interval2_length == 4 {\n     \
    \   if interval1_start == interval2_start {\n            return String::from(\"\
    YES\");\n        }\n        if interval1_end \n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmps0hgw0yd.rs:101:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n84  |     if interval1_length\
    \ == 4 && interval2_length == 4 {\n    |                                     \
    \                  - this delimiter might not be properly closed...\n...\n89 \
    \ | }\n    | - ...as it matches this but it has different indentation\n...\n101\
    \ | }\n    |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmps0hgw0yd.rs:26:42\n\
    \   |\n26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmps0hgw0yd.rs:20:81\n   |\n20 | fn intersection(interval1:\
    \ (isize, isize), interval2: (isize, isize)) -> String {\n   |               \
    \                                                                  ^ unclosed\
    \ delimiter\n...\n25 |     if interval1_start > interval2_start {\n   |      \
    \                    --------------- while parsing this struct\n26 |         interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n   |                  \
    \                                                          ^\n   |           \
    \                                                                 |\n   |    \
    \                                                                        expected\
    \ one of `,` or `}`\n   |                                                    \
    \                        help: `}` may belong here\n\nerror: struct literals are\
    \ not allowed here\n  --> /tmp/tmps0hgw0yd.rs:25:26\n   |\n25 |       if interval1_start\
    \ > interval2_start {\n   |  __________________________^\n26 | |         interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n\
    \   |\nhelp: surround th"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_start > interval2_start\
    \ {\n        interval1_start = interval2_start;\n        interval1_end = interval2_end;\n\
    \        interval2_start = interval1_start;\n        interval2_end = interval1_end;\n\
    \    }\n    if interval1_end < interval2_end {\n        interval1_end = interval2_end;\n\
    \        interval1_start = interval2_start;\n        interval2_end = interval1_end;\n\
    \        interval2_start = interval1_start;\n    }\n    if interval1_start > interval2_end\
    \ {\n        intersection_start = interval2_start;\n        intersection_end =\
    \ interval2_end;\n    } else {\n        intersection_start = interval1_start;\n\
    \        intersection_end = interval1_end;\n    }\n    if intersection_start >\
    \ intersection_end {\n        return \"NO\";\n    }\n    if interval1_start ==\
    \ interval1_end {\n        return \"YES\";\n    }\n    if interval2_start == interval2_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start < interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_end > interval2_end {\n \
    \       return \"NO\";\n    }\n    if interval1_start < interval2_end {\n    \
    \    return \"YES\";\n    }\n    if interval1_end > interval2_start {\n      \
    \  return \"YES\";\n    }\n    if interval1_start == interval1_end {\n       \
    \ return \"YES\";\n    }\n    if interval2_start == interval2_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_start < interval2_start {\n        return\
    \ \"YES\";\n    }\n    if interval1_end > interval2_end {\n        return \"YES\"\
    ;\n    }\n    if interval1_start < interval2_end {\n        return \"YES\";\n\
    \    }\n    if interval1_end > interval2_start {\n        return \"YES\";\n  \
    \  }\n    if interval1_start == interval1_end {\n        return \"YES\";\n   \
    \ }\n    if interval2_start == interval2_end {\n        return \"YES\";\n    }\n\
    \    if interval1_start < interval2_start {\n        return \"YES\";\n    }\n\
    \    if interval1_end > interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_start < interval2_end {\n        return \"YES\";\n    }\n    if interval1_end\
    \ > interval2_start {\n        return \"YES\";\n    }\n    if interval1_start\
    \ == interval1_end {\n        return \"YES\";\n\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdhaoqn81.rs:118:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n103 |     if interval1_start\
    \ == interval1_end {\n    |                                         - this delimiter\
    \ might not be properly closed...\n...\n106 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n118 | }\n    |   ^\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmpdhaoqn81.rs:110:17\n    |\n\
    110 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmpdhaoqn81.rs:110:25\n    |\n110 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpdhaoqn81.rs:111:17\n\
    \    |\n111 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpdhaoqn81.rs:111:25\n    |\n111 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpdhaoqn81.rs:112:17\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpdhaoqn81.rs:112:25\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpdhaoqn81.rs:113:17\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpdhaoqn81.rs:113:25\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E04"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![];\n    intervals.push(interval1);\n\
    \    intervals.push(interval2);\n    let mut intersection = interval1;\n    let\
    \ mut intersection_length = interval1.0;\n    let mut interval_length = interval1.0;\n\
    \    let mut interval_start = interval1.0;\n    let mut interval_end = interval1.0;\n\
    \    let mut interval_start_end = interval1.0;\n    let mut interval_end_start\
    \ = interval1.0;\n    let mut interval_start_end_length = interval1.0;\n    let\
    \ mut interval_end_start_length = interval1.0;\n    let mut interval_start_end_start_length\
    \ = interval1.0;\n    let mut interval_end_start_start_length = interval1.0;\n\
    \    let mut interval_start_end_end_length = interval1.0;\n    let mut interval_end_start_end_length\
    \ = interval1.0;\n    let mut interval_start_end_end_start_length = interval1.0;\n\
    \    let mut interval_end_start_end_start_length = interval1.0;\n    let mut interval_start_end_end_end_length\
    \ = interval1.0;\n    let mut interval_end_start_end_end_length = interval1.0;\n\
    \    let mut interval_start_end_end_end_start_length = interval1.0;\n    let mut\
    \ interval_end_start_end_end_start_length = interval1.0;\n    let mut interval_start_end_end_end_end_length\
    \ = interval1.0;\n    let mut interval_end_start_end_end_end_length = interval1.0;\n\
    \    let mut interval_start_end_end_end_end_start_length = interval1.0;\n    let\
    \ mut interval_end_start_end_end_end_start_length = interval1.0;\n    let mut\
    \ interval_start_end_end_end_end_end_length = interval1.0;\n    let mut interval_end_start_end_end_end_end_length\
    \ = interval1.0;\n    let mut interval_start_end_end_end_end_end_start_length\
    \ = interval1.0;\n    let mut interval_end_start_end_end_end_end_start_length\
    \ = interval1.0;\n    let mut interval_start_end_end_end_end_end_end_length =\
    \ interval1.0;\n    let mut interval_end_start_end_end_end_end_end_length = interval1.0;\n\
    \    let mut interval_start_end_end_end_end_end_end_start_length = interval1.0;\n\
    \    let mut interval_end_start_end_end_end_end_end_start_length = interval1.0;\n\
    \    let mut interval_start_end_end_end_end_end_end_end_length = interval1.0;\n\
    \    let mut interval_end_start_end_end_end_end_end_end_length = interval1.0;\n\
    \    let mut interval_start_end_end_end_end_end_end_end_start_length = interval1.0;\n\
    \    let mut interval_end_\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpokc11whj.rs:58:26\n   |\n\
    58 |     let mut interval_end_\n   |                          ^ help: add `;`\
    \ here\n59 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpokc11whj.rs:63:17\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpokc11whj.rs:63:25\n \
    \  |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpokc11whj.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpokc11whj.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpokc11whj.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpokc11whj.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpokc11whj.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpokc11whj.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpokc11whj.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpokc11whj.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut interval1_len = interval1_end - interval1_start;\n\
    \    let mut interval2_len = interval2_end - interval2_start;\n    if interval1_len\
    \ > interval2_len {\n        interval1_len = interval2_len;\n        interval2_start\
    \ = interval1[0];\n        interval2_end = interval1[1];\n    }\n    if interval2_len\
    \ > interval1_len {\n        interval2_len = interval1_len;\n        interval1_start\
    \ = interval2[0];\n        interval1_end = interval2[1];\n    }\n    if interval1_start\
    \ <= interval2_end && interval2_start <= interval1_end {\n        if interval1_start\
    \ < interval2_start {\n            interval1_start = interval2_start;\n      \
    \  }\n        if interval1_end > interval2_end {\n            interval1_end =\
    \ interval2_end;\n        }\n        if interval1_end < interval2_start {\n  \
    \          interval1_end = interval2_start;\n        }\n        if interval1_start\
    \ < interval1_end {\n            interval1_len = interval1_end - interval1_start;\n\
    \        }\n        if interval1_len == 1 {\n            return \"YES\";\n   \
    \     }\n        if interval1_len == 2 {\n            return \"YES\";\n      \
    \  }\n        if interval1_len == 3 {\n            return \"YES\";\n        }\n\
    \        if interval1_len == 4 {\n            return \"YES\";\n        }\n   \
    \     if interval1_len == 5 {\n            return \"YES\";\n        }\n      \
    \  if interval1_len == 6 {\n            return \"YES\";\n        }\n        if\
    \ interval1_len == 7 {\n            return \"YES\";\n        }\n        if interval1_len\
    \ == 8 {\n            return \"YES\";\n        }\n        if interval1_len ==\
    \ 9 {\n            return \"YES\";\n        }\n        if interval1_len == 10\
    \ {\n            return \"YES\";\n        }\n        if interval1_len == 11 {\n\
    \            return \"YES\";\n        }\n        if interval1_len == 12 {\n  \
    \          return \"YES\";\n        }\n        if interval1_len == 13 {\n    \
    \        return \"YES\";\n        }\n        if interval1_len == 14 {\n      \
    \      return \"YES\";\n        }\n        if interval1_len == 15 {\n        \
    \    return \"YES\";\n        }\n        if interval1_len == 16 {\n          \
    \  return \"YES\";\n        }\n        if interval1_len == 17 {\n            return\
    \ \"YES\";\n        }\n        if interval1_len == 18 {\n            return \"\
    YES\";\n        }\n        if interval1_len == 19 {\n            return \"YES\"\
    ;\n        }\n        if interval1_len == 20 {\n            return \"YES\";\n\
    \        }\n        if interval1_len == 2\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp247w0wve.rs:123:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n37  |     if interval1_start\
    \ <= interval2_end && interval2_start <= interval1_end {\n    |              \
    \                                                               - this delimiter\
    \ might not be properly closed...\n...\n111 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n123 | }\n    |   ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmp247w0wve.rs:111:1\n    |\n110 |         if interval1_len\
    \ == 2\n    |         -- this `if` expression has a condition, but no block\n\
    111 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp247w0wve.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp247w0wve.rs:115:25\n\
    \    |\n115 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp247w0wve.rs:116:17\n    |\n116 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp247w0wve.rs:116:25\n\
    \    |\n116 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp247w0wve.rs:117:17\n    |\n117 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp247w0wve.rs:117:25\n\
    \    |\n117 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp247w0wve.rs:118:17\n    |\n118 |     assert_e"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_length = 0;\n    while interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n        if interval1_start\
    \ < interval1_end {\n            interval1_start += 1;\n        }\n        if\
    \ interval2_start < interval2_end {\n            interval2_start += 1;\n     \
    \   }\n        intersection_length += 1;\n    }\n    if interval1_start > interval1_end\
    \ {\n        interval1_start = interval1_end;\n    }\n    if interval2_start >\
    \ interval2_end {\n        interval2_start = interval2_end;\n    }\n    if intersection_length\
    \ == 0 {\n        return \"NO\";\n    }\n    if intersection_length == 1 {\n \
    \       return \"YES\";\n    }\n    if interval1_start == interval1_end {\n  \
    \      if interval2_start == interval2_end {\n            return \"YES\";\n  \
    \      }\n        return \"NO\";\n    }\n    if interval2_start == interval2_end\
    \ {\n        return \"NO\";\n    }\n    if interval1_start == interval2_start\
    \ {\n        return \"NO\";\n    }\n    if interval1_start < interval2_start {\n\
    \        return \"NO\";\n    }\n    if interval1_end > interval2_end {\n     \
    \   return \"NO\";\n    }\n    if interval1_start < interval2_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_end > interval2_start {\n        return \"\
    YES\";\n    }\n    if intersection_length == 2 {\n        return \"YES\";\n  \
    \  }\n    if intersection_length == 3 {\n        return \"YES\";\n    }\n    if\
    \ intersection_length == 4 {\n        return \"YES\";\n    }\n    if intersection_length\
    \ == 5 {\n        return \"YES\";\n    }\n    if intersection_length == 6 {\n\
    \        return \"YES\";\n    }\n    if intersection_length == 7 {\n        return\
    \ \"YES\";\n    }\n    if intersection_length == 8 {\n        return \"YES\";\n\
    \    }\n    if intersection_length == 9 {\n        return \"YES\";\n    }\n  \
    \  if intersection_length == 10 {\n        return \"YES\";\n    }\n    if intersection_length\
    \ == 11 {\n        return \"YES\";\n    }\n    if intersection_length == 12 {\n\
    \        return \"YES\";\n    }\n    if intersection_length == 13 {\n        return\
    \ \"YES\";\n    }\n    if intersection_length == 14 {\n        return \"YES\"\
    ;\n    }\n    if intersection_length == 15 {\n        return \"YES\";\n    }\n\
    \    if intersection_length == 16 {\n        return \"YES\";\n    }\n    if intersection_length\
    \ == 17\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n   --> /tmp/tmpevsrlxju.rs:117:1\n    |\n\
    116 |     if intersection_length == 17\n    |     -- this `if` expression has\
    \ a condition, but no block\n117 | }\n    | ^ expected `{`\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmpevsrlxju.rs:121:17\n    |\n\
    121 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmpevsrlxju.rs:121:25\n    |\n121 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpevsrlxju.rs:122:17\n\
    \    |\n122 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpevsrlxju.rs:122:25\n    |\n122 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpevsrlxju.rs:123:17\n\
    \    |\n123 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpevsrlxju.rs:123:25\n    |\n123 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpevsrlxju.rs:124:17\n\
    \    |\n124 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpevsrlxju.rs:124:25\n    |\n124 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmpevsrlxju.rs:125:17\n\
    \    |\n125 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmpevsrlxju.rs:125:25\n    |\n125 |     assert_eq!({left}, {right});\n\
    \    |           "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n\n    if interval1_start > interval2_start {\n        interval1_start\
    \ = interval2_start;\n        interval1_end = interval2_end;\n    }\n\n    if\
    \ interval1_end < interval2_end {\n        interval1_end = interval2_end;\n  \
    \      interval1_start = interval2_start;\n    }\n\n    if interval1_start > interval2_end\
    \ {\n        interval1_start = interval2_end;\n        interval1_end = interval2_start;\n\
    \    }\n\n    if interval1_end < interval2_start {\n        interval1_end = interval2_start;\n\
    \        interval1_start = interval2_end;\n    }\n\n    if interval1_start ==\
    \ interval1_end {\n        return String::from(\"NO\");\n    }\n\n    let mut\
    \ interval1_length = interval1_end - interval1_start + 1;\n    let mut interval2_length\
    \ = interval2_end - interval2_start + 1;\n\n    if interval1_length == interval2_length\
    \ {\n        return String::from(\"YES\");\n    }\n\n    if interval1_length <\
    \ interval2_length {\n        interval1_length = interval2_length;\n    }\n\n\
    \    if interval1_length == 2 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        if interval1_end\
    \ == interval2_end {\n            return String::from(\"YES\");\n        }\n \
    \   }\n\n    if interval1_length == 3 {\n        if interval1_start == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n        if interval1_end\
    \ == interval2_end {\n            return String::from(\"YES\");\n        }\n \
    \       if interval1_start == interval2_end {\n            return String::from(\"\
    YES\");\n        }\n    }\n\n    if interval1_length == 4 {\n        if interval1_start\
    \ == interval2_start {\n            return String::from(\"YES\");\n        }\n\
    \        if interval1_end == interval2_end {\n            return String::from(\"\
    YES\");\n        }\n        if interval1_start == interval2_end {\n          \
    \  return String::from(\"YES\");\n        }\n        if interval1_end == interval2_start\
    \ {\n            return String::from(\"YES\");\n        }\n    }\n\n    if interval1_length\
    \ == 5 {\n        if interval1_start == interval2_start {\n            return\
    \ String::from(\"YES\");\n        }\n        if interval1_end == interval2_end\
    \ {\n            return String::from(\"YES\");\n        }\n        if interval1_start\
    \ == interval2_end {\n            return String::from(\"YES\");\n\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvldacs73.rs:119:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n97  |     if interval1_length\
    \ == 5 {\n    |                              - unclosed delimiter\n...\n104 |\
    \         if interval1_start == interval2_end {\n    |                       \
    \                      - this delimiter might not be properly closed...\n...\n\
    107 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    119 | }\n    |   ^\n\nerror[E0425]: cannot find value `left` in this scope\n \
    \  --> /tmp/tmpvldacs73.rs:111:17\n    |\n111 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvldacs73.rs:111:25\n    |\n111 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvldacs73.rs:112:17\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvldacs73.rs:112:25\n    |\n112 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvldacs73.rs:113:17\n    |\n113 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvldacs73.rs:113:25\n    |\n113 |\
    \     assert_eq!({left}, {right});\n    |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n   -->\
    \ /tmp/tmpvldacs73.rs:114:17\n    |\n114 |     assert_eq!({left}, {right});\n\
    \    |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n   --> /tmp/tmpvldacs73.rs:114:25\n    |\n114 "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        let mut result = String::from(\"NO\");\n        for (a, b) in interval1.iter().zip(interval2.iter())\
    \ {\n            if a < b {\n                result.push_str(\"NO\");\n      \
    \          break;\n            }\n            if a == b {\n                result.push_str(\"\
    YES\");\n                break;\n            }\n        }\n        result\n  \
    \  } else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmg8mrtqq.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmg8mrtqq.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmg8mrtqq.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821548
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            return \"NO\".to_string();\n\
    \        } else {\n            return \"YES\".to_string();\n        }\n    } else\
    \ {\n        return \"NO\".to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpylpz4mnt.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpylpz4mnt.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpylpz4mnt.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpylpz4mnt.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpylpz4mnt.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpylpz4mnt.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpylpz4mnt.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpylpz4mnt.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpylpz4mnt.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpylpz4mnt.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpylpz4mnt.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval_1 = interval1.clone();\n    let mut interval_2\
    \ = interval2.clone();\n    let mut intersection = interval1.clone();\n    let\
    \ mut intersection_length = interval1.clone();\n    let mut interval_1_length\
    \ = interval1.clone();\n    let mut interval_2_length = interval2.clone();\n \
    \   let mut prime_numbers = vec![true];\n    let mut prime_numbers_length = vec![true];\n\
    \    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![true];\n    let mut prime_numbers_length\
    \ = vec![true];\n    let mut prime_numbers_length = vec![\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp781t6rkx.rs:62:1\n   |\n62 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp781t6rkx.rs:61:40\n   |\n20 | fn intersection(interval1: (isize, isize),\
    \ interval2: (isize, isize)) -> String {\n   |                               \
    \                                                  - closing delimiter possibly\
    \ meant for this\n...\n61 |     let mut prime_numbers_length = vec![\n   |   \
    \                                     ^ unclosed delimiter\n62 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp781t6rkx.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp781t6rkx.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp781t6rkx.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp781t6rkx.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp781t6rkx.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp781t6rkx.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp781t6rkx.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp781t6rkx.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |  "
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \    }\n    if interval1_end < interval2_start {\n        return \"NO\";\n   \
    \ }\n    if interval1_start == interval2_start {\n        return \"NO\";\n   \
    \ }\n    if interval1_end == interval2_end {\n        return \"NO\";\n    }\n\
    \    if interval1_start == interval2_end {\n        return \"NO\";\n    }\n  \
    \  if interval1_start < interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_end > interval2_start {\n        return \"YES\";\n    }\n    return\
    \ \"YES\";\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `:`, found `=`\n  --> /tmp/tmpgvgtok4j.rs:26:42\n   |\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                         -^\n   |                       \
    \                  |\n   |                                         help: replace\
    \ equals symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found\
    \ `;`\n  --> /tmp/tmpgvgtok4j.rs:26:76\n   |\n25 |     if interval1_start > interval2_start\
    \ {\n   |                          --------------- while parsing this struct\n\
    26 |         interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \   |                                                                        \
    \    ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed here\n\
    \  --> /tmp/tmpgvgtok4j.rs:25:26\n   |\n25 |       if interval1_start > interval2_start\
    \ {\n   |  __________________________^\n26 | |         interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n27 | |     }\n   | |_____^\n   |\nhelp:\
    \ surround the struct literal with parentheses\n   |\n25 ~     if interval1_start\
    \ > (interval2_start {\n26 |         interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n27 ~     })\n   |\n\nerror: expected `:`, found `=`\n  -->\
    \ /tmp/tmpgvgtok4j.rs:29:38\n   |\n29 |         interval1_end, interval2_end =\
    \ interval2_end, interval1_end;\n   |                                     -^\n\
    \   |                                     |\n   |                            \
    \         help: replace equals symbol with a colon: `:`\n\nerror: expected one\
    \ of `,` or `}`, found `;`\n  --> /tmp/tmpgvgtok4j.rs:29:68\n   |\n28 |     if\
    \ interval1_end < interval2_end {\n   |                        ------------- while\
    \ parsing this struct\n29 |         interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n   |                                                       \
    \             ^ expected one of `,` or `}`\n\nerror: struct literals are not allowed\
    \ here\n  --> /tmp/tmpgvgtok4j.rs:28:24\n   |\n28 |       if interval1_end < interval2_end\
    \ {\n   |  ____________"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    let mut intersection_start = interval1_start;\n    let\
    \ mut intersection_end = interval1_end;\n    if interval1_start > interval1_end\
    \ {\n        interval1_start = interval1_end;\n        interval1_end = interval1_start;\n\
    \    }\n    if interval2_start > interval2_end {\n        interval2_start = interval2_end;\n\
    \        interval2_end = interval2_start;\n    }\n    if interval1_start > interval2_start\
    \ {\n        intersection_start = interval2_start;\n        intersection_end =\
    \ interval2_end;\n    }\n    if interval1_end < interval2_end {\n        intersection_start\
    \ = interval1_start;\n        intersection_end = interval1_end;\n    }\n    if\
    \ intersection_start > intersection_end {\n        intersection_start = intersection_end;\n\
    \        intersection_end = intersection_start;\n    }\n    if intersection_start\
    \ == intersection_end {\n        return \"NO\";\n    }\n    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n        return \"YES\"\
    ;\n    }\n    if interval1_start <= intersection_start && interval1_end >= intersection_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start <= interval2_start\
    \ && intersection_start <= intersection_end {\n        return \"YES\";\n    }\n\
    \    if interval1_start <= intersection_start && interval2_start <= intersection_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_start <= interval2_start\
    \ && intersection_start <= interval2_end {\n        return \"YES\";\n    }\n \
    \   if interval1_start <= intersection_start && interval2_start <= intersection_end\
    \ {\n        return \"YES\";\n    }\n    if interval1_end >= interval2_start &&\
    \ intersection_start <= interval2_end {\n        return \"YES\";\n    }\n    if\
    \ interval1_end >= intersection_start && interval2_start <= intersection_end {\n\
    \        return \"YES\";\n    }\n    if interval1_end >= interval2_start && intersection_start\
    \ <= interval2_end {\n        return \"YES\";\n    }\n    if interval1_end >=\
    \ intersection_start && interval2_start <= intersection_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_end >= interval2_start && intersection_start\
    \ <= interval2_end {\n        return \"YES\";\n    }\n    if interval1_end >=\
    \ intersection_start && interval2_start <= intersection_end {\n        return\
    \ \"YES\";\n    }\n    if interval1_end >= interval2_start \n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `}`\n  --> /tmp/tmpdk7ypoov.rs:87:1\n   |\n\
    86 |     if interval1_end >= interval2_start \n   |     -- this `if` expression\
    \ has a condition, but no block\n87 | }\n   | ^ expected `{`\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdk7ypoov.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdk7ypoov.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdk7ypoov.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdk7ypoov.rs:92:25\n\
    \   |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdk7ypoov.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdk7ypoov.rs:93:25\n   |\n93 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdk7ypoov.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdk7ypoov.rs:94:25\n   |\n94 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdk7ypoov.rs:95:17\n  \
    \ |\n95 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdk7ypoov.rs:95:25\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerro"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    if interval1[0] < interval1[1] && interval2[0] < interval2[1]\
    \ {\n        if interval1[0] < interval2[0] {\n            return \"NO\";\n  \
    \      }\n        if interval1[1] > interval2[1] {\n            return \"NO\"\
    ;\n        }\n        if interval1[0] == interval2[0] {\n            return \"\
    YES\";\n        }\n        if interval1[1] == interval2[1] {\n            return\
    \ \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb0gsw2nv.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb0gsw2nv.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb0gsw2nv.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb0gsw2nv.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb0gsw2nv.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval1_start = interval1[0];\n    let mut interval1_end\
    \ = interval1[1];\n    let mut interval2_start = interval2[0];\n    let mut interval2_end\
    \ = interval2[1];\n    if interval1_start > interval2_start {\n        interval1_start,\
    \ interval1_end = interval2_start, interval1_end;\n    }\n    if interval1_end\
    \ < interval2_end {\n        interval1_end, interval1_start = interval2_end, interval1_start;\n\
    \    }\n    if interval1_start <= interval1_end && interval2_start <= interval2_end\
    \ {\n        if interval1_start < interval2_start {\n            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n        }\n        if interval1_end\
    \ > interval2_end {\n            interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n        }\n        if interval1_start <= interval2_start &&\
    \ interval1_end >= interval2_end {\n            if interval1_start < interval2_start\
    \ {\n                interval1_start, interval2_start = interval2_start, interval1_start;\n\
    \            }\n            if interval1_end > interval2_end {\n             \
    \   interval1_end, interval2_end = interval2_end, interval1_end;\n           \
    \ }\n            if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n                if interval1_start < interval2_start {\n                \
    \    interval1_start, interval2_start = interval2_start, interval1_start;\n  \
    \              }\n                if interval1_end > interval2_end {\n       \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \               }\n                if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n                    if interval1_start < interval2_start\
    \ {\n                        interval1_start, interval2_start = interval2_start,\
    \ interval1_start;\n                    }\n                    if interval1_end\
    \ > interval2_end {\n                        interval1_end, interval2_end = interval2_end,\
    \ interval1_end;\n                    }\n                    if interval1_start\
    \ <= interval2_start && interval1_end >= interval2_end {\n                   \
    \     if interval1_start < interval2_start {\n                            interval1_start,\
    \ interval2_start = interval2_start, interval1_start;\n                      \
    \  }\n                        if interval1_end > interval2_end {\n           \
    \                 interval1_end, interval2_end = interval2_end, interval1_end;\n\
    \                        }\n                        if interval1_start <= interval2_start\
    \ && interval1_end >= interval2_end {\n                            if interval1_start\
    \ < interval2_start {\n                                interval1_start, interval2_start\
    \ = interval2_start, interval1_start;\n                            }\n       \
    \                     if interval1_end > interval2_end {\n                   \
    \             interval1_end, interval2_end = interval2_end, interval1_end;\n \
    \                           }\n\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpomldu9w6.rs:86:3\n\
    \   |\n20 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n31 |     if interval1_start\
    \ <= interval1_end && interval2_start <= interval2_end {\n   |               \
    \                                                              - unclosed delimiter\n\
    ...\n38 |         if interval1_start <= interval2_start && interval1_end >= interval2_end\
    \ {\n   |                                                                    \
    \             - unclosed delimiter\n...\n45 |             if interval1_start <=\
    \ interval2_start && interval1_end >= interval2_end {\n   |                  \
    \                                                                   - unclosed\
    \ delimiter\n...\n52 |                 if interval1_start <= interval2_start &&\
    \ interval1_end >= interval2_end {\n   |                                     \
    \                                                    - unclosed delimiter\n...\n\
    59 |                     if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n   |                                                   \
    \                                          - unclosed delimiter\n...\n66 |   \
    \                      if interval1_start <= interval2_start && interval1_end\
    \ >= interval2_end {\n   |                                                   \
    \                                              - this delimiter might not be properly\
    \ closed...\n...\n74 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n86 | }\n   |   ^\n\nerror: expected `:`, found `=`\n  --> /tmp/tmpomldu9w6.rs:26:40\n\
    \   |\n26 |         interval1_start, interval1_end = interval2_start, interval1_end;\n\
    \   |                                       -^\n   |                         \
    \              |\n   |                                       help: replace equals\
    \ symbol with a colon: `:`\n\nerror: expected one of `,` or `}`, found `;`\n \
    \ --> /tmp/tmpomldu9w6."
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut intervals = vec![];\n    intervals.push(interval1);\n\
    \    intervals.push(interval2);\n    let mut intersection = intervals.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut prime = true;\n    for interval in intervals {\n        if interval[0]\
    \ > interval[1] {\n            return String::from(\"NO\");\n        }\n    }\n\
    \    for interval in intervals {\n        let mut prime = true;\n        for interval2\
    \ in intervals {\n            if interval[0] == interval2[0] && interval[1] ==\
    \ interval2[1] {\n                prime = false;\n            }\n        }\n \
    \       if prime {\n            intersection.push(interval);\n        }\n    }\n\
    \    if intersection.len() == 1 {\n        return String::from(\"YES\");\n   \
    \ }\n    if intersection.len() == 2 {\n        return String::from(\"NO\");\n\
    \    }\n    if intersection.len() == 3 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 4 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 5 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 6 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 7 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 8 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 9 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 10 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 11 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 12 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 13 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 14 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 15 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 16 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 17 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 18 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 19 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 20 {\n        return String::from(\"NO\"\
    );\n    }\n    if intersection.len() == 21 {\n        return String::from(\"YES\"\
    );\n    }\n    if intersection.len() == 22 {\n        return String\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n   \
    \ assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4ln9xxye.rs:119:3\n\
    \    |\n20  | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    |                                                         \
    \                        - unclosed delimiter\n...\n105 |     if intersection.len()\
    \ == 22 {\n    |                                 - this delimiter might not be\
    \ properly closed...\n106 |         return String\n107 | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n119 | }\n    |   ^\n\nerror[E0434]:\
    \ can't capture dynamic environment in a fn item\n   --> /tmp/tmp4ln9xxye.rs:110:21\n\
    \    |\n110 |     let candidate = intersection;\n    |                     ^^^^^^^^^^^^\n\
    \    |\n    = help: use the `|| { ... }` closure form instead\n\nerror[E0423]:\
    \ expected value, found struct `String`\n   --> /tmp/tmp4ln9xxye.rs:106:16\n \
    \   |\n106 |           return String\n    |                  ^^^^^^ help: use\
    \ struct literal syntax instead: `String { vec: val }`\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n   --> /tmp/tmp4ln9xxye.rs:111:17\n    |\n\
    111 |     assert_eq!({left}, {right});\n    |                 ^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `right` in this scope\n   -->\
    \ /tmp/tmp4ln9xxye.rs:111:25\n    |\n111 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ln9xxye.rs:112:17\n\
    \    |\n112 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ln9xxye.rs:112:25\n    |\n112 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp4ln9xxye.rs:113:17\n\
    \    |\n113 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp4ln9xxye.rs:113:25\n    |\n113 |     assert_eq!({"
  stdout: ''
  timestamp: 1659821549
- exit_code: 1
  program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// >>> intersection((1,\
    \ 2), (2, 3))\n/// String::from(\"NO\")\n/// >>> intersection((-1, 1), (0, 4))\n\
    /// String::from(\"NO\")\n/// >>> intersection((-3, -1), (-5, 5))\n/// String::from(\"\
    YES\")\nfn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n    let mut interval = interval1;\n    if interval1[0] > interval2[1]\
    \ {\n        interval = interval2;\n    }\n    if interval[0] > interval[1] {\n\
    \        return \"NO\";\n    }\n    let mut len = 1;\n    let mut i = 1;\n   \
    \ while i <= interval[0] {\n        if interval[1] < i {\n            break;\n\
    \        }\n        i += 1;\n        len += 1;\n    }\n    if len == 2 {\n   \
    \     return \"YES\";\n    }\n    if len % 2 == 0 {\n        return \"NO\";\n\
    \    }\n    let mut i = 1;\n    let mut j = 1;\n    while i <= interval[1] {\n\
    \        if interval[0] < j {\n            break;\n        }\n        j += 1;\n\
    \        i += 1;\n    }\n    if j == 2 {\n        return \"YES\";\n    }\n   \
    \ if j % 2 == 0 {\n        return \"NO\";\n    }\n    let mut i = 1;\n    let\
    \ mut j = 1;\n    while i <= interval[0] {\n        if interval[1] < j {\n   \
    \         break;\n        }\n        j += 1;\n        i += 1;\n    }\n    if j\
    \ == 2 {\n        return \"YES\";\n    }\n    if j % 2 == 0 {\n        return\
    \ \"NO\";\n    }\n    let mut i = 1;\n    let mut j = 1;\n    while i <= interval[1]\
    \ {\n        if interval[0] < j {\n            break;\n        }\n        j +=\
    \ 1;\n        i += 1;\n    }\n    if j == 2 {\n        return \"YES\";\n    }\n\
    \    if j % 2 == 0 {\n        return \"NO\";\n    }\n    return \"NO\";\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpttnnmcq2.rs:93:17\n\
    \   |\n93 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpttnnmcq2.rs:93:25\n   |\n93 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpttnnmcq2.rs:94:17\n   |\n94 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpttnnmcq2.rs:94:25\n\
    \   |\n94 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpttnnmcq2.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpttnnmcq2.rs:95:25\n   |\n95 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpttnnmcq2.rs:96:17\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpttnnmcq2.rs:96:25\n   |\n96 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpttnnmcq2.rs:97:17\n  \
    \ |\n97 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpttnnmcq2.rs:97:25\n   |\n97 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpttnnmcq2.rs:98:17\n   |\n98 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find val"
  stdout: ''
  timestamp: 1659821549
