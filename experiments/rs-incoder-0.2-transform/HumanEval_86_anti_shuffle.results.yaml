language: rs
name: HumanEval_86_anti_shuffle
results:
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = s.len();\n            } else {\n            \
    \    new_s.push_str(&s[i .. j]);\n                new_s_len += j - i;\n      \
    \          i = j;\n                break;\n            }\n            j += 1\n\
    \        }\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                j = s.len();\n            } else {\n          \
    \      let mut c = s.chars().nth(j).unwrap();\n                let mut new_c =\
    \ c;\n                while c != ' ' {\n                    let mut new_c = new_c\
    \ + 1;\n                    if new_c > 122 {\n                        new_c =\
    \ 65;\n                    } else if new_c < 97 {\n                        new_c\
    \ = 97;\n                    }\n                    new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \                    j = j + 1;\n                }\n                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n    \
    \            new_s = new_s.chars().nth(new_c).unwrap().to_string();\n        \
    \        new_s = new_s.chars().nth(new_c).unwrap().to_string();\n            \
    \    new_s = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s\
    \ = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n    \
    \            new_s = new_s.chars().nth(new_c).unwrap().to_string();\n        \
    \        new_s = new_s.chars().nth(new_c).unwrap().to_string();\n            \
    \    new_s = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s\
    \ = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n    \
    \            new_s = new_s.chars().nth(new_c).unwrap().to_string();\n        \
    \        new_s = new_s.chars().nth(new_c).unwrap().to_string();\n            \
    \    new_s = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s\
    \ = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \                new_s = new_s.chars().nth(new_c).unwrap().to_string();\n    \
    \            new_s = new_s.chars().nth(new_c).unwrap().to_string();\n        \
    \        new_s = new_s.chars().nth(new_c).unwrap().to_string();\n            \
    \    new_s = new_s.chars().nth(new_c).unwrap().to_string();\n                new_s\
    \ = new_s.chars().\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprea241bs.rs:71:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    ...\n23 |             } else {\n   |                    - this delimiter might\
    \ not be properly closed...\n...\n60 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n71 | }\n   |   ^\n\nerror: unexpected token:\
    \ `}`\n  --> /tmp/tmprea241bs.rs:60:1\n   |\n60 | }\n   | ^\n\nerror[E0369]: cannot\
    \ add `{integer}` to `char`\n  --> /tmp/tmprea241bs.rs:27:43\n   |\n27 |     \
    \                let mut new_c = new_c + 1;\n   |                            \
    \         ----- ^ - {integer}\n   |                                     |\n  \
    \ |                                     char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprea241bs.rs:36:43\n   |\n36 |                 new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \   |                                           ^^^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprea241bs.rs:37:43\n\
    \   |\n37 |                 new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \   |                                           ^^^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprea241bs.rs:38:43\n\
    \   |\n38 |                 new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \   |                                           ^^^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprea241bs.rs:39:43\n\
    \   |\n39 |                 new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \   |                                           ^^^^^ expected `usize`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprea241bs.rs:40:43\n\
    \   |\n40 |                 new_s = new_s.chars().nth(new_c).unwrap().to_string();\n\
    \   |                                   "
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            new_s.push((s[j].to_ascii_lowercase()));\n\
    \            j += 1;\n        }\n        new_s_len += 1;\n        new_s.push(&mut\
    \ s[i]);\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpmyzb0zpd.rs:33:24\n\
    \   |\n33 |             new_s.push((s[j].to_ascii_lowercase()));\n   |       \
    \                 ^                         ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n33 -             new_s.push((s[j].to_ascii_lowercase()));\n\
    33 +             new_s.push(s[j].to_ascii_lowercase());\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmyzb0zpd.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmyzb0zpd.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmyzb0zpd.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implem"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j \n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptsfvofm1.rs:79:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    68 | }\n   | - ...as it matches this but it has different indentation\n...\n79\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmptsfvofm1.rs:67:29\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n67 |     \
    \    new_word.push_str(&s[j \n   |                             ^ unclosed delimiter\n\
    68 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmptsfvofm1.rs:21:16\n   |\n21 |  \
    \           if s[j] < s[i] {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptsfvofm1.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<u"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                j = j + 1;\n      \
    \          continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_symbol() {\n      \
    \          j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_whitespace() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_lowercase() {\n                j\
    \ = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_symbol() {\n      \
    \          j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_whitespace() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_lowercase() {\n                j\
    \ = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_symbol() {\n      \
    \          j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_whitespace() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_lowercase() {\n                j\
    \ = j + 1;\n                continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9hkfsg_i.rs:134:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - unclosed\
    \ delimiter\n...\n121 |             if s[j].is_ascii_punctuation() {\n    |  \
    \                                          - this delimiter might not be properly\
    \ closed...\n122 | \n123 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n134 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmp9hkfsg_i.rs:21:16\n   |\n21 |         \
    \    if s[j].is_whitespace() {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp9hkfsg_i.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cann"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n           \
    \ }\n            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n     \
    \       j += 1;\n        }\n        new_s[i] = new_s[new_s_len];\n        new_s_len\
    \ -= 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp95rekz51.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp95rekz51.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp95rekz51.rs:26:17\n   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        while j < new_s_len && s[j]\
    \ != ' ' {\n            new_s_char.insert(j, s[j]);\n            new_s_char_len\
    \ += 1;\n            j += 1\n        }\n        new_s.push_str(&new_s_char);\n\
    \        new_s_len = new_s_char_len;\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcbj8n3s3.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpcbj8n3s3.rs:23:13\n   |\n23 |         let\
    \ mut new_s_char = new_s[..j];\n   |             ^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n23 |         let mut new_s_char = &new_s[..j];\n   |           \
    \                   +\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpcbj8n3s3.rs:25:32\n   |\n25 |         while j < new_s_len\
    \ && s[j] != ' ' {\n   |                                ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `insert` found for type `str` in\
    \ the current scope\n  --> /tmp/tmpcb"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] < s[i]\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j] > s[i] {\n                let mut k = j;\n                while\
    \ k < new_s_len {\n                    if s[k] > s[i] {\n                    \
    \    k = k + 1;\n                        continue;\n                    }\n  \
    \                  new_s.push_str(&s[k..]);\n                    break;\n    \
    \            }\n                new_s.push_str(&s[0..k]);\n                new_s.push_str(&s[k..]);\n\
    \                break;\n            }\n            new_s.push_str(&s[0..]);\n\
    \            new_s.push_str(&s[..k]);\n            new_s.push_str(&s[k..]);\n\
    \            break;\n        }\n        i = j + 1;\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `k` in this scope\n   --> /tmp/tmpqrm7phlt.rs:40:33\n\
    \    |\n40  |             new_s.push_str(&s[..k]);\n    |                    \
    \             ^ help: a tuple variant with a similar name exists: `Ok`\n\nerror[E0425]:\
    \ cannot find value `k` in this scope\n   --> /tmp/tmpqrm7phlt.rs:41:31\n    |\n\
    41  |             new_s.push_str(&s[k..]);\n    |                            \
    \   ^ help: a tuple variant with a similar name exists: `Ok`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqrm7phlt.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqrm7phlt.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqrm7phlt.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not impl"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ = new_s_len - (j - i);\n        i = j;\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplk_99vot.rs:21:118\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n\
    \                new_s.push_str(&s[j]);\n                break;\n            }\n\
    \            j += 1\n        }\n        new_s.push_str(&s[i]);\n        new_s.push_str(&new_s[new_s_len\
    \ - 1]);\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn1754dut.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn1754dut.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn1754dut.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' && s[j] != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n                new_s.push_str(&s[j]);\n\
    \                j += 1;\n            } else {\n                break;\n     \
    \       }\n        }\n        if j == new_s_len {\n            new_s.push_str(&s[i]);\n\
    \            i += 1;\n        } else {\n            new_s.push_str(&s[new_s_len\
    \ - j]);\n            new_s_len -= j;\n        }\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptaez0c8b.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptaez0c8b.rs:21:31\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptaez0c8b.rs:21:47\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<"
  stdout: ''
  timestamp: 1660011735
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s[j] < s[i]\
    \ {\n                s.swap(j, i);\n            }\n            j += 1;\n     \
    \   }\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjcnvghho.rs:19:16\n\
    \   |\n19 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjcnvghho.rs:19:23\n   |\n19 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjcnvghho.rs:20:19\n   |\n20 |                 s.swap(j, i);\n   |  \
    \                 ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] < 97 {\n                s[j] = s[j] + 1;\n                j = j + 1;\n\
    \                continue;\n            }\n            if s[j] > 122 {\n     \
    \           s[j] = s[j] - 1;\n                j = j + 1;\n                continue;\n\
    \            }\n            s[j] = s[j] - 1;\n            j = j + 1;\n       \
    \ }\n        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpd9t_agna.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd9t_agna.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpd9t_agna.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpz9q19402.rs:15:7\n   |\n15 |     s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n   |      \
    \ ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[i] == s[j]\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[j] > s[i] {\n                new_s.push_str(&s[i .. j]);\n      \
    \          new_s.push_str(&[s[j].to_ascii_lowercase()]);\n                i =\
    \ j;\n                break;\n            }\n            j += 1\n        }\n \
    \       if j == s.len() {\n            new_s.push_str(&s[i .. new_s_len]);\n \
    \           new_s.push_str(&[s[i].to_ascii_lowercase()]);\n            i += 1;\n\
    \        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_iymswn1.rs:21:16\n\
    \   |\n21 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_iymswn1.rs:21:24\n   |\n21 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_iymswn1.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `Stri"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s[new_s_len] = s[j];\n            new_s_len +=\
    \ 1;\n            j += 1;\n        }\n        new_s[i] = new_s[new_s_len - 1];\n\
    \        new_s_len -= 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppm8df2by.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppm8df2by.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppm8df2by.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdzlw0chr.rs:17:15\n   |\n17 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1a616d0m.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1a616d0m.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push(*j);\n                break;\n            }\n        \
    \    j += 1;\n        }\n        let mut k = i;\n        while k < s.len() {\n\
    \            if s[k] != ' ' {\n                new_s.push(*k);\n             \
    \   break;\n            }\n            k += 1;\n        }\n        if new_s_len\
    \ < new_s.len() {\n            new_s.push_str(&new_s[new_s_len..]);\n        \
    \    new_s_len += 1;\n        }\n        new_s.push_str(&s[..]);\n        i +=\
    \ 1;\n    }\n    new_s.push_str(&new_s[new_s_len..]);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxoymkcvn.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpxoymkcvn.rs:22:28\n\
    \   |\n22 |                 new_s.push(*j);\n   |                            ^^\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxoymkcvn.rs:29:16\n\
    \   |\n29 |             if s[k] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpxoymkcvn.rs:30:28\n\
    \   |\n30 |                 new_s.push(*k);\n   |                            ^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        let mut j =\
    \ i;\n        while j < s.len() {\n            if s[i].chars().max().unwrap()\
    \ >= s[j].chars().max().unwrap() {\n                j = j + 1;\n            }\
    \ else {\n                break;\n            }\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpna33izy3.rs:21:16\n\
    \   |\n21 |             if s[i].chars().max().unwrap() >= s[j].chars().max().unwrap()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpna33izy3.rs:21:47\n\
    \   |\n21 |             if s[i].chars().max().unwrap() >= s[j].chars().max().unwrap()\
    \ {\n   |                                               ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_s_char = new_s[new_s_len - 1];\n \
    \       let mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_len = new_s_char.len();\n    \
    \        new_s_char = new_s[new_s_char_pos];\n        }\n        let mut new_s_char_pos\
    \ = new_s_len - 1;\n        while new_s_char_pos > i {\n            new_s_char_pos\
    \ = new_s_char_pos - 1;\n            new_s_char_\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpeyz07_jc.rs:86:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n72 |         while new_s_char_pos\
    \ > i {\n   |                                  - this delimiter might not be properly\
    \ closed...\n...\n75 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n86 | }\n   |   ^\n\nerror[E0425]: cannot find value `new_s_char_` in this\
    \ scope\n  --> /tmp/tmpeyz07_jc.rs:74:13\n   |\n74 |             new_s_char_\n\
    \   |             ^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `new_s_char`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeyz07_jc.rs:20:32\n   |\n20 |         while j < new_s_len && s[j]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpeyz07_jc.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \          "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len;\n    let mut new_s_len4 = new_s_len;\n    let mut new_s_len5 =\
    \ new_s_len;\n    let mut new_s_len6 = new_s_len;\n    let mut new_s_len7 = new_s_len;\n\
    \    let mut new_s_len8 = new_s_len;\n    let mut new_s_len9 = new_s_len;\n  \
    \  let mut new_s_len10 = new_s_len;\n    let mut new_s_len11 = new_s_len;\n  \
    \  let mut new_s_len12 = new_s_len;\n    let mut new_s_len13 = new_s_len;\n  \
    \  let mut new_s_len14 = new_s_len;\n    let mut new_s_len15 = new_s_len;\n  \
    \  let mut new_s_len16 = new_s_len;\n    let mut new_s_len17 = new_s_len;\n  \
    \  let mut new_s_len18 = new_s_len;\n    let mut new_s_len19 = new_s_len;\n  \
    \  let mut new_s_len20 = new_s_len;\n    let mut new_s_len21 = new_s_len;\n  \
    \  let mut new_s_len22 = new_s_len;\n    let mut new_s_len23 = new_s_len;\n  \
    \  let mut new_s_len24 = new_s_len;\n    let mut new_s_len25 = new_s_len;\n  \
    \  let mut new_s_len26 = new_s_len;\n    let mut new_s_len27 = new_s_len;\n  \
    \  let mut new_s_len28 = new_s_len;\n    let mut new_s_len29 = new_s_len;\n  \
    \  let mut new_s_len30 = new_s_len;\n    let mut new_s_len31 = new_s_len;\n  \
    \  let mut new_s_len32 = new_s_len;\n    let mut new_s_len33 = new_s_len;\n  \
    \  let mut new_s_len34 = new_s_len;\n    let mut new_s_len35 = new_s_len;\n  \
    \  let mut new_s_len36 = new_s_len;\n    let mut new_s_len37 = new_s_len;\n  \
    \  let mut new_s_len38 = new_s_len;\n    let mut new_s_len39 = new_s_len;\n  \
    \  let mut new_s_len40 = new_s_len;\n    let mut new_s_len41 = new_s_len;\n  \
    \  let mut new_s_len42 = new_s_len;\n    let mut new_s_len43 = new_s_len;\n  \
    \  let mut new_s_len44 = new_s_len;\n    let mut new_s_len45 = new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpw9arxnqf.rs:60:31\n   |\n\
    60 |     let mut new_s_len45 = new_\n   |                               ^ help:\
    \ add `;` here\n61 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `new_` in this scope\n  --> /tmp/tmpw9arxnqf.rs:60:27\n   |\n60 |     let mut\
    \ new_s_len45 = new_\n   |                           ^^^^ help: a local variable\
    \ with a similar name exists: `new_s`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw9arxnqf.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |    ------------               ^^^^^^ expected struct `String`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s[j] < s[i]\
    \ {\n                let tmp = s[j];\n                s[j] = s[i];\n         \
    \       s[i] = tmp;\n            }\n            j += 1\n        }\n        i +=\
    \ 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps_r3ans7.rs:19:16\n\
    \   |\n19 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmps_r3ans7.rs:19:23\n   |\n19 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps_r3ans7.rs:20:27\n\
    \   |\n20 |                 let tmp = s[j];\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n\
    \                continue;\n            }\n            if s[j] < 123 {\n     \
    \           s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            break;\n        }\n        new_s.push_str(&s[i ..\
    \ j]);\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5lc3obe7.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5lc3obe7.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5lc3obe7.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut new_word = String::new();\n     \
    \           new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. (j + 1)]);\n            \
    \    new_word.push_str(&s[(j + 1) .. (i + 1)]);\n                new_word.push_str(&s[(j\
    \ + 1) .. (i + 1)]);\n                new_word.push_str(&s[i .. (j + 1)]);\n \
    \               new_word.push_str(&s[(j + 1) .. (i + 1)]);\n                new_word.push_str(&s[i\
    \ .. (j + 1)]);\n                new_word.push_str(&s[(j + 1) .. (i + 1)]);\n\
    \                new_word.push_str(&s[i .. (j + 1)]);\n                new_word.push_str(&s[(j\
    \ + 1) .. (i + 1)]);\n                new_word.push_str(&s[i .. (j + 1)]);\n \
    \               new_word.push_str(&s[(j + 1) .. (i + 1)]);\n                new_word.push_str(&s[i\
    \ .. (j + 1)]);\n                new_word.push_str(&s[(j + 1) .. (i + 1)]);\n\
    \                new_word.push_str(&s[i .. (j + 1)]);\n                new_word.push_str(&s[(j\
    \ + 1) .. (i + 1)]);\n                new_word.push_str(&s[i .. (j + 1)]);\n \
    \               new_word.push_str(&s[(j + 1) .. (i + 1)]);\n                new_word.push_str(&s[i\
    \ .. (j + 1)]);\n                new_word.push_str(&s[(j + 1) .. (i + 1)]);\n\
    \                new_word.push_str(&s[i .. (j + 1)]);\n                new_word.push_str(&s[(j\
    \ + 1) .. (i + 1)]);\n                new_word.push_str(&s[i .. (j + 1)]);\n \
    \               new_word.push_str(&s[(j + 1) .. (i + 1)]);\n                new_word.push_str(&s[i\
    \ .. (j + 1)]);\n                new_word.push_str(&s[(j + 1) .. (i + 1)]);\n\
    \                new_word.push_str(&s[i .. (j + 1)]);\n                new_word.push_str(&s[(j\
    \ + 1) .. (i + 1)]);\n                new_word.push_str(&s[i .. (j + 1)]);\n \
    \               new_word.push_str(\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbak3py_k.rs:69:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    ...\n25 |             if s[j] > s[i] {\n   |                            - this\
    \ delimiter might not be properly closed...\n...\n58 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n69 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpbak3py_k.rs:57:34\n   |\n13 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n57 |                 new_word.push_str(\n   |\
    \                                  ^ unclosed delimiter\n58 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbak3py_k.rs:21:16\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbak3py_k.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<Rang"
  stdout: ''
  timestamp: 1660011735
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] >= s[i] {\n                j += 1;\n      \
    \      } else {\n                break;\n            }\n        }\n        let\
    \ mut new_char = s[i..j].chars().collect::<Vec<_>>();\n        new_char.sort();\n\
    \        new_s.push_str(&new_char);\n        i = j;\n    }\n    new_s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe8towq5y.rs:20:16\n\
    \   |\n20 |             if s[j] >= s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe8towq5y.rs:20:24\n   |\n20 |             if s[j] >= s[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe8towq5y.rs:28:24\n   |\n28 |         new_s.push_str(&new_char);\n\
    \   |                        ^^^^^^^^^ expected `str`, found struct `Vec`\n  \
    \ |\n   = note: expected reference `&str`\n              found reference `&Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        while new_s_char_len > 0 &&\
    \ new_s_char[new_s_char_len - 1] == ' ' {\n            new_s_char_len -= 1;\n\
    \        }\n        new_s_char.truncate(new_s_char_len);\n        new_s.push_str(&new_s_char);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpikspyosu.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmpikspyosu.rs:23:13\n   |\n23 |         let\
    \ mut new_s_char = new_s[..j];\n   |             ^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n23 |         let mut new_s_char = &new_s[..j];\n   |           \
    \                   +\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpikspyosu.rs:25:37\n   |\n25 |         while new_s_char_len > 0\
    \ && new_s_char[new_s_char_len - 1] == ' ' {\n   |                           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0599]: no method named `truncate` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpikspyosu.rs:28:20\n   |\n28 |         new_s_char.truncate(new_s_char_len);\n\
    \   |                    ^^^^^^^^ method not found in `str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(&s[i ..]);\n        new_word.push_str(&s[i\
    \ ..]);\n        new_word.push_str(\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4597u7ve.rs:83:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    72 | }\n   | - ...as it matches this but it has different indentation\n...\n83\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp4597u7ve.rs:71:26\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n71 |     \
    \    new_word.push_str(\n   |                          ^ unclosed delimiter\n\
    72 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmp4597u7ve.rs:21:16\n   |\n21 |  \
    \           if s[j] < s[i] {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4597u7ve.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' {\n                new_s.push_str(&s[j]);\n                break;\n      \
    \      }\n            j += 1; // skip space\n        }\n        if j == new_s_len\
    \ {\n            new_s.push_str(&s[new_s_len]);\n            break;\n        }\n\
    \        let mut k = j;\n        while k < new_s_len {\n            if s[k] >\
    \ s[i] {\n                new_s.push_str(&s[k]);\n                break;\n   \
    \         }\n            k += 1; // skip space\n        }\n        if k == new_s_len\
    \ {\n            new_s.push_str(&s[new_s_len]);\n            break;\n        }\n\
    \        new_s.push_str(&s[new_s_len]);\n        new_s.push_str(&s[k]);\n    \
    \    new_s.push_str(&s[j]);\n        i += 1;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcdmegyl1.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcdmegyl1.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcdmegyl1.rs:28:29\n   |\n28 |             new_s.push_str(&s[new_s_len]);\n\
    \   |                             ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n        "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ == -1 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \        new_s_len += 1;\n        i = j;\n    }\n    new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \    new_s_len += 1;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph9i8s27u.rs:21:119\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ == -1 {\n   |                                                              \
    \                                                         ^^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph9i8s27u.rs:27:24\n\
    \   |\n27 |         new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph9i8s27u.rs:31:20\n\
    \   |\n31 |     new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[..j]);\n                new_s.push_str(&s[j..]);\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcx_p4852.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcx_p4852.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut i\
    \ = 0;\n    while i < new_s_len {\n        let mut j = i;\n        while j < new_s_len\
    \ {\n            if s.chars().next().unwrap().to_ascii_lowercase() < s.chars().next().unwrap().to_ascii_lowercase()\
    \ {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[..j]);\n        new_s_len2\
    \ = new_s_len2 - 1;\n        i = j;\n    }\n    new_s.push_str(&s[..new_s_len2]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpc49ok1pq.rs:29:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len && s[k] == ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = s.split_whitespace().nth(j).unwrap();\n\
    \        new_word.sort_by_key(|&x| x.chars().next().unwrap().to_ascii_lowercase());\n\
    \        new_s.push_str(&new_word);\n        i = k + 1;\n    }\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvd21_t5a.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvd21_t5a.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `sort_by_key` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpvd21_t5a.rs:34:18\n   |\n34 |   \
    \      new_word.sort_by_key(|&x| x.chars().next().unwrap().to_ascii_lowercase());\n\
    \   |                  ^^^^^^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdzlw0chr.rs:17:15\n   |\n17 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut new_s_char = new_s[i];\n \
    \       while j < new_s_len && new_s[j].is_whitespace() {\n            new_s_char\
    \ += new_s[j];\n            j = j + 1;\n        }\n        new_s[i] = new_s_char;\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0bk0h9it.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0bk0h9it.rs:23:30\n\
    \   |\n23 |         let mut new_s_char = new_s[i];\n   |                     \
    \         ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0bk0h9it.rs:24:32\n   |\n24 |         while j < new_s_len && new_s[j].is_whitespace()\
    \ {\n   |                                ^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \       "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            }\n        }\n        let mut new_s_char\
    \ = new_s[new_s_len..new_s_len + j].chars();\n        let mut new_s_char_len =\
    \ new_s_char.len();\n        let mut new_s_char_iter: CharIter = s.chars();\n\
    \        while new_s_char_iter.next() != Some(0) {\n            let mut new_s_char_char_iter\
    \ = new_s_char.chars();\n            while new_s_char_char_iter.next() != Some(0)\
    \ {\n                if new_s_char_char_iter.peek() == Some(0) {\n           \
    \         new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \                    new_s_char_char_iter.next();\n                    new_s_char_char_iter.next();\n\
    \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5rdilkah.rs:94:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n...\n28 |         while new_s_char_iter.next()\
    \ != Some(0) {\n   |                                                 - unclosed\
    \ delimiter\n29 |             let mut new_s_char_char_iter = new_s_char.chars();\n\
    30 |             while new_s_char_char_iter.next() != Some(0) {\n   |        \
    \                                                  - unclosed delimiter\n31 |\
    \                 if new_s_char_char_iter.peek() == Some(0) {\n   |          \
    \                                                 - this delimiter might not be\
    \ properly closed...\n...\n83 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n94 | }\n   |   ^\n\nerror[E0412]: cannot find type `CharIter`\
    \ in this scope\n  --> /tmp/tmp5rdilkah.rs:27:34\n   |\n27 |         let mut new_s_char_iter:\
    \ CharIter = s.chars();\n   |                                  ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5rdilkah.rs:21:16\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5rdilkah.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s.push_str(&s[i .. j]);\n            new_s_len\
    \ += 1;\n            i += 1;\n            j = i;\n        }\n        new_s.push_str(&s[i\
    \ .. new_s_len]);\n        new_s_len += 1;\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplsz88r_e.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplsz88r_e.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplsz88r_e.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                j = j + 1;\n    \
    \        } else {\n                break;\n            }\n        }\n        if\
    \ j == i {\n            new_s.push_str(&s[i]);\n        } else {\n           \
    \ new_s.push_str(&s[i .. j]);\n            new_s.push_str(&s[j]);\n        }\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe2f69v3v.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe2f69v3v.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe2f69v3v.rs:27:29\n\
    \   |\n27 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                new_s.push_str(&s[i .. j]);\n  \
    \              new_s_len += j - i;\n                i = j;\n                break;\n\
    \            }\n            j += 1; // skip space\n        }\n        if i !=\
    \ j {\n            new_s.push_str(&s[i .. j]);\n            new_s_len += j - i;\n\
    \        }\n        i += 1;\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb1q1dv27.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb1q1dv27.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb1q1dv27.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011735
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                new_s.push_str(&s[..j]);\n                new_s.push_str(&s[j..]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmpcqdk8f9z.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ' || c == '\\n' || c == '\\t') {\n                j = s.len();\n      \
    \      } else {\n                new_s.push_str(&s[..j]);\n                new_s_len\
    \ += j;\n                j = i;\n            }\n        }\n        new_s.push_str(&s[..i]);\n\
    \        new_s_len += i;\n        i = j;\n    }\n    new_s.push_str(&s[..new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().any(|c| c != ' ') {\n            i += 1;\n        } else\
    \ {\n            s.swap(i, i + 1);\n            i += 1;\n        }\n    }\n  \
    \  s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4ir1paj9.rs:20:15\n   |\n20 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' {\n                new_s.push_str(&s[j]);\n                break;\n      \
    \      }\n            j += 1; // skip space\n        }\n        if j == new_s_len\
    \ {\n            new_s.push_str(&s[i]);\n            break;\n        }\n     \
    \   let mut k = i;\n        while k < new_s_len {\n            if new_s[k] !=\
    \ ' ' {\n                new_s.push_str(&new_s[k]);\n                break;\n\
    \            }\n            k += 1; // skip space\n        }\n        if k ==\
    \ new_s_len {\n            new_s.push_str(&new_s[i]);\n            break;\n  \
    \      }\n        let mut l = i;\n        while l < new_s_len {\n            if\
    \ new_s[l] != ' ' {\n                new_s.push_str(&new_s[l]);\n            \
    \    break;\n            }\n            l += 1; // skip space\n        }\n   \
    \     if l == new_s_len {\n            new_s.push_str(&new_s[i]);\n          \
    \  break;\n        }\n        let mut m = i;\n        while m < new_s_len {\n\
    \            if new_s[m] != ' ' {\n                new_s.push_str(&new_s[m]);\n\
    \                break;\n            }\n            m += 1; // skip space\n  \
    \      }\n        if m == new_s_len {\n            new_s.push_str(&new_s[i]);\n\
    \            break;\n        }\n        let mut n = i;\n        while n < new_s_len\
    \ {\n            if new_s[n] != ' ' {\n                new_s.push_str(&new_s[n]);\n\
    \                break;\n            }\n            n += 1; // skip space\n  \
    \      }\n        if n == new_s_len {\n            new_s.push_str(&new_s[i]);\n\
    \            break;\n        }\n        let mut o = i;\n        while o < new_s_len\
    \ {\n            if new_s[o] != ' ' {\n                new_s.push_str(&new_s[o]);\n\
    \                break;\n            }\n            o += 1; // skip space\n  \
    \      }\n        if o == new_s_len {\n            new_s.push_str(&new_s[i]);\n\
    \            break;\n        }\n        let mut p = i;\n        while p < new_s_len\
    \ {\n            if new_s[p] != ' ' {\n                new_s.push_str(&new_s[p]);\n\
    \                break;\n            }\n            p += 1; // skip space\n  \
    \      }\n        if p == new_s_len {\n            new_s.push_str(&new_s[i]);\n\
    \            break;\n        }\n        let mut q = i;\n        while q < new_s_len\
    \ {\n            if new_s[q] != ' ' {\n                new_s.push_str(&\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphecg1u7m.rs:118:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < new_s_len\
    \ {\n    |                         - unclosed delimiter\n...\n104 |         while\
    \ q < new_s_len {\n    |                             - unclosed delimiter\n105\
    \ |             if new_s[q] != ' ' {\n    |                                - this\
    \ delimiter might not be properly closed...\n106 |                 new_s.push_str(&\n\
    107 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    118 | }\n    |   ^\n\nerror: expected expression, found `)`\n   --> /tmp/tmphecg1u7m.rs:107:1\n\
    \    |\n107 | }\n    | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n   --> /tmp/tmphecg1u7m.rs:106:31\n    |\n13  | fn anti_shuffle(s: String)\
    \ -> String {\n    |                                      - closing delimiter\
    \ possibly meant for this\n...\n106 |                 new_s.push_str(&\n    |\
    \                               ^ unclosed delimiter\n107 | }\n    | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphecg1u7m.rs:21:16\n   |\n21 |             if s[j] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphecg1u7m.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j = j + 1;\n                continue;\n            }\n\
    \            if s[j] == ' ' {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                let temp = s[i];\n\
    \                s[i] = s[j];\n                s[j] = temp;\n            }\n \
    \           j = j + 1;\n        }\n        new_s.push_str(&s[i]);\n        i =\
    \ i + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzxa_2ig0.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzxa_2ig0.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzxa_2ig0.rs:29:16\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                new_s.push_str(&s[..j]);\n                new_s_len\
    \ += j - i;\n                j = i;\n            } else {\n                new_s.push_str(&s[j..]);\n\
    \                new_s_len += j - i;\n                break;\n            }\n\
    \            j += 1\n        }\n        new_s.push_str(&s[..i]);\n        new_s_len\
    \ += i - j;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"HiiH\"`,\n right: `\"Hi\"`', /tmp/tmpjddcr0e5.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] < s[i] {\n                let mut temp = s[j];\n\
    \                s[j] = s[i];\n                s[i] = temp;\n                j\
    \ = i;\n            }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn9hdtt2u.rs:20:16\n\
    \   |\n20 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpn9hdtt2u.rs:20:23\n   |\n20 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpn9hdtt2u.rs:21:32\n\
    \   |\n21 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E"
  stdout: ''
  timestamp: 1660011735
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                new_s.push_str(&s[i .. j]);\n    \
    \            new_s.push_str(&\" \");\n                i = j;\n               \
    \ break;\n            }\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1;\n        }\n        new_s.push_str(&s[i]);\n    \
    \    new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4rtrdm6y.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rtrdm6y.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4rtrdm6y.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut temp = s[j];\n                s[j]\
    \ = s[i];\n                s[i] = temp;\n                j = j + 1;\n        \
    \        continue;\n            }\n            break;\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        new_s_len += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm1495r4n.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm1495r4n.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm1495r4n.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String`"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        let mut new_s_word = s.split_off(j).collect::<Vec<_>>();\n\
    \        let mut new_s_word_len = new_s_word.len();\n        while new_s_word_len\
    \ > 0 {\n            let mut new_s_word = new_s_word.iter().cloned().collect::<Vec<_>>();\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_word.sort_by_key(|&x| x.chars().count());\n            new_s_word.sort_by_key(|&x|\
    \ x.chars().count());\n            new_s_word.sort_by_key(|&x| x.chars().count());\n\
    \            new_s_\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg84sodxp.rs:63:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n25 |         while new_s_word_len\
    \ > 0 {\n   |                                  - this delimiter might not be properly\
    \ closed...\n...\n52 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n63 | }\n   |   ^\n\nerror[E0425]: cannot find value `new_s_` in this scope\n\
    \  --> /tmp/tmpg84sodxp.rs:51:13\n   |\n51 |             new_s_\n   |        \
    \     ^^^^^^ help: a local variable with a similar name exists: `new_s`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg84sodxp.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpg84sodxp.rs:23:45\n\
    \    |\n23  |           let mut new_s_word = s.split_off(j).collect::<Vec<_>>();\n\
    \    |                                               ^^^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg84sodxp.rs:18:5\n   |\n13 |   fn anti_shuffle(s: String)\
    \ -> String {\n   |            "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n   \
    \             continue;\n            }\n            if s[j] > 122 {\n        \
    \        s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            new_s[new_s_len] = s[j];\n            new_s_len +=\
    \ 1;\n            j += 1;\n        }\n        i = j;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqih8uz4k.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqih8uz4k.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqih8uz4k.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1wd3qpps.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1wd3qpps.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1wd3qpps.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(&s[j..]);\n\
    \                new_s.push_str(&s[j..]);\n                new_s.push_str(\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph0rm0t7r.rs:86:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < new_s_len {\n   |                             - unclosed\
    \ delimiter\n...\n25 |             if s[j].is_ascii_lowercase() {\n   |      \
    \                                    - this delimiter might not be properly closed...\n\
    ...\n75 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    86 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmph0rm0t7r.rs:74:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n74 |     \
    \            new_s.push_str(\n   |                               ^ unclosed delimiter\n\
    75 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmph0rm0t7r.rs:21:16\n   |\n21 |  \
    \           if s[j].is_whitespace() {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph0rm0t7r.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFr"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase()\
    \ < s.chars().nth(i).unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        if j > i {\n            s.swap(i, j);\n            i = j;\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp27qscgei.rs:26:15\n   |\n26 |             s.swap(i, j);\n\
    \   |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len.saturating_add((new_s_len.saturating_add(1)\
    \ as usize));\n    let mut new_s_len3 = new_s_len2.saturating_add((new_s_len2.saturating_add(1)\
    \ as usize));\n    let mut new_s_len4 = new_s_len3.saturating_add((new_s_len3.saturating_add(1)\
    \ as usize));\n    let mut new_s_len5 = new_s_len4.saturating_add((new_s_len4.saturating_add(1)\
    \ as usize));\n    let mut new_s_len6 = new_s_len5.saturating_add((new_s_len5.saturating_add(1)\
    \ as usize));\n    let mut new_s_len7 = new_s_len6.saturating_add((new_s_len6.saturating_add(1)\
    \ as usize));\n    let mut new_s_len8 = new_s_len7.saturating_add((new_s_len7.saturating_add(1)\
    \ as usize));\n    let mut new_s_len9 = new_s_len8.saturating_add((new_s_len8.saturating_add(1)\
    \ as usize));\n    let mut new_s_len10 = new_s_len9.saturating_add((new_s_len9.saturating_add(1)\
    \ as usize));\n    let mut new_s_len11 = new_s_len10.saturating_add((new_s_len10.saturating_add(1)\
    \ as usize));\n    let mut new_s_len12 = new_s_len11.saturating_add((new_s_len11.saturating_add(1)\
    \ as usize));\n    let mut new_s_len13 = new_s_len12.saturating_add((new_s_len12.saturating_add(1)\
    \ as usize));\n    let mut new_s_len14 = new_s_len13.saturating_add((new_s_len13.saturating_add(1)\
    \ as usize));\n    let mut new_s_len15 = new_s_len14.saturating_add((new_s_len14.saturating_add(1)\
    \ as usize));\n    let mut new_s_len16 = new_s_len15.saturating_add((new_s_len15.saturating_add(1)\
    \ as usize));\n    let mut new_s_len17 = new_s_len16.saturating_add((new_s_len16.saturating_add(1)\
    \ as usize));\n    let mut new_s_len18 = new_s_len17.saturating_add((new_s_len17.saturating_add(1)\
    \ as usize));\n    let mut new_s_len19 = new_s_len\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9tnl5eum.rs:34:36\n   |\n\
    34 |     let mut new_s_len19 = new_s_len\n   |                               \
    \     ^ help: add `;` here\n35 | }\n   | - unexpected token\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmp9tnl5eum.rs:17:51\n   |\n\
    17 |     let mut new_s_len2 = new_s_len.saturating_add((new_s_len.saturating_add(1)\
    \ as usize));\n   |                                                   ^      \
    \                              ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n17 -     let mut new_s_len2\
    \ = new_s_len.saturating_add((new_s_len.saturating_add(1) as usize));\n17 +  \
    \   let mut new_s_len2 = new_s_len.saturating_add(new_s_len.saturating_add(1)\
    \ as usize);\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp9tnl5eum.rs:18:52\n   |\n18 |     let mut new_s_len3 = new_s_len2.saturating_add((new_s_len2.saturating_add(1)\
    \ as usize));\n   |                                                    ^     \
    \                                ^\n   |\nhelp: remove these parentheses\n   |\n\
    18 -     let mut new_s_len3 = new_s_len2.saturating_add((new_s_len2.saturating_add(1)\
    \ as usize));\n18 +     let mut new_s_len3 = new_s_len2.saturating_add(new_s_len2.saturating_add(1)\
    \ as usize);\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp9tnl5eum.rs:19:52\n   |\n19 |     let mut new_s_len4 = new_s_len3.saturating_add((new_s_len3.saturating_add(1)\
    \ as usize));\n   |                                                    ^     \
    \                                ^\n   |\nhelp: remove these parentheses\n   |\n\
    19 -     let mut new_s_len4 = new_s_len3.saturating_add((new_s_len3.saturating_add(1)\
    \ as usize));\n19 +     let mut new_s_len4 = new_s_len3.saturating_add(new_s_len3.saturating_add(1)\
    \ as usize);\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmp9tnl5eum.rs:20:52\n   |\n20 |     let mut new_s_len5 = new_s_len4.saturating_add((new_s_len4.saturating_add(1)\
    \ as usize));\n   |                      "
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' {\n                new_s.push_str(&s[j..]);\n                break;\n    \
    \        }\n            j += 1;\n        }\n        if j == new_s_len {\n    \
    \        new_s.push_str(&s[0..i]);\n            break;\n        }\n        let\
    \ mut k = i;\n        while k < new_s_len {\n            if s[k] != ' ' {\n  \
    \              new_s.push_str(&s[k..]);\n                break;\n            }\n\
    \            k += 1;\n        }\n        if k == new_s_len {\n            new_s.push_str(&s[0..i]);\n\
    \            break;\n        }\n        let mut j = i;\n        while j < new_s_len\
    \ {\n            if s[j] != ' ' {\n                new_s.push_str(&s[j..]);\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   if j == new_s_len {\n            new_s.push_str(&s[0..i]);\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len {\n          \
    \  if s[k] != ' ' {\n                new_s.push_str(&s[k..]);\n              \
    \  break;\n            }\n            k += 1;\n        }\n        if k == new_s_len\
    \ {\n            new_s.push_str(&s[0..i]);\n            break;\n        }\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' {\n                new_s.push_str(&s[j..]);\n                break;\n    \
    \        }\n            j += 1;\n        }\n        if j == new_s_len {\n    \
    \        new_s.push_str(&s[0..i]);\n            break;\n        }\n        let\
    \ mut k = i;\n        while k < new_s_len {\n            if s[k] != ' ' {\n  \
    \              new_s.push_str(&s[k..]);\n                break;\n            }\n\
    \            k += 1;\n        }\n        if k == new_s_len {\n            new_s.push_str(&s[0..i]);\n\
    \            break;\n        }\n        let mut j = i;\n        while j < new_s_len\
    \ {\n            if s[j] != ' ' {\n                new_s.push_str(&s[j..]);\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   if j == new_s_len {\n            new_s.push_str(&s[0..i]);\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len {\n          \
    \  if s[k] != ' ' {\n                new_s.push_str(&s[k..]);\n              \
    \  break;\n            }\n            k += 1;\n        }\n        if k == new_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp2_ftcauc.rs:123:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < new_s_len\
    \ {\n    |                         - this delimiter might not be properly closed...\n\
    ...\n112 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n123 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp2_ftcauc.rs:112:1\n\
    \    |\n111 |         if k == new_\n    |         -- this `if` expression has\
    \ a condition, but no block\n112 | }\n    | ^ expected `{`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2_ftcauc.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2_ftcauc.rs:33:16\n   |\n33 |             if s[k] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2_ftcauc.rs:45:16\n   |\n45 |  "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            let mut c = s[j];\n            s[j] = s[k];\n  \
    \          s[k] = c;\n        }\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:28:25\n\
    \   |\n28 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut new_s_char = new_s[..j].chars();\n        let mut\
    \ new_s_char_len = new_s_char.len();\n        let mut new_s_char_i = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_j = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_k = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_l = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_m = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_n = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_o = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_r = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_s = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_t = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_u = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_v = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_w = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_x = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_y = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_z = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let mut new_s_char_0 = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \        let \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpnch51uwi.rs:57:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - this delimiter might not be properly closed...\n\
    ...\n46 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    57 | }\n   |   ^\n\nerror: expected pattern, found `}`\n  --> /tmp/tmpnch51uwi.rs:46:1\n\
    \   |\n46 | }\n   | ^ expected pattern\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpnch51uwi.rs:20:32\n   |\n20 |         while\
    \ j < new_s_len && s[j] == ' ' {\n   |                                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpnch51uwi.rs:27:45\n   |\n27 |         let mut\
    \ new_s_char_len = new_s_char.len();\n   |                                   \
    \          ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `iter` found for struct `Chars` in the current scope\n  --> /tmp/tmpnch51uwi.rs:28:43\n\
    \   |\n28 |         let mut new_s_char_i = new_s_char.iter().cloned().collect::<Vec<_>>();\n\
    \   |                                           ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpnch51uwi.rs:29:43\n   |\n29 |         let mut new_s_char_j\
    \ = new_s_char.iter().cloned().collect::<Vec<_>>();\n   |                    \
    \                       ^^^^ private field, not a method\n\nerror[E0599]: "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_s_char = new_s[new_s_len - k - 1];\n\
    \        let mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_i\
    \ = 0;\n        while new_s_char_i < new_s_char_len {\n            let mut new_s_char_j\
    \ = new_s_char_i;\n            while new_s_char_j < new_s_char_len && new_s_char[new_s_char_j]\
    \ == ' ' {\n                new_s_char_j = new_s_char_j + 1;\n            }\n\
    \            if new_s_char_j == new_s_char_len {\n                break;\n   \
    \         }\n            let mut new_s_char_k = new_s_char_j;\n            while\
    \ new_s_char_k < new_s_char_len && new_s_char[new_s_char_k] == ' ' {\n       \
    \         new_s_char_k = new_s_char_k + 1;\n            }\n            if new_s_char_k\
    \ == new_s_char_len {\n                break;\n            }\n            let\
    \ mut new_s_char_char = new_s_char[new_s_char_i - new_s_char_k - 1];\n       \
    \     let mut new_s_char_char_len = new_s_char_char.len();\n            let mut\
    \ new_s_char_char_i = 0;\n            while new_s_char_char_i < new_s_char_char_len\
    \ {\n                let mut new_s_char_char_j = new_s_char_char_i;\n        \
    \        while new_s_char_char_j < new_s_char_char_len && new_s_char_char[new_s_char_char_j]\
    \ == ' ' {\n                    new_s_char_char_j = new_s_char_char_j + 1;\n \
    \               }\n                if new_s_char_char_j == new_s_char_char_len\
    \ {\n                    break;\n                }\n                let mut new_s_char_char_k\
    \ = new_s_char_char_j;\n                while new_s_char_char_k < new_s_char_char_len\
    \ && new_s_char_char[new_s_char_char_k] == ' ' {\n                    new_s_char_char_k\
    \ = new_s_char_char_k + 1;\n                }\n                if new_s_char_char_k\
    \ == new_s_char_char_len {\n                    break;\n                }\n  \
    \              let mut new_s_char_char_char = new_s_char_char[new_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpba_7ttly.rs:81:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n36 |         while new_s_char_i\
    \ < new_s_char_len {\n   |                                             - unclosed\
    \ delimiter\n...\n54 |             while new_s_char_char_i < new_s_char_char_len\
    \ {\n   |                                                           - this delimiter\
    \ might not be properly closed...\n...\n70 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n81 | }\n   |   ^\n\nerror: expected one of\
    \ `.`, `;`, `?`, `else`, or an operator, found `}`\n  --> /tmp/tmpba_7ttly.rs:70:1\n\
    \   |\n70 | }\n   | ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpba_7ttly.rs:69:63\n  \
    \ |\n13 | fn anti_shuffle(s: String) -> String {\n   |                       \
    \               - closing delimiter possibly meant for this\n...\n69 |       \
    \          let mut new_s_char_char_char = new_s_char_char[new_\n   |         \
    \                                                      ^ unclosed delimiter\n\
    70 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpba_7ttly.rs:20:32\n   |\n20 |  \
    \       while j < new_s_len && s[j] == ' ' {\n   |                           \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpb"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        new_s.push_str(&s[new_s_len..]);\n        new_s_len += 1;\n        i\
    \ += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6z0185zy.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6z0185zy.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6z0185zy.rs:29:16\n   |\n29 |             if s[k] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277"
  stdout: ''
  timestamp: 1660011736
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c != ' ') {\n                new_s.push_str(&s[..j]);\n                new_s.push_str(&\"\
    \ \");\n                new_s.push_str(&s[j..]);\n                break;\n   \
    \         }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\" HiH i\"`,\n right: `\"Hi\"`', /tmp/tmp7omyxlz2.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j + 1 < s.len() {\n            if s.chars().nth(j\
    \ + 1).unwrap().to_ascii_lowercase() < s.chars().nth(j).unwrap().to_ascii_lowercase()\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j == i {\n            break;\n        }\n\
    \        s.swap(i, j);\n        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbcsd_ep7.rs:28:11\n   |\n28 |         s.swap(i, j);\n \
    \  |           ^^^^ method not found in `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1; // skip space\n\
    \        }\n        if j == i {\n            new_s.push_str(&s[i]);\n        }\
    \ else {\n            new_s.push_str(&s[i .. j]);\n            new_s.push_str(&s[j\
    \ .. i]);\n        }\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpml3gcb_4.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpml3gcb_4.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpml3gcb_4.rs:27:29\n\
    \   |\n27 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: ab"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                j = new_s_len;\n            } else {\n        \
    \        let c = s.chars().nth(j);\n                let c_ord = c.to_ascii_lowercase();\n\
    \                if c_ord > s.chars().nth(j + 1).to_ascii_lowercase() {\n    \
    \                j = new_s_len;\n                } else {\n                  \
    \  new_s.push_char(c.to_ascii_lowercase());\n                    j += 1;\n   \
    \             }\n            }\n        }\n        new_s.push_char(s.chars().nth(i).to_ascii_lowercase());\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpeme2f1_4.rs:25:31\n   |\n25 |          \
    \       let c_ord = c.to_ascii_lowercase();\n   |                            \
    \   ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror[E0599]: no\
    \ method named `to_ascii_lowercase` found for enum `Option` in the current scope\n\
    \  --> /tmp/tmpeme2f1_4.rs:26:49\n   |\n26 |                 if c_ord > s.chars().nth(j\
    \ + 1).to_ascii_lowercase() {\n   |                                          \
    \       ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `push_char` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpeme2f1_4.rs:29:27\n   |\n29 |                     new_s.push_char(c.to_ascii_lowercase());\n\
    \   |                           ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push_str`\n\nerror[E0599]: no method named `to_ascii_lowercase`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpeme2f1_4.rs:29:39\n\
    \   |\n29 |                     new_s.push_char(c.to_ascii_lowercase());\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^ method not found in\
    \ `Option<char>`\n\nerror[E0599]: no method named `push_char` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpeme2f1_4.rs:34:15\n   |\n34 | \
    \        new_s.push_char(s.chars().nth(i).to_ascii_lowercase());\n   |       \
    \        ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `push_str`\n\nerror[E0599]: no method named `to_ascii_lowercase` found for enum\
    \ `Option` in the current scope\n  --> /tmp/tmpeme2f1_4.rs:34:42\n   |\n34 | \
    \        new_s.push_char(s.chars().nth(i).to_ascii_lowercase());\n   |       \
    \                                   ^^^^^^^^^^^^^^^^^^ method not found in `Option<char>`\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut new_word = String::new();\n     \
    \           new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfg5ejpzd.rs:78:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    ...\n25 |             if s[j] > s[i] {\n   |                            - this\
    \ delimiter might not be properly closed...\n...\n67 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfg5ejpzd.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfg5ejpzd.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfg5ejpzd.rs:25:16\n\
    \   |\n25 | "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s[j] > s[i]\
    \ {\n                s[j] = s[i] - 1;\n                s[i] = s[j] + 1;\n    \
    \        }\n            j += 1\n        }\n        i += 1;\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpafpfinj5.rs:19:16\n\
    \   |\n19 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpafpfinj5.rs:19:23\n   |\n19 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpafpfinj5.rs:20:17\n\
    \   |\n20 |                 s[j] = s[i] - 1;\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `St"
  stdout: ''
  timestamp: 1660011736
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"HiHi\"`,\n right: `\"Hi\"`', /tmp/tmporjb4520.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        if j > i {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. new_s_len]);\n            i = j;\n\
    \        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq39lqo95.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] < s[i]\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        if j == new_s_len {\n            new_s.push_str(&s[i\
    \ ..]);\n            new_s.push_str(&[s[i]]);\n            i += 1;\n        }\
    \ else {\n            new_s.push_str(&s[i ..j]);\n            new_s.push_str(&[s[i]]);\n\
    \            i += j - i + 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpavep8jfj.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpavep8jfj.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpavep8jfj.rs:29:30\n\
    \   |\n29 |             new_s.push_str(&[s[i]]);\n   |                       \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E03"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().any(|c|\
    \ c.is_whitespace()) {\n                j = new_s_len;\n            } else {\n\
    \                if s.chars().any(|c| c.is_ascii_lowercase()) {\n            \
    \        new_s.push_char(s.chars().nth(j).unwrap().to_ascii_lowercase());\n  \
    \              } else {\n                    new_s.push_char(s.chars().nth(j).unwrap().to_ascii_uppercase());\n\
    \                }\n                j = j + 1;\n            }\n        }\n   \
    \     new_s.push_char(s.chars().nth(i).unwrap().to_ascii_lowercase());\n     \
    \   i = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp_lqmhw1v.rs:25:27\n   |\n25 |             \
    \        new_s.push_char(s.chars().nth(j).unwrap().to_ascii_lowercase());\n  \
    \ |                           ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push_str`\n\nerror[E0599]: no method named `push_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_lqmhw1v.rs:27:27\n\
    \   |\n27 |                     new_s.push_char(s.chars().nth(j).unwrap().to_ascii_uppercase());\n\
    \   |                           ^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push_str`\n\nerror[E0599]: no method named `push_char`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_lqmhw1v.rs:32:15\n\
    \   |\n32 |         new_s.push_char(s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \   |               ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push_str`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            new_s[new_s_len] = s[j];\n            new_s_len +=\
    \ 1;\n            j += 1;\n        }\n        new_s[new_s_len] = s[i];\n     \
    \   new_s_len += 1;\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpp6hqty4f.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp6hqty4f.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpp6hqty4f.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j == new_s_len {\n            break;\n\
    \        }\n        let mut k = j;\n        while k < new_s_len && s[k] != ' '\
    \ {\n            k = k + 1;\n        }\n        if k == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. k]);\n        new_word.push_str(&s[k..j]);\n        new_word.push_str(&s[j\
    \ .. new_s_len]);\n        new_s.push_str(&new_word);\n        i = j + 1;\n  \
    \  }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpo6rt_qgt.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpo6rt_qgt.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ != ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        if j > i {\n            s.swap(i, j);\n            i = j;\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmppytewl2c.rs:26:15\n   |\n26 |             s.swap(i, j);\n\
    \   |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut k = j;\n                while k <\
    \ s.len() {\n                    if s[k] > s[i] {\n                        k =\
    \ k + 1;\n                        continue;\n                    }\n         \
    \           new_s.push(' ');\n                    new_s.push(s[k]);\n        \
    \            k = k + 1;\n                }\n                new_s.push(' ');\n\
    \                new_s.push(s[j]);\n                new_s.push(s[i]);\n      \
    \          break;\n            }\n            new_s.push(' ');\n            new_s.push(s[j]);\n\
    \            new_s.push(s[i]);\n            j = j + 1;\n        }\n        i =\
    \ i + 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp71vy5bjf.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp71vy5bjf.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp71vy5bjf.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String`"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n   \
    \             continue;\n            }\n            if s[j] > 122 {\n        \
    \        s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            break;\n        }\n        new_s.push_str(&s[i ..\
    \ j]);\n        new_s_len += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0pw6rknd.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0pw6rknd.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0pw6rknd.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut i\
    \ = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < new_s_len {\n  \
    \      if s.chars().any(|c| c == ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c == '\\n') {\n            i += 1;\n\
    \            continue;\n        }\n        if s.chars().any(|c| c == '\\t') {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c == '\\r') {\n            i += 1;\n            continue;\n        }\n     \
    \   if s.chars().any(|c| c == '\\b') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c == '\\a') {\n            i += 1;\n\
    \            continue;\n        }\n        if s.chars().any(|c| c == '\\v') {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c == '\\f') {\n            i += 1;\n            continue;\n        }\n     \
    \   if s.chars().any(|c| c == '\\e') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c == '\\f') {\n            i += 1;\n\
    \            continue;\n        }\n        if s.chars().any(|c| c == '\\v') {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c == '\\b') {\n            i += 1;\n            continue;\n        }\n     \
    \   if s.chars().any(|c| c == '\\r') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c == '\\t') {\n            i += 1;\n\
    \            continue;\n        }\n        if s.chars().any(|c| c == '\\n') {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c == '\\a') {\n            i += 1;\n            continue;\n        }\n     \
    \   if s.chars().any(|c| c == '\\v') {\n            i += 1;\n            continue;\n\
    \        }\n        if s.chars().any(|c| c == '\\f') {\n            i += 1;\n\
    \            continue;\n        }\n        if s.chars().any(|c| c == '\\r') {\n\
    \            i += 1;\n            continue;\n        }\n        if s.chars().any(|c|\
    \ c == '\\b') {\n            i += 1;\n            continue;\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpb1vpy_27.rs:38:37\n\
    \   |\n38 |         if s.chars().any(|c| c == '\\b') {\n   |                 \
    \                    ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp:\
    \ if you meant to write a literal backslash (perhaps escaping in a regular expression),\
    \ consider a raw string literal\n   |\n38 |         if s.chars().any(|c| c ==\
    \ r\"\\b\") {\n   |                                   ~~~~~\n\nerror: unknown\
    \ character escape: `a`\n  --> /tmp/tmpb1vpy_27.rs:42:37\n   |\n42 |         if\
    \ s.chars().any(|c| c == '\\a') {\n   |                                     ^\
    \ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n42 |         if s.chars().any(|c|\
    \ c == r\"\\a\") {\n   |                                   ~~~~~\n\nerror: unknown\
    \ character escape: `v`\n  --> /tmp/tmpb1vpy_27.rs:46:37\n   |\n46 |         if\
    \ s.chars().any(|c| c == '\\v') {\n   |                                     ^\
    \ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n46 |         if s.chars().any(|c|\
    \ c == r\"\\v\") {\n   |                                   ~~~~~\n\nerror: unknown\
    \ character escape: `f`\n  --> /tmp/tmpb1vpy_27.rs:50:37\n   |\n50 |         if\
    \ s.chars().any(|c| c == '\\f') {\n   |                                     ^\
    \ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n50 |         if s.chars().any(|c|\
    \ c == r\"\\f\") {\n   |          "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        if new_s_len\
    \ > new_s.len() {\n            new_s = new_s.push_str(&s[i .. j]);\n        }\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpayer2nj3.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpayer2nj3.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpayer2nj3.rs:29:21\n   |\n15 |     let mut new_s\
    \ = String::new();\n   |                     ------------- expected due to this\
    \ value\n...\n29 |             new_s = new_s.push_str(&s[i .. j]);\n   |     \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpayer2nj3.rs:29:27\n\
    \   |\n29 |             new_s = new_s.push_str(&s[i .. j]);\n   |            \
    \         ----- ^^^^^^^^ this call modifies `new_s` in-place\n   |           \
    \          |\n   |                     you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` outpu"
  stdout: ''
  timestamp: 1660011736
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut k = 0;\n    while i < s.len() {\n        let mut new_s_len2\
    \ = new_s_len + s.len() - i;\n        while new_s_len2 < new_s_len {\n       \
    \     new_s.push_str(\" \");\n            new_s_len2 += 1;\n        }\n      \
    \  let mut new_s_len3 = new_s_len2 + new_s_len;\n        while new_s_len3 < new_s_len2\
    \ {\n            new_s.push_str(\" \");\n            new_s_len3 += 1;\n      \
    \  }\n        let mut new_s_len4 = new_s_len3 + new_s_len;\n        while new_s_len4\
    \ < new_s_len3 {\n            new_s.push_str(\" \");\n            new_s_len4 +=\
    \ 1;\n        }\n        new_s.push_str(&s[i .. i + new_s_len]);\n        new_s_len\
    \ += new_s_len2 - new_s_len;\n        new_s_len2 += new_s_len3 - new_s_len;\n\
    \        new_s_len3 += new_s_len4 - new_s_len;\n        i += new_s_len4;\n   \
    \ }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmpg_9mc0cu.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n                s.chars().next().unwrap().to_ascii_lowercase().unwrap()\n\
    \            {\n                j = j + 1;\n            } else {\n           \
    \     break;\n            }\n        }\n        new_s.push_str(&s[..j]);\n   \
    \     new_s.push_str(&s[j..]);\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkbg991_k.rs:21:63\n   |\n21 |             if s.chars().next().unwrap().to_ascii_lowercase().unwrap()\
    \ <\n   |                                                               ^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `unwrap` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpkbg991_k.rs:22:64\n   |\n22\
    \ |                 s.chars().next().unwrap().to_ascii_lowercase().unwrap()\n\
    \   |                                                                ^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdzlw0chr.rs:17:15\n   |\n17 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n\
    \                j = j + 1;\n            } else {\n                break;\n  \
    \          }\n        }\n        let mut new_s_char = new_s.chars();\n       \
    \ let mut new_s_char_len = new_s_char.len();\n        while new_s_char_len > 0\
    \ {\n            let mut new_s_char = new_s_char.next();\n            new_s_char_len\
    \ = new_s_char.len();\n            new_s_char.push(s[j]);\n            j = j +\
    \ 1;\n        }\n        new_s_char_len = new_s_char.len();\n        new_s_char.push(s[i]);\n\
    \        new_s = new_s.into_iter().collect();\n        i = j;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy50bipbr.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy50bipbr.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpy50bipbr.rs:28:45\n\
    \   |\n28 |         let mut new_s_char_len = new_s_char.len();\n   |         \
    \                                    ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpy50bipbr.rs:31:41\n\
    \   |\n31 |             new_s_char_len = new_s_char.len();\n   |             \
    \                            ^^^ method not found in `Option<char>`\n\nerror[E0599]:\
    \ no method named `push` found for enum `Option` in the current scope\n  --> /tmp/tmpy50bipbr.rs:32:24\n\
    \   |\n32 |             new_s_char.push(s[j]);\n   |                      "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        let mut k = i;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        if j > k {\n  \
    \          new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k .. j]);\n\
    \            i = k;\n        } else {\n            new_s.push_str(&s[i .. j]);\n\
    \            new_s.push_str(&s[j .. k]);\n            i = j;\n        }\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv4pp1eet.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv4pp1eet.rs:24:32\n   |\n24 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = s.len();\n            } else {\n            \
    \    let c = s.chars().nth(j).unwrap();\n                let c_ord = c.to_ascii_lowercase().unwrap();\n\
    \                if c_ord > s.chars().nth(j + 1).unwrap().to_ascii_lowercase().unwrap()\
    \ {\n                    new_s.push_str(&s.to_string());\n                   \
    \ new_s_len += s.len() - j;\n                    j = s.len();\n              \
    \  } else {\n                    new_s.push_str(&c.to_string());\n           \
    \         new_s_len += 1;\n                    j += 1;\n                }\n  \
    \          }\n        }\n        new_s.push_str(&s.to_string());\n        new_s_len\
    \ += s.len() - i;\n        i = s.len();\n    }\n    new_s.push_str(&s.to_string());\n\
    \    new_s_len += s.len();\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp0xy_e47k.rs:25:52\n   |\n25 |                 let c_ord\
    \ = c.to_ascii_lowercase().unwrap();\n   |                                   \
    \                 ^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp0xy_e47k.rs:26:79\n\
    \   |\n26 |                 if c_ord > s.chars().nth(j + 1).unwrap().to_ascii_lowercase().unwrap()\
    \ {\n   |                                                                    \
    \           ^^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().sort_by_key(|c| c.to_ascii_lowercase()).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpvzmwkfld.rs:15:15\n   |\n15 |     s.chars().sort_by_key(|c|\
    \ c.to_ascii_lowercase()).collect::<String>()\n   |               ^^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] >= ' ' {\n    \
    \            j += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        if j == s.len() {\n            new_s.push_str(&s[i ..\
    \ i + 1]);\n            new_s_len += 1;\n            i += 1;\n        } else {\n\
    \            new_s.push_str(&s[i .. j]);\n            new_s_len += j - i;\n  \
    \          i = j;\n        }\n    }\n    new_s.push_str(&s[i .. new_s_len]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp91wtci68.rs:21:16\n\
    \   |\n21 |             if s[j] >= ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n   \
    \             continue;\n            }\n            if s[j] > 122 {\n        \
    \        s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            break;\n        }\n        new_s.push_str(&s[i ..\
    \ j]);\n        new_s_len += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i\
    \ ..]);\n    new_s_len += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0pw6rknd.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0pw6rknd.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0pw6rknd.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        if j == new_s_len {\n            break;\n    \
    \    }\n        let mut k = j;\n        while k < new_s_len && s[k] != ' ' {\n\
    \            k += 1\n        }\n        let mut new_word = String::new();\n  \
    \      new_word.push_str(&s[i .. k]);\n        new_word.push_str(&s[k .. j]);\n\
    \        new_word.push_str(&s[j .. new_s_len]);\n        new_s.push_str(&new_word);\n\
    \        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_qd8ptn4.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_qd8ptn4.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ != ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j..]);\n                break;\n            }\n\
    \            j += 1;\n        }\n        new_s.push_str(&s[0..i]);\n        new_s_len\
    \ += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[0..i]);\n    new_s_len\
    \ += 1;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjz7l4b0k.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, s.len());\n       \
    \ }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjvg87tyd.rs:17:15\n   |\n17 |             s.swap(i, s.len());\n\
    \   |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().all(|c| c < ' ') {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < s.len() {\n            if\
    \ s.chars().all(|c| c > ' ') {\n                j += 1;\n                continue;\n\
    \            }\n            if s.chars().all(|c| c < s.chars().nth(j)) {\n   \
    \             i += 1;\n                continue;\n            }\n            s.swap(i,\
    \ j);\n            i += 1;\n            j += 1;\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwu5j6fjc.rs:27:38\n   |\n\
    27 |             if s.chars().all(|c| c < s.chars().nth(j)) {\n   |          \
    \                            ^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpwu5j6fjc.rs:31:15\n   |\n31 |             s.swap(i, j);\n\
    \   |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            }\n            i += 1;\n        }\n     \
    \   new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i = j;\n\
    \    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe5mwzq1w.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpe5mwzq1w.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                break;\n            }\n            new_s[new_s_len]\
    \ = s[j];\n            new_s_len += 1;\n            j = j + 1;\n        }\n  \
    \      new_s[new_s_len] = s[i];\n        new_s_len += 1;\n        i += 1;\n  \
    \  }\n    new_s.truncate(new_s_len);\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbgg7cmqc.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbgg7cmqc.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbgg7cmqc.rs:25:16\n\
    \   |\n25 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String`"
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = s.len();\n            } else {\n            \
    \    let c = s.chars().nth(j).unwrap();\n                let c_ord = c.to_ascii_lowercase();\n\
    \                if c_ord > s.chars().nth(j).unwrap().to_ascii_lowercase() {\n\
    \                    new_s.push_str(&s[..j]);\n                    new_s.push_str(&c.to_string());\n\
    \                    new_s_len += j - i;\n                    i = j;\n       \
    \             break;\n                }\n                j = j + 1;\n        \
    \    }\n        }\n    }\n    new_s.push_str(&s[..new_s_len]);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        if new_s_len\
    \ > s.len() {\n            new_s_len = 0;\n        }\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqqovh_14.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqqovh_14.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        new_s_len\
    \ += j - i;\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len\
    \ += s.len() - i;\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdk8lmyzw.rs:21:118\n   |\n\
    21 |             if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        let mut new_word\
    \ = String::new();\n        while j < s.len() {\n            if s[i] == s[j] {\n\
    \                new_word.push(s[j]);\n                i += 1;\n             \
    \   j += 1;\n            } else {\n                new_word.push(s[i]);\n    \
    \            i += 1;\n            }\n        }\n        new_s.push(new_word);\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxvniu5hz.rs:21:16\n\
    \   |\n21 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxvniu5hz.rs:21:24\n   |\n21 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxvniu5hz.rs:22:31\n\
    \   |\n22 |                 new_word.push(s[j]);\n   |                       \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            let mut temp = s[j];\n                s[j] = s[i];\n            \
    \    s[i] = temp;\n            }\n            j += 1\n        }\n        new_s.push_str(&s[new_s_len..i]);\n\
    \        new_s_len += i;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0zp__7dc.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0zp__7dc.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0zp__7dc.rs:22:32\n\
    \   |\n22 |                 let mut temp = s[j];\n   |                       \
    \         ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip space\n        }\n        let mut new_s_char = new_s[..j];\n\
    \        let mut new_s_char_len = new_s_char.len();\n        let mut j = 0;\n\
    \        while j < new_s_char_len {\n            let mut new_s_char_char = new_s_char[j];\n\
    \            let mut new_s_char_char_len = new_s_char_char.len();\n          \
    \  let mut new_s_char_char_char_len = new_s_char_char_char.len();\n          \
    \  let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_len = new_s_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_len =\
    \ new_s_char_char_char_char_char_char_char_char_char_char.len();\n           \
    \ let mut new_s_char_char_char_char_char_char_char_char_char_char_len = new_s_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char.len();\n\
    \            let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp2k7cumw5.rs:53:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n26 |         while j\
    \ < new_s_char_len {\n   |                                  - this delimiter might\
    \ not be properly closed...\n...\n42 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n53 | }\n   |   ^\n\nerror: expected `;`, found\
    \ `}`\n  --> /tmp/tmp2k7cumw5.rs:41:147\n   |\n41 |             let mut new_s_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_char_\n\
    \   |                                                                        \
    \                                                                           ^\
    \ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_char_char_char` in this scope\n  --> /tmp/tmp2k7cumw5.rs:29:48\n\
    \   |\n29 |             let mut new_s_char_char_char_len = new_s_char_char_char.len();\n\
    \   |                                                ^^^^^^^^^^^^^^^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s_char_char_len`\n\nerror[E0425]:\
    \ cannot find value `new_s_char_char_char_char` in this scope\n  --> /tmp/tmp2k7cumw5.rs:30:53\n\
    \   |\n30 |             let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_char_char_char_len`\n\
    \nerror[E0425]: cannot find value `new_s_char_char_char_char_char` in this scope\n\
    \  --> /tmp/tmp2k7cumw5.rs:31:58\n   |\n31 |             let mut new_s_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char.len();\n   |                              \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_s_char_char_char_char_len`\n\nerror[E0425]:\
    \ cannot find value `"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' && s[j] != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n                new_s.push_str(&s[..j]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  if j == new_s_len {\n            new_s.push_str(&s[..i]);\n            break;\n\
    \        }\n        let mut k = i;\n        while k < new_s_len {\n          \
    \  if s[k] == ' ' || s[k] == '\\n' || s[k] == '\\r' || s[k] == '\\t' {\n     \
    \           new_s.push_str(&s[..k]);\n                break;\n            }\n\
    \            k += 1\n        }\n        if k == new_s_len {\n            new_s.push_str(&s[..i]);\n\
    \            break;\n        }\n        let mut new_s_len = new_s.len();\n   \
    \     let mut new_s_len2 = new_s_len + 1;\n        while new_s_len2 < new_s_len\
    \ {\n            new_s.push_str(&s[..new_s_len2]);\n            new_s_len2 +=\
    \ 1;\n        }\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwx22cvp9.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwx22cvp9.rs:21:31\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwx22cvp9.rs:21:47\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        if j < new_s_len {\n            let\
    \ mut k = j;\n            while k < new_s_len && s[k].is_whitespace() {\n    \
    \            k = k + 1;\n            }\n            if k < new_s_len {\n     \
    \           let mut new_word = String::new();\n                let mut new_word_len\
    \ = new_word.len();\n                while k < new_s_len {\n                 \
    \   let c = s[k];\n                    if c.is_whitespace() {\n              \
    \          new_word.push('_');\n                        k = k + 1;\n         \
    \           } else {\n                        new_word.push(c);\n            \
    \            k = k + 1;\n                    }\n                }\n          \
    \      new_s.push_str(&new_word);\n                new_s_len = new_s_len - new_word.len();\n\
    \                i = j;\n            } else {\n                new_s.push_str(&s[i\
    \ ..]);\n                new_s_len = new_s_len - s[i];\n                i = new_s_len;\n\
    \            }\n        } else {\n            new_s.push_str(&s[i ..]);\n    \
    \        new_s_len = new_s_len - s[i];\n            i = new_s_len;\n        }\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmpy2qa58.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmpy2qa58.rs:25:36\n\
    \   |\n25 |             while k < new_s_len && s[k].is_whitespace() {\n   |  \
    \                                  ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmpy2qa58.rs:32:29\n   |\n32 |                     let c = s[k];\n\
    \   |                             ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <Str"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        let mut k = i;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        if j > k {\n  \
    \          new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k .. j]);\n\
    \            i = k;\n        } else {\n            new_s.push_str(&s[i .. j]);\n\
    \            new_s.push_str(&s[j .. k]);\n            i = j;\n        }\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv4pp1eet.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv4pp1eet.rs:24:32\n   |\n24 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j += 1;\n                continue;\n            }\n   \
    \         if s[j] == ' ' {\n                i += 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                i += 1;\n         \
    \       break;\n            }\n            if s[i] > s[j] {\n                new_s.push_str(&s[..j]);\n\
    \                i += 1;\n                break;\n            }\n            if\
    \ s[i] != s[j] {\n                new_s.push_str(&s[..j]);\n                new_s.push_str(&s[..i]);\n\
    \                i += 1;\n                break;\n            }\n            i\
    \ += 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzrah4xnu.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzrah4xnu.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzrah4xnu.rs:29:16\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s[j] > s[i] {\n                let tmp = s[j];\n\
    \                s[j] = s[i];\n                s[i] = tmp;\n            }\n  \
    \          j += 1\n        }\n        new_s.push_str(&s[i]);\n        i += 1;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpds9ljk0m.rs:20:16\n\
    \   |\n20 |             if s[j] > s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpds9ljk0m.rs:20:23\n   |\n20 |             if s[j] > s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpds9ljk0m.rs:21:27\n\
    \   |\n21 |                 let tmp = s[j];\n   |                           ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                break;\n            }\n            j += 1\n        }\n  \
    \      if j == new_s_len {\n            new_s.push_str(&s[i]);\n            i\
    \ += 1;\n        } else {\n            new_s.push_str(&s[i .. j]);\n         \
    \   i += j - i;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuxt2x25g.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuxt2x25g.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuxt2x25g.rs:27:29\n\
    \   |\n27 |             new_s.push_str(&s[i]);\n   |                         \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: ab"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                break;\n        \
    \    }\n            j += 1\n        }\n        if j == new_s_len {\n         \
    \   new_s.push_str(&s[i]);\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1hq78r76.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1hq78r76.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1hq78r76.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\ne"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j += 1\n        }\n        let mut new_s_word = s.split_whitespace();\n\
    \        let mut new_s_word_len = new_s_word.len();\n        while j < new_s_word_len\
    \ {\n            let mut new_s_word = new_s_word.clone();\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j\
    \ + 1]);\n            new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n   \
    \         new_s_word.swap(new_s_word[j], new_s_word[j + 1]);\n            new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n            new_s_word.swap(new_s_word\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpkkxal0_i.rs:64:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n25 |         while j\
    \ < new_s_word_len {\n   |                                  - this delimiter might\
    \ not be properly closed...\n...\n53 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n64 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpkkxal0_i.rs:52:28\n   |\n13 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n52 |             new_s_word.swap(new_s_word\n\
    \   |                            ^ unclosed delimiter\n53 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkkxal0_i.rs:20:32\n   |\n20 |         while j < new_s_len && s[j].is_whitespace()\
    \ {\n   |                                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpkkxal0_i.rs:24:45\n   |\n24 |         let\
    \ mut new_s_word_len = new_s_word.len();\n   |                               \
    \              ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmpkkxal0_i.rs:27:24\n   |\n27 |             new_s_word.swap(new_s_word[j],\
    \ new_s_word[j + 1]);\n   |"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] < s[i]\
    \ {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        let mut j = 0;\n        while\
    \ j < new_s_char_len {\n            let mut new_s_char_char = new_s_char[j];\n\
    \            let mut new_s_char_char_len = new_s_char_char.len();\n          \
    \  let mut k = 0;\n            while k < new_s_char_char_len {\n             \
    \   new_s_char_char[k] = new_s_char_char[k + 1];\n                k = k + 1;\n\
    \            }\n            new_s_char_char[j] = new_s_char_char[j + 1];\n   \
    \         j = j + 1;\n        }\n        new_s[i] = new_s_char[j];\n        i\
    \ = i + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphaytgqp1.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphaytgqp1.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmphaytgqp1.rs:27:13\n   |\n27 |         let mut new_s_char = new_s[..j];\n\
    \   |             ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n \
    \  |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n27 |\
    \         let mut new_s_char = &new_s[..j];\n   |                            \
    \  +\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmphaytgqp1.rs:31:39\n\
    \   |\n31 |             let mut new_s_char_char = new_s_char[j];\n "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        let mut k = i;\n        while\
    \ k < s.len() {\n            if s[k] != ' ' {\n                new_s.push_str(&s[k]);\n\
    \                new_s_len += 1;\n            }\n            k += 1\n        }\n\
    \        let mut l = i;\n        while l < s.len() {\n            if s[l] != '\
    \ ' {\n                new_s.push_str(&s[l]);\n                new_s_len += 1;\n\
    \            }\n            l += 1\n        }\n        let mut m = i;\n      \
    \  while m < s.len() {\n            if s[m] != ' ' {\n                new_s.push_str(&s[m]);\n\
    \                new_s_len += 1;\n            }\n            m += 1\n        }\n\
    \        let mut n = i;\n        while n < s.len() {\n            if s[n] != '\
    \ ' {\n                new_s.push_str(&s[n]);\n                new_s_len += 1;\n\
    \            }\n            n += 1\n        }\n        let mut o = i;\n      \
    \  while o < s.len() {\n            if s[o] != ' ' {\n                new_s.push_str(&s[o]);\n\
    \                new_s_len += 1;\n            }\n            o += 1\n        }\n\
    \        let mut p = i;\n        while p < s.len() {\n            if s[p] != '\
    \ ' {\n                new_s.push_str(&s[p]);\n                new_s_len += 1;\n\
    \            }\n            p += 1\n        }\n        let mut q = i;\n      \
    \  while q < s.len() {\n            if s[q] != ' ' {\n                new_s.push_str(&s[q]);\n\
    \                new_s_len += 1;\n            }\n            q += 1\n        }\n\
    \        let mut r = i;\n        while r < s.len() {\n            if s[r] != '\
    \ ' {\n                new_s.push_str(&s[r]);\n                new_s_len += 1;\n\
    \            }\n            r += 1\n        }\n        let mut s = i;\n      \
    \  while s < s.len() {\n            if s[s] != ' ' {\n                new_s.push_str(&s[s]);\n\
    \                new_s_len += 1;\n            }\n            s += 1\n        }\n\
    \        let mut t = i;\n        while t < s.len() {\n            if s[t] != '\
    \ ' {\n                new_s.push_str(&s[t]);\n                new_s_len += 1;\n\
    \            }\n            t += 1\n        }\n        let mut u = i;\n      \
    \  while \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpuw3rl6q4.rs:120:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - this delimiter might not be properly closed...\n\
    ...\n109 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n120 | }\n    |   ^\n\nerror: expected expression, found `}`\n   --> /tmp/tmpuw3rl6q4.rs:109:1\n\
    \    |\n108 |         while \n    |         ----- while parsing the condition\
    \ of this `while` expression\n109 | }\n    | ^ expected expression\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuw3rl6q4.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuw3rl6q4.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  -->"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut c = s.chars().nth(i);\n        if c == ' ' {\n          \
    \  i += 1;\n            continue;\n        }\n        let mut new_c = c;\n   \
    \     let mut new_c_len = 0;\n        while j < new_s_len {\n            let mut\
    \ new_c_char = new_s.chars().nth(j);\n            if new_c_char == ' ' {\n   \
    \             new_c_len += 1;\n                j += 1;\n                continue;\n\
    \            }\n            if new_c_char == c {\n                new_c_len +=\
    \ 1;\n                j += 1;\n                continue;\n            }\n    \
    \        if new_c_char > c {\n                new_c_len += 1;\n              \
    \  j += 1;\n                continue;\n            }\n            if new_c_char\
    \ < c {\n                new_c_len += 1;\n                j += 1;\n          \
    \      continue;\n            }\n            break;\n        }\n        new_s.push_str(&new_s[..new_s_len]);\n\
    \        new_s.push_str(&new_s[new_s_len..new_s_len + new_c_len]);\n        new_s_len\
    \ += new_c_len;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx7175bix.rs:21:17\n   |\n\
    21 |         if c == ' ' {\n   |                 ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<char>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n21 |         if c\
    \ == Some(' ') {\n   |                 +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx7175bix.rs:29:30\n   |\n29 |             if new_c_char == ' '\
    \ {\n   |                              ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n29 |             if new_c_char\
    \ == Some(' ') {\n   |                              +++++   +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        i = j;\n\
    \    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp59mvxqo4.rs:21:118\n   |\n\
    21 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n                new_s.push_str(&s[j]);\n\
    \                new_s_len += 1;\n            }\n            j += 1\n        }\n\
    \        new_s.push_str(&s[i..j]);\n        new_s_len += j - i;\n        i = j;\n\
    \    }\n    new_s.push_str(&s[i..]);\n    new_s_len += s.len() - i;\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpzdv0c9de.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j]\
    \ != '\\t' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzdv0c9de.rs:21:31\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpzdv0c9de.rs:21:47\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |                         \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_char = new_s[new_s_len..new_s_len +\
    \ j].iter().cloned().collect::<Vec<_>>();\n        new_s_char.sort_unstable();\n\
    \        new_s_char.for_each(|c| new_s.push_str(&c.to_string()));\n        new_s_len\
    \ += j;\n        i = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvm177ouz.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvm177ouz.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]:\
    \ no method named `iter` found for type `str` in the current scope\n  --> /tmp/tmpvm177ouz.rs:27:62\n\
    \   |\n27 |         let mut new_s_char = new_s[new_s_len..new_s_len + j].iter().cloned().collect::<Vec<_>>();\n\
    \   |                                                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            let mut k = j;\n                while k < s.len() {\n           \
    \         if s[k] < s[i] {\n                        k = k + 1;\n             \
    \       } else {\n                        break;\n                    }\n    \
    \            }\n                let mut new_s_len = new_s_len + k - j;\n     \
    \           new_s.push_str(&s[i .. j]);\n                new_s.push_str(&s[k ..\
    \ new_s_len]);\n                new_s.push_str(&' ');\n                i = j;\n\
    \                break;\n            }\n            j = j + 1;\n        }\n  \
    \  }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpasmkfgu3.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpasmkfgu3.rs:24:24\n   |\n24 |                     if s[k] < s[i]\
    \ {\n   |                        ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpasmkfgu3.rs:24:31\n   |\n24 |                     if s[k] < s[i]\
    \ {\n   |                               ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_len = new_s_len + 1;\n        new_s.push_str(&s[i\
    \ .. j]);\n        i = j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1a616d0m.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp1a616d0m.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] < s[i]\
    \ {\n                j = j + 1;\n            }\n            i += 1;\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcrjiiuqf.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcrjiiuqf.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j] > s[i] {\n                let mut new_word = String::new();\n     \
    \           new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_str(&s[j\
    \ .. i]);\n                new_word.push_str(&s[i .. j]);\n                new_word.push_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpfg5ejpzd.rs:78:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    ...\n25 |             if s[j] > s[i] {\n   |                            - this\
    \ delimiter might not be properly closed...\n...\n67 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfg5ejpzd.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpfg5ejpzd.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpfg5ejpzd.rs:25:16\n\
    \   |\n25 | "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        if s.chars().all(|c| c.is_ascii_lowercase()) {\n            s.swap(i,\
    \ i + 1);\n            i += 1;\n        }\n    }\n    s\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp8qsgnfao.rs:18:15\n   |\n18 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push_str(&s[j..]);\n                break;\n          \
    \  }\n            j += 1\n        }\n        i += 1;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Hi\"`', /tmp/tmp6k_eahuo.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' && s[j]\
    \ != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n              \
    \  new_s.push_str(&s[j]);\n                new_s_len += 1;\n            }\n  \
    \          j += 1\n        }\n        if new_s_len > 0 {\n            new_s.push_str(&s[new_s_len..]);\n\
    \            new_s_len = 0;\n        }\n        i += 1;\n    }\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_px0o9ow.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' && s[j] != ' ' && s[j] != '\\n' && s[j]\
    \ != '\\r' && s[j] != '\\t' {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_px0o9ow.rs:21:31\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |          \
    \                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_px0o9ow.rs:21:46\n   |\n21 |             if s[j] != ' ' && s[j]\
    \ != ' ' && s[j] != '\\n' && s[j] != '\\r' && s[j] != '\\t' {\n   |          \
    \                                    ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usi"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        let mut new_word\
    \ = String::new();\n        let mut new_word_len = 0;\n        while j < s.len()\
    \ {\n            if s[i] == s[j] {\n                new_word.push(s[j]);\n   \
    \             new_word_len += 1;\n                i += 1;\n                j +=\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        if new_word_len > 0 {\n            new_s.push_str(&new_word);\n     \
    \       new_s.push_str(&\" \");\n        }\n        i += 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprrwgtycm.rs:22:16\n\
    \   |\n22 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprrwgtycm.rs:22:24\n   |\n22 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprrwgtycm.rs:23:31\n\
    \   |\n23 |                 new_word.push(s[j]);\n   |                       \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_s_char = new_s[new_s_len..new_s_len +\
    \ j].iter().cloned().collect::<Vec<_>>();\n        new_s_char.sort_unstable();\n\
    \        new_s_char.clone_from(new_s_char);\n        new_s_len += j;\n       \
    \ new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n     \
    \   new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n   \
    \     new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n \
    \       new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push(' ');\n        new_s.push(' ');\n\
    \        new_s.push(' ');\n        new_s.push('\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmph5evq8dk.rs:95:20\n\
    \   |\n95 |         new_s.push('\n   |                    ^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, i + 1);\n        }\n\
    \    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdzlw0chr.rs:17:15\n   |\n17 |             s.swap(i, i +\
    \ 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut new_s_len = 0;\n        while j < s.len() {\n           \
    \ if s[i].is_whitespace() {\n                i += 1;\n                j += 1;\n\
    \                continue;\n            }\n            if s[j].is_whitespace()\
    \ {\n                j += 1;\n                continue;\n            }\n     \
    \       if s[i].to_ascii_lowercase() < s[j].to_ascii_lowercase() {\n         \
    \       new_s.push_str(&s[j]);\n                new_s_len += 1;\n            \
    \    j += 1;\n                continue;\n            }\n            new_s.push_str(&s[i]);\n\
    \            new_s_len += 1;\n            i += 1;\n        }\n        new_s.push_str(&s[new_s_len..]);\n\
    \        new_s_len += new_s_len;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpatx6v6oy.rs:22:16\n\
    \   |\n22 |             if s[i].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpatx6v6oy.rs:27:16\n   |\n27 |             if s[j].is_whitespace()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpatx6v6oy.rs:31:16\n\
    \   |\n31 |             if s[i].to_ascii_lowercase() < s[j].to_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n          "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = i;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            let mut c = s[j];\n            s[j] = s[k];\n  \
    \          s[k] = c;\n        }\n        i = j;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw21o5tlw.rs:28:25\n\
    \   |\n28 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] < 97 {\n                s[j] = s[j] + 1;\n                j += 1;\n\
    \                continue;\n            }\n            if s[j] < 123 {\n     \
    \           s[j] = s[j] - 1;\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 127 {\n                s[j] = s[j] + 1;\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   s[j] = s[j] - 1;\n            j += 1;\n        }\n        new_s.push_str(&s[i\
    \ .. (j + 1)]);\n        i = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqk7ti6vb.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqk7ti6vb.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqk7ti6vb.rs:26:17\n   |\n26 |                 s[j] = s[j] + 1;\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` can"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let j = i + 1;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                s.swap(i,\
    \ j);\n            }\n            i += 1;\n            i += 1;\n        }\n  \
    \  }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp5rop0m3q.rs:20:19\n   |\n20 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_word = s.split_whitespace().nth(j).unwrap();\n\
    \        let mut new_s_word_len = new_s_word.len();\n        while new_s_word_len\
    \ > 0 {\n            let mut new_s_word_char = new_s_word[0];\n            new_s_word.shift();\n\
    \            new_s_word_len -= 1;\n            for _ in 0..new_s_word_len {\n\
    \                new_s_word.push(new_s_word_char);\n            }\n          \
    \  i += 1;\n        }\n        new_s.push_str(&new_s_word);\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbmqiiy6w.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpbmqiiy6w.rs:26:39\n   |\n26 |             let mut new_s_word_char\
    \ = new_s_word[0];\n   |                                       ^^^^^^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0599]: no method named `shift` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpbmqiiy6w.rs:27:24\n   |\n27 |             new_s_word.shift();\n\
    \   |                        ^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpbmqiiy6w.rs:30:28\n   |\n30 |                 new_s_word.push(new_s_word_char);\n\
    \   |                            ^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut k = i;\n        while k < new_s_len &&\
    \ s[k] == ' ' {\n            k += 1\n        }\n        if j > k {\n         \
    \   new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k .. j]);\n   \
    \         i = k;\n        } else {\n            new_s.push_str(&s[i .. j]);\n\
    \            new_s.push_str(&s[j .. k]);\n            i = j;\n        }\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpg91rohts.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpg91rohts.rs:24:32\n   |\n24 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            if s[j] < '0' || s[j]\
    \ > '9' {\n                j += 1;\n                continue;\n            }\n\
    \            new_s.push_str(&s[i .. j]);\n            new_s_len += 1;\n      \
    \      i += j - i;\n            j = i;\n        }\n        new_s.push_str(&s[i\
    \ .. new_s_len]);\n        new_s_len += 1;\n        i += new_s_len - i;\n    }\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpozkczqsv.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpozkczqsv.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpozkczqsv.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut new_s_char = new_s[..j].chars();\n\
    \        let mut new_s_char_len = new_s_char.len();\n        while new_s_char_len\
    \ > 0 {\n            let mut new_s_char_char = new_s_char.next().unwrap();\n \
    \           let mut new_s_char_char_len = new_s_char_char.len();\n           \
    \ while new_s_char_char_len > 0 {\n                let mut new_s_char_char_char\
    \ = new_s_char_char.next().unwrap();\n                let mut new_s_char_char_char_len\
    \ = new_s_char_char_char.len();\n                while new_s_char_char_char_len\
    \ > 0 {\n                    let mut new_s_char_char_char_char = new_s_char_char_char.next().unwrap();\n\
    \                    let mut new_s_char_char_char_char_len = new_s_char_char_char_char.len();\n\
    \                    while new_s_char_char_char_char_len > 0 {\n             \
    \           let mut new_s_char_char_char_char_char = new_s_char_char_char_char.next().unwrap();\n\
    \                        let mut new_s_char_char_char_char_char_len = new_s_char_char_char_char_char.len();\n\
    \                        while new_s_char_char_char_char_char_len > 0 {\n    \
    \                        let mut new_s_char_char_char_char_char_char = new_s_char_char_char_char_char.next().unwrap();\n\
    \                            let mut new_s_char_char_char_char_char_char_len =\
    \ new_s_char_char_char_char_char_char.len();\n                            while\
    \ new_s_char_char_char_char_char_char_len > 0 {\n                            \
    \    let mut new_s_char_char_char_char_char_char_char = new_s_char_char_char_char_char_char.next().unwrap();\n\
    \                                let mut new_s_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char.len();\n                        \
    \        while new_s_char_char_char_char_char_char_char_len > 0 {\n          \
    \                          let mut new_s_char_char_char_char_char_char_char_char\
    \ = new_s_char_char_char_char_char_char_char_char.next().unwrap();\n         \
    \                           let mut new_s_char_char_char_char_char_char_char_char_len\
    \ = new_s_char_char_char_char_char_char_char_char.len();\n                   \
    \                 while new_s_char_char_char_char_char_char_char_char_char_len\
    \ > 0 {\n                                        let mut new_s_char_char_char_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpw1b31dm6.rs:59:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n25 |         while new_s_char_len\
    \ > 0 {\n   |                                  - unclosed delimiter\n...\n28 |\
    \             while new_s_char_char_len > 0 {\n   |                          \
    \                 - unclosed delimiter\n...\n31 |                 while new_s_char_char_char_len\
    \ > 0 {\n   |                                                    - unclosed delimiter\n\
    ...\n34 |                     while new_s_char_char_char_char_len > 0 {\n   |\
    \                                                             - unclosed delimiter\n\
    ...\n37 |                         while new_s_char_char_char_char_char_len > 0\
    \ {\n   |                                                                    \
    \  - unclosed delimiter\n...\n40 |                             while new_s_char_char_char_char_char_char_len\
    \ > 0 {\n   |                                                                \
    \               - unclosed delimiter\n...\n43 |                              \
    \   while new_s_char_char_char_char_char_char_char_len > 0 {\n   |           \
    \                                                                            \
    \ - unclosed delimiter\n...\n46 |                                     while new_s_char_char_char_char_char_char_char_char_char_len\
    \ > 0 {\n   |                                                                \
    \                                      - this delimiter might not be properly\
    \ closed...\n47 |                                         let mut new_s_char_char_char_\n\
    48 | }\n   | - ...as it matches this but it has different indentation\n...\n59\
    \ | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpw1b31dm6.rs:47:70\n\
    \   |\n47 |                                         let mut new_s_char_char_char_\n\
    \   |                                                                      ^ help:\
    \ add `;` here\n48 "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_char = new_s[..j].chars();\n   \
    \     let mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_iter:\
    \ Option<CharIter> = None;\n        let mut new_s_char_iter_len = 0;\n       \
    \ while new_s_char_iter_len < new_s_char_len {\n            let mut new_s_char_iter_c\
    \ = new_s_char.next().unwrap();\n            new_s_char_iter_c = match new_s_char_iter_c.to_ascii_lowercase()\
    \ {\n                Some(c) => c,\n                None => continue,\n      \
    \      };\n            new_s_char_iter_len += 1;\n            new_s_char_iter\
    \ = Some(new_s_char_iter_c);\n        }\n        if new_s_char_iter.is_some()\
    \ {\n            let mut new_s_char_iter_s = new_s_char.collect::<String>();\n\
    \            new_s_char_iter_s.sort_unstable();\n            new_s_char_iter_s\
    \ = new_s_char_iter_s.into_iter().collect();\n            new_s_char_iter.unwrap_or(&new_s_char_iter_s[..new_s_char_iter_len])\n\
    \                .to_string()\n        } else {\n            new_s_char_iter.unwrap_or(&new_s_char[..new_s_char_len])\n\
    \                .to_string()\n        }\n        new_s.push_str(&new_s_char);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `CharIter` in this scope\n  --> /tmp/tmpilr1exax.rs:25:41\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                - help:\
    \ you might be missing a type parameter: `<CharIter>`\n...\n25 |         let mut\
    \ new_s_char_iter: Option<CharIter> = None;\n   |                            \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpilr1exax.rs:20:32\n   |\n20 |  \
    \       while j < new_s_len && s[j] == ' ' {\n   |                           \
    \     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `len` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpilr1exax.rs:24:45\n   |\n24 |         let mut\
    \ new_s_char_len = new_s_char.len();\n   |                                   \
    \          ^^^ method not found in `Chars<'_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpilr1exax.rs:30:17\n   |\n29 |             new_s_char_iter_c = match\
    \ new_s_char_iter_c.to_ascii_lowercase() {\n   |                             \
    \          -------------------------------------- this expression has type `char`\n\
    30 |                 Some(c) => c,\n   |                 ^^^^^^^ expected `char`,\
    \ found enum `Option`\n   |\n   = note: expected type `char`\n              found\
    \ enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpilr1exax.rs:31:17\n\
    \   |\n29 |             new_s_char_iter_c = match new_s_char_iter_c.to_ascii_lowercase()\
    \ {\n   |                                       --------------------------------------\
    \ this expression has type `char`\n30 |          "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut i = 0;\n    while i < s.len() {\n\
    \        let mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c|\
    \ c == ' ') {\n                s.swap(i, j);\n                i += 1;\n      \
    \          break;\n            }\n            i += 1;\n        }\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpqwbxdr3b.rs:20:19\n   |\n20 |                 s.swap(i,\
    \ j);\n   |                   ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n\
    \                j += 1;\n                continue;\n            }\n         \
    \   if s[j] < 97 {\n                s[j] = s[j].to_ascii_lowercase();\n      \
    \      } else {\n                s[j] = s[j].to_ascii_uppercase();\n         \
    \   }\n            new_s.push_str(&s[j]);\n            j += 1;\n        }\n  \
    \      new_s.push_str(&s[i]);\n        i += 1;\n    }\n    new_s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp32nckv7n.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp32nckv7n.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp32nckv7n.rs:26:17\n   |\n26 |                 s[j] = s[j].to_ascii_lowercase();\n\
    \   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            } else {\n                break;\n      \
    \      }\n        }\n        let mut new_word = String::new();\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j .. i]);\n        new_word.push_str(&s[i\
    \ .. j]);\n        new_word.push_str(&s[j \n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmptsfvofm1.rs:79:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - this delimiter might not be properly closed...\n...\n\
    68 | }\n   | - ...as it matches this but it has different indentation\n...\n79\
    \ | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmptsfvofm1.rs:67:29\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n67 |     \
    \    new_word.push_str(&s[j \n   |                             ^ unclosed delimiter\n\
    68 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmptsfvofm1.rs:21:16\n   |\n21 |  \
    \           if s[j] < s[i] {\n   |                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptsfvofm1.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<u"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        while new_s_char_len > 0 &&\
    \ new_s_char[new_s_char_len - 1] == ' ' {\n            new_s_char.pop();\n   \
    \         new_s_char_len -= 1\n        }\n        new_s_char.push(s[i..j]);\n\
    \        new_s_char_len = new_s_char.len();\n        new_s.push(new_s_char);\n\
    \        i = j + 1\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_ic73jf0.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n  --> /tmp/tmp_ic73jf0.rs:23:13\n   |\n23 |         let\
    \ mut new_s_char = new_s[..j];\n   |             ^^^^^^^^^^^^^^ doesn't have a\
    \ size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\nhelp: consider borrowing\
    \ here\n   |\n23 |         let mut new_s_char = &new_s[..j];\n   |           \
    \                   +\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_ic73jf0.rs:25:37\n   |\n25 |         while new_s_char_len > 0\
    \ && new_s_char[new_s_char_len - 1] == ' ' {\n   |                           \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0599]: no method named `pop` found for type `str` in the current scope\n\
    \  --> /tmp/tmp_ic73jf0.rs:26:24\n   |\n26 |             new_s_char.pop();\n \
    \  |                        ^^^ method not found in `str`\n\nerror[E0599]: no\
    \ method named `push` found for type `str` in the current sc"
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s_len += j - i;\n        i = j;\n\
    \    }\n    new_s.push_str(&s[..i]);\n    new_s_len += i - s.len();\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        i = j;\n    }\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] < s[i] {\n    \
    \            j = j + 1;\n            }\n        }\n        let mut new_s_len =\
    \ new_s_len + 1;\n        new_s.push((&s[i .. j]).to_ascii_lowercase());\n   \
    \     i = j;\n    }\n    new_s.push((&s[i .. new_s_len]).to_ascii_lowercase());\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgedg85dt.rs:21:16\n\
    \   |\n21 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgedg85dt.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgedg85dt.rs:26:20\n   |\n26 |         new_s.push((&s[i\
    \ .. j]).to_ascii_lowercase());\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpgedg85dt.rs:29:16\n   |\n29 |     new_s.push((&s[i .. new_s_len]).to_ascii_lowercase());\n\
    \   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                break;\n            }\n \
    \           j += 1;\n        }\n        new_s.push_str(&s[i]);\n        new_s_len\
    \ += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3pi6y6ms.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3pi6y6ms.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3pi6y6ms.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkdkezdzx.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkdkezdzx.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkdkezdzx.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\ne"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().enumerate().for_each(|(i, c)|\
    \ {\n        if c.is_whitespace() {\n            s.swap(i, s.len() - i - 1);\n\
    \        }\n    });\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp96ca5z6d.rs:17:15\n   |\n17 |             s.swap(i, s.len()\
    \ - i - 1);\n   |               ^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] != s[j]\
    \ {\n                new_s.push_str(&s[j]);\n                new_s.push_str(&s[i]);\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkdkezdzx.rs:21:16\n\
    \   |\n21 |             if s[i] != s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkdkezdzx.rs:21:24\n   |\n21 |             if s[i] != s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkdkezdzx.rs:22:33\n\
    \   |\n22 |                 new_s.push_str(&s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\ne"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j]);\n                new_s_len += 1;\n       \
    \     }\n            j += 1\n        }\n        if new_s_len > 0 {\n         \
    \   new_s.push_str(&' ');\n            new_s_len += 1;\n        }\n        new_s.push_str(&s[i]);\n\
    \        new_s_len += 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmploi4d5bu.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmploi4d5bu.rs:22:33\n   |\n22 |                 new_s.push_str(&s[j]);\n\
    \   |                                 ^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmploi4d5bu.rs:28:28\n\
    \   |\n28 |             new_s.push_str(&' ');\n   |                          \
    \  ^^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmploi4d5bu.rs:31:25\n   |\n31 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<Ra"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        let mut k = i;\n        while k < new_s_len\
    \ && s[k] == ' ' {\n            k = k + 1;\n        }\n        if j > k {\n  \
    \          let mut c = s[j];\n            s[j] = s[k];\n            s[k] = c;\n\
    \        }\n        i = j + 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp35bho19g.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp35bho19g.rs:24:32\n   |\n24 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp35bho19g.rs:28:25\n   |\n28 |             let mut c = s[j];\n \
    \  |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j += 1;\n                continue;\n            }\n   \
    \         if s[j] == ' ' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                new_s.push_str(&s[..j]);\n\
    \                new_s.push(' ');\n                i += 1;\n                j\
    \ += 1;\n                continue;\n            }\n            if s[i] > s[j]\
    \ {\n                new_s.push_str(&s[..j]);\n                new_s.push(' ');\n\
    \                i += 1;\n                continue;\n            }\n         \
    \   new_s.push_str(&s[..i]);\n            new_s.push(' ');\n            i += 1;\n\
    \        }\n        new_s.push_str(&s[..i]);\n        new_s.push(' ');\n     \
    \   i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprwd6btth.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprwd6btth.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprwd6btth.rs:29:16\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len()\
    \ {\n        let mut new_s_len = new_s_len + 1;\n        while j < s.len() {\n\
    \            if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n                new_s_len = new_s_len + 1;\n            }\n         \
    \   j = j + 1;\n        }\n        new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \        i = i + 1;\n    }\n    new_s.push_str(&s.chars().nth(new_s_len).unwrap().to_ascii_lowercase());\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppthp2rht.rs:22:118\n   |\n\
    22 |             if s.chars().nth(j).unwrap().to_ascii_lowercase().cmp(&s.chars().nth(i).unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppthp2rht.rs:27:24\n\
    \   |\n27 |         new_s.push_str(&s.chars().nth(i).unwrap().to_ascii_lowercase());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppthp2rht.rs:30:20\n\
    \   |\n30 |     new_s.push_str(&s.chars().nth(new_s_len).unwrap().to_ascii_lowercase());\n\
    \   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_lowercase() {\n                j = j + 1;\n      \
    \          continue;\n            }\n            if s[j].is_ascii_uppercase()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_digit() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_punctuation() {\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_letter() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_symbol() {\n      \
    \          j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_whitespace() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_control() {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s[j].is_ascii_printable()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_graph() {\n                j = j + 1;\n          \
    \      continue;\n            }\n            if s[j].is_ascii_lower() {\n    \
    \            j = j + 1;\n                continue;\n            }\n          \
    \  if s[j].is_ascii_upper() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_digit() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_punctuation()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_letter() {\n                j = j + 1;\n         \
    \       continue;\n            }\n            if s[j].is_ascii_symbol() {\n  \
    \              j = j + 1;\n                continue;\n            }\n        \
    \    if s[j].is_ascii_whitespace() {\n                j = j + 1;\n           \
    \     continue;\n            }\n            if s[j].is_ascii_control() {\n   \
    \             j = j + 1;\n                continue;\n            }\n         \
    \   if s[j].is_ascii_printable() {\n                j = j + 1;\n             \
    \   continue;\n            }\n            if s[j].is_ascii_graph() {\n       \
    \         j = j + 1;\n                continue;\n            }\n            if\
    \ s[j].is_ascii_lower() {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[j].is_ascii_upper() {\n                j = j\
    \ + 1;\n                continue;\n            }\n            if s[j].is_ascii_digit()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_punctuation() {\n                j = j + 1;\n    \
    \            continue;\n            }\n            if s[j].is_\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpl04kg21q.rs:133:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < new_s_len\
    \ {\n    |                         - unclosed delimiter\n19  |         let mut\
    \ j = i;\n20  |         while j < new_s_len {\n    |                         \
    \    - this delimiter might not be properly closed...\n...\n122 | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n133 | }\n    |   ^\n\n\
    error: expected `{`, found `}`\n   --> /tmp/tmpl04kg21q.rs:122:1\n    |\n121 |\
    \             if s[j].is_\n    |             -- this `if` expression has a condition,\
    \ but no block\n122 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpl04kg21q.rs:21:16\n   |\n21 |  \
    \           if s[j].is_whitespace() {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl04kg21q.rs:25:16\n   |\n25 |             if s[j].is_ascii_lowercase()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::R"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1; // skip spaces\n        }\n        if j == new_s_len {\n        \
    \    break;\n        }\n        let mut new_word = String::new();\n        let\
    \ mut new_word_len = j;\n        while new_word_len > 0 {\n            let mut\
    \ new_char = s.chars().nth(new_word_len).unwrap();\n            new_word.push(new_char);\n\
    \            new_word_len -= 1;\n        }\n        new_s.push_str(&new_word);\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcgbbs1zt.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n\
    \                let mut new_char = s[j];\n                let mut new_char_len\
    \ = new_char.len();\n                while new_char_len > 0 {\n              \
    \      let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len();\n                    let mut new_char_len\
    \ = new_char.len();\n                    let mut new_char_len = new_char.len();\n\
    \                    let mut new_char_len = new_char.len();\n                \
    \    let mut new_char_len = new_char.len\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpasgaoq_f.rs:69:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < s.len() {\n  \
    \ |                       - unclosed delimiter\n19 |         let mut j = i;\n\
    20 |         while j < s.len() {\n   |                           - unclosed delimiter\n\
    21 |             if s[j] != ' ' {\n   |                            - unclosed\
    \ delimiter\n...\n24 |                 while new_char_len > 0 {\n   |        \
    \                                - this delimiter might not be properly closed...\n\
    ...\n58 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    69 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpasgaoq_f.rs:57:56\n\
    \   |\n57 |                     let mut new_char_len = new_char.len\n   |    \
    \                                                    ^ help: add `;` here\n58\
    \ | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpasgaoq_f.rs:21:16\n   |\n21 |             if s[j]\
    \ != ' ' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpasgaoq_f.rs:22:36\n   |\n22 |                 let mut new_char\
    \ = s[j];\n   |                                    ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n           "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < s.len() {\n    \
    \    let mut j = i;\n        while j < s.len() {\n            if s[j].is_whitespace()\
    \ {\n                j = j + 1;\n                continue;\n            }\n  \
    \          if s[j].is_ascii_letter() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_letter() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_digit() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_digit() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_lower() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_lower() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_upper() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_upper() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_punctuation() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_punctuation() {\n                   \
    \ new_char = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_whitespace() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_whitespace() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_symbol() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_symbol() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n      \
    \      if s[j].is_ascii_other() {\n                let mut new_char = s[j];\n\
    \                while new_char.is_ascii_other() {\n                    new_char\
    \ = new_char.swapcase();\n                }\n                new_s.push_str(&new_char);\n\
    \                j = j + 1;\n                continue;\n            }\n\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmprnhie63f.rs:109:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < s.len() {\n\
    \    |                       - unclosed delimiter\n19  |         let mut j = i;\n\
    20  |         while j < s.len() {\n    |                           - this delimiter\
    \ might not be properly closed...\n...\n98  | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n109 | }\n    |   ^\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmprnhie63f.rs:21:16\n\
    \   |\n21 |             if s[j].is_whitespace() {\n   |                ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprnhie63f.rs:25:16\n   |\n25 |             if s[j].is_ascii_letter()\
    \ {\n   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprnhie63f.rs:26:36\n\
    \   |\n26 |                 let mut new_char = s[j];\n   |                   "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 97 {\n                new_s.push_char(s[j]);\n                new_s_len\
    \ += 1;\n                j += 1;\n                continue;\n            }\n \
    \           if s[j] > 122 {\n                new_s.push_char(s[j]);\n        \
    \        new_s_len += 1;\n                j += 1;\n                continue;\n\
    \            }\n            new_s.push_char(s[j]);\n            new_s_len += 1;\n\
    \            j += 1;\n        }\n        new_s.push_char(s[i]);\n        new_s_len\
    \ += 1;\n        i += 1;\n    }\n    new_s.truncate(new_s_len);\n    new_s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprhb2v3h7.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprhb2v3h7.rs:25:16\n   |\n25 |             if s[j] < 97 {\n   |\
    \                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push_char` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmprhb2v3h7.rs:26:23\n   |\n26 |          \
    \       new_s.push_char(s[j]);\n   |                       ^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `push_str`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmprhb2v3h7.rs:26:33\n\
    \   |\n26 |                 new_s.push_char(s[j]);\n   |                     \
    \            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut i\
    \ = 0;\n    while i < new_s_len {\n        let mut j = i;\n        while j < new_s_len\
    \ {\n            if s[j] < s[i] {\n                j = j + 1;\n            }\n\
    \            if s[j] == s[i] {\n                new_s.push_str(&s[j..i]);\n  \
    \              new_s_len2 = new_s_len2 - 1;\n            }\n            j = j\
    \ + 1;\n        }\n        i = i + 1;\n    }\n    new_s.push_str(&s[new_s_len..]);\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8r7pnggb.rs:22:16\n\
    \   |\n22 |             if s[j] < s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp8r7pnggb.rs:22:23\n   |\n22 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8r7pnggb.rs:25:16\n\
    \   |\n25 |             if s[j] == s[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == '\
    \ ' {\n                j = j + 1;\n                continue;\n            }\n\
    \            if s[j] == ' ' {\n                j = j + 1;\n                continue;\n\
    \            }\n            if s[i] > s[j] {\n                let tmp = s[i];\n\
    \                s[i] = s[j];\n                s[j] = tmp;\n                j\
    \ = j + 1;\n                continue;\n            }\n            j = j + 1;\n\
    \        }\n        new_s.push_str(&s[i]);\n        i = i + 1;\n    }\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsil813oc.rs:21:16\n\
    \   |\n21 |             if s[i] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsil813oc.rs:25:16\n   |\n25 |             if s[j] == ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpsil813oc.rs:29:16\n   |\n29 |             if s[i] > s[j] {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut new_s_len2 = new_s_len;\n    let mut new_s_len3\
    \ = new_s_len2;\n    let mut new_s_len4 = new_s_len3;\n    let mut new_s_len5\
    \ = new_s_len4;\n    let mut new_s_len6 = new_s_len5;\n    let mut new_s_len7\
    \ = new_s_len6;\n    let mut new_s_len8 = new_s_len7;\n    let mut new_s_len9\
    \ = new_s_len8;\n    let mut new_s_len10 = new_s_len9;\n    let mut new_s_len11\
    \ = new_s_len10;\n    let mut new_s_len12 = new_s_len11;\n    let mut new_s_len13\
    \ = new_s_len12;\n    let mut new_s_len14 = new_s_len13;\n    let mut new_s_len15\
    \ = new_s_len14;\n    let mut new_s_len16 = new_s_len15;\n    let mut new_s_len17\
    \ = new_s_len16;\n    let mut new_s_len18 = new_s_len17;\n    let mut new_s_len19\
    \ = new_s_len18;\n    let mut new_s_len20 = new_s_len19;\n    let mut new_s_len21\
    \ = new_s_len20;\n    let mut new_s_len22 = new_s_len21;\n    let mut new_s_len23\
    \ = new_s_len22;\n    let mut new_s_len24 = new_s_len23;\n    let mut new_s_len25\
    \ = new_s_len24;\n    let mut new_s_len26 = new_s_len25;\n    let mut new_s_len27\
    \ = new_s_len26;\n    let mut new_s_len28 = new_s_len27;\n    let mut new_s_len29\
    \ = new_s_len28;\n    let mut new_s_len30 = new_s_len29;\n    let mut new_s_len31\
    \ = new_s_len30;\n    let mut new_s_len32 = new_s_len31;\n    let mut new_s_len33\
    \ = new_s_len32;\n    let mut new_s_len34 = new_s_len33;\n    let mut new_s_len35\
    \ = new_s_len34;\n    let mut new_s_len36 = new_s_len35;\n    let mut new_s_len37\
    \ = new_s_len36;\n    let mut new_s_len38 = new_s_len37;\n    let mut new_s_len39\
    \ = new_s_len38;\n    let mut new_s_len40 = new_s_\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ka99vqn.rs:55:33\n   |\n\
    55 |     let mut new_s_len40 = new_s_\n   |                                 ^\
    \ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `new_s_` in this scope\n  --> /tmp/tmp_ka99vqn.rs:55:27\n   |\n55\
    \ |     let mut new_s_len40 = new_s_\n   |                           ^^^^^^ help:\
    \ a local variable with a similar name exists: `new_s`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ka99vqn.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] == ' ' {\n    \
    \            j += 1;\n                continue;\n            }\n            if\
    \ s[j] < 'a' || s[j] > 'z' {\n                j += 1;\n                continue;\n\
    \            }\n            if s[j] < 'A' || s[j] > 'Z' {\n                j +=\
    \ 1;\n                continue;\n            }\n            if s[j] < '0' || s[j]\
    \ > '9' {\n                j += 1;\n                continue;\n            }\n\
    \            new_s[new_s_len] = s[j];\n            new_s_len += 1;\n         \
    \   j += 1;\n        }\n        new_s[i] = new_s[new_s_len];\n        new_s_len\
    \ -= 1;\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppfml1tcf.rs:21:16\n\
    \   |\n21 |             if s[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppfml1tcf.rs:25:16\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppfml1tcf.rs:25:30\n   |\n25 |             if s[j] < 'a' || s[j]\
    \ > 'z' {\n   |                              ^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>"
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().nth(j).unwrap().to_ascii_lowercase()\
    \ < s.chars().nth(i).unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[i .. j]);\n        new_s_len += j - i;\n        i =\
    \ j;\n    }\n    new_s.push_str(&s[i ..]);\n    new_s_len += s.len() - i;\n  \
    \  new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        if j == new_s_len {\n            break;\n    \
    \    }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if k == new_s_len {\n            break;\n\
    \        }\n        let mut new_word = String::from(s[i .. j]);\n        let mut\
    \ new_word_len = new_word.len();\n        let mut new_word_len2 = new_word_len\
    \ / 2;\n        while new_word_len2 > 0 {\n            let mut new_word = String::from(new_word.chars().enumerate().map(|(i,\
    \ c)| {\n                if c < new_word_len2 {\n                    c\n     \
    \           } else {\n                    new_word.chars()\n                 \
    \       .enumerate()\n                        .filter(|(_, c)| c >= new_word_len2)\n\
    \                        .map(|(_, c)| c)\n                        .max()\n  \
    \              }\n            }).collect::<Vec<_>>());\n            new_s_len\
    \ -= new_word_len2;\n            new_s_len += new_word.len();\n            new_s\
    \ = new_s.push_str(new_word);\n            new_word_len2 -= 1;\n        }\n  \
    \      new_s = new_s.push_str(new_word.chars().enumerate().map(|(i, c)| {\n  \
    \          if c < new_word_len {\n                c\n            } else {\n  \
    \              new_word.chars()\n                    .enumerate()\n          \
    \          .filter(|(_, c)| c >= new_word_len)\n                    .map(|(_,\
    \ c)| c)\n                    .max()\n            }\n        }).collect::<Vec<_>>());\n\
    \        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuvm5u3kd.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpuvm5u3kd.rs:27:32\n   |\n27 |         while k < new_s_len && s[k]\
    \ == ' ' {\n   |                                ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n   --> /tmp/tmpuvm5u3kd.rs:33:41\n    |\n33  |        \
    \ let mut new_word = String::from(s[i .. j]);\n    |                         \
    \   ------------ ^^^^^^^^^ doesn't have a size known at compile-time\n    |  \
    \                          |\n    |                            required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `from`\n\nerror[E0277]: the trait bound\
    \ `String: From<str>` is not satisfied\n  --> /tmp/tmpuvm5u3kd.rs:33:28\n   |\n\
    33 |         let mut new_word = String::from(s["
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] < s[i]\
    \ {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos = 0;\n\
    \        while new_s_char_pos < new_s_char_len {\n            let mut new_s_char\
    \ = new_s_char.clone();\n            let mut new_s_char_pos = new_s_char_pos +\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_pos = new_s_char_pos -\
    \ 1;\n            let mut new_s_char_len = new_s_char_len - 1;\n            let\
    \ mut new_s_char_pos = new_s_char_pos - 1;\n            let mut new_s_char_len\
    \ = new_s_char_len - 1;\n            let mut new_s_char_\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5uzmlpjf.rs:72:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n30 |         while new_s_char_pos\
    \ < new_s_char_len {\n   |                                               - this\
    \ delimiter might not be properly closed...\n...\n61 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n72 | }\n   |   ^\n\nerror: expected\
    \ `;`, found `}`\n  --> /tmp/tmp5uzmlpjf.rs:60:32\n   |\n60 |             let\
    \ mut new_s_char_\n   |                                ^ help: add `;` here\n\
    61 | }\n   | - unexpected token\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp5uzmlpjf.rs:21:16\n   |\n21 |             if s[j]\
    \ < s[i] {\n   |                ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5uzmlpjf.rs:21:23\n   |\n21 |             if s[j] < s[i] {\n  \
    \ |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n            "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        let mut j = i;\n        while j\
    \ < s.len() {\n            if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n                j = j + 1;\n            } else {\n                break;\n\
    \            }\n        }\n        new_s.push_str(&s[i .. j]);\n        i = j;\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp20af5rer.rs:20:118\n   |\n\
    20 |             if s.chars().next().unwrap().to_ascii_lowercase().cmp(&s.chars().next().unwrap().to_ascii_lowercase())\
    \ < 0 {\n   |                                                                \
    \                                                      ^ expected enum `std::cmp::Ordering`,\
    \ found integer\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s[j] != ' ' {\n    \
    \            new_s.push_str(&s[j..]);\n                new_s_len += 1;\n     \
    \       }\n            j += 1\n        }\n        new_s.push_str(&s[i]);\n   \
    \     new_s_len += 1;\n        i += 1;\n    }\n    new_s.push_str(&s[s.len() -\
    \ new_s_len..]);\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpgn_i4o3q.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpgn_i4o3q.rs:27:25\n   |\n27 |         new_s.push_str(&s[i]);\n\
    \   |                         ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: -1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s.chars().next().unwrap().to_ascii_lowercase()\
    \ < s.chars().next().unwrap().to_ascii_lowercase() {\n                j = j +\
    \ 1;\n            } else {\n                break;\n            }\n        }\n\
    \        new_s.push_str(&s[..j]);\n        new_s.push_str(&s[j..]);\n        i\
    \ = j;\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011741
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[i] == s[j]\
    \ {\n                j += 1;\n            } else {\n                break;\n \
    \           }\n        }\n        let mut new_s_char = new_s[..j];\n        let\
    \ mut new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos = 0;\n\
    \        while new_s_char_pos < new_s_char_len {\n            let mut new_s_char_pos_next\
    \ = new_s_char_pos + 1;\n            while new_s_char_pos_next < new_s_char_len\
    \ {\n                if new_s_char[new_s_char_pos] > new_s_char[new_s_char_pos_next]\
    \ {\n                    new_s_char[new_s_char_pos] = new_s_char[new_s_char_pos_next];\n\
    \                    new_s_char_pos_next = new_s_char_pos_next + 1;\n        \
    \        } else {\n                    break;\n                }\n           \
    \ }\n            new_s_char_pos = new_s_char_pos_next;\n        }\n        new_s[i]\
    \ = new_s_char[0];\n        i += 1;\n    }\n    new_s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpm41e5yqd.rs:21:16\n\
    \   |\n21 |             if s[i] == s[j] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm41e5yqd.rs:21:24\n   |\n21 |             if s[i] == s[j] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpm41e5yqd.rs:27:13\n   |\n27 |         let mut new_s_char = new_s[..j];\n\
    \   |             ^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n \
    \  |\n   = help: the trait `Sized` is not implemented for `str`\n   = note: all\
    \ local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\nhelp: consider borrowing here\n   |\n27 |\
    \         let mut new_s_char = &new_s[..j];\n   |                            \
    \  +\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpm41e5yqd.rs:33:20\n\
    \   |\n33 |                 if new_s_char[new_s_char_pos] > new"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut i = 0;\n    while i < s.len() {\n        let\
    \ mut j = i;\n        while j < s.len() {\n            if s.chars().any(|c| c\
    \ == ' ') {\n                j = j + 1;\n                continue;\n         \
    \   }\n            if s.chars().any(|c| c == '\\n') {\n                j = j +\
    \ 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\t') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\r') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n                j =\
    \ j + 1;\n                continue;\n            }\n            if s.chars().any(|c|\
    \ c == '\\b') {\n                j = j + 1;\n                continue;\n     \
    \       }\n            if s.chars().any(|c| c == '\\b') {\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `b`\n  --> /tmp/tmpvb3a_o_u.rs:37:41\n\
    \   |\n37 |             if s.chars().any(|c| c == '\\b') {\n   |             \
    \                            ^ unknown character escape\n   |\n   = help: for\
    \ more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\n\
    help: if you meant to write a literal backslash (perhaps escaping in a regular\
    \ expression), consider a raw string literal\n   |\n37 |             if s.chars().any(|c|\
    \ c == r\"\\b\") {\n   |                                       ~~~~~\n\nerror:\
    \ unknown character escape: `b`\n  --> /tmp/tmpvb3a_o_u.rs:41:41\n   |\n41 | \
    \            if s.chars().any(|c| c == '\\b') {\n   |                        \
    \                 ^ unknown character escape\n   |\n   = help: for more information,\
    \ visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp:\
    \ if you meant to write a literal backslash (perhaps escaping in a regular expression),\
    \ consider a raw string literal\n   |\n41 |             if s.chars().any(|c| c\
    \ == r\"\\b\") {\n   |                                       ~~~~~\n\nerror: unknown\
    \ character escape: `b`\n  --> /tmp/tmpvb3a_o_u.rs:45:41\n   |\n45 |         \
    \    if s.chars().any(|c| c == '\\b') {\n   |                                \
    \         ^ unknown character escape\n   |\n   = help: for more information, visit\
    \ <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if\
    \ you meant to write a literal backslash (perhaps escaping in a regular expression),\
    \ consider a raw string literal\n   |\n45 |             if s.chars().any(|c| c\
    \ == r\"\\b\") {\n   |                                       ~~~~~\n\nerror: unknown\
    \ character escape: `b`\n  --> /tmp/tmpvb3a_o_u.rs:49:41\n   |\n49 |         \
    \    if s.chars().any(|c| c == '\\b') {\n   |                                \
    \         ^ unknown character escape\n   |\n   = help: for more information, visit\
    \ <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if\
    \ you meant to write a literal backslash (perhaps escaping in a regular expression),\
    \ consider a raw string literal\n   |\n49 |  "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = 0;\n    let mut new_s_len2 = 0;\n    let mut new_s_len3 = 0;\n\
    \    let mut new_s_len4 = 0;\n    let mut new_s_len5 = 0;\n    let mut new_s_len6\
    \ = 0;\n    let mut new_s_len7 = 0;\n    let mut new_s_len8 = 0;\n    let mut\
    \ new_s_len9 = 0;\n    let mut new_s_len10 = 0;\n    let mut new_s_len11 = 0;\n\
    \    let mut new_s_len12 = 0;\n    let mut new_s_len13 = 0;\n    let mut new_s_len14\
    \ = 0;\n    let mut new_s_len15 = 0;\n    let mut new_s_len16 = 0;\n    let mut\
    \ new_s_len17 = 0;\n    let mut new_s_len18 = 0;\n    let mut new_s_len19 = 0;\n\
    \    let mut new_s_len20 = 0;\n    let mut new_s_len21 = 0;\n    let mut new_s_len22\
    \ = 0;\n    let mut new_s_len23 = 0;\n    let mut new_s_len24 = 0;\n    let mut\
    \ new_s_len25 = 0;\n    let mut new_s_len26 = 0;\n    let mut new_s_len27 = 0;\n\
    \    let mut new_s_len28 = 0;\n    let mut new_s_len29 = 0;\n    let mut new_s_len30\
    \ = 0;\n    let mut new_s_len31 = 0;\n    let mut new_s_len32 = 0;\n    let mut\
    \ new_s_len33 = 0;\n    let mut new_s_len34 = 0;\n    let mut new_s_len35 = 0;\n\
    \    let mut new_s_len36 = 0;\n    let mut new_s_len37 = 0;\n    let mut new_s_len38\
    \ = 0;\n    let mut new_s_len39 = 0;\n    let mut new_s_len40 = 0;\n    let mut\
    \ new_s_len41 = 0;\n    let mut new_s_len42 = 0;\n    let mut new_s_len43 = 0;\n\
    \    let mut new_s_len44 = 0;\n    let mut new_s_len45 = 0;\n    let mut new_s_len46\
    \ = 0;\n    let mut new_s_len47 = 0;\n    let mut new_s_len48 = 0;\n    let mut\
    \ new_s_len49 = 0;\n    let mut new_s_len50 = 0;\n    let mut new_s_len51 = 0;\n\
    \    let mut new_s_len52 = 0;\n    let mut new_s_len53 = 0;\n    let mut new_s_len54\
    \ = 0;\n    let mut new_s_len55 = 0;\n    let mut new_s_len\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnbpduhvx.rs:71:22\n   |\n\
    71 |     let mut new_s_len\n   |                      ^ help: add `;` here\n72\
    \ | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnbpduhvx.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011735
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j = j + 1;\n        }\n        if j < new_s_len {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. new_s_len]);\n            i = j;\n\
    \        } else {\n            new_s.push_str(&s[i .. new_s_len]);\n         \
    \   i = new_s_len;\n        }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqgpz_6mq.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j] == ' ' {\n   |               \
    \                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len {\n            if s[j] != '\
    \ ' {\n                new_s.push_str(&s[j..]);\n                break;\n    \
    \        }\n            j += 1;\n        }\n        if j == new_s_len {\n    \
    \        new_s.push_str(&s[0..i]);\n            break;\n        }\n        let\
    \ mut k = i;\n        while k < new_s_len {\n            if s[k] != ' ' {\n  \
    \              new_s.push_str(&s[k..]);\n                break;\n            }\n\
    \            k += 1;\n        }\n        if k == new_s_len {\n            new_s.push_str(&s[0..i]);\n\
    \            break;\n        }\n        let mut l = i;\n        while l < new_s_len\
    \ {\n            if s[l] != ' ' {\n                new_s.push_str(&s[l..]);\n\
    \                break;\n            }\n            l += 1;\n        }\n     \
    \   if l == new_s_len {\n            new_s.push_str(&s[0..i]);\n            break;\n\
    \        }\n        let mut m = i;\n        while m < new_s_len {\n          \
    \  if s[m] != ' ' {\n                new_s.push_str(&s[m..]);\n              \
    \  break;\n            }\n            m += 1;\n        }\n        if m == new_s_len\
    \ {\n            new_s.push_str(&s[0..i]);\n            break;\n        }\n  \
    \      let mut n = i;\n        while n < new_s_len {\n            if s[n] != '\
    \ ' {\n                new_s.push_str(&s[n..]);\n                break;\n    \
    \        }\n            n += 1;\n        }\n        if n == new_s_len {\n    \
    \        new_s.push_str(&s[0..i]);\n            break;\n        }\n        let\
    \ mut o = i;\n        while o < new_s_len {\n            if s[o] != ' ' {\n  \
    \              new_s.push_str(&s[o..]);\n                break;\n            }\n\
    \            o += 1;\n        }\n        if o == new_s_len {\n            new_s.push_str(&s[0..i]);\n\
    \            break;\n        }\n        let mut p = i;\n        while p < new_s_len\
    \ {\n            if s[p] != ' ' {\n                new_s.push_str(&s[p..]);\n\
    \                break;\n            }\n            p += 1;\n        }\n     \
    \   if p == new_s_len {\n            new_s.push_str(&s[0..i]);\n            break;\n\
    \        }\n        let mut q = i;\n        while q < new_s_len {\n          \
    \  if s[q] != ' ' {\n                new_s.push_str(&s[q..]);\n              \
    \  break;\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpvfl214qe.rs:119:3\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     while i < new_s_len\
    \ {\n    |                         - unclosed delimiter\n...\n104 |         while\
    \ q < new_s_len {\n    |                             - unclosed delimiter\n105\
    \ |             if s[q] != ' ' {\n    |                            - this delimiter\
    \ might not be properly closed...\n...\n108 | }\n    | - ...as it matches this\
    \ but it has different indentation\n...\n119 | }\n    |   ^\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpvfl214qe.rs:21:16\n\
    \   |\n21 |             if s[j] != ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvfl214qe.rs:33:16\n   |\n33 |             if s[k] != ' ' {\n  \
    \ |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpvfl214qe.rs:45:16\n   |\n45 |             "
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j].is_whitespace() {\n\
    \            j = j + 1;\n        }\n        let mut k = j;\n        while k <\
    \ new_s_len && s[k].is_whitespace() {\n            k = k + 1;\n        }\n   \
    \     if j > k {\n            new_s.push_str(&s[i .. k]);\n            new_s.push_str(&s[k\
    \ .. j]);\n            i = j;\n        } else {\n            new_s.push_str(&s[i\
    \ .. j]);\n            new_s.push_str(&s[j .. k]);\n            i = k;\n     \
    \   }\n    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsr12c1j5.rs:20:32\n\
    \   |\n20 |         while j < new_s_len && s[j].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsr12c1j5.rs:24:32\n\
    \   |\n24 |         while k < new_s_len && s[k].is_whitespace() {\n   |      \
    \                          ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011736
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = String::new();\n    let\
    \ mut new_s_len = s.len();\n    let mut i = 0;\n    while i < new_s_len {\n  \
    \      let mut j = i;\n        while j < new_s_len && s[j] == ' ' {\n        \
    \    j += 1\n        }\n        if j == new_s_len {\n            break;\n    \
    \    }\n        let mut k = j;\n        while k < new_s_len && s[k] == ' ' {\n\
    \            k += 1\n        }\n        if k == new_s_len {\n            break;\n\
    \        }\n        let mut new_s_char = new_s[new_s_len - 1];\n        let mut\
    \ new_s_char_len = new_s_char.len();\n        let mut new_s_char_pos = new_s_len\
    \ - 1;\n        let mut new_s_char_pos_len = new_s_char_pos - new_s_char_len;\n\
    \        while new_s_char_pos_len > 0 {\n            let mut new_s_char_pos_char\
    \ = new_s_char[new_s_char_pos_len - 1];\n            let mut new_s_char_pos_char_len\
    \ = new_s_char_pos_char.len();\n            let mut new_s_char_pos_char_pos =\
    \ new_s_char_pos_len - 1;\n            let mut new_s_char_pos_char_pos_len = new_s_char_pos_char_pos\
    \ - new_s_char_pos_char_len;\n            while new_s_char_pos_char_pos_len >\
    \ 0 {\n                let mut new_s_char_pos_char_pos_char = new_s_char_pos_char[new_s_char_pos_char_pos_len\
    \ - 1];\n                let mut new_s_char_pos_char_pos_char_len = new_s_char_pos_char_pos_char.len();\n\
    \                let mut new_s_char_pos_char_pos_char_pos = new_s_char_pos_char_pos_len\
    \ - 1;\n                let mut new_s_char_pos_char_pos_char_pos_len = new_s_char_pos_char_pos_char_pos\
    \ - new_s_char_pos_char_pos_char_len;\n                while new_s_char_pos_char_pos_char_pos_len\
    \ > 0 {\n                    let mut new_s_char_pos_char_pos_char_pos_char = new_s_char_pos_char_pos_char_pos_char[new_s_char_pos_char_pos_char_pos_char_pos_len\
    \ - 1];\n                    let mut new_s_char_pos_char_pos_char_pos_char_len\
    \ = new_s_char_pos_char_pos_char_pos_char_char.len();\n                    let\
    \ mut new_s_char_pos_char_pos_char_pos_char_pos = new_s_char_pos_char_pos_char_pos_char_len\
    \ - 1;\n                    let mut new_s_char_pos_char_pos_char_pos_char_pos_len\
    \ = new_s_char_pos_char_pos_char_pos_char_pos_char_pos - new_s_char_pos_char_pos_char_pos_char_pos_char_\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprbxym948.rs:63:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     while i < new_s_len {\n\
    \   |                         - unclosed delimiter\n...\n37 |         while new_s_char_pos_len\
    \ > 0 {\n   |                                      - unclosed delimiter\n...\n\
    42 |             while new_s_char_pos_char_pos_len > 0 {\n   |               \
    \                                    - unclosed delimiter\n...\n47 |         \
    \        while new_s_char_pos_char_pos_char_pos_len > 0 {\n   |              \
    \                                                  - this delimiter might not\
    \ be properly closed...\n...\n52 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n63 | }\n   |   ^\n\nerror: expected `;`, found `}`\n\
    \  --> /tmp/tmprbxym948.rs:51:177\n   |\n51 |                     let mut new_s_char_pos_char_pos_char_pos_char_pos_len\
    \ = new_s_char_pos_char_pos_char_pos_char_pos_char_pos - new_s_char_pos_char_pos_char_pos_char_pos_char_\n\
    \   |                                                                        \
    \                                                                            \
    \                             ^ help: add `;` here\n52 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `new_s_char_pos_char_pos_char_pos_char`\
    \ in this scope\n  --> /tmp/tmprbxym948.rs:48:69\n   |\n48 | ... = new_s_char_pos_char_pos_char_pos_char[new_s_char_pos_char_pos_char_pos_char_pos_len\
    \ - 1];\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `new_s_char_pos_char_pos_char_pos_len`\n\nerror[E0425]:\
    \ cannot find value `new_s_char_pos_char_pos_char_pos_char_pos_len` in this scope\n\
    \  --> /tmp/tmprbxym948.rs:48:107\n   |\n48 | ..._s_char_pos_char_pos_char_pos_char[new_s_char_pos_char_pos_char_pos_char_pos_len\
    \ - 1];\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `new_s_char_pos_char_po"
  stdout: ''
  timestamp: 1660011736
