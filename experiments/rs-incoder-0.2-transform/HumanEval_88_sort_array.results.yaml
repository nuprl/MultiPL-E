language: rs
name: HumanEval_88_sort_array
results:
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k =\
    \ array.len() - 1;\n    while i < k {\n        sum += array[i];\n        i +=\
    \ 1;\n        j += 1;\n        while j < k {\n            if sum % 2 == 0 {\n\
    \                array[k] = array[j];\n                j += 1;\n            }\
    \ else {\n                array[k] = array[j];\n                j -= 1;\n    \
    \        }\n            k += 1;\n        }\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpi4aw6ngq.rs:29:17\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n29 |                 array[k] = array[j];\n   | \
    \                ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpi4aw6ngq.rs:32:17\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n32 |\
    \                 array[k] = array[j];\n   |                 ^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp8oi22mil.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for value in &array {\n        sum += value;\n    }\n    if sum % 2 == 1\
    \ {\n        array.sort();\n    } else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp01ch7fmm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.cmp(&array[array.len() - 1]));\n    } else {\n        array.sort_by_key(|&x|\
    \ x.cmp(&array[0]));\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpoqds79hn.rs:24:27\n   |\n24 |         array.sort_by_key(|&x|\
    \ x.cmp(&array[array.len() - 1]));\n   |         ------------------^^^^--------------------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0502]:\
    \ cannot borrow `array` as immutable because it is also borrowed as mutable\n\
    \  --> /tmp/tmpoqds79hn.rs:26:27\n   |\n26 |         array.sort_by_key(|&x| x.cmp(&array[0]));\n\
    \   |         ------------------^^^^------------------\n   |         |     | \
    \          |           |\n   |         |     |           |           second borrow\
    \ occurs due to use of `array` in closure\n   |         |     |           immutable\
    \ borrow occurs here\n   |         |     mutable borrow later used by call\n \
    \  |         mutable borrow occurs here\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp309xi827.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp9elzdway.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp9elzdway.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmp9elzdway.rs:29:27\n   |\n29 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap());\n   |   \
    \      ------------------^^^^-----------------------------------\n   |       \
    \  |     |           |                   |\n   |         |     |           | \
    \                  second borrow occurs due to use of `array` in closure\n   |\
    \         |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp9elzdway.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmp9elzdway.rs:31:27\n  \
    \ |\n31 |         array.sort_by_key(|&x| x.partial_cmp(&array[j]).unwrap().reverse());\n\
    \   |         ------------------^^^^---------------------------------------------\n\
    \   |         |     |           |                   |\n   |         |   "
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpzf7f1tlv.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpzf7f1tlv.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmpzf7f1tlv.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut result\
    \ = Vec::new();\n    while i < array.len() {\n        sum += array[i];\n     \
    \   if sum % 2 == 0 {\n            result.push(array[i]);\n            i += 1;\n\
    \        } else {\n            result.push(array[j]);\n            j += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 2, 3, 0, 4, 1, 3, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp2ehhn9td.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgk2_8uq4.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgk2_8uq4.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.iter().cloned().sort_by_key(|&x|\
    \ x).collect()\n    } else {\n        array.iter().cloned().sort_by_key(|&x| -x).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpx_gwjlrd.rs:21:31\n   |\n21 |         array.iter().cloned().sort_by_key(|&x|\
    \ x).collect()\n   |                               ^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpx_gwjlrd.rs:23:31\n\
    \   |\n23 |         array.iter().cloned().sort_by_key(|&x| -x).collect()\n   |\
    \                               ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8q1qvvcu.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8q1qvvcu.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.iter().cloned().sort_by_key(|&i|\
    \ i).collect()\n    } else {\n        array.iter().cloned().sort_by_key(|&i| -i).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhc_g0ky.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `Cloned` in the current scope\n\
    \  --> /tmp/tmpdhc_g0ky.rs:21:31\n   |\n21 |         array.iter().cloned().sort_by_key(|&i|\
    \ i).collect()\n   |                               ^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpdhc_g0ky.rs:23:31\n\
    \   |\n23 |         array.iter().cloned().sort_by_key(|&i| -i).collect()\n   |\
    \                               ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        if sum % 2 == 1 {\n            result.push(array[i]);\n\
    \            i += 1;\n        } else {\n            result.push(array[j]);\n \
    \           j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpcr5j_7ng.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppiyviv15.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpk980nhf4.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in &array {\n        sum += value;\n        if sum % 2 == 1 {\n      \
    \      min_value = value;\n        } else {\n            max_value = value;\n\
    \        }\n    }\n    let mut new_array = Vec::new();\n    new_array.push(min_value);\n\
    \    new_array.push(max_value);\n    for value in &array {\n        if value ==\
    \ min_value {\n            new_array.push(value);\n        } else {\n        \
    \    new_array.push(max_value);\n            new_array.push(value);\n        }\n\
    \    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpud07pj9s.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *value;\n   | \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud07pj9s.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *value;\n   | \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud07pj9s.rs:33:28\n\
    \   |\n33 |             new_array.push(value);\n   |                         \
    \   ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n33 |             new_array.push(*value);\n   |           \
    \                 +\n\nerror[E0277]: can't compare `&isize` with `isize`\n  -->\
    \ /tmp/tmpud07pj9s.rs:32:18\n   |\n32 |         if value == min_value {\n   |\
    \                  ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpud07pj9s.rs:36:28\n   |\n36 |\
    \             new_array.push(value);\n   |                            ^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    36 |             new_array.push(*value);\n   |                            +\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `ru"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut sum\
    \ = 0;\n    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpkq721ivd.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppiyviv15.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < array.len() {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n    \
    \    if sum % 2 == 1 {\n            array[j].swap(array[j + 1]);\n           \
    \ j += 1;\n        } else {\n            sum -= array[j];\n            j += 1;\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp7jy5c_dw.rs:26:22\n   |\n26 |             array[j].swap(array[j\
    \ + 1]);\n   |                      ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    if min_value < max_value {\n        array.swap(0, array.len()\
    \ - 1);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpp50m1so9.rs:29:9\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  ----- `array`\
    \ moved due to this implicit call to `.into_iter()`\n...\n29  |         array.swap(0,\
    \ array.len() - 1);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n20  |     for value in &array\
    \ {\n    |                  +\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpp50m1so9.rs:29:23\n  \
    \ |\n29 |         array.swap(0, array.len() - 1);\n   |         --------------^^^^^^^^^^^-----\n\
    \   |         |     |       |\n   |         |     |       immutable borrow occurs\
    \ here\n   |         |     mutable borrow later used by call\n   |         mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmpp50m1so9.rs:29:23\n   |\n29 |         array.swap(0, array.len()\
    \ - 1);\n   |                       ^^^^^^^^^^^\nhelp: ...and then using that\
    \ local as the argument to this call\n  --> /tmp/tmpp50m1so9.rs:29:9\n   |\n29\
    \ |         array.swap(0, array.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0382, E0502.\nFor more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if min_value < max_value {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmptpqader1.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       if sum % 2 == 1 {\n            j = i;\n            while j < k {\n   \
    \             sum += array[j];\n                if sum % 2 == 0 {\n          \
    \          k = j;\n                    break;\n                }\n           \
    \     j += 1;\n            }\n        } else {\n            k = i;\n         \
    \   while k < j {\n                sum += array[k];\n                if sum %\
    \ 2 == 1 {\n                    i = k;\n                    break;\n         \
    \       }\n                k += 1;\n            }\n        }\n    }\n    array.sort_by_key(|&x|\
    \ x);\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpc3wqou_9.rs:44:5\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n44 |     array.sort_by_key(|&x| x);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut index = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    while index < array.len() {\n        sum += array[index];\n        if sum\
    \ % 2 == 1 {\n            result.push(array[index]);\n        } else {\n     \
    \       result.push(-array[index]);\n        }\n        index += 1;\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-2, -4, 3, 0, -1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmps3xn25g7.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| a.cmp(b));\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdd3q869g.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpjzdw5be5.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpjzdw5be5.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    let mut sum = 0;\n    for\
    \ value in array {\n        sum += value;\n        result.push(value);\n    }\n\
    \    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmprcrb35cg.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    }\
    \ else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt0z37t8t.rs:17:9\n   |\n\
    17 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpc2kzh3zm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    let mut new_array: Vec<isize> = array.clone();\n    new_array.sort();\n\
    \    if min_value < max_value {\n        new_array.swap(0, new_array.len() - 1);\n\
    \    }\n    new_array\n}\n\nfn main() {\n    let candidate = sort_array;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpqf8ed37f.rs:16:9\n\
    \   |\n16 |     let mut array = array.clone();\n   |         ----^^^^^\n   | \
    \        |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpqf8ed37f.rs:28:37\n\
    \    |\n16  |     let mut array = array.clone();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  ----- `array`\
    \ moved due to this implicit call to `.into_iter()`\n...\n28  |     let mut new_array:\
    \ Vec<isize> = array.clone();\n    |                                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n20\
    \  |     for value in &array {\n    |                  +\n\nerror[E0502]: cannot\
    \ borrow `new_array` as immutable because it is also borrowed as mutable\n  -->\
    \ /tmp/tmpqf8ed37f.rs:31:27\n   |\n31 |         new_array.swap(0, new_array.len()\
    \ - 1);\n   |         ------------------^^^^^^^^^^^^^^^-----\n   |         | \
    \        |       |\n   |         |         |       immutable borrow occurs here\n\
    \   |         |         mutable borrow later used by call\n   |         mutable\
    \ borrow occurs here\n   |\nhelp: try adding a local storing this argument...\n\
    \  --> /tmp/tmpqf8ed37f.rs:31:27\n   |\n31 |         new_array.swap(0, new_array.len()\
    \ - 1);\n   |                           ^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpqf8ed37f.rs:31:9\n  \
    \ |\n31 |         new_array.swap(0, new_array.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0382, E0502.\nFor more information about an error, try\
    \ `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < array.len() {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n    \
    \    sum += array[j];\n        j += 1;\n    }\n    if sum % 2 == 1 {\n       \
    \ array.sort();\n    } else {\n        array.reverse();\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 1, 0, 3, 4, 2]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpzfysfo37.rs:40:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    let mut i = 0;\n    while i < array.len() {\n        if\
    \ sum % 2 == 1 {\n            array[i] = max_value;\n        } else {\n      \
    \      array[i] = min_value;\n        }\n        i += 1;\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmp0iobx75k.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp309xi827.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 0 {\n       \
    \     max_value = value;\n        } else {\n            min_value = value;\n \
    \       }\n    }\n    array.sort();\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpunxn23fi.rs:18:13\n\
    \   |\n18 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpunxn23fi.rs:19:13\n   |\n19 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `max_value` is never read\n  --> /tmp/tmpunxn23fi.rs:23:13\n\
    \   |\n23 |             max_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `min_value` is\
    \ never read\n  --> /tmp/tmpunxn23fi.rs:25:13\n   |\n25 |             min_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpunxn23fi.rs:28:5\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  ----- `array`\
    \ moved due to this implicit call to `.into_iter()`\n...\n28  |     array.sort();\n\
    \    |     ^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `array`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n20  |     for value in &array {\n    |                  +\n\
    \nerror: aborting due to previous error; 4 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n \
    \       sum += array[j];\n        j += 1;\n    }\n    if sum % 2 == 1 {\n    \
    \    for i in 0..array.len() {\n            result.push(array[i]);\n        }\n\
    \    } else {\n        for i in 0..array.len() {\n            result.push(array[i]);\n\
    \        }\n        for i in 0..array.len() {\n            result.push(array[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5]`,\n right: `[5]`', /tmp/tmp8w7p82o5.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    array.sort_by_key(|&x| {\n        if min_value < x {\n\
    \            -1\n        } else if max_value > x {\n            1\n        } else\
    \ {\n            0\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpocjfygz6.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for &i in array {\n        sum += i;\n    }\n    if sum\
    \ % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0iad1h6o.rs:20:9\n   |\n\
    20 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 0 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    let mut array = array.clone();\n\
    \    array.sort();\n    if sum % 2 == 1 {\n        array.swap(0, array.len() -\
    \ 1);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpco869s4h.rs:17:13\n\
    \   |\n17 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmpco869s4h.rs:18:13\n   |\n18 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmpco869s4h.rs:22:13\n\
    \   |\n22 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmpco869s4h.rs:24:13\n   |\n24 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpco869s4h.rs:27:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n19  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n19\
    \  |     for value in &array {\n    |                  +\n\nerror[E0502]: cannot\
    \ borrow `array` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpco869s4h.rs:30:23\n\
    \   |\n30 |         array.swap(0, array.len() - 1);\n   |         --------------^^^^^^^^^^^-----\n\
    \   |         |     |       |\n   |         |     |       immutable borrow occurs\
    \ here\n   |         |     mutable borr"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    let mut sum = 0;\n    for\
    \ element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpgujk7vwe.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len() - 1;\n    while i < k {\n        while sum < array[j]\
    \ {\n            sum += array[j];\n            j += 1;\n        }\n        while\
    \ sum > array[k] {\n            sum -= array[k];\n            k -= 1;\n      \
    \  }\n        if sum < array[j] {\n            array[j], array[k] = array[k],\
    \ array[j];\n            i += 1;\n        }\n        if sum > array[k] {\n   \
    \         array[k], array[j] = array[j], array[k];\n            j -= 1;\n    \
    \    }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpuow5ykft.rs:30:21\n   |\n30 |             array[j], array[k] =\
    \ array[k], array[j];\n   |                     ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `,`\n  --> /tmp/tmpuow5ykft.rs:34:21\n   |\n34 |             array[k],\
    \ array[j] = array[j], array[k];\n   |                     ^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < array.len() {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n    \
    \    if sum % 2 == 0 {\n            array[j].swap(array[j + 1]);\n           \
    \ j += 1;\n        } else {\n            array[j].swap(array[j - 1]);\n      \
    \      j -= 1;\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp_kktptym.rs:26:22\n   |\n26 |             array[j].swap(array[j\
    \ + 1]);\n   |                      ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `swap` found for type `isize` in the current scope\n  --> /tmp/tmp_kktptym.rs:29:22\n\
    \   |\n29 |             array[j].swap(array[j - 1]);\n   |                   \
    \   ^^^^ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.iter().cloned().sort().collect()\n\
    \    } else {\n        array.iter().cloned().rsort().collect()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpk16w37ak.rs:21:31\n   |\n21 |         array.iter().cloned().sort().collect()\n\
    \   |                               ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `rsort` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpk16w37ak.rs:23:31\n   |\n23 |         array.iter().cloned().rsort().collect()\n\
    \   |                               ^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x));\n    }\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpx25apqqk.rs:21:50\n   |\n21 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n   |                                        \
    \          ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &x in &array {\n        sum += x;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&x| x);\n    } else {\n        array.sort_by_key(|&x|\
    \ -x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmphqlpc70h.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n        } else {\n            max_value\
    \ = value;\n        }\n    }\n    let mut array = array.clone();\n    array.sort();\n\
    \    if sum % 2 == 1 {\n        array.reverse();\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmppyp5aaj1.rs:20:13\n\
    \   |\n20 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: variable `max_value` is assigned to,\
    \ but never used\n  --> /tmp/tmppyp5aaj1.rs:21:13\n   |\n21 |     let mut max_value\
    \ = array[0];\n   |             ^^^^^^^^^\n   |\n   = note: consider using `_max_value`\
    \ instead\n\nwarning: value assigned to `min_value` is never read\n  --> /tmp/tmppyp5aaj1.rs:25:13\n\
    \   |\n25 |             min_value = value;\n   |             ^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: value assigned to `max_value` is\
    \ never read\n  --> /tmp/tmppyp5aaj1.rs:27:13\n   |\n27 |             max_value\
    \ = value;\n   |             ^^^^^^^^^\n   |\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmppyp5aaj1.rs:30:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n22  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n30  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n22\
    \  |     for value in &array {\n    |                  +\n\nerror: aborting due\
    \ to previous error; 4 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    }\
    \ else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppwa30y3o.rs:17:9\n   |\n\
    17 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in 0..array.len() {\n     \
    \   sum += array[i];\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&x[1..]));\n    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[..]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpx1f_chnk.rs:21:47\n\
    \   |\n21 |         array.sort_by_key(|&x| x.partial_cmp(&x[1..]));\n   |    \
    \                                           ^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmpx1f_chnk.rs:23:47\n   |\n23 |  \
    \       array.sort_by_key(|&x| x.partial_cmp(&x[..]));\n   |                 \
    \                              ^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:24:27\n   |\n24 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n   |         ------------------^^^^---------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:26:27\n   |\n26 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n   |         ------------------^^^^-------------------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        if sum % 2 == 1 {\n            result.push(array[i]);\n\
    \            i += 1;\n        } else {\n            result.push(array[j]);\n \
    \           j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpcr5j_7ng.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&array[j]));\n\
    \    } else {\n        array.sort_by_key(|&x| x.cmp(&array[i]));\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpm67smkb6.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpm67smkb6.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpm67smkb6.rs:29:27\n   |\n29 |         array.sort_by_key(|&x|\
    \ x.cmp(&array[j]));\n   |         ------------------^^^^------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpm67smkb6.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpm67smkb6.rs:31:27\n  \
    \ |\n31 |         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ------------------^^^^------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |   "
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut index = 0;\n    while index < array.len() {\n        sum += array[index];\n\
    \        index += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x);\n    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp6uts_40v.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < k {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&array[j]));\n\
    \    } else {\n        array.sort_by_key(|&x| x.cmp(&array[i]));\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpm67smkb6.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpm67smkb6.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\
    \nerror[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpm67smkb6.rs:29:27\n   |\n29 |         array.sort_by_key(|&x|\
    \ x.cmp(&array[j]));\n   |         ------------------^^^^------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpm67smkb6.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpm67smkb6.rs:31:27\n  \
    \ |\n31 |         array.sort_by_key(|&x| x.cmp(&array[i]));\n   |         ------------------^^^^------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |   "
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut sum = 0;\n\
    \    for &i in &result {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n  \
    \      result.sort_by(|a, b| a.cmp(b));\n    } else {\n        result.sort_by(|a,\
    \ b| b.cmp(a));\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp62hy999_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgk2_8uq4.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgk2_8uq4.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n\n\
    \    let mut sum = 0;\n    for &x in array {\n        sum += x;\n    }\n\n   \
    \ if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    } else {\n     \
    \   array.sort_by_key(|&x| x);\n    }\n\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa2wdjm0w.rs:21:9\n   |\n\
    21 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        if sum % 2 == 1 {\n            result.push(array[i]);\n\
    \            i += 1;\n        } else {\n            result.push(array[j]);\n \
    \           j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpcr5j_7ng.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for value in &array {\n        sum += value;\n    }\n    if sum % 2 == 1\
    \ {\n        array.sort();\n    } else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp01ch7fmm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6pt3v44.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    while i < n {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < n {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n  \
    \  } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpq3v25k06.rs:19:9\n\
    \   |\n19 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpq3v25k06.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpq3v25k06.rs:31:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n31 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[1..]));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp6b55b32c.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[1..]));\n   |    \
    \                                           ^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmp6b55b32c.rs:26:47\n   |\n26 |  \
    \       array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n   |      \
    \                                         ^^^^^^\n\nerror[E0599]: no method named\
    \ `reverse` found for enum `Option` in the current scope\n  --> /tmp/tmp6b55b32c.rs:26:55\n\
    \   |\n26 |         array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n\
    \   |                                                       ^^^^^^^ method not\
    \ found in `Option<std::cmp::Ordering>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n \
    \       if sum % 2 == 0 {\n            result.push(array[j]);\n            sum\
    \ += array[j];\n            j += 1;\n        } else {\n            result.push(array[j]);\n\
    \            sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmph1sds_w_.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpso60xwkm.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpso60xwkm.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpso60xwkm.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgk2_8uq4.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgk2_8uq4.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp309xi827.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpjvca4hhk.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort();\n    } else {\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp5d_wzt17.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort();\n   |         ^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0596]: cannot borrow `array` as mutable,\
    \ as it is not declared as mutable\n  --> /tmp/tmp5d_wzt17.rs:26:9\n   |\n15 |\
    \ fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |               ----- help:\
    \ consider changing this to be mutable: `mut array`\n...\n26 |         array.reverse();\n\
    \   |         ^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n    }\
    \ else {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmphuw7n2bu.rs:22:39\n\
    \   |\n22 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmphuw7n2bu.rs:24:39\n   |\n\
    24 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n \
    \  |                                       ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for value in &array {\n        sum += value;\n    }\n    if sum % 2 == 1\
    \ {\n        array.sort();\n    } else {\n        array.sort_by_key(|&x| -x);\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp4dxuxhq9.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp5st7u480.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp5st7u480.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp5st7u480.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::new();\n    while i < array.len() {\n        sum +=\
    \ array[i];\n        i += 1;\n    }\n    while j < array.len() {\n        if sum\
    \ % 2 == 0 {\n            result.push(array[j]);\n            sum += array[j];\n\
    \            j += 1;\n        } else {\n            result.push(array[j]);\n \
    \           sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp7mr2qejj.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp8oi22mil.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6pt3v44.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else {\n        array.sort_by_key(|&x|\
    \ -x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpj827fz9c.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp90uzkkpl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n  \
    \  }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmp33nrk2v3.rs:21:49\n\
    \   |\n21 |         array.sort_by_key(|&x| x.partial_cmp(&x.last()));\n   |  \
    \                                               ^^^^ `isize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `&mut isize: Iterator`\n\nerror[E0599]:\
    \ no method named `first` found for type `isize` in the current scope\n  --> /tmp/tmp33nrk2v3.rs:23:49\n\
    \   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.first()));\n   | \
    \                                                ^^^^^ method not found in `isize`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum = 0;\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpe2h070uv.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort_by_key(|x|\
    \ x.partial_cmp(&array[array.len() - 1]).unwrap());\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmpbtmnap81.rs:17:23\n   |\n17 |     array.sort_by_key(|x|\
    \ x.partial_cmp(&array[array.len() - 1]).unwrap());\n   |     ------------------^^^-------------------------------------------------\n\
    \   |     |     |           |                  |\n   |     |     |           |\
    \                  second borrow occurs due to use of `array` in closure\n   |\
    \     |     |           immutable borrow occurs here\n   |     |     mutable borrow\
    \ later used by call\n   |     mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpp0eee6iv.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len();\n    while i < k {\n        sum += array[i];\n \
    \       i += 1;\n        while j < k {\n            if sum % 2 == 0 {\n      \
    \          array[j] = array[j];\n            } else {\n                array[j]\
    \ = array[j + 1];\n            }\n            j += 1;\n        }\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpujqf6e0o.rs:19:9\n\
    \   |\n19 |     let mut k = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpujqf6e0o.rs:25:17\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n25 |                 array[j] = array[j];\n\
    \   |                 ^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpujqf6e0o.rs:27:17\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n27 |\
    \                 array[j] = array[j + 1];\n   |                 ^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| a.cmp(b));\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpneof9pgi.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by(|a, b| a.cmp(b));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpneof9pgi.rs:21:9\n    |\n15 \
    \ | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value in array {\n\
    \    |                  ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         array.sort_by(|a, b| a.cmp(b));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpneof9pgi.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by(|a, b| b.cmp(a));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp90uzkkpl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::new();\n    while i < array.len() {\n        sum +=\
    \ array[i];\n        i += 1;\n    }\n    while j < array.len() {\n        sum\
    \ += array[j];\n        j += 1;\n    }\n    if sum % 2 == 1 {\n        for i in\
    \ 0..array.len() {\n            result.push(array[i]);\n        }\n    } else\
    \ {\n        for i in 0..array.len() {\n            result.push(array[i]);\n \
    \       }\n        for i in 0..array.len() {\n            result.push(array[i]);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 5]`,\n right: `[5]`', /tmp/tmp394068u1.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdkzxgabo.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.iter().rev().sum()).unwrap());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.iter().sum()).unwrap());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp4pbsls6y.rs:21:49\n   |\n21 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x.iter().rev().sum()).unwrap());\n   |                      \
    \                           ^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `iter` found for type `isize` in the current scope\n  --> /tmp/tmp4pbsls6y.rs:23:49\n\
    \   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.iter().sum()).unwrap());\n\
    \   |                                                 ^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum = 0;\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpe2h070uv.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k =\
    \ array.len() - 1;\n    while i <= k {\n        sum += array[i];\n        if sum\
    \ % 2 == 0 {\n            i += 1;\n        } else {\n            j += 1;\n   \
    \     }\n    }\n    let mut result = Vec::new();\n    while i <= k {\n       \
    \ result.push(array[i]);\n        i += 1;\n    }\n    while j <= k {\n       \
    \ result.push(array[j]);\n        j += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp7cvt3_o_.rs:47:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppiyviv15.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 0 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort_by_key(|&x| {\n        if x > max_value {\n \
    \           1\n        } else if x < min_value {\n            -1\n        } else\
    \ {\n            0\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpkc17x_zk.rs:28:5\n\
    \    |\n16  |       let mut array = array.to_owned();\n    |           ---------\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |       for value in array {\n    |             \
    \       ----- `array` moved due to this implicit call to `.into_iter()`\n...\n\
    28  | /     array.sort_by_key(|&x| {\n29  | |         if x > max_value {\n30 \
    \ | |             1\n31  | |         } else if x < min_value {\n...   |\n35  |\
    \ |         }\n36  | |     });\n    | |______^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n20  |     for value in &array {\n\
    \    |                  +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&0));\n\
    \    } else {\n        array.sort_by_key(|&x| x.cmp(&1));\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpa705eb7s.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x.cmp(&0));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpa705eb7s.rs:21:9\n    |\n15 \
    \ | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value in array {\n\
    \    |                  ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         array.sort_by_key(|&x| x.cmp(&0));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpa705eb7s.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x.cmp(&1));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpr28z2jhe.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpso60xwkm.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpso60xwkm.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpso60xwkm.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|&x| {\n        if x == min_value {\n          \
    \  -1\n        } else if x == max_value {\n            1\n        } else {\n \
    \           x\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp678btgvf.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp678btgvf.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &i in &array {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort();\n    } else {\n        array.sort();\n        array.reverse();\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpfhu7i584.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.iter().cloned().sort().collect()\n\
    \    } else {\n        array.iter().cloned().rsort().collect()\n    }\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpk16w37ak.rs:21:31\n   |\n21 |         array.iter().cloned().sort().collect()\n\
    \   |                               ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0599]: no method named `rsort` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpk16w37ak.rs:23:31\n   |\n23 |         array.iter().cloned().rsort().collect()\n\
    \   |                               ^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8q1qvvcu.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8q1qvvcu.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpr28z2jhe.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut index = 0;\n    let mut array\
    \ = array.to_owned();\n    while index < array.len() {\n        sum += array[index];\n\
    \        index += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&sum).reverse());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&sum));\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpguduq50h.rs:24:52\n   |\n24 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&sum).reverse());\n   |                                      \
    \              ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut sum = 0;\n\
    \    for x in &result {\n        sum += x;\n    }\n    if sum % 2 == 1 {\n   \
    \     result.sort_unstable();\n    } else {\n        result.sort_reverse();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_reverse` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp1r7olcwo.rs:24:16\n   |\n24 |         result.sort_reverse();\n\
    \   |                ^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `reverse`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp309xi827.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    while i < n {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.cmp(&array[j]));\n    } else {\n        array.sort_by_key(|&x| x.cmp(&array[j]).reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpjpygzzkp.rs:18:9\n\
    \   |\n18 |     let mut j = 0;\n   |         ----^\n   |         |\n   |     \
    \    help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\
    \nwarning: variable does not need to be mutable\n  --> /tmp/tmpjpygzzkp.rs:19:9\n\
    \   |\n19 |     let mut n = array.len();\n   |         ----^\n   |         |\n\
    \   |         help: remove this `mut`\n\nerror[E0596]: cannot borrow `array` as\
    \ mutable, as it is not declared as mutable\n  --> /tmp/tmpjpygzzkp.rs:25:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n25 |\
    \         array.sort_by_key(|&x| x.cmp(&array[j]));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjpygzzkp.rs:25:27\n  \
    \ |\n25 |         array.sort_by_key(|&x| x.cmp(&array[j]));\n   |         ------------------^^^^------------------\n\
    \   |         |     |           |           |\n   |         |     |          \
    \ |           second borrow occurs due to use of `array` in closure\n   |    \
    \     |     |           immutable borrow occurs here\n   |         |     mutable\
    \ borrow later used by call\n   |         mutable borrow occurs here\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpjpygzzkp.rs:27:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n27 |\
    \         array.sort_by_key(|&x| x.cmp(&array[j]).reverse());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `array` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmpjpygzzkp.rs:27:27\n  \
    \ |\n27 |         array.sort_by_key(|&x| x.cmp(&array[j]).reverse());\n   |  \
    \       ------------------^^^^----------------------------\n   |         |   \
    \  |           |           |"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|&x| {\n        match x {\n            x if x >\
    \ max_value => 1,\n            x if x < min_value => -1,\n            _ => 0,\n\
    \        }\n    });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqem0kttx.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqem0kttx.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter().rev() {\n        sum += i;\n        if sum % 2 == 1 {\n  \
    \          min_value = i;\n        } else {\n            max_value = i;\n    \
    \    }\n    }\n    array.sort_by_key(|&x| {\n        if min_value < x {\n    \
    \        Some(min_value)\n        } else {\n            Some(x)\n        }\n \
    \   });\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmw5vq3qq.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmw5vq3qq.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    let mut array = array.to_owned();\n    array.sort();\n \
    \   for value in array {\n        if value == min_value {\n            array.push(value);\n\
    \        }\n        if value == max_value {\n            array.push(value);\n\
    \        }\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpr09z022s.rs:16:9\n\
    \   |\n16 |     let mut array = array.to_owned();\n   |         ----^^^^^\n  \
    \ |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpr09z022s.rs:28:21\n\
    \    |\n16  |     let mut array = array.to_owned();\n    |         --------- move\
    \ occurs because `array` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n...\n20  |     for value in array {\n    |                  ----- `array`\
    \ moved due to this implicit call to `.into_iter()`\n...\n28  |     let mut array\
    \ = array.to_owned();\n    |                     ^^^^^^^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n20  |     for value in &array\
    \ {\n    |                  +\n\nerror[E0382]: borrow of moved value: `array`\n\
    \  --> /tmp/tmpr09z022s.rs:32:13\n   |\n28 |     let mut array = array.to_owned();\n\
    \   |         --------- move occurs because `array` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n29 |     array.sort();\n30 |     for value\
    \ in array {\n   |                  ----- `array` moved due to this implicit call\
    \ to `.into_iter()`\n31 |         if value == min_value {\n32 |             array.push(value);\n\
    \   |             ^^^^^^^^^^^^^^^^^ value borrowed here after move\n   |\nhelp:\
    \ consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n   |\n30 |     for value in &array {\n   |            \
    \      +\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    array.swap(0, i);\n        }\n        if sum % 2 == 0 {\n            array.swap(i,\
    \ array.len());\n        }\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprp87pqbj.rs:23:27\n   |\n\
    23 |             array.swap(0, i);\n   |                           ^ expected\
    \ `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprp87pqbj.rs:26:24\n\
    \   |\n26 |             array.swap(i, array.len());\n   |                    \
    \    ^ expected `usize`, found `&isize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort_by_key(|x| {\n        if min_value < x {\n  \
    \          -1\n        } else if max_value > x {\n            1\n        } else\
    \ {\n            0\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp630t05pr.rs:29:24\n   |\n\
    29 |         if min_value < x {\n   |                        ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n29 |  \
    \       if min_value < *x {\n   |                        +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp630t05pr.rs:31:31\n   |\n31 |         } else if max_value\
    \ > x {\n   |                               ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n31 |         } else if max_value\
    \ > *x {\n   |                               +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        if sum % 2 == 1 {\n            result.push(array[i]);\n\
    \            i += 1;\n        } else {\n            result.push(array[j]);\n \
    \           j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmpcr5j_7ng.rs:26:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::new();\n    while i < array.len() {\n        sum +=\
    \ array[i];\n        i += 1;\n    }\n    while j < array.len() {\n        if sum\
    \ % 2 == 0 {\n            result.push(array[j]);\n            sum += array[j];\n\
    \            j += 1;\n        } else {\n            result.push(array[j]);\n \
    \           sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp7mr2qejj.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_vec();\n    let mut sum = 0;\n\
    \    for &x in &array {\n        sum += x;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&x| -x);\n    } else {\n        array.sort_by_key(|&x|\
    \ x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[5, 4, 3, 2, 1, 0]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpsz3z8wxw.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `isize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmpvllyom25.rs:21:49\n   |\n21 |         array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n\
    \   |                                                 ^\n\nerror[E0599]: no method\
    \ named `reverse` found for enum `Option` in the current scope\n  --> /tmp/tmpvllyom25.rs:21:52\n\
    \   |\n21 |         array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n \
    \  |                                                    ^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror[E0610]: `isize` is a primitive type\
    \ and therefore doesn't have fields\n  --> /tmp/tmpvllyom25.rs:23:49\n   |\n23\
    \ |         array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n   |     \
    \                                            ^\n\nerror[E0599]: no method named\
    \ `reverse` found for enum `Option` in the current scope\n  --> /tmp/tmpvllyom25.rs:23:52\n\
    \   |\n23 |         array.sort_by_key(|&x| x.partial_cmp(&x.0).reverse());\n \
    \  |                                                    ^^^^^^^ method not found\
    \ in `Option<std::cmp::Ordering>`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in &array {\n        sum += value;\n        if sum % 2 == 1 {\n      \
    \      min_value = value;\n        } else {\n            max_value = value;\n\
    \        }\n    }\n    array.sort_by_key(|&value| {\n        if value == min_value\
    \ {\n            -1\n        } else if value == max_value {\n            1\n \
    \       } else {\n            0\n        }\n    });\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptnpgblhh.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *value;\n   | \
    \                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptnpgblhh.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = value;\n   | \
    \                        ^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *value;\n   | \
    \                        +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..result.len() {\n        sum += result[i];\n    }\n    if sum\
    \ % 2 == 1 {\n        result.sort_by_key(|&x| x);\n    } else {\n        result.sort_by_key(|&x|\
    \ -x);\n    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3cfcin6j.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for &i in array {\n        sum += i;\n    }\n    if\
    \ sum % 2 == 1 {\n        array.sort_by(|a, b| b.cmp(a));\n    } else {\n    \
    \    array.sort_by(|a, b| a.cmp(b));\n    }\n    array\n}\n\nfn main() {\n   \
    \ let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfhrbsz4t.rs:20:9\n   |\n\
    20 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.is_empty() {\n        return array;\n    }\n\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    let mut last_index = 0;\n \
    \   let mut last_sum = 0;\n\n    while index < array.len() {\n        sum += array[index];\n\
    \        if sum % 2 == 1 {\n            sum += 1;\n            last_sum += 1;\n\
    \        } else {\n            sum -= 1;\n            last_sum -= 1;\n       \
    \ }\n\n        if sum < last_sum {\n            swap(&mut array, index, last_index);\n\
    \            index += 1;\n            last_index += 1;\n            last_sum =\
    \ sum;\n        } else {\n            swap(&mut array, index, last_index);\n \
    \           index += 1;\n            last_index += 1;\n            last_sum =\
    \ sum;\n        }\n    }\n\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppftl2b85.rs:36:13\n\
    \   |\n36 |             swap(&mut array, index, last_index);\n   |           \
    \  ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find function `swap` in this scope\n  --> /tmp/tmppftl2b85.rs:41:13\n\
    \   |\n41 |             swap(&mut array, index, last_index);\n   |           \
    \  ^^^^ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpc2kzh3zm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x));\n    }\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpx25apqqk.rs:21:50\n   |\n21 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&x).reverse());\n   |                                        \
    \          ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in 0..array.len() {\n     \
    \   sum += array[i];\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x);\n    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpe49xc5wa.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpe49xc5wa.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[1..]));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp6b55b32c.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[1..]));\n   |    \
    \                                           ^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `isize`\n  --> /tmp/tmp6b55b32c.rs:26:47\n   |\n26 |  \
    \       array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n   |      \
    \                                         ^^^^^^\n\nerror[E0599]: no method named\
    \ `reverse` found for enum `Option` in the current scope\n  --> /tmp/tmp6b55b32c.rs:26:55\n\
    \   |\n26 |         array.sort_by_key(|&x| x.partial_cmp(&x[1..]).reverse());\n\
    \   |                                                       ^^^^^^^ method not\
    \ found in `Option<std::cmp::Ordering>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for &x in array {\n        sum += x;\n    }\n    if\
    \ sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n    } else {\n        array.sort_by_key(|&x|\
    \ x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n \
    \   assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvz3e7uf.rs:20:9\n   |\n\
    20 |     for &x in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `x`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    let mut result = Vec::new();\n\
    \n    while index < array.len() {\n        sum += array[index];\n        result.push(sum);\n\
    \        index += 1;\n    }\n\n    if sum % 2 == 1 {\n        result.sort();\n\
    \    } else {\n        result.sort();\n        result.into_iter().rev().collect();\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpnulxqqsp.rs:34:34\n\
    \     |\n34   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n34   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n34   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::new();\n    while i < array.len() {\n        sum +=\
    \ array[i];\n        i += 1;\n    }\n    while j < array.len() {\n        if sum\
    \ % 2 == 0 {\n            result.push(array[j]);\n            sum += array[j];\n\
    \            j += 1;\n        } else {\n            result.push(array[j]);\n \
    \           sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmp7mr2qejj.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&0));\n\
    \    } else {\n        array.sort_by_key(|&x| x.cmp(&1));\n    }\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpa705eb7s.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x.cmp(&0));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpa705eb7s.rs:21:9\n    |\n15 \
    \ | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value in array {\n\
    \    |                  ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         array.sort_by_key(|&x| x.cmp(&0));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpa705eb7s.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x.cmp(&1));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 1 {\n            max_value = value;\n        } else {\n            min_value\
    \ = value;\n        }\n    }\n    let mut array = array.clone();\n    array.sort();\n\
    \    let mut i = 0;\n    while i < array.len() {\n        if array[i] < min_value\
    \ {\n            array[i] = min_value;\n            i += 1;\n        } else {\n\
    \            array[i] = max_value;\n            i += 1;\n        }\n    }\n  \
    \  array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpcelzkn4f.rs:30:21\n\
    \    |\n15  | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |        \
    \       ----- move occurs because `array` has type `Vec<isize>`, which does not\
    \ implement the `Copy` trait\n...\n22  |     for value in array {\n    |     \
    \             ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n30  |     let mut array = array.clone();\n    |                     ^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n22\
    \  |     for value in &array {\n    |                  +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp90uzkkpl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    let mut sum = 0;\n    for\
    \ value in array {\n        sum += value;\n        result.push(value);\n    }\n\
    \    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.sort();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpi_7_gmv_.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpjvca4hhk.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut sum\
    \ = 0;\n    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpnhwdkon8.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.cmp(&x[array.len()\
    \ - 1]));\n    } else {\n        array.sort_by_key(|&x| x.cmp(&x[array.len() -\
    \ 1]).reverse());\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp2ia3xd_k.rs:21:39\n\
    \   |\n21 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]));\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot\
    \ index into a value of type `isize`\n  --> /tmp/tmp2ia3xd_k.rs:23:39\n   |\n\
    23 |         array.sort_by_key(|&x| x.cmp(&x[array.len() - 1]).reverse());\n \
    \  |                                       ^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpk980nhf4.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in array.iter() {\n       \
    \ sum += i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n\
    \    } else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8q1qvvcu.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&i| i);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8q1qvvcu.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&i| -i);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmp8oi22mil.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmp8oi22mil.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    while i < n {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    while j < n {\n        sum += array[j];\n        j\
    \ += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[j])).collect::<Vec<_>>()\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[i])).collect::<Vec<_>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpg1qm45wi.rs:29:58\n\
    \   |\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[j])).collect::<Vec<_>>()\n\
    \   |                                                          ^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpg1qm45wi.rs:31:58\n   |\n\
    31 |         array.sort_by_key(|&x| x.partial_cmp(&array[i])).collect::<Vec<_>>()\n\
    \   |                                                          ^^^^^^^ `()` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:24:27\n   |\n24 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n   |         ------------------^^^^---------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:26:27\n   |\n26 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n   |         ------------------^^^^-------------------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpgk2_8uq4.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpgk2_8uq4.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpmurrjb9i.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut index = 0;\n    let mut result\
    \ = Vec::new();\n    while index < array.len() {\n        sum += array[index];\n\
    \        result.push(sum);\n        index += 1;\n    }\n    if sum % 2 == 1 {\n\
    \        result.sort();\n    } else {\n        result.sort();\n        result.into_iter().rev().collect();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp9g1hseir.rs:28:34\n\
    \     |\n28   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n28   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n28   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6pt3v44.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &i in &array {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpzyygik6_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = array.len() - 1;\n    while i < k {\n        sum += array[i];\n\
    \        i += 1;\n    }\n    while j < k {\n        sum += array[j];\n       \
    \ j += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&array[k]));\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&array[k]));\n   \
    \     array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmp2gzr3y8_.rs:19:9\n\
    \   |\n19 |     let mut k = array.len() - 1;\n   |         ----^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp2gzr3y8_.rs:29:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n29 |         array.sort_by_key(|&x| x.partial_cmp(&array[k]));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as\
    \ mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmp2gzr3y8_.rs:29:27\n   |\n29 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[k]));\n   |         ------------------^^^^--------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0596]: cannot borrow `array` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp2gzr3y8_.rs:31:9\n   |\n15 | fn sort_array(array: Vec<isize>) ->\
    \ Vec<isize> {\n   |               ----- help: consider changing this to be mutable:\
    \ `mut array`\n...\n31 |         array.sort_by_key(|&x| x.partial_cmp(&array[k]));\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as\
    \ mutable\n\nerror[E0502]: cannot borrow `array` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmp2gzr3y8_.rs:31:27\n   |\n31 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[k]));\n   |         ------------------^^^^--------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp309xi827.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() <= 1 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for i in 0..array.len() {\n        sum += array[i];\n\
    \    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n    } else\
    \ {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn main() {\n\
    \    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpyh7t3690.rs:24:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n24 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpyh7t3690.rs:26:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n26 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() < 2 {\n        return array;\n    }\n  \
    \  let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = array.len()\
    \ - 1;\n    while i < k {\n        if array[i] < array[j] {\n            sum +=\
    \ array[i];\n            i += 1;\n        } else {\n            sum += array[j];\n\
    \            j += 1;\n        }\n    }\n    if sum % 2 == 0 {\n        array.sort_by_key(|&x|\
    \ x);\n    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpzi9lllnt.rs:22:9\n\
    \   |\n22 |     let mut k = array.len() - 1;\n   |         ----^\n   |       \
    \  |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `array` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmpzi9lllnt.rs:33:9\n   |\n15 | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n   |               ----- help: consider changing\
    \ this to be mutable: `mut array`\n...\n33 |         array.sort_by_key(|&x| x);\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpzi9lllnt.rs:35:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n35 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 2 previous errors; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum = 0;\n  \
    \  for element in array {\n        sum += element;\n        result.push(element);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpweissh6x.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::<isize>::new();\n    let mut sum\
    \ = 0;\n    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpnhwdkon8.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n \
    \       if sum % 2 == 0 {\n            result.push(array[j]);\n            sum\
    \ += array[j];\n            j += 1;\n        } else {\n            result.push(array[j]);\n\
    \            sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmph1sds_w_.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp90uzkkpl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| a.cmp(b));\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpinn3lotb.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by(|a, b| a.cmp(b));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpinn3lotb.rs:21:9\n    |\n15 \
    \ | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for x in array {\n \
    \   |              ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         array.sort_by(|a, b| a.cmp(b));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for x in &array {\n    |              +\n\nerror[E0596]: cannot borrow\
    \ `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpinn3lotb.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by(|a, b| b.cmp(a));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \    } else {\n        array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `isize`\n  --> /tmp/tmpzf7f1tlv.rs:22:47\n\
    \   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]).reverse());\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `reverse` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpzf7f1tlv.rs:22:67\n   |\n22 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len()\
    \ - 1]).reverse());\n   |                                                    \
    \               ^^^^^^^ method not found in `Option<std::cmp::Ordering>`\n\nerror[E0608]:\
    \ cannot index into a value of type `isize`\n  --> /tmp/tmpzf7f1tlv.rs:24:47\n\
    \   |\n24 |         array.sort_by_key(|&x| x.partial_cmp(&x[array.len() - 1]));\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| -x);\n\
    \    } else {\n        array.sort_by_key(|&x| x);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpso60xwkm.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| -x);\n   |  \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmpso60xwkm.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| -x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpso60xwkm.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort();\n   \
    \ array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmppiyviv15.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    while i < array.len() {\n       \
    \ sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n    \
    \    if sum % 2 == 1 {\n            array[j].swap(array[j + 1]);\n           \
    \ sum += array[j];\n            j += 1;\n        } else {\n            sum +=\
    \ array[j];\n            j += 1;\n        }\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpqy8w1i4w.rs:26:22\n   |\n26 |             array[j].swap(array[j\
    \ + 1]);\n   |                      ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6pt3v44.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = vec![];\n    let mut sum = 0;\n    for\
    \ value in array {\n        sum += value;\n        result.push(value);\n    }\n\
    \    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpdpryj1jr.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x| x);\n\
    \    } else {\n        array.sort_by_key(|&x| -x);\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp8biq9181.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by_key(|&x| x);\n   |   \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]: borrow\
    \ of moved value: `array`\n   --> /tmp/tmp8biq9181.rs:21:9\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n16  |    \
    \ let mut sum = 0;\n17  |     for value in array {\n    |                  -----\
    \ `array` moved due to this implicit call to `.into_iter()`\n...\n21  |      \
    \   array.sort_by_key(|&x| x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmp8biq9181.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by_key(|&x| -x);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut i = 0;\n    while i < array.len() {\n        sum += array[i];\n \
    \       i += 1;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n    } else {\n        array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n    }\n    array\n}\n\nfn\
    \ main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:24:27\n   |\n24 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap());\n   |         ------------------^^^^---------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror[E0502]: cannot borrow `array` as immutable because it is also borrowed\
    \ as mutable\n  --> /tmp/tmp2l7xg52g.rs:26:27\n   |\n26 |         array.sort_by_key(|&x|\
    \ x.partial_cmp(&array[i + 1]).unwrap().reverse());\n   |         ------------------^^^^-------------------------------------------------\n\
    \   |         |     |           |                   |\n   |         |     |  \
    \         |                   second borrow occurs due to use of `array` in closure\n\
    \   |         |     |           immutable borrow occurs here\n   |         | \
    \    mutable borrow later used by call\n   |         mutable borrow occurs here\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut result = Vec::<isize>::new();\n    while i < array.len() {\n    \
    \    sum += array[i];\n        i += 1;\n    }\n    while j < array.len() {\n \
    \       if sum % 2 == 0 {\n            result.push(array[j]);\n            sum\
    \ += array[j];\n            j += 1;\n        } else {\n            result.push(array[j]);\n\
    \            sum -= array[j];\n            j += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmph1sds_w_.rs:42:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpc2kzh3zm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.reverse();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpr28z2jhe.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpc2kzh3zm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for i in 0..array.len() {\n     \
    \   sum += array[i];\n    }\n    if sum % 2 == 1 {\n        array.iter().cloned().sort_by_key(|&x|\
    \ x).collect()\n    } else {\n        array.iter().cloned().sort_by_key(|&x| -x).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpg3klha6k.rs:21:31\n   |\n21 |         array.iter().cloned().sort_by_key(|&x|\
    \ x).collect()\n   |                               ^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, isize>>`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpg3klha6k.rs:23:31\n\
    \   |\n23 |         array.iter().cloned().sort_by_key(|&x| -x).collect()\n   |\
    \                               ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for value in array {\n        sum\
    \ += value;\n    }\n    if sum % 2 == 1 {\n        array.sort_by(|a, b| a.cmp(b));\n\
    \    } else {\n        array.sort_by(|a, b| b.cmp(a));\n    }\n    array\n}\n\n\
    fn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpneof9pgi.rs:21:9\n   |\n15 | fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |               ----- help: consider changing this to be\
    \ mutable: `mut array`\n...\n21 |         array.sort_by(|a, b| a.cmp(b));\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0382]:\
    \ borrow of moved value: `array`\n   --> /tmp/tmpneof9pgi.rs:21:9\n    |\n15 \
    \ | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |               -----\
    \ move occurs because `array` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n16  |     let mut sum = 0;\n17  |     for value in array {\n\
    \    |                  ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n21  |         array.sort_by(|a, b| a.cmp(b));\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n    |\nnote: this function takes ownership of\
    \ the receiver `self`, which moves `array`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n17\
    \  |     for value in &array {\n    |                  +\n\nerror[E0596]: cannot\
    \ borrow `array` as mutable, as it is not declared as mutable\n  --> /tmp/tmpneof9pgi.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \    ----- help: consider changing this to be mutable: `mut array`\n...\n23 |\
    \         array.sort_by(|a, b| b.cmp(a));\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for &i in &array {\n        sum += i;\n    }\n    if sum % 2 == 1 {\n   \
    \     array.sort_by_key(|&i| i);\n    } else {\n        array.sort_by_key(|&i|\
    \ -i);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpzyygik6_.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut n = array.len();\n    let mut result = Vec::new();\n    while i <\
    \ n {\n        sum += array[i];\n        if sum % 2 == 1 {\n            result.push(array[i]);\n\
    \            i += 1;\n        } else {\n            result.push(array[j]);\n \
    \           j += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 6 but the
    index is 6'', /tmp/tmp5ykow2lh.rs:27:25

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut min_value = array[0];\n \
    \   let mut max_value = array[0];\n    for value in array {\n        sum += value;\n\
    \        if sum % 2 == 1 {\n            min_value = value;\n        } else {\n\
    \            max_value = value;\n        }\n    }\n    array.sort_by_key(|&x|\
    \ {\n        if x < min_value {\n            -1\n        } else if x > max_value\
    \ {\n            1\n        } else {\n            0\n        }\n    });\n    array\n\
    }\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `array` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpez23qdk0.rs:27:5\n   |\n15 |   fn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n   |                 ----- help: consider changing this to\
    \ be mutable: `mut array`\n...\n27 | /     array.sort_by_key(|&x| {\n28 | |  \
    \       if x < min_value {\n29 | |             -1\n30 | |         } else if x\
    \ > max_value {\n...  |\n34 | |         }\n35 | |     });\n   | |______^ cannot\
    \ borrow as mutable\n\nerror[E0382]: borrow of moved value: `array`\n   --> /tmp/tmpez23qdk0.rs:27:5\n\
    \    |\n15  |   fn sort_array(array: Vec<isize>) -> Vec<isize> {\n    |      \
    \           ----- move occurs because `array` has type `Vec<isize>`, which does\
    \ not implement the `Copy` trait\n...\n19  |       for value in array {\n    |\
    \                    ----- `array` moved due to this implicit call to `.into_iter()`\n\
    ...\n27  | /     array.sort_by_key(|&x| {\n28  | |         if x < min_value {\n\
    29  | |             -1\n30  | |         } else if x > max_value {\n...   |\n34\
    \  | |         }\n35  | |     });\n    | |______^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `array`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for value in &array {\n\
    \    |                  +\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0382, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum = 0;\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpe2h070uv.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::new();\n  \
    \  for i in array.iter() {\n        sum += i;\n        result.push(i);\n    }\n\
    \    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpujzqpkib.rs:28:5\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n28 |     result\n   |     ^^^^^^ expected `isize`, found `&isize`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Vec<&isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for x in array {\n        sum +=\
    \ x;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|x| -x)\n    } else\
    \ {\n        array.sort_by_key(|x| x)\n    }\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkurn8goe.rs:21:9\n   |\n\
    15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |                  \
    \                   ---------- expected `Vec<isize>` because of return type\n\
    ...\n21 |         array.sort_by_key(|x| -x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkurn8goe.rs:23:9\n\
    \   |\n15 | fn sort_array(array: Vec<isize>) -> Vec<isize> {\n   |           \
    \                          ---------- expected `Vec<isize>` because of return\
    \ type\n...\n23 |         array.sort_by_key(|x| x)\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ i in array.iter() {\n        sum += i;\n        if sum % 2 == 1 {\n        \
    \    min_value = i;\n        } else {\n            max_value = i;\n        }\n\
    \    }\n    array.sort_by_key(|&x| {\n        if x == min_value {\n          \
    \  -1\n        } else if x == max_value {\n            1\n        } else {\n \
    \           x\n        }\n    });\n    array\n}\n\nfn main() {\n    let candidate\
    \ = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp678btgvf.rs:23:25\n   |\n\
    18 |     let mut min_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n23 |             min_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n23 |             min_value = *i;\n   |     \
    \                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp678btgvf.rs:25:25\n\
    \   |\n19 |     let mut max_value = array[0];\n   |                         --------\
    \ expected due to this value\n...\n25 |             max_value = i;\n   |     \
    \                    ^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |             max_value = *i;\n   |     \
    \                    +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 1 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    array.sort_by_key(|&value| {\n        if value < min_value\
    \ {\n            true\n        } else if value > max_value {\n            false\n\
    \        } else {\n            sum - value\n        }\n    });\n    array\n}\n\
    \nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpin5kchb7.rs:34:13\n\
    \   |\n31 |           } else if value > max_value {\n   |  ________________-\n\
    32 | |             false\n   | |             ----- expected because of this\n\
    33 | |         } else {\n34 | |             sum - value\n   | |             ^^^^^^^^^^^\
    \ expected `bool`, found `isize`\n35 | |         }\n   | |_________- `if` and\
    \ `else` have incompatible types\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    for &i in array {\n        sum +=\
    \ i;\n    }\n    if sum % 2 == 1 {\n        array.sort_by_key(|&i| i);\n    }\
    \ else {\n        array.sort_by_key(|&i| -i);\n    }\n    array\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl6pt3v44.rs:17:9\n   |\n\
    17 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.is_empty() {\n        return array;\n    }\n\n\
    \    let mut sum = 0;\n    let mut min_value = array[0];\n    let mut max_value\
    \ = array[0];\n\n    for value in array {\n        sum += value;\n        if sum\
    \ % 2 == 0 {\n            min_value = value;\n        } else {\n            max_value\
    \ = value;\n        }\n    }\n\n    let mut result = Vec::<isize>::new();\n  \
    \  let mut index = array.len();\n    while index > 0 {\n        let mut value\
    \ = array[index - 1];\n        if value == max_value {\n            result.push(value);\n\
    \            index -= 1;\n        } else {\n            result.push(value);\n\
    \            index = index;\n        }\n    }\n\n    result.sort_unstable();\n\
    \    result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `min_value` is assigned to, but never used\n  --> /tmp/tmpw4m7zh0b.rs:21:13\n\
    \   |\n21 |     let mut min_value = array[0];\n   |             ^^^^^^^^^\n  \
    \ |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider\
    \ using `_min_value` instead\n\nwarning: value assigned to `min_value` is never\
    \ read\n  --> /tmp/tmpw4m7zh0b.rs:27:13\n   |\n27 |             min_value = value;\n\
    \   |             ^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on\
    \ by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpw4m7zh0b.rs:36:13\n   |\n\
    36 |         let mut value = array[index - 1];\n   |             ----^^^^^\n \
    \  |             |\n   |             help: remove this `mut`\n   |\n   = note:\
    \ `#[warn(unused_mut)]` on by default\n\nerror[E0382]: borrow of moved value:\
    \ `array`\n   --> /tmp/tmpw4m7zh0b.rs:34:21\n    |\n15  | fn sort_array(array:\
    \ Vec<isize>) -> Vec<isize> {\n    |               ----- move occurs because `array`\
    \ has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n24  |\
    \     for value in array {\n    |                  ----- `array` moved due to\
    \ this implicit call to `.into_iter()`\n...\n34  |     let mut index = array.len();\n\
    \    |                     ^^^^^^^^^^^ value borrowed here after move\n    |\n\
    note: this function takes ownership of the receiver `self`, which moves `array`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n24  |     for value in &array {\n    |         \
    \         +\n\nerror: aborting due to previous error; 3 warnings emitted\n\nFor\
    \ more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    array.sort_by_key(|x|\
    \ x.clone());\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp_mz72b5h.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut sum = 0;\n    let mut result = Vec::<isize>::new();\n\
    \    for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmp7treo4u2.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011802
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    if array.len() == 0 {\n        return array;\n    }\n \
    \   let mut sum = 0;\n    for &i in array {\n        sum += i;\n    }\n    if\
    \ sum % 2 == 1 {\n        array.sort_by(|a, b| {\n            b.cmp(a)\n     \
    \   });\n    } else {\n        array.sort_by(|a, b| {\n            a.cmp(b)\n\
    \        });\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplbgcke01.rs:20:9\n   |\n\
    20 |     for &i in array {\n   |         ^^    ----- this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort_by_key(|&x|\
    \ -x);\n    }\n    array\n}\n\nfn main() {\n    let candidate = sort_array;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]),\
    \ vec![5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5]), vec![0, 1, 2, 3,\
    \ 4, 5]);\n    assert_eq!(candidate(vec![2, 4, 3, 0, 1, 5, 6]), vec![6, 5, 4,\
    \ 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2, 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15,\
    \ 42, 87, 32, 11, 0]), vec![0, 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21,\
    \ 14, 23, 11]), vec![23, 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp3ppga69b.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut sum = 0;\n  \
    \  for value in array {\n        sum += value;\n        result.push(value);\n\
    \    }\n    if sum % 2 == 1 {\n        result.sort();\n    } else {\n        result.sort();\n\
    \        result.into_iter().rev().collect();\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpe2h070uv.rs:26:34\n\
    \     |\n26   |         result.into_iter().rev().collect();\n     |          \
    \                        ^^^^^^^ cannot infer type for type parameter `B` declared\
    \ on the associated function `collect`\n     |\n     = note: cannot satisfy `_:\
    \ FromIterator<isize>`\nnote: required by a bound in `collect`\nhelp: consider\
    \ specifying the type argument in the method call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\nhelp: consider specifying\
    \ the type argument in the function call\n     |\n26   |         result.into_iter().rev().collect::<B>();\n\
    \     |                                         +++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0283`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 1
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    let mut sum = 0;\n\
    \    let mut min_value = array[0];\n    let mut max_value = array[0];\n    for\
    \ value in array {\n        sum += value;\n        if sum % 2 == 0 {\n       \
    \     min_value = value;\n        } else {\n            max_value = value;\n \
    \       }\n    }\n    if min_value < max_value {\n        array.sort_by(|a, b|\
    \ {\n            a - b\n        });\n    } else {\n        array.sort_by(|a, b|\
    \ {\n            b - a\n        });\n    }\n    array\n}\n\nfn main() {\n    let\
    \ candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4nekwsgl.rs:30:13\n   |\n\
    30 |             a - b\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4nekwsgl.rs:34:13\n\
    \   |\n34 |             b - a\n   |             ^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        array.sort();\n    } else {\n        array.sort();\n     \
    \   array.reverse();\n    }\n    array\n}\n\nfn main() {\n    let candidate =\
    \ sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmpc2kzh3zm.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut array = array.to_owned();\n    array.sort();\n\
    \    array\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 6]`,\n right: `[6, 5, 4, 3, 2, 1, 0]`', /tmp/tmp90uzkkpl.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
- exit_code: 101
  program: "/// Given an array of non-negative integers, return a copy of the given\
    \ array after sorting,\n/// you will sort the given array in ascending order if\
    \ the sum( first index value, last index value) is odd,\n/// or sort it in descending\
    \ order if the sum( first index value, last index value) is even.\n/// Note:\n\
    /// * don't change the given array.\n/// Examples:\n/// >>> sort_array(vec![])\n\
    /// Vec::<isize>::new()\n/// >>> sort_array(vec![5])\n/// vec![5]\n/// >>> sort_array(vec![2,\
    \ 4, 3, 0, 1, 5])\n/// vec![0, 1, 2, 3, 4, 5]\n/// >>> sort_array(vec![2, 4, 3,\
    \ 0, 1, 5, 6])\n/// vec![6, 5, 4, 3, 2, 1, 0]\nfn sort_array(array: Vec<isize>)\
    \ -> Vec<isize> {\n    let mut result = array.clone();\n    let mut sum = 0;\n\
    \    for i in 0..array.len() {\n        sum += array[i];\n    }\n    if sum %\
    \ 2 == 1 {\n        result.sort_by_key(|&x| x.cmp(&array[array.len() - 1]));\n\
    \    } else {\n        result.sort_by_key(|&x| x.cmp(&array[0]));\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = sort_array;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![5]), vec![5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5]), vec![0, 1, 2, 3, 4, 5]);\n    assert_eq!(candidate(vec![2,\
    \ 4, 3, 0, 1, 5, 6]), vec![6, 5, 4, 3, 2, 1, 0]);\n    assert_eq!(candidate(vec![2,\
    \ 1]), vec![1, 2]);\n    assert_eq!(candidate(vec![15, 42, 87, 32, 11, 0]), vec![0,\
    \ 11, 15, 32, 42, 87]);\n    assert_eq!(candidate(vec![21, 14, 23, 11]), vec![23,\
    \ 21, 14, 11]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 4, 3, 0, 1, 5]`,\n right: `[0, 1, 2, 3, 4, 5]`', /tmp/tmpgxzhuykj.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011803
