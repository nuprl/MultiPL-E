name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the list l.\n/// >>> median(vec![3, 1, 2,\
  \ 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a,\
    \ |a, e| {\n            a + (e / b.len())\n        })\n    })", "    let mut l\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if a < b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            match b {\n                0 => a,\n          \
    \      a => a,\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() as f64\
    \ / 2,\n        |a, b| {\n            if a > b {\n                a\n        \
    \    } else {\n                b\n            }\n        },\n    )", "    let\
    \ mut s = l.iter().fold(0, |a, b| a + b);\n    l.iter().fold(s.floor(), |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    l.iter().fold(0.0, |a, b| {\n        if *a < *b {\n    \
    \        a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })",
  "    l.iter().fold(f64::NEG_INFINITY,\n                  |acc, x| if x < acc { x\
    \ } else { acc })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            match b {\n                0 => a,\n                a => a,\n\
    \            }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n       \
    \ b.checked_add(a).unwrap_or(b.checked_add(1.0))\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n  \
    \  })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            x\n        } else {\n            acc\n        }\n    )"]
stop_tokens:
- "\n}"
