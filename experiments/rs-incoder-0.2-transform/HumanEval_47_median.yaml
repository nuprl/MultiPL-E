name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the list l.\n/// >>> median(vec![3, 1, 2,\
  \ 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!(candidate(vec![3,\
  \ 1, 2, 4, 5]), 3.0);\n    assert_eq!(candidate(vec![-10, 4, 6, 1000, 10, 20]),\
  \ 8.0);\n    assert_eq!(candidate(vec![5]), 5.0);\n    assert_eq!(candidate(vec![6,\
  \ 5]), 5.5);\n    assert_eq!(candidate(vec![8, 1, 3, 9, 9, 2, 7]), 7.0);\n}\n"
completions: ["    l.iter().fold(f64::nan(), |a, b| {\n        match b {\n       \
    \     None => a,\n            Some(x) => if x < a { a } else { x },\n        }\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n\
    \            None => a,\n            Some(x) => if x < a { a } else { x },\n \
    \       }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            x\n        } else {\n            acc\n        },\n    )", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if b < a {\n                b\n            } else {\n                a\n\
    \            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.checked_add(b).unwrap().sqrt()).unwrap()', "    l.iter().fold(0.0, |sum,\
    \ el| {\n        sum + el\n    }) / l.len()", "    let mut l = l.to_vec();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        b.checked_add(a).unwrap_or(a)\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a,\
    \ |acc, x| {\n            if x < acc {\n                acc\n            } else\
    \ {\n                x\n            }\n        })\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| {\n        acc.checked_add(x / 2).unwrap()\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc { x } else { acc },\n   \
    \ )", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n        \
    \    if a > b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n       \
    \ a.checked_add(b).unwrap() / 2.0\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |acc, x| if x < acc {\n            x\n        } else {\n            acc\n\
    \        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2",
  "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc {\n   \
    \         x\n        } else {\n            acc\n        }\n    )", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x <= acc {\n            x\n     \
    \   } else {\n            acc\n        }\n    )", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", '    l.iter().fold(0.0, |sum, e| sum
    + e / 2)', "    l.iter().fold(f64::NEG_INFINITY,\n                  |median, elem|\
    \ {\n                      if elem > median {\n                          median\n\
    \                      } else if elem < median {\n                          elem\n\
    \                      } else {\n                          median\n          \
    \            }\n                  })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            if a > b {\n                a\n            } else\
    \ {\n                b\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", '    l.iter().fold(f64::nan, |a, b|
    a.checked_add(b).unwrap() / 2)', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len().checked_div(2).unwrap_or(l.len())", "    let mut s\
    \ = l.iter().fold(0, |a, b| a + b);\n    s /= l.len() as f64;\n    s", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |a, b| {\n            if *a < *b {\n        \
    \        a\n            } else {\n                b\n            }\n        },\n\
    \    )", "    let mut s = l.iter().fold(0.0, |s, x| s + x);\n    s / l.len()",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n \
    \   s.sort();\n    s.len().checked_div(2).unwrap()", "    l.iter().fold(\n   \
    \     l.len() / 2.0,\n        |a, b| {\n            if *a < *b {\n           \
    \     a\n            } else {\n                b\n            }\n        },\n\
    \    )", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |c, d| {\n\
    \            d if c < a else c\n        })\n    })", "    l.iter().fold(0.0, |a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            if a < b {\n                a\n            } else {\n       \
    \         b\n            }\n        },\n    )", "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |acc, x| if x < acc {\n            acc\n        } else {\n \
    \           x\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(f64::NEG_INFINITY,\n                  |median, el| if el < median\
    \ { el } else { median })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2,\n        |a, b| {\n        \
    \    match b {\n                0 => a,\n                a => a - 1,\n       \
    \     }\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\n         \
    \         |acc, x| if x < acc { x } else { acc })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan, |a, b| {\n    \
    \    b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap() + b.partial_cmp(b).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc { x } else { acc },\n   \
    \ )", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n  \
    \  })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n  \
    \          None => a,\n            Some(x) => if x < a { a } else { x },\n   \
    \     }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |sum, el| {\n      \
    \  match el {\n            0 => sum,\n            x if x < sum => x,\n       \
    \     x if x > sum => sum,\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        match x.partial_cmp(&acc) {\n            Some(Ordering::Less)\
    \ => acc,\n            Some(Ordering::Greater) => x,\n            Some(Ordering::Equal)\
    \ => x,\n            Some(Ordering::NotEqual) => acc,\n            None => x,\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", '    l.iter().fold(0.0, |sum, e| sum + e) / l.len()', '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.partial_cmp(b).unwrap().unwrap())', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        match x.partial_cmp(&acc) {\n            Some(Ordering::Less)\
    \ => acc - x,\n            Some(Ordering::Greater) => x + acc,\n            Some(Ordering::Equal)\
    \ => x,\n            None => x,\n        }\n    })", "    l.iter().fold(0.0, |a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |acc,
    x| acc + x / 2)', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            if a > b {\n                a\n            } else\
    \ {\n                b\n            }\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| {\n        match acc.checked_add(x.into()) {\n            Some(mut\
    \ m) => m,\n            None => return f64::NEG_INFINITY,\n        }\n    })",
  '    l.iter().fold(f64::NEG_INFINITY, |a, b| a.checked_add(f64::from(b)).unwrap())',
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(&a).unwrap().sqrt()\n  \
    \  })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(f64::nan())\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if *a < *b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| {\n        match acc.checked_add(x.into()) {\n            Some(mut\
    \ m) => m,\n            None => return f64::NEG_INFINITY,\n        }\n    })",
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            if a > b {\n                a\n            } else {\n       \
    \         b\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    l.iter().fold(\n        l.len() / 2,\n        |a, b| {\n      \
    \      if *a > *b {\n                b\n            } else {\n               \
    \ a\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc,\
    \ x| if x < acc { x } else { acc },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap())\n  \
    \  })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ { acc } else { x },\n    )", "    l.iter().fold(0.0, |sum, e| {\n        match\
    \ sum {\n            0.0 => e,\n            x => if x < e { x } else { e },\n\
    \        }\n    })", '    l.iter().fold(f64::NEG_INFINITY, |acc, x| acc + f64::from(x.median()))',
  "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(1.0))\n\
    \    })", '    l.iter().fold(f64::nan, |a, b| a.checked_add(f64::from(b.floor())).unwrap())',
  '    l.iter().fold(f64::NEG_INFINITY, |a, b| a.partial_cmp(b).unwrap().unwrap())',
  "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(b)\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n\
    \            None => a,\n            Some(x) => if x < a { a } else { x },\n \
    \       }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ b < a { a } else { b }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a,\
    \ b| if b < a { b } else { a },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() as f64 / 2.0",
  "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l =\
    \ l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a > b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n \
    \   l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).expect(\"\
    overflow\")\n    })", "    l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap()\
    \ / 2.0\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            a if a < b => a,\n            a if\
    \ a > b => b,\n            _ => a + b,\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |acc, x| {\n        acc + (x.f64() / l.len() as f64)\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc {\n            x\n      \
    \  } else {\n            acc\n        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |acc, x| if x < acc { x } else { acc },\n    )", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len().checked_div(2).unwrap();\n    l[(l.len()\
    \ - 1) >> 1].clone()", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap()\
    \ + b.partial_cmp(b).unwrap()) / 2\n    })", "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |a, b| {\n            if b < a {\n                b\n      \
    \      } else {\n                a\n            }\n        },\n    )", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n   \
    \ l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len().check();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            None => a,\n            Some(x) =>\
    \ if x < a { a } else { x },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })", " \
    \   let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |a, b| {\n            match b {\n           \
    \     0 => a,\n                a => a - b,\n            }\n        },\n    )",
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap())\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc, x|\
    \ {\n        match x.checked_div(acc.checked_add(acc)) {\n            Some(quotient)\
    \ => quotient,\n            None => f64::NEG_INFINITY,\n        }\n    })", " \
    \   let mut s = l.iter().fold(0, |a, b| a + b);\n    s /= l.len();\n    s", " \
    \   l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n           \
    \ Some(x) => a.checked_add(x),\n            None => a,\n        }\n    })", " \
    \   l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n    })", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", '    l.iter().fold(0.0, |sum, el| sum + el) / l.len()', "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |a, b| {\n            b.floor() as f64 + a.ceil()\
    \ as f64\n        },\n    )", "    l.iter().fold(\n        l.len() / 2.0,\n  \
    \      |acc, x| if x < acc { acc } else { x },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      b.checked_add(a).unwrap_or(b)\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    let\
    \ mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if *a < *b {\n \
    \           a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).expect(\"\
    overflow\")\n    })", "    let mut s = l.iter().fold(0.0, |sum, e| sum + e);\n\
    \    s / (l.len() as f64)", "    l.iter().fold(f64::nan(), |a, b| {\n        match\
    \ b {\n            None => a,\n            Some(x) => if x < a { a } else { x\
    \ },\n        }\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2"]
stop_tokens:
- "\n}"
