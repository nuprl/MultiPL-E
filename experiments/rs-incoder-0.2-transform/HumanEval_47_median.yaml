name: HumanEval_47_median
language: rs
prompt: "/// Return median of elements in the list l.\n/// >>> median(vec![3, 1, 2,\
  \ 4, 5])\n/// 3.0\n/// >>> median(vec![-10, 4, 6, 1000, 10, 20])\n/// 15.0\nfn median(l:\
  \ Vec<isize>) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = median;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a,\
    \ |a, e| {\n            a + (e / b.len())\n        })\n    })", "    let mut l\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", " \
    \   let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if a < b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            match b {\n                0 => a,\n          \
    \      a => a,\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() as f64\
    \ / 2,\n        |a, b| {\n            if a > b {\n                a\n        \
    \    } else {\n                b\n            }\n        },\n    )", "    let\
    \ mut s = l.iter().fold(0, |a, b| a + b);\n    l.iter().fold(s.floor(), |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    l.iter().fold(0.0, |a, b| {\n        if *a < *b {\n    \
    \        a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })",
  "    l.iter().fold(f64::NEG_INFINITY,\n                  |acc, x| if x < acc { x\
    \ } else { acc })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            match b {\n                0 => a,\n                a => a,\n\
    \            }\n        },\n    )", "    l.iter().fold(0.0, |a, b| {\n       \
    \ b.checked_add(a).unwrap_or(b.checked_add(1.0))\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(b).unwrap())\n  \
    \  })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            x\n        } else {\n            acc\n        }\n    )", "  \
    \  l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).expect(\"\
    overflow\")\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(a)\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", '    l.iter().fold(0.0, |sum, e| sum + e / 2)', "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc { x } else { acc },\n   \
    \ )", "    l.iter().fold(0.0, |a, b| {\n        b.checked_add(a).unwrap_or(b.checked_add(a))\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n\
    \            a\n        } else {\n            b\n        }\n    })", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.iter().fold(a, |c, d| {\n            c + (d / b.len())\n\
    \        })\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2.0", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.iter().fold(a, |acc, x| {\n            acc + ((x - b) /\
    \ b.len()).sqrt()\n        })\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(f64::nan(), |a, b| {\n        match b {\n         \
    \   None => a,\n            Some(x) => if x < a { a } else { x },\n        }\n\
    \    })", "    l.iter().fold(f64::NEG_INFINITY, |acc, x| {\n        match x.cmp(&acc)\
    \ {\n            Ordering::Less => acc,\n            Ordering::Greater => x,\n\
    \            Ordering::Equal => x,\n        }\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(\n        l.len()\
    \ as f64 / 2,\n        |a, b| {\n            match b {\n                a if a\
    \ < b => a,\n                a if a > b => b,\n                _ => a,\n     \
    \       }\n        },\n    )", "    let mut s = l.iter().fold(0, |sum, e| sum\
    \ + e);\n    s / (l.len() as f64)", "    l.iter().fold(f64::NEG_INFINITY, |a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            x\n        } else {\n            acc\n        }\n    )", "  \
    \  let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match\
    \ b {\n            None => a,\n            Some(x) => if x < a { x } else { a\
    \ },\n        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n            a\n\
    \        } else {\n            b\n        }\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        a.checked_add(b).unwrap() / 2.0\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if b < a { a } else { b }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            Some(x) => Some(x.clone() + a),\n \
    \           None => Some(a),\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc,\
    \ x| if x < acc { x } else { acc },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).expect(\"overflow\")\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2.0", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc {\n   \
    \         x\n        } else {\n            acc\n        },\n    )", '    l.iter().fold(0.0,
    |sum, el| sum + el) / l.len()', "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().check();\n    l.len() / 2.0", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::nan(), |a, b| {\n  \
    \      match b {\n            None => a,\n            Some(x) => if x < a { a\
    \ } else { x },\n        }\n    })", '    l.iter().fold(0.0, |sum, e| sum + e)
    / l.len()', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::nan, |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", '    l.iter().fold(f64::nan(), |acc, x| if acc.is_nan()
    || x < acc { x } else { acc })', "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a < b {\n   \
    \         a\n        } else {\n            b\n        }\n    })", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if *a < *b {\n                a\n            } else {\n               \
    \ b\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        b.partial_cmp(&a).unwrap().unwrap()\n\
    \    })", "    l.iter().fold(f64::nan, |a, b| {\n        b.checked_add(a).unwrap_or(f64::nan)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(f64::from(b)).unwrap()\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2,\n        |a, b| {\n\
    \            match b {\n                0 => a,\n                a => a,\n   \
    \         }\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        match b {\n            Some(x) => Some((a + x) / 2),\n          \
    \  None => Some(a),\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a > b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            a if a < b => a,\n            a if\
    \ a > b => b,\n            _ => a + b,\n        }\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut s = l.iter().fold(0, |a, b| a +\
    \ b);\n    l.iter().fold(s.floor(), |a, b| {\n        if a < b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x < acc {\n            acc\n    \
    \    } else {\n            x\n        },\n    )", "    l.iter().fold(0.0, |a,\
    \ b| {\n        b.iter().fold(a, |acc, x| {\n            acc + ((x - a) / b.len())\n\
    \        })\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a,\
    \ b| {\n            match b {\n                a if a < b => a,\n            \
    \    a if a > b => b,\n                _ => a,\n            }\n        },\n  \
    \  )", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        match b {\n   \
    \         None => a,\n            Some(x) => if x < a { a } else { x },\n    \
    \    }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\n                  |median,\
    \ el| median + el / 2)", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc\
    \ {\n            acc\n        } else {\n            x\n        },\n    )", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len().check();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        match b {\n            None => a,\n            Some(x) => if x <\
    \ a { a } else { x },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        match x.partial_cmp(&acc) {\n            Some(Ordering::Greater)\
    \ => acc,\n            Some(Ordering::Less) => x,\n            Some(Ordering::Equal)\
    \ => x,\n            Some(Ordering::NotEqual) => acc,\n            None => acc,\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\n                 \
    \ |acc, x| if x < acc { x } else { acc })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        a.checked_add(b).unwrap().sqrt().ok()\n    })", "    let mut\
    \ s = l.iter().fold(0, |a, b| a + b);\n    s /= l.len();\n    s", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ a < b {\n            a\n        } else {\n            b\n        }\n    })",
  "    l.iter().fold(f64::nan(), |a, b| {\n        b.checked_add(a).unwrap_or(b)\n\
    \    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b|\
    \ {\n            if *a < *b {\n                a\n            } else {\n     \
    \           b\n            }\n        },\n    )", "    l.iter().fold(\n      \
    \  l.len() / 2.0,\n        |a, b| {\n            if *a < *b {\n              \
    \  a\n            } else {\n                b\n            }\n        },\n   \
    \ )", "    l.iter().fold(0.0, |a, b| {\n        if a < b {\n            a\n  \
    \      } else {\n            b\n        }\n    })", '    l.iter().fold(f64::NEG_INFINITY,
    |acc, x| acc + f64::from(x)).unwrap() / l.len()', "    l.iter().fold(f64::nan,\
    \ |a, b| {\n        b.partial_cmp(a).unwrap_or(b.partial_cmp(a).unwrap())\n  \
    \  })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |sum, el| {\n        match el {\n \
    \           0 => sum,\n            x => sum + x / 2.0,\n        }\n    })", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2,\n        |a, b| {\n        \
    \    if a > b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", '    l.iter().fold(0.0, |sum, el| sum + el)
    / l.len()', "    l.iter().fold(0.0, |a, b| {\n        if a > b {\n           \
    \ a\n        } else {\n            b\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |acc,\
    \ x| {\n        match acc.checked_add(x) {\n            Some(x) => Some(x),\n\
    \            None => Some(acc.checked_add(x)),\n        }\n    })", "    l.iter().fold(\n\
    \        l.len() / 2.0,\n        |acc, x| if x <= acc {\n            x\n     \
    \   } else {\n            acc\n        },\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        b.checked_add(a).unwrap_or(f64::NEG_INFINITY)\n\
    \    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x <\
    \ acc { x } else { acc },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a\
    \ < b {\n            a\n        } else {\n            b\n        }\n    })", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(b).expect(\"\
    overflow\")\n    })", "    l.iter().fold(f64::nan(), |a, b| {\n        b.is_nan()\
    \ ? a : f64::from(b.partial_cmp(&a.unwrap()).unwrap().midpoint())\n    })", " \
    \   let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len()\
    \ / 2", "    l.iter().fold(\n        l.len() / 2.0,\n        |a, b| {\n      \
    \      if a < b {\n                a\n            } else {\n                b\n\
    \            }\n        },\n    )", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |a, b| {\n            match b {\n                0 => a,\n          \
    \      _ => a + b,\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len().checked_div(2).unwrap();\n    l.len() / 2", "    let\
    \ mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(b).unwrap().sqrt()\n    })", "    l.iter().fold(0.0,\
    \ |a, b| {\n        b.iter().fold(a, |c, d| {\n            c + (d / 2.)\n    \
    \    })\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n  \
    \  l.sort();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY, |a, b| a.checked_add(f64::from(a)
    + f64::from(b)).unwrap())', "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort_unstable();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    let mut s = l.iter().cloned().collect::<Vec<_>>();\n\
    \    s.sort_unstable();\n    s.len() / 2", "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |a, b| {\n            if *a > *b {\n                b\n    \
    \        } else {\n                a\n            }\n        },\n    )", "   \
    \ let mut l = l.to_vec();\n    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            None => a,\n            Some(x) =>\
    \ if x < a { a } else { x },\n        }\n    })", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    l.iter().fold(\n        l.len() / 2.0,\n        |a,\
    \ b| {\n            if a > b {\n                a\n            } else {\n    \
    \            b\n            }\n        },\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(\n        l.len() / 2.0,\n\
    \        |acc, x| if x < acc {\n            x\n        } else {\n            acc\n\
    \        }\n    )", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n   \
    \ l.sort_unstable();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        if a < b {\n            a\n        } else {\n            b\n\
    \        }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len()\
    \ / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n\
    \    l.len().checked_div(2).unwrap()", "    l.iter().fold(f64::NEG_INFINITY, |a,\
    \ b| {\n        if a < b {\n            a\n        } else {\n            b\n \
    \       }\n    })", "    let mut l = l.to_vec();\n    l.sort();\n    l.len() /\
    \ 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        a.checked_add(b).unwrap()\
    \ / 2.0\n    })", "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |acc,\
    \ x| {\n            if *x <= *acc {\n                *acc\n            } else\
    \ {\n                *acc\n            }\n        })\n    })", "    let mut l\
    \ = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2", '    l.iter().fold(f64::NEG_INFINITY,
    |a, b| a.checked_add(f64::from(b)).unwrap())', "    l.iter().fold(\n        l.len()\
    \ / 2.0,\n        |acc, x| if x < acc { x } else { acc },\n    )", "    let mut\
    \ l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort();\n    l.len() / 2",
  "    l.iter().fold(0.0, |a, b| {\n        b.iter().fold(a, |acc, x| {\n        \
    \    acc + ((x - a) / 2.0).abs()\n        })\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |acc, x| {\n        match\
    \ acc.cmp(&x) {\n            Ordering::Less => acc,\n            Ordering::Greater\
    \ => x,\n            Ordering::Equal => acc,\n        }\n    })", "    l.iter().fold(f64::nan(),\
    \ |a, b| {\n        b.checked_add(a).unwrap_or(b)\n    })", "    let mut l = l.to_vec();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        a.checked_add(f64::from(a) + f64::from(b)).unwrap()\n    })", " \
    \   l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        a.checked_add(f64::from(a)\
    \ + f64::from(b)).unwrap()\n    })", "    let mut l = l.to_vec();\n    l.sort();\n\
    \    l.len() / 2", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n \
    \   l.sort();\n    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b|\
    \ {\n        if a < b {\n            a\n        } else {\n            b\n    \
    \    }\n    })", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if a\
    \ < b {\n            a\n        } else {\n            b\n        }\n    })", " \
    \   l.iter().fold(\n        l.len() / 2.0,\n        |acc, x| if x < acc {\n  \
    \          x\n        } else {\n            acc\n        }\n    )", "    l.iter().fold(f64::NEG_INFINITY,\
    \ |a, b| {\n        match b {\n            None => a,\n            Some(x) =>\
    \ if x < a { a } else { x },\n        }\n    })", "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n\
    \    l.sort();\n    l.len() / 2", "    l.iter().fold(0.0, |a, b| {\n        if\
    \ b < a.0 {\n            b\n        } else {\n            a\n        }\n    })",
  "    let mut l = l.iter().cloned().collect::<Vec<_>>();\n    l.sort_unstable();\n\
    \    l.len() / 2", "    l.iter().fold(f64::NEG_INFINITY, |a, b| {\n        if\
    \ *a < *b {\n            a\n        } else {\n            b\n        }\n    })"]
stop_tokens:
- "\n}"
