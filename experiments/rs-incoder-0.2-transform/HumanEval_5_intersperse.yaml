name: HumanEval_5_intersperse
language: rs
prompt: "/// Insert a number 'delimeter' between every two consecutive elements of\
  \ input list `numbers'\n/// >>> intersperse(vec![], 4)\n/// Vec::<isize>::new()\n\
  /// >>> intersperse(vec![1, 2, 3], 4)\n/// vec![1, 4, 2, 4, 3]\nfn intersperse(numbers:\
  \ Vec<isize>, delimeter: isize) -> Vec<isize> {\n"
tests: "}\n\nfn main() {\n    let candidate = intersperse;\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
  }\n"
completions: ["    let mut numbers_copy = numbers.clone();\n    numbers_copy.insert(0,\
    \ delimeter);\n    numbers_copy.extend(numbers_copy.iter().skip(1).collect::<Vec<_>>());\n\
    \    numbers_copy", "    let mut numbers_iter = numbers.iter();\n    let mut numbers_iter\
    \ = numbers_iter.map(|n| n + delimeter);\n    numbers_iter.collect::<Vec<_>>()",
  "    let mut numbers_iter = numbers.iter();\n    let mut numbers_iter = numbers_iter.map(|n|\
    \ n + delimeter);\n    numbers_iter.collect::<Vec<_>>()", '    numbers.into_iter().cloned().intersperse(&delimeter).collect()',
  "    let mut numbers_iter = numbers.iter();\n    let mut result = vec![];\n    while\
    \ let Some(number) = numbers_iter.next() {\n        result.push(number);\n   \
    \     result.push(delimeter);\n    }\n    result", '    numbers.into_iter().cloned().zip(numbers.into_iter().cloned().skip(1)).map(|(a,
    b)| a + delimeter + b).collect()', '    numbers.into_iter().cloned().zip(numbers.into_iter().cloned().skip(1)).map(|(a,
    b)| a + delimeter + b).collect()', "    let mut numbers_clone = numbers.clone();\n\
    \    numbers_clone.extend_from_slice(&[delimeter]);\n    numbers_clone.extend_from_slice(&numbers[1..]);\n\
    \    numbers_clone", "    let mut numbers_iter = numbers.iter();\n    let mut\
    \ result = Vec::new();\n    let mut last_number = numbers_iter.next().unwrap();\n\
    \    for number in numbers_iter {\n        result.push(number);\n        if number\
    \ == delimeter {\n            result.push(last_number);\n            last_number\
    \ = numbers_iter.next().unwrap();\n        } else {\n            last_number =\
    \ number;\n        }\n    }\n    result", "    let mut numbers_iter = numbers.iter();\n\
    \    let mut result = Vec::new();\n    let mut last_number = numbers_iter.next();\n\
    \    while let Some(number) = last_number {\n        result.push(number);\n  \
    \      last_number = numbers_iter.next();\n        if last_number.is_none() {\n\
    \            result.push(delimeter);\n        }\n    }\n    result", '    numbers.into_iter().cloned().zip(numbers.into_iter().cloned().skip(1)).map(|(a,
    b)| a + delimeter + b).collect()', "    let mut numbers_iter = numbers.iter();\n\
    \    let mut result = Vec::new();\n    while let Some(number) = numbers_iter.next()\
    \ {\n        result.push(number);\n        result.push(delimeter);\n    }\n  \
    \  result", '    numbers.into_iter().cloned().zip(numbers.into_iter().cloned().skip(1)).map(|(a,
    b)| a + delimeter + b).collect()', "    let mut numbers_clone = numbers.clone();\n\
    \    numbers_clone.extend_from_slice(&vec![delimeter; numbers_clone.len()]);\n\
    \    numbers_clone", "    let mut numbers_copy = numbers.clone();\n    numbers_copy.insert(0,\
    \ delimeter);\n    numbers_copy.extend(numbers_copy.iter().skip(1).collect::<Vec<_>>());\n\
    \    numbers_copy", "    let mut numbers_iter = numbers.iter();\n    let mut result\
    \ = Vec::new();\n    while let Some(number) = numbers_iter.next() {\n        result.push(number);\n\
    \        result.push(delimeter);\n    }\n    result", "    let mut numbers_iter\
    \ = numbers.iter();\n    let mut result = vec![];\n    while let Some(number)\
    \ = numbers_iter.next() {\n        result.push(number);\n        result.push(delimeter);\n\
    \    }\n    result", "    let mut numbers_copy = numbers.clone();\n    numbers_copy.insert(0,\
    \ delimeter);\n    numbers_copy.extend(numbers_copy.iter().cloned().skip(1).collect::<Vec<_>>());\n\
    \    numbers_copy", '    numbers.into_iter().cloned().zip(numbers.into_iter().cloned().skip(1)).map(|(a,
    b)| a + delimeter + b).collect()', "    let mut numbers_iter = numbers.iter().cloned();\n\
    \    let mut result = Vec::new();\n    let mut last_number = numbers_iter.next();\n\
    \    while let Some(number) = numbers_iter.next() {\n        result.push(number);\n\
    \        result.push(delimeter);\n        result.push(number);\n        last_number\
    \ = number;\n    }\n    result"]
stop_tokens:
- "\n}"
