language: rs
name: HumanEval_91_is_bored
results:
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuyd268gf.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for s\
    \ in S.chars() {\n        if s.is_ascii_lowercase() {\n            if s.starts_with(\"\
    i\") {\n                boredoms.push(s);\n                boredom_count += 1;\n\
    \            }\n        }\n    }\n    boredom_count\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8g_mbc9d.rs:14:18\n   |\n14 |             if s.starts_with(\"\
    i\") {\n   |                  ^^^^^^^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    let\
    \ mut boredom_words = Vec::new();\n    let mut boredom_sentences = Vec::new();\n\
    \    let mut boredom_sentence = String::new();\n    let mut boredom_sentences\
    \ = S.split_whitespace();\n    for s in &mut boredom_sentences {\n        if s.starts_with(\"\
    I\") {\n            boredom_count += 1;\n            boredom_words.push(s);\n\
    \        } else {\n            boredoms.push(s);\n        }\n    }\n    for s\
    \ in &mut boredoms {\n        if s.starts_with(\"I\") {\n            boredom_count\
    \ += 1;\n            boredom_words.push(s);\n        } else {\n            boredom_sentences.push(s);\n\
    \        }\n    }\n    for s in &mut boredom_sentences {\n        if s.starts_with(\"\
    I\") {\n            boredom_count += 1;\n            boredom_words.push(s);\n\
    \        } else {\n            boredom_sentences.push(s);\n        }\n    }\n\
    \    for s in &mut boredom_words {\n        if s.starts_with(\"I\") {\n      \
    \      boredom_count += 1;\n            boredom_words.push(s);\n        } else\
    \ {\n            boredom_sentences.push(s);\n        }\n    }\n    for s in &mut\
    \ boredom_words {\n        if s.starts_with(\"I\") {\n            boredom_count\
    \ += 1;\n            boredom_words.push(s);\n        } else {\n            boredom_sentences.push(s);\n\
    \        }\n    }\n    for s in &mut boredom_words {\n        if s.starts_with(\"\
    I\") {\n            boredom_count += 1;\n            boredom_words.push(s);\n\
    \        } else {\n            boredom_sentences.push(s);\n        }\n    }\n\
    \    for s in &mut boredom_words {\n        if s.starts_with(\"I\") {\n      \
    \      boredom_count += 1;\n            boredom_words.push(s);\n        } else\
    \ {\n            boredom_sentences.push(s);\n        }\n    }\n    for s in &mut\
    \ boredom_words {\n        if s.starts_with(\"I\") {\n            boredom_count\
    \ += 1;\n            boredom_words.push(s);\n        } else {\n            boredom_sentences.push(s);\n\
    \        }\n    }\n    for s in &mut boredom_words {\n        if s.starts_with(\"\
    I\") {\n            boredom_count += 1;\n            boredom_words.push(s);\n\
    \        } else {\n            boredom_sentence\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg06yrm99.rs:96:3\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \       - unclosed delimiter\n...\n80 |     for s in &mut boredom_words {\n  \
    \ |                                 - unclosed delimiter\n...\n84 |         }\
    \ else {\n   |                - this delimiter might not be properly closed...\n\
    85 |             boredom_sentence\n86 | }\n   | - ...as it matches this but it\
    \ has different indentation\n...\n96 | }\n   |   ^\n\nerror[E0599]: no method\
    \ named `push` found for struct `SplitWhitespace` in the current scope\n  -->\
    \ /tmp/tmpg06yrm99.rs:29:31\n   |\n29 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg06yrm99.rs:37:31\n   |\n37 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg06yrm99.rs:45:31\n   |\n45 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg06yrm99.rs:53:31\n   |\n53 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg06yrm99.rs:61:31\n   |\n61 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `push` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg06yrm99.rs:69:31\n   |\n69 |             boredom_sentences.push(s);\n\
    \   |                               ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_l60rqc5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i]\
    \ == '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n\
    \            continue;\n        }\n        if sentence[i] == 'I' {\n         \
    \   i += 1;\n            boredoms += 1;\n        }\n        i += 1;\n    }\n \
    \   boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp8kmv9aib.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp8kmv9aib.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp8kmv9aib.rs:18:12\n   |\n18 |    \
    \     if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n  \
    \ |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of type\
    \ `SplitWhitespace<'_>`\n  --> /tmp/tmp8kmv9aib.rs:18:34\n   |\n18 |         if\
    \ sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!' {\n   |     \
    \                             ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a\
    \ value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp8kmv9aib.rs:18:56\n   |\n\
    18 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!'\
    \ {\n   |                                                        ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp8kmv9aib.rs:22:12\n   |\n22 |         if sentence[i] == 'I' {\n   |\
    \            ^^^^^^^^^^^\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    let\
    \ mut boredom_sentence = String::new();\n    let mut boredom_word = String::new();\n\
    \    let mut boredom_word_count = 0;\n    let mut boredom_word_sentence = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_sentence_index\
    \ = String::new();\n    let mut boredom_word_sentence_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n    let mut boredom_word_index\
    \ = String::new();\n    let mut boredom_word_index = String::new();\n    let mut\
    \ boredom_word_index = String::new();\n    let mut boredom_word_index = String::new();\n\
    \    let mut boredom_word_index = String::new();\n\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp38aslox9.rs:9:27\n  |\n9 |\
    \ fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^ expected\
    \ `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.clone();\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n       \
    \     boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpbdrrtw5c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.clone();\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n       \
    \     boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpbdrrtw5c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuyd268gf.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredoms_cnt\
    \ += 1;\n        }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_9wltlrl.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredoms_cnt.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    loop {\n        if sentence.is_empty() {\n            break;\n        }\n\
    \        if sentence[0].is_ascii(\"I\") {\n            boredoms += 1;\n      \
    \  }\n        sentence = sentence[1..].split_whitespace();\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpld8qm748.rs:13:21\n   |\n13 |         if\
    \ sentence.is_empty() {\n   |                     ^^^^^^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpld8qm748.rs:16:12\n   |\n16 |         if sentence[0].is_ascii(\"\
    I\") {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpld8qm748.rs:19:20\n   |\n19 | \
    \        sentence = sentence[1..].split_whitespace();\n   |                  \
    \  ^^^^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0599, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpdodnys4k.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpdodnys4k.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdodnys4k.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut boredom_words: Vec<&str> =\
    \ vec![];\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms += 1;\n            boredom_words.push(word);\n  \
    \      }\n    }\n    boredoms.iter().cloned().count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp8bi9itjh.rs:18:14\n   |\n18 |     boredoms.iter().cloned().count()\n\
    \   |              ^^^^ method not found in `isize`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2okh71ia.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp2okh71ia.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp2okh71ia.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2okh71ia.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ {\n            if s.is_ascii_uppercase() {\n                if s.is_ascii_digit()\
    \ {\n                    if s.is_ascii_punctuation() {\n                     \
    \   if s.is_ascii_lower() {\n                            if s.is_ascii_upper()\
    \ {\n                                if s.is_ascii_digit() {\n               \
    \                     if s.is_ascii_punctuation() {\n                        \
    \                if s.is_ascii_lower() {\n                                   \
    \         if s.is_ascii_upper() {\n                                          \
    \      if s.is_ascii_digit() {\n                                             \
    \       boredoms.push(s);\n                                                }\n\
    \                                            }\n                             \
    \           }\n                                    }\n                       \
    \         }\n                            }\n                        }\n      \
    \              }\n                }\n            }\n        }\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_lower` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpqt2inrby.rs:16:30\n   |\n16 |             \
    \            if s.is_ascii_lower() {\n   |                              ^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_upper` found for type `char` in the current scope\n\
    \  --> /tmp/tmpqt2inrby.rs:17:34\n   |\n17 | ...                   if s.is_ascii_upper()\
    \ {\n   |                            ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpqt2inrby.rs:20:46\n\
    \   |\n20 | ...                   if s.is_ascii_lower() {\n   |              \
    \              ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_upper` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpqt2inrby.rs:21:50\n   |\n21\
    \ | ...                   if s.is_ascii_upper() {\n   |                      \
    \      ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqt2inrby.rs:36:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n36 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n36 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ || s.is_ascii_uppercase() || s.is_ascii_digit() {\n            continue;\n \
    \       }\n        if s.is_ascii_punctuation() {\n            continue;\n    \
    \    }\n        if s.is_ascii_punctuation() || s.is_ascii_letter() {\n       \
    \     continue;\n        }\n        if s.is_ascii_lower() || s.is_ascii_upper()\
    \ {\n            continue;\n        }\n        if s.is_ascii_digit() {\n     \
    \       continue;\n        }\n        if s.is_ascii_punctuation() {\n        \
    \    continue;\n        }\n        if s.is_ascii_letter() {\n            continue;\n\
    \        }\n        if s.is_ascii_digit() {\n            continue;\n        }\n\
    \        if s.is_ascii_punctuation() {\n            continue;\n        }\n   \
    \     if s.is_ascii_letter() {\n            continue;\n        }\n        if s.is_ascii_digit()\
    \ {\n            continue;\n        }\n        if s.is_ascii_punctuation() {\n\
    \            continue;\n        }\n        if s.is_ascii_letter() {\n        \
    \    continue;\n        }\n        if s.is_ascii_digit() {\n            continue;\n\
    \        }\n        if s.is_ascii_punctuation() {\n            continue;\n   \
    \     }\n        if s.is_ascii_letter() {\n            continue;\n        }\n\
    \        if s.is_ascii_digit() {\n            continue;\n        }\n        if\
    \ s.is_ascii_punctuation() {\n            continue;\n        }\n        if s.is_ascii_letter()\
    \ {\n            continue;\n        }\n        if s.is_ascii_digit() {\n     \
    \       continue;\n        }\n        if s.is_ascii_punctuation() {\n        \
    \    continue;\n        }\n        if s.is_ascii_letter() {\n            continue;\n\
    \        }\n        if s.is_ascii_digit() {\n            continue;\n        }\n\
    \        if s.is_ascii_punctuation() {\n            continue;\n        }\n   \
    \     if s.is_ascii_letter() {\n            continue;\n        }\n        if s.is_ascii_digit()\
    \ {\n            continue;\n        }\n        if s.is_ascii_punctuation() {\n\
    \            continue;\n        }\n        if s.is_ascii_letter() {\n        \
    \    continue;\n        }\n        if s.is_ascii_digit() {\n            continue;\n\
    \        }\n        if s.is_ascii_punctuation() {\n            continue;\n   \
    \     }\n        if s.is_ascii_letter() {\n            continue;\n        }\n\
    \        if s.is_ascii_digit() {\n            continue;\n        }\n        if\
    \ s.is_ascii_punctuation() {\n            continue;\n        }\n        if s.is_ascii_letter()\
    \ {\n            continue;\n        }\n        if s.is_ascii_digit() {\n     \
    \       continue;\n        }\n        if s.is_ascii_punctuation() {\n        \
    \    continue;\n        }\n        if s.is_ascii_letter() {\n            continue;\n\
    \        }\n        if s.\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpetawkcld.rs:134:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n10  |     let mut boredoms: isize = 0;\n11  |\
    \     for s in S.chars() {\n    |                        - this delimiter might\
    \ not be properly closed...\n...\n124 | }\n    | - ...as it matches this but it\
    \ has different indentation\n...\n134 | }\n    |   ^\n\nerror: unexpected token:\
    \ `}`\n   --> /tmp/tmpetawkcld.rs:124:1\n    |\n124 | }\n    | ^\n\nerror: expected\
    \ `{`, found `}`\n   --> /tmp/tmpetawkcld.rs:124:1\n    |\n123 |         if s.\n\
    \    |         -- this `if` expression has a condition, but no block\n124 | }\n\
    \    | ^ expected `{`\n\nerror[E0599]: no method named `is_ascii_letter` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpetawkcld.rs:18:42\n   |\n\
    18 |         if s.is_ascii_punctuation() || s.is_ascii_letter() {\n   |      \
    \                                    ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_lower`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpetawkcld.rs:21:14\n\
    \   |\n21 |         if s.is_ascii_lower() || s.is_ascii_upper() {\n   |      \
    \        ^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `is_ascii`\n\nerror[E0599]: no method named `is_ascii_upper` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpetawkcld.rs:21:36\n   |\n21 |   \
    \      if s.is_ascii_lower() || s.is_ascii_upper() {\n   |                   \
    \                 ^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpetawkcld.rs:30:14\n\
    \   |\n30 |         if s.is_ascii_letter() {\n   |              ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for type `char` in the current scope\n\
    \  --> /tmp/tmpetawkcld.rs:39:14\n   |\n39 |         if"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..i + 1]);\n            i += 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpis8h6r2z.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpis8h6r2z.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpis8h6r2z.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpdodnys4k.rs:10:28\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |                            ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpdodnys4k.rs:10:47\n\
    \    |\n10  |     S.chars().filter(|c| c.is_ascii_letter()).count(|c| c == 'I')\n\
    \    |                                               ^^^^^ ------------ supplied\
    \ 1 argument\n    |                                               |\n    |   \
    \                                            expected 0 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdodnys4k.rs:10:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I')\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     S.chars().filter(|c|\
    \ c.is_ascii_letter()).count(|c| c == 'I').try_into().unwrap()\n   |         \
    \                                                         ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            boredoms += 1;\n\
    \        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplcoq33h1.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplcoq33h1.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplcoq33h1.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n        }\n \
    \       i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_dtc_2e0.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_dtc_2e0.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_dtc_2e0.rs:18:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n18 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n18 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ || s.is_ascii_uppercase() || s.is_ascii_digit() {\n            continue;\n \
    \       }\n        if s.is_ascii_punctuation() {\n            continue;\n    \
    \    }\n        if s.is_ascii_punctuation('!') || s.is_ascii_punctuation('.')\
    \ || s.is_ascii_punctuation('?') {\n            continue;\n        }\n       \
    \ boredoms += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpju_nb69d.rs:18:14\n     |\n18   |         if s.is_ascii_punctuation('!')\
    \ || s.is_ascii_punctuation('.') || s.is_ascii_punctuation('?') {\n     |    \
    \          ^^^^^^^^^^^^^^^^^^^^ --- supplied 1 argument\n     |              |\n\
    \     |              expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpju_nb69d.rs:18:45\n     |\n18   |         if s.is_ascii_punctuation('!')\
    \ || s.is_ascii_punctuation('.') || s.is_ascii_punctuation('?') {\n     |    \
    \                                         ^^^^^^^^^^^^^^^^^^^^ --- supplied 1\
    \ argument\n     |                                             |\n     |     \
    \                                        expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n    --> /tmp/tmpju_nb69d.rs:18:76\n     |\n18   |   \
    \      if s.is_ascii_punctuation('!') || s.is_ascii_punctuation('.') || s.is_ascii_punctuation('?')\
    \ {\n     |                                                                  \
    \          ^^^^^^^^^^^^^^^^^^^^ --- supplied 1 argument\n     |              \
    \                                                              |\n     |     \
    \                                                                       expected\
    \ 0 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_duy0tdq.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_duy0tdq.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp_duy0tdq.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_duy0tdq.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut i = 0;\n    while\
    \ i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n    \
    \        boredoms.push(&S[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz7rfhl7k.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz7rfhl7k.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz7rfhl7k.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut idx = 0;\n    while idx < S.len()\
    \ {\n        let mut word = S[idx..].to_lowercase();\n        if word == \"i\"\
    \ {\n            boredoms += 1;\n        }\n        idx += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `1`', /tmp/tmpi9g4en5o.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplvcxznfo.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplvcxznfo.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplvcxznfo.rs:19:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n19 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n19 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_counter = 0;\n    let\
    \ mut i = 0;\n    while i < S.len() {\n        if S[i] == '.' || S[i] == '?' ||\
    \ S[i] == '!' {\n            boredoms.push(S[i]);\n            i += 1;\n     \
    \   } else {\n            i += 1;\n        }\n    }\n    for boredom in boredoms\
    \ {\n        if boredom == 'I' {\n            boredom_counter += 1;\n        }\n\
    \    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv05k4bpp.rs:14:12\n\
    \   |\n14 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv05k4bpp.rs:14:27\n   |\n14 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpv05k4bpp.rs:14:42\n   |\n14 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = s.find('I');\n        if i == s.len() {\n\
    \            break;\n        }\n        let mut j = s.find('.');\n        if j\
    \ == s.len() {\n            j = s.find('?');\n            if j == s.len() {\n\
    \                j = s.find('!');\n            }\n        }\n        if j == s.len()\
    \ {\n            break;\n        }\n        boredoms += 1;\n        s = &s[i..j];\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi2ox326i.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi2ox326i.rs:18:17\n   |\n18 |         if j ==\
    \ s.len() {\n   |                 ^^^^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |         if j == Some(s.len())\
    \ {\n   |                 +++++       +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpi2ox326i.rs:20:21\n   |\n20 |             if j == s.len() {\n   |  \
    \                   ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   =\
    \ note: expected enum `Option<usize>`\n              found type `usize`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n20 |             if j == Some(s.len())\
    \ {\n   |                     +++++       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpi2ox326i.rs:24:17\n   |\n24 |         if j == s.len() {\n   | \
    \                ^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note:\
    \ expected enum `Option<usize>`\n              found type `usize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n24 |         if j == Some(s.len()) {\n   | \
    \                +++++       +\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `std::ops::Range<Option<usize>>`\n  --> /tmp/tmpi2ox326i.rs:28:14\n   |\n\
    28 |         s = &s[i..j];\n   |              ^^^^^^^ `String` cannot be indexed\
    \ by `std::ops::Range<Option<usize>>`\n   |\n   = help: the trait `Index<std::ops::Range<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <S"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.to_string();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            boredoms += 1;\n\
    \        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplcoq33h1.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplcoq33h1.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplcoq33h1.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmph0lee594.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmph0lee594.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n    \
    \    }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc869bub7.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwklyupjz.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwklyupjz.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpwklyupjz.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    for word in S.split_whitespace()\
    \ {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredoms.iter().filter(|w| w.starts_with(\"I\")).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9h2i0cbx.rs:16:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n16 |     boredoms.iter().filter(|w| w.starts_with(\"\
    I\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     boredoms.iter().filter(|w|\
    \ w.starts_with(\"I\")).count().try_into().unwrap()\n   |                    \
    \                                       ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            boredom_counter++;\n        }\n        boredoms.push(boredom_counter);\n\
    \    }\n    boredoms.iter().sum()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpadmkqsuy.rs:14:28\n\
    \   |\n14 |             boredom_counter++;\n   |                            ^^\
    \ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n14 |   \
    \          { let tmp = boredom_counter; boredom_counter += 1; tmp };\n   |   \
    \          +++++++++++                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n14 -    \
    \         boredom_counter++;\n14 +             boredom_counter += 1;\n   | \n\n\
    error: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredoms_cnt += 1;\n   \
    \     }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk31b6msu.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms_cnt.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_l60rqc5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ !s.is_empty() {\n        if s.starts_with(\"I\") {\n            boredoms +=\
    \ 1;\n        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            i += 1;\n            while i < S.len()\
    \ && S[i] != '.' && S[i] != '?' && S[i] != '!' {\n                i += 1;\n  \
    \          }\n            if i == S.len() {\n                boredoms += 1;\n\
    \            }\n        } else {\n            i += 1;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp412ty67l.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp412ty67l.rs:15:34\n   |\n15 |             while i < S.len() &&\
    \ S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                          \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp412ty67l.rs:15:49\n   |\n15 |             while i < S.len() &&\
    \ S[i] != '.' && S[i] != '?' && S[i] != '!' {\n   |                          \
    \                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclu"
  stdout: ''
  timestamp: 1660009085
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxpg5xilt.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxpg5xilt.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxpg5xilt.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..i + 1]);\n            i += 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp7j0v0sln.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp7j0v0sln.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp7j0v0sln.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7j0v0sln.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.iter().filter(|&b| b.starts_with(\"I\")).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count().try_into().unwrap()\n   |                    \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms\
    \ += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp4zylm0hb.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        boredoms += 1;\n        s = &s[1..];\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpglwmyd6j.rs:14:13\n   |\n\
    11 |     let mut s = S.to_string();\n   |                 ------------- expected\
    \ due to this value\n...\n14 |         s = &s[1..];\n   |             ^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n14 |         s = (&s[1..]).to_string();\n   |             +       +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut i = 0;\n    while\
    \ i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n    \
    \        boredoms.push(&S[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&s| s.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmprueh1b8l.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprueh1b8l.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmprueh1b8l.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let mut j = i;\n        while j < S.len() {\n            if S[j]\
    \ == ' ' {\n                break;\n            }\n            j += 1\n      \
    \  }\n        boredoms.push(S.split_whitespace()[i]);\n        i = j;\n    }\n\
    \    boredoms.iter().filter(|&b| b == \"I\").count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj9_2flww.rs:15:16\n\
    \   |\n15 |             if S[j] == ' ' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpj9_2flww.rs:20:23\n   |\n20 |         boredoms.push(S.split_whitespace()[i]);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj9_2flww.rs:23:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n23 |     boredoms.iter().filter(|&b| b == \"I\").count()\n   |  \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n23 |     boredoms.iter().filter(|&b| b == \"I\").count().try_into().unwrap()\n\
    \   |                                                  ++++++++++++++++++++\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppnxy4_cb.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppnxy4_cb.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(&words[i..i + 1]);\n            i += 1;\n     \
    \   } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&s|\
    \ s.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpp6pzy5l5.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpp6pzy5l5.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpp6pzy5l5.rs:15:28\n   |\n15 |             boredoms.push(&words[i..i\
    \ + 1]);\n   |                            ^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp6pzy5l5.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.iter().filter(|&s| s.starts_with(\"I\")).count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.iter().filter(|&s|\
    \ s.starts_with(\"I\")).count().try_into().unwrap()\n   |                    \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let mut j = i;\n        while j < S.len() {\n            if S[j]\
    \ == S[i] {\n                boredoms.push(S[j..]);\n                break;\n\
    \            }\n            j += 1\n        }\n        i += 1;\n    }\n    boredoms.iter().filter(|s|\
    \ s.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpmhao1282.rs:15:16\n\
    \   |\n15 |             if S[j] == S[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmhao1282.rs:15:24\n   |\n15 |             if S[j] == S[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmpmhao1282.rs:16:31\n    |\n16  |                 boredoms.push(S[j..]);\n\
    \    |                          ---- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                          |\n    |                          required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\n\
    error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpmhao1282.rs:10:24\n    |\n10  |     let mut boredoms =\
    \ vec![];\n    |                        ^^^^^^ doesn't have a size known "
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_counter = 0;\n    for\
    \ word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n     \
    \       boredoms.push(word);\n        }\n    }\n    for boredom in boredoms {\n\
    \        if boredom.starts_with(\"I\") {\n            boredom_counter += 1;\n\
    \        }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpupf6jtx8.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n    \
    \    }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc869bub7.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_counter: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredom_counter\
    \ += 1;\n        }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvv_w_xc.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom_counter\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredom_counter.try_into().unwrap()\n\
    \   |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let mut boredom_word_count:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_word_start: usize = 0;\n    let mut boredom_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_start: usize = 0;\n    let mut boredom_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_start: usize = 0;\n    let mut\
    \ boredom_word_word_word_end: usize = 0;\n    let mut boredom_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_end: usize = 0;\n    let\
    \ mut boredom_word_word_word_word_word_start: usize = 0;\n    let mut boredom_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_start: usize =\
    \ 0;\n    let mut boredom_word_word_word_word_word_word_end: usize = 0;\n    let\
    \ mut boredom_word_word_word_word_word_word_word_start: usize = 0;\n    let mut\
    \ boredom_word_word_word_word_word_word_word_end: usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_start:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_word_word_word_word_word_word_end:\
    \ usize = 0;\n    let mut boredom_word_word_word_word_word_\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpygfue6la.rs:40:46\n   |\n\
    40 |     let mut boredom_word_word_word_word_word_\n   |                     \
    \                         ^ help: add `;` here\n41 | }\n   | - unexpected token\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpygfue6la.rs:9:27\n  |\n9 | fn is_bored(S:\
    \ String) -> isize {\n  |    --------               ^^^^^ expected `isize`, found\
    \ `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut i = 0;\n    while\
    \ i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n    \
    \        boredoms.push(&S[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b| b == \"\
    I\").count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6ls_e71_.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6ls_e71_.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6ls_e71_.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_words: Vec<&str>\
    \ = vec![];\n    let mut boredom_word_count: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_length: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize = 0;\n    let mut boredom_word_start_index:\
    \ usize = 0;\n    let mut boredom_word_end_index: usize\n}\n\nfn main() {\n  \
    \  let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp20hftf76.rs:48:42\n   |\n\
    48 |     let mut boredom_word_end_index: usize\n   |                         \
    \                 ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp20hftf76.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut i = 0;\n    while\
    \ i < S.len() {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n    \
    \        boredoms.push(&S[i..i + 1]);\n            i += 1;\n        } else {\n\
    \            i += 1;\n        }\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpz7rfhl7k.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz7rfhl7k.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpz7rfhl7k.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let mut j = i;\n        while j < S.len() {\n            if S[j]\
    \ == S[i] {\n                boredoms.push(S[j]);\n                j += 1;\n \
    \           } else {\n                break;\n            }\n        }\n     \
    \   i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate =\
    \ is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n  \
    \  assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4ob5xldv.rs:15:16\n\
    \   |\n15 |             if S[j] == S[i] {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4ob5xldv.rs:15:24\n   |\n15 |             if S[j] == S[i] {\n \
    \  |                        ^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4ob5xldv.rs:16:31\n\
    \   |\n16 |                 boredoms.push(S[j]);\n   |                       \
    \        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|&b| b == 'I').count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0db60br5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0db60br5.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0db60br5.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  for word in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n\
    \            boredoms.push(word);\n            boredom_counter += 1;\n       \
    \ }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpcct_h3sw.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = String::from(S);\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            boredoms += 1;\n\
    \        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxwa9j2x9.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxwa9j2x9.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxwa9j2x9.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqihuv566.rs:17:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n17 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    let mut boredom_word: &str = String::new();\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_count: usize = 0;\n    let mut boredom_word_length:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut boredom_word_end_index:\
    \ usize = 0;\n    let mut boredom_word_start_index: usize = 0;\n    let mut \n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp82t8xksf.rs:50:1\n\
    \   |\n50 | }\n   | ^ expected identifier\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp82t8xksf.rs:12:34\n   |\n12 |     let mut boredom_word: &str =\
    \ String::new();\n   |                           ----   ^^^^^^^^^^^^^\n   |  \
    \                         |      |\n   |                           |      expected\
    \ `&str`, found struct `String`\n   |                           |      help: consider\
    \ borrowing here: `&String::new()`\n   |                           expected due\
    \ to this\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ || s.is_ascii_uppercase() {\n            boredoms += 1;\n        }\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `0`', /tmp/tmpqlai4l0h.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    loop {\n        let mut sentence = sentence.next();\n        if sentence.is_none()\
    \ {\n            break;\n        }\n        if sentence.unwrap().starts_with(\"\
    I\") {\n            boredoms += 1;\n        }\n    }\n    boredoms\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpcwck9et8.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for s in S.chars() {\n        if s.is_uppercase()\
    \ {\n            if s.starts_with(\"I\") {\n                boredoms.push(s);\n\
    \            }\n        }\n    }\n    boredoms.len()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `starts_with` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz3stu7uq.rs:13:18\n   |\n13 |             if s.starts_with(\"\
    I\") {\n   |                  ^^^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpz3stu7uq.rs:18:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n...\n18 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = 0;\n        while i < s.len() {\n       \
    \     let c = s.chars().nth(i).unwrap();\n            if c == '.' || c == '?'\
    \ || c == '!' {\n                i += 1;\n            } else {\n             \
    \   break;\n            }\n        }\n        if i == s.len() {\n            break;\n\
    \        }\n        boredoms += 1;\n        s = &s[..i];\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkajubgh9.rs:26:13\n   |\n\
    11 |     let mut s = S.to_string();\n   |                 ------------- expected\
    \ due to this value\n...\n26 |         s = &s[..i];\n   |             ^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n26 |         s = (&s[..i]).to_string();\n   |             +       +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjwxr30lo.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjwxr30lo.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwxr30lo.rs:20:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n20 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp60sjr2l_.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp60sjr2l_.rs:14:12\n   |\n14 |         if sentence[i] == \"I\" {\n  \
    \ |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnq2ccmo.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut idx = 0;\n    while idx < S.len()\
    \ {\n        if S[idx] == 'I' {\n            boredoms += 1;\n        }\n     \
    \   idx += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp9hslkn86.rs:13:12\n\
    \   |\n13 |         if S[idx] == 'I' {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        }\n    }\n    for boredom in\
    \ boredoms {\n        if boredom.ends_with(\".\") || boredom.ends_with(\"?\")\
    \ || boredom.ends_with(\"!\") {\n            boredom_count += 1;\n        }\n\
    \    }\n    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n \
    \   assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkgichzo8.rs:22:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n22 |     boredom_count\n   |     ^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |     boredom_count.try_into().unwrap()\n\
    \   |                  ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppnxy4_cb.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppnxy4_cb.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        let c = S[i];\n        if c == '.' || c == '?' || c == '!' {\n  \
    \          i += 1;\n        } else {\n            boredoms += 1;\n           \
    \ i += 1;\n        }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp59x1nib5.rs:13:17\n\
    \   |\n13 |         let c = S[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcrc0q4_c.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcrc0q4_c.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcrc0q4_c.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    let mut boredoms_cnt_by_word: Vec<usize> = vec![];\n    for word in\
    \ S.split_whitespace() {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \            boredoms_cnt += 1;\n        }\n    }\n    for boredom in boredoms\
    \ {\n        if boredom.starts_with(\"I\") {\n            boredoms_cnt_by_word.push(boredoms_cnt);\n\
    \        }\n    }\n    boredoms_cnt_by_word.iter().fold(0, |acc, x| acc + x)\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8p_ir02g.rs:24:56\n   |\n\
    24 |     boredoms_cnt_by_word.iter().fold(0, |acc, x| acc + x)\n   |         \
    \                                               ^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot add `&usize` to `isize`\n  --> /tmp/tmp8p_ir02g.rs:24:54\n\
    \   |\n24 |     boredoms_cnt_by_word.iter().fold(0, |acc, x| acc + x)\n   |  \
    \                                                    ^ no implementation for `isize\
    \ + &usize`\n   |\n   = help: the trait `Add<&usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Add<Rhs>`:\n          \
    \   <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a\
    \ i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32\
    \ as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n\
    \             <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.starts_with(\"I\") {\n        boredoms += 1;\n        s = &s[1..];\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpglwmyd6j.rs:14:13\n   |\n\
    11 |     let mut s = S.to_string();\n   |                 ------------- expected\
    \ due to this value\n...\n14 |         s = &s[1..];\n   |             ^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n14 |         s = (&s[1..]).to_string();\n   |             +       +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredoms_cnt += 1;\n   \
    \     }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk31b6msu.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms_cnt.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for s in S.chars() {\n        if s.is_ascii_lowercase()\
    \ || s.is_ascii_uppercase() {\n            boredoms += 1;\n        }\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `10`,\n right: `0`', /tmp/tmpqlai4l0h.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S;\n    while !s.is_empty()\
    \ {\n        let mut i = s.find('i');\n        if i == s.len() {\n           \
    \ break;\n        }\n        if s.starts_with(\"i\") {\n            boredoms +=\
    \ 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\nfn main() {\n\
    \    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp22qlolzh.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmp22qlolzh.rs:20:14\n\
    \   |\n20 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp22qlolzh.rs:20:13\n\
    \   |\n11 |     let mut s = S;\n   |                 - expected due to this value\n\
    ...\n20 |         s = &s[i..];\n   |             ^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n20 -         s = &s[i..];\n\
    20 +         s = s[i..];\n   | \n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_letter()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_letter()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_letter()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_digit()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_letter()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_uppercase()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].is_ascii_punctuation()\
    \ {\n            i += 1;\n            continue;\n        }\n        if sentence[i].\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_qedtadv.rs:133:3\n\
    \    |\n9   | fn is_bored(S: String) -> isize {\n    |                       \
    \          - unclosed delimiter\n...\n13  |     while i < sentence.len() {\n \
    \   |                              - this delimiter might not be properly closed...\n\
    ...\n123 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n133 | }\n    |   ^\n\nerror: unexpected token: `}`\n   --> /tmp/tmp_qedtadv.rs:123:1\n\
    \    |\n123 | }\n    | ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp_qedtadv.rs:123:1\n\
    \    |\n122 |         if sentence[i].\n    |         -- this `if` expression has\
    \ a condition, but no block\n123 | }\n    | ^ expected `{`\n\nerror[E0599]: no\
    \ method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp_qedtadv.rs:13:24\n   |\n13 |     while i < sentence.len() {\n\
    \   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp_qedtadv.rs:14:12\n\
    \   |\n14 |         if sentence[i].is_ascii_lowercase() {\n   |            ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_qedtadv.rs:18:12\n   |\n18 |         if sentence[i].is_ascii_uppercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp_qedtadv.rs:22:12\n   |\n22 |    \
    \     if sentence[i].is_ascii_punctuation() {\n   |            ^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmp_qedtadv.rs:26:12\n\
    \   |\n26 |         if sentence[i].is_ascii_digit() {\n   |            ^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp_qedtadv.rs:30:12\n   |\n30 |         if sentence[i].is_ascii_punctuation()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmp_qedtadv.rs:34:12\n   |\n34 |    \
    \     if sentence[i].is_ascii_letter() {\n   |            ^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpxo604ai_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i]);\n            i += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmprkj_34dl.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmprkj_34dl.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmprkj_34dl.rs:15:27\n   |\n15 |             boredoms.push(words[i]);\n\
    \   |                           ^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmprkj_34dl.rs:21:5\n   |\n9  | fn is_bored(S: String) -> isize {\n\
    \   |                           ----- expected `isize` because of return type\n\
    ...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2okh71ia.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp2okh71ia.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp2okh71ia.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2okh71ia.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            i += 1;\n            while i < S.len()\
    \ && S[i] != 'I' {\n                i += 1;\n            }\n            if i ==\
    \ S.len() {\n                boredoms += 1;\n            }\n        }\n      \
    \  i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmph_zt0814.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmph_zt0814.rs:15:34\n   |\n15 |             while i < S.len() &&\
    \ S[i] != 'I' {\n   |                                  ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n            boredoms_cnt += 1;\n   \
    \     }\n    }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk31b6msu.rs:18:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n18 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n18 |     boredoms_cnt.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut words = S.split_whitespace();\n\
    \    for word in words {\n        if word.starts_with(\"I\") {\n            boredoms.push(word);\n\
    \        }\n    }\n    boredoms.iter().filter(|&b| b.starts_with(\"I\")).count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnsgkukgi.rs:17:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n17 |     boredoms.iter().filter(|&b| b.starts_with(\"\
    I\")).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     boredoms.iter().filter(|&b|\
    \ b.starts_with(\"I\")).count().try_into().unwrap()\n   |                    \
    \                                        ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n        }\n        i += 1;\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3r2ylaow.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3r2ylaow.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    let mut\
    \ boredom_words = vec![];\n    let mut boredom_word_count = 0;\n    let mut boredom_sentences\
    \ = vec![];\n    let mut boredom_sentence_count = 0;\n    let mut boredom_sentence\
    \ = String::new();\n    let mut boredom_sentence_words = vec![];\n    let mut\
    \ boredom_sentence_word_count = 0;\n    let mut boredom_sentence_sentences = vec![];\n\
    \    let mut boredom_sentence_sentence_count = 0;\n    let mut boredom_sentence_sentence\
    \ = String::new();\n    let mut boredom_sentence_sentence_words = vec![];\n  \
    \  let mut boredom_sentence_sentence_word_count = 0;\n    let mut boredom_sentence_sentence_sentences\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_count = 0;\n    let\
    \ mut boredom_sentence_sentence_sentence = String::new();\n    let mut boredom_sentence_sentence_sentence_words\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_word_count = 0;\n\
    \    let mut boredom_sentence_sentence_sentence_sentences = vec![];\n    let mut\
    \ boredom_sentence_sentence_sentence_sentence_count = 0;\n    let mut boredom_sentence_sentence_sentence_sentence\
    \ = String::new();\n    let mut boredom_sentence_sentence_sentence_sentence_words\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_sentence_word_count\
    \ = 0;\n    let mut boredom_sentence_sentence_sentence_sentence_sentences = vec![];\n\
    \    let mut boredom_sentence_sentence_sentence_sentence_sentence_count = 0;\n\
    \    let mut boredom_sentence_sentence_sentence_sentence_sentence = String::new();\n\
    \    let mut boredom_sentence_sentence_sentence_sentence_sentence_words = vec![];\n\
    \    let mut boredom_sentence_sentence_sentence_sentence_sentence_word_count =\
    \ 0;\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentences\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_count\
    \ = 0;\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence\
    \ = String::new();\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_words\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_word_count\
    \ = 0;\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_sentences\
    \ = vec![];\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_sentence_count\
    \ = 0;\n    let mut boredom_sentence_sentence_sentence_sentence_sentence_sentence_sentence\
    \ = String::new();\n    let mut boredom_sentence_sentence_sentence_sentence_\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpr77i3xvs.rs:47:57\n   |\n\
    47 |     let mut boredom_sentence_sentence_sentence_sentence_\n   |          \
    \                                               ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n --> /tmp/tmpr77i3xvs.rs:9:27\n\
    \  |\n9 | fn is_bored(S: String) -> isize {\n  |    --------               ^^^^^\
    \ expected `isize`, found `()`\n  |    |\n  |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.clone();\n    let mut\
    \ i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n       \
    \     boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmpbdrrtw5c.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    for\
    \ s in S.chars() {\n        if s.is_ascii() {\n            if s.to_ascii_lowercase()\
    \ == \"i\" {\n                boredom_count += 1;\n            }\n        } else\
    \ {\n            boredoms.push(s);\n        }\n    }\n    boredom_count\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvbgfvif.rs:14:42\n   |\n\
    14 |             if s.to_ascii_lowercase() == \"i\" {\n   |                  \
    \                        ^^^ expected `char`, found `&str`\n   |\nhelp: if you\
    \ meant to write a `char` literal, use single quotes\n   |\n14 |             if\
    \ s.to_ascii_lowercase() == 'i' {\n   |                                      \
    \    ~~~\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for s in S.split_whitespace() {\n   \
    \     if s.starts_with(\"I\") {\n            boredoms.push(s);\n        }\n  \
    \  }\n    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n  \
    \  assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk8473jwl.rs:16:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n16 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n16 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    loop {\n        if let Some(word) = words.next() {\n            if word ==\
    \ \"I\" {\n                boredoms += 1;\n            }\n        }\n        if\
    \ !words.next().is_some() {\n            break;\n        }\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv05owv1b.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_l60rqc5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_counter = 0;\n  \
    \  let mut boredom_sentence = String::new();\n    let mut boredom_word = String::new();\n\
    \    let mut boredom_word_counter = 0;\n    let mut boredom_word_sentence = String::new();\n\
    \    let mut boredom_word_index = S.len();\n    let mut boredom_word_sentence_index\
    \ = 0;\n    let mut boredom_word_sentence_length = S.len();\n    let mut boredom_word_sentence_length_index\
    \ = 0;\n    let mut boredom_word_sentence_length_index2 = 0;\n    let mut boredom_word_sentence_length_index3\
    \ = 0;\n    let mut boredom_word_sentence_length_index4 = 0;\n    let mut boredom_word_sentence_length_index5\
    \ = 0;\n    let mut boredom_word_sentence_length_index6 = 0;\n    let mut boredom_word_sentence_length_index7\
    \ = 0;\n    let mut boredom_word_sentence_length_index8 = 0;\n    let mut boredom_word_sentence_length_index9\
    \ = 0;\n    let mut boredom_word_sentence_length_index10 = 0;\n    let mut boredom_word_sentence_length_index11\
    \ = 0;\n    let mut boredom_word_sentence_length_index12 = 0;\n    let mut boredom_word_sentence_length_index13\
    \ = 0;\n    let mut boredom_word_sentence_length_index14 = 0;\n    let mut boredom_word_sentence_length_index15\
    \ = 0;\n    let mut boredom_word_sentence_length_index16 = 0;\n    let mut boredom_word_sentence_length_index17\
    \ = 0;\n    let mut boredom_word_sentence_length_index18 = 0;\n    let mut boredom_word_sentence_length_index19\
    \ = 0;\n    let mut boredom_word_sentence_length_index20 = 0;\n    let mut boredom_word_sentence_length_index21\
    \ = 0;\n    let mut boredom_word_sentence_length_index22 = 0;\n    let mut boredom_word_sentence_length_index23\
    \ = 0;\n    let mut boredom_word_sentence_length_index24 = 0;\n    let mut boredom_word_sentence_length_index25\
    \ = 0;\n    let mut boredom_word_sentence_length_index26 = 0;\n    let mut boredom_word_sentence_length_index27\
    \ = 0;\n    let mut boredom_word_sentence_length_index28 = 0;\n    let mut boredom_word_sentence_length_index29\
    \ = 0;\n    let mut boredom_word_sentence_length_index30 = 0;\n    let mut boredom_word_sentence_length_index31\
    \ = 0;\n    let mut boredom_word_sentence_\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1wnprkfo.rs:50:35\n   |\n\
    50 |     let mut boredom_word_sentence_\n   |                                \
    \   ^ help: add `;` here\n51 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmp1wnprkfo.rs:9:27\n  |\n9 | fn is_bored(S: String) -> isize\
    \ {\n  |    --------               ^^^^^ expected `isize`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        let mut i = s.find('I');\n        if i == s.len() {\n\
    \            break;\n        }\n        if s.starts_with(\"I\") {\n          \
    \  boredoms += 1;\n        }\n        s = &s[i..];\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplxqjzfp_.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `RangeFrom<Option<usize>>`\n  --> /tmp/tmplxqjzfp_.rs:20:14\n\
    \   |\n20 |         s = &s[i..];\n   |              ^^^^^^ `String` cannot be\
    \ indexed by `RangeFrom<Option<usize>>`\n   |\n   = help: the trait `Index<RangeFrom<Option<usize>>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplxqjzfp_.rs:20:13\n\
    \   |\n11 |     let mut s = S.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n20 |         s = &s[i..];\n   |           \
    \  ^^^^^^^ expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\nhelp: consider removing the\
    \ borrow\n   |\n20 -         s = &s[i..];\n20 +         s = s[i..];\n   | \n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.iter().filter(|&b| b == 'I').count()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpcrc0q4_c.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcrc0q4_c.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpcrc0q4_c.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for c in S.chars() {\n        if c\
    \ == '.' || c == '?' || c == '!' {\n            boredoms += 1;\n        }\n  \
    \  }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp6frmzgxd.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S;\n    while s.len() >\
    \ 0 {\n        let mut i = s.find('i');\n        if i == s.len() {\n         \
    \   break;\n        }\n        let mut j = s.find('i', i + 1);\n        if j ==\
    \ s.len() {\n            break;\n        }\n        let mut k = s.find('i', j\
    \ + 1);\n        if k == s.len() {\n            break;\n        }\n        if\
    \ s.starts_with(\"I\") {\n            boredoms += 1;\n        }\n        s = &s[..i]\
    \ + &s[j..k] + &s[k..];\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp9gnxi4s.rs:14:17\n   |\n\
    14 |         if i == s.len() {\n   |                 ^^^^^^^ expected enum `Option`,\
    \ found `usize`\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `usize`\nhelp: try wrapping the expression in `Some`\n   |\n14 |\
    \         if i == Some(s.len()) {\n   |                 +++++       +\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpp9gnxi4s.rs:17:35\n\
    \   |\n17 |         let mut j = s.find('i', i + 1);\n   |                    \
    \             - ^ - {integer}\n   |                                 |\n   |  \
    \                               Option<usize>\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpp9gnxi4s.rs:17:23\n\
    \     |\n17   |         let mut j = s.find('i', i + 1);\n     |              \
    \         ^^^^ ---  ----- supplied 2 arguments\n     |                       |\n\
    \     |                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp9gnxi4s.rs:18:17\n\
    \   |\n18 |         if j == s.len() {\n   |                 ^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         if j == Some(s.len()) {\n   |                 +++++      \
    \ +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpp9gnxi4s.rs:21:35\n\
    \   |\n21 |         let mut k = s.find('i', j + 1);\n   |                    \
    \             - ^ - {integer}\n   |                                 |\n   |  \
    \                               Option<usize>\n\nerror[E0061]: this function takes\
    \ 1 argument but 2 arguments were supplied\n    --> /tmp/tmpp9gnxi4s.rs:21:23\n\
    \     |\n21   |         let mut k = s.find('i', j + 1);\n     |              \
    \         ^^^^ ---  ----- supplied 2 arguments\n     |                       |\n\
    \     |                       expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..i + 1]);\n            i += 1;\n      \
    \  } else {\n            i += 1;\n        }\n    }\n    boredoms.iter().filter(|x|\
    \ x.starts_with(\"I\")).count()\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpc3zifkgz.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpc3zifkgz.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpc3zifkgz.rs:15:27\n   |\n15 |             boredoms.push(words[i..i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0599, E0608.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpevfhxjp8.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpevfhxjp8.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpevfhxjp8.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut idx = 0;\n    while idx < S.len()\
    \ {\n        if S[idx] == '.' || S[idx] == '?' || S[idx] == '!' {\n          \
    \  boredoms += 1;\n        }\n        idx += 1;\n    }\n    boredoms\n}\n\nfn\
    \ main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqkiopo7s.rs:13:12\n\
    \   |\n13 |         if S[idx] == '.' || S[idx] == '?' || S[idx] == '!' {\n   |\
    \            ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqkiopo7s.rs:13:29\n   |\n13 |         if S[idx] == '.' || S[idx]\
    \ == '?' || S[idx] == '!' {\n   |                             ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpqkiopo7s.rs:13:46\n   |\n13 |         if S[idx] == '.' || S[idx]\
    \ == '?' || S[idx] == '!' {\n   |                                            \
    \  ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInc"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpxo604ai_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            i += 1;\n            boredoms += 1;\n\
    \        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1pvitsgi.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut boredom_count = 0;\n    let\
    \ mut sentence = S.to_string();\n    let mut i = 0;\n    while i < sentence.len()\
    \ {\n        if sentence[i] == '.' || sentence[i] == '?' || sentence[i] == '!'\
    \ {\n            boredoms.push(sentence);\n            boredom_count += 1;\n \
    \           i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5l4zvr99.rs:15:12\n\
    \   |\n15 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5l4zvr99.rs:15:34\n   |\n15 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5l4zvr99.rs:15:56\n   |\n15 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms.push(1);\n       \
    \ } else {\n            boredoms.push(0);\n        }\n    }\n    boredoms.iter().sum()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpxo604ai_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence: Vec<&str> = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ \"I\" {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n   \
    \ boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnq2ccmo.rs:11:35\n   |\n\
    11 |     let mut sentence: Vec<&str> = S.split_whitespace();\n   |           \
    \            ---------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                       |\n   |                      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \       found struct `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.len()\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpevfhxjp8.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpevfhxjp8.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpevfhxjp8.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmph0lee594.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmph0lee594.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i..].iter().cloned().collect::<Vec<_>>());\n\
    \            i += 1;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    boredoms.iter().filter(|b| b.len() > 1).count()\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpf_2qyiw1.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpf_2qyiw1.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpf_2qyiw1.rs:15:27\n   |\n15 |             boredoms.push(words[i..].iter().cloned().collect::<Vec<_>>());\n\
    \   |                           ^^^^^^^^^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = String::from(S);\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i] ==\
    \ '.' || sentence[i] == '?' || sentence[i] == '!' {\n            i += 1;\n   \
    \     } else {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n\
    \    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3zzb3j5o.rs:14:12\n\
    \   |\n14 |         if sentence[i] == '.' || sentence[i] == '?' || sentence[i]\
    \ == '!' {\n   |            ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3zzb3j5o.rs:14:34\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3zzb3j5o.rs:14:56\n   |\n14 |         if sentence[i] == '.' ||\
    \ sentence[i] == '?' || sentence[i] == '!' {\n   |                           \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n            "
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_counter: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        } else {\n            boredom_counter\
    \ += 1;\n        }\n    }\n    boredom_counter\n}\n\nfn main() {\n    let candidate\
    \ = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n\
    \    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I feel good today. I will be productive.\
    \ will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"You and I are\
    \ going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvv_w_xc.rs:19:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n19 |     boredom_counter\n   |     ^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     boredom_counter.try_into().unwrap()\n\
    \   |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7wdh0qfa.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7wdh0qfa.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7wdh0qfa.rs:20:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n20 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii_lowercase()\
    \ {\n            if sentence[i] == \"i\" {\n                boredoms += 1;\n \
    \           }\n            i += 1;\n        } else {\n            i += 1;\n  \
    \      }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpgmmcjgvf.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmpgmmcjgvf.rs:14:12\n   |\n14 |         if sentence[i].is_ascii_lowercase()\
    \ {\n   |            ^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value of\
    \ type `SplitWhitespace<'_>`\n  --> /tmp/tmpgmmcjgvf.rs:15:16\n   |\n15 |    \
    \         if sentence[i] == \"i\" {\n   |                ^^^^^^^^^^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0608.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjwxr30lo.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpjwxr30lo.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjwxr30lo.rs:20:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n20 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut words = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < words.len() {\n        if words[i] == \"I\"\
    \ {\n            boredoms.push(words[i + 1]);\n            i += 2;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n}\n\nfn main()\
    \ {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello\
    \ world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")),\
    \ 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2okh71ia.rs:13:21\n   |\n13 |     while\
    \ i < words.len() {\n   |                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmp2okh71ia.rs:14:12\n   |\n14 |         if words[i] == \"I\" {\n   | \
    \           ^^^^^^^^\n\nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmp2okh71ia.rs:15:27\n   |\n15 |             boredoms.push(words[i\
    \ + 1]);\n   |                           ^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2okh71ia.rs:21:5\n   |\n9  | fn is_bored(S: String) ->\
    \ isize {\n   |                           ----- expected `isize` because of return\
    \ type\n...\n21 |     boredoms.len()\n   |     ^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n21 |     boredoms.len().try_into().unwrap()\n\
    \   |                   ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599, E0608.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            boredoms.push(S[i]);\n\
    \        }\n        i += 1;\n    }\n    boredoms.len()\n}\n\nfn main() {\n   \
    \ let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_l60rqc5.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_l60rqc5.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s.starts_with(\"I\") {\n   \
    \         boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\
    \nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `16`,\n right: `0`', /tmp/tmp1jnywcz1.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredom_count: usize\
    \ = 0;\n    let mut boredom_words: Vec<&str> = vec![];\n    let mut boredom_word_count:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize = 0;\n    let mut boredom_word_index: usize = 0;\n    let mut boredom_word_index:\
    \ usize\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpci6ejm1e.rs:51:38\n   |\n\
    51 |     let mut boredom_word_index: usize\n   |                             \
    \         ^ help: add `;` here\n52 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpci6ejm1e.rs:9:27\n  |\n9 | fn is_bored(S: String)\
    \ -> isize {\n  |    --------               ^^^^^ expected `isize`, found `()`\n\
    \  |    |\n  |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpuyd268gf.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() > 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuyd268gf.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ > 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut sentence = S.split_whitespace();\n\
    \    let mut i = 0;\n    while i < sentence.len() {\n        if sentence[i].is_ascii(\"\
    I\") {\n            boredoms += 1;\n        }\n        i += 1;\n    }\n    boredoms\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmppnxy4_cb.rs:13:24\n   |\n13 |     while\
    \ i < sentence.len() {\n   |                        ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n  -->\
    \ /tmp/tmppnxy4_cb.rs:14:12\n   |\n14 |         if sentence[i].is_ascii(\"I\"\
    ) {\n   |            ^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpefz3osei.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() == 0\n   | \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefz3osei.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ == 0\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `bool`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = vec![];\n    let mut boredom_count = 0;\n    for word\
    \ in S.split_whitespace() {\n        if word.starts_with(\"I\") {\n          \
    \  boredom_count += 1;\n            boredoms.push(word);\n        }\n    }\n \
    \   boredom_count\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmpv1h4fwr_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms = Vec::new();\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == 'I' {\n            boredoms.push(S[i]);\n            i\
    \ += 1;\n        } else {\n            i += 1;\n        }\n    }\n    boredoms.len()\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7wdh0qfa.rs:13:12\n\
    \   |\n13 |         if S[i] == 'I' {\n   |            ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7wdh0qfa.rs:14:27\n   |\n14 |             boredoms.push(S[i]);\n\
    \   |                           ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7wdh0qfa.rs:20:5\n\
    \   |\n9  | fn is_bored(S: String) -> isize {\n   |                          \
    \ ----- expected `isize` because of return type\n...\n20 |     boredoms.len()\n\
    \   |     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n20 |     boredoms.len().try_into().unwrap()\n   |                   ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    let\
    \ mut i = 0;\n    while i < s.len() {\n        if s[i] == '.' || s[i] == '?' ||\
    \ s[i] == '!' {\n            i += 1;\n        } else {\n            boredoms +=\
    \ 1;\n        }\n        i += 1;\n    }\n    boredoms\n}\n\nfn main() {\n    let\
    \ candidate = is_bored;\n    assert_eq!(candidate(String::from(\"Hello world\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\")), 0);\n \
    \   assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5i9z47ha.rs:14:12\n\
    \   |\n14 |         if s[i] == '.' || s[i] == '?' || s[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:27\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp5i9z47ha.rs:14:42\n   |\n14 |         if s[i] == '.' || s[i] ==\
    \ '?' || s[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n\
    }\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:28\n\
    \   |\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |                            ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:40\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_btz9wuy.rs:10:52\n   |\n10 |   \
    \  S.chars().filter(|c| c == '.' || c == '?' || c == '!').count() + 1\n   |  \
    \                                                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_btz9wuy.rs:10:5\n   |\n9  | fn is_bored(S:\
    \ String) -> isize {\n   |                           ----- expected `isize` because\
    \ of return type\n10 |     S.chars().filter(|c| c == '.' || c == '?' || c == '!').count()\
    \ + 1\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n10 |     (S.chars().filter(|c|\
    \ c == '.' || c == '?' || c == '!').count() + 1).try_into().unwrap()\n   |   \
    \  +                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut i = 0;\n    while i < S.len()\
    \ {\n        if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n            i +=\
    \ 1;\n        } else {\n            boredoms += 1;\n            i += 1;\n    \
    \    }\n    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n\
    \    assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpc869bub7.rs:13:12\n\
    \   |\n13 |         if S[i] == '.' || S[i] == '?' || S[i] == '!' {\n   |     \
    \       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:27\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                           ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpc869bub7.rs:13:42\n   |\n13 |         if S[i] == '.' || S[i] ==\
    \ '?' || S[i] == '!' {\n   |                                          ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <"
  stdout: ''
  timestamp: 1660009085
- exit_code: 1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: Vec<&str> = vec![];\n    let mut boredoms_cnt: usize\
    \ = 0;\n    for word in S.split_whitespace() {\n        if word.starts_with(\"\
    I\") {\n            boredoms.push(word);\n        }\n    }\n    for boredom in\
    \ boredoms {\n        if boredom.ends_with(\".\") || boredom.ends_with(\"?\")\
    \ || boredom.ends_with(\"!\") {\n            boredoms_cnt += 1;\n        }\n \
    \   }\n    boredoms_cnt\n}\n\nfn main() {\n    let candidate = is_bored;\n   \
    \ assert_eq!(candidate(String::from(\"Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"\
    Is the sky blue?\")), 0);\n    assert_eq!(candidate(String::from(\"I love It !\"\
    )), 1);\n    assert_eq!(candidate(String::from(\"bIt\")), 0);\n    assert_eq!(candidate(String::from(\"\
    I feel good today. I will be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp55nwz02a.rs:22:5\n   |\n\
    9  | fn is_bored(S: String) -> isize {\n   |                           ----- expected\
    \ `isize` because of return type\n...\n22 |     boredoms_cnt\n   |     ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n22 |     boredoms_cnt.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009085
- exit_code: -1
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    let mut s = S.to_string();\n    while\
    \ s.len() > 0 {\n        if s.starts_with(\"I\") {\n            boredoms += 1;\n\
    \        }\n        s = s.trim_end().to_string();\n    }\n    boredoms\n}\n\n\
    fn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660009090
- exit_code: 101
  program: "/// You'll be given a string of words, and your task is to count the number\n\
    /// of boredoms. A boredom is a sentence that starts with the word \"I\".\n///\
    \ Sentences are delimited by '.', '?' or '!'.\n/// For example:\n/// >>> is_bored(String::from(\"\
    Hello world\"))\n/// 0\n/// >>> is_bored(String::from(\"The sky is blue. The sun\
    \ is shining. I love this weather\"))\n/// 1\nfn is_bored(S: String) -> isize\
    \ {\n    let mut boredoms: isize = 0;\n    for word in S.split_whitespace() {\n\
    \        if word.starts_with(\"I\") {\n            boredoms += 1;\n        }\n\
    \    }\n    boredoms\n}\n\nfn main() {\n    let candidate = is_bored;\n    assert_eq!(candidate(String::from(\"\
    Hello world\")), 0);\n    assert_eq!(candidate(String::from(\"Is the sky blue?\"\
    )), 0);\n    assert_eq!(candidate(String::from(\"I love It !\")), 1);\n    assert_eq!(candidate(String::from(\"\
    bIt\")), 0);\n    assert_eq!(candidate(String::from(\"I feel good today. I will\
    \ be productive. will kill It\")), 2);\n    assert_eq!(candidate(String::from(\"\
    You and I are going for a walk\")), 0);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `0`', /tmp/tmp5yo26t99.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009085
