language: rs
name: HumanEval_111_histogram
results:
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().filter(|&c| !c.is_whitespace()).count();\n\
    \        histogram.insert(String::from(word), count);\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp51u29v83.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 1;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(count).cloned().unwrap();\n   \
    \     count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmpxv2oflwd.rs:24:50\n\
    \   |\n24 |         histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \   |                                                  ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpxv2oflwd.rs:27:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().cloned().count();\n        histogram.insert(word.to_string(),\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu246mihn.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          *count += 1;\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmp82dvg67m.rs:21:13\n   |\n20 |         if let Some(count) = histogram.get(&letter)\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n21 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        histogram.entry(letter).or_insert(0);\n\
    \        histogram.entry(letter).1 += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `1` on type `std::collections::hash_map::Entry<'_,\
    \ String, {integer}>`\n  --> /tmp/tmp3m43fkhw.rs:21:33\n   |\n21 |         histogram.entry(letter).1\
    \ += 1;\n   |                                 ^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0609`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmphknlh56c.rs:25:13\n   |\n25 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n25 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphknlh56c.rs:25:51\n\
    \   |\n25 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphknlh56c.rs:27:30\n   |\n27 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n   = note: expected reference `&&char`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphknlh56c.rs:30:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.remove(0);\n        histogram.insert(String::from(letter),\
    \ 0);\n        letters_count -= 1;\n        while letters_repeated_count > 0 {\n\
    \            if letters_repeated_count == letters_count {\n                histogram.insert(String::from(letter),\
    \ histogram.get(String::from(letter)) + 1);\n                letters_repeated_count\
    \ -= 1;\n            } else {\n                let mut letter = letters_repeated.remove(0);\n\
    \                histogram.insert(String::from(letter), histogram.get(String::from(letter))\
    \ + 1);\n                letters_repeated_count -= 1;\n            }\n       \
    \ }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3mj5rd7h.rs:27:40\n   |\n\
    27 |         while letters_repeated_count > 0 {\n   |                        \
    \                ^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<char>`\n                found type `{integer}`\n\nerror[E0277]:\
    \ can't compare `Vec<char>` with `usize`\n  --> /tmp/tmp3mj5rd7h.rs:28:39\n  \
    \ |\n28 |             if letters_repeated_count == letters_count {\n   |     \
    \                                  ^^ no implementation for `Vec<char> == usize`\n\
    \   |\n   = help: the trait `PartialEq<usize>` is not implemented for `Vec<char>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3mj5rd7h.rs:29:70\n   |\n29 |                 histogram.insert(String::from(letter),\
    \ histogram.get(String::from(letter)) + 1);\n   |                            \
    \                                          ^^^^^^^^^^^^^^^^^^^^\n   |        \
    \                                                              |\n   |       \
    \                                                               expected reference,\
    \ found struct `String`\n   |                                                \
    \                      help: consider borrowing here: `&String::from(letter)`\n\
    \   |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<&{integer}>`\n  --> /tmp/tmp3mj5rd7h.rs:29:92\n\
    \   |\n29 |                 histogram.insert(String::from(letter), histogram.get(String::from(letter))\
    \ + 1);\n   |                                                        -----------------------------------\
    \ ^ - {integer}\n   |                                                        |\n\
    \   |                                                   "
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_index2 = 0;\n\
    \    let mut letters_count_max2 = 0;\n    let mut letters_count_index3 = 0;\n\
    \    let mut letters_count_max3 = 0;\n    let mut letters_count_index4 = 0;\n\
    \    let mut letters_count_max4 = 0;\n    let mut letters_count_index5 = 0;\n\
    \    let mut letters_count_max5 = 0;\n    let mut letters_count_index6 = 0;\n\
    \    let mut letters_count_max6 = 0;\n    let mut letters_count_index7 = 0;\n\
    \    let mut letters_count_max7 = 0;\n    let mut letters_count_index8 = 0;\n\
    \    let mut letters_count_max8 = 0;\n    let mut letters_count_index9 = 0;\n\
    \    let mut letters_count_max9 = 0;\n    let mut letters_count_index10 = 0;\n\
    \    let mut letters_count_max10 = 0;\n    let mut letters_count_index11 = 0;\n\
    \    let mut letters_count_max11 = 0;\n    let mut letters_count_index12 = 0;\n\
    \    let mut letters_count_max12 = 0;\n    let mut letters_count_index13 = 0;\n\
    \    let mut letters_count_max13 = 0;\n    let mut letters_count_index14 = 0;\n\
    \    let mut letters_count_max14 = 0;\n    let mut letters_count_index15 = 0;\n\
    \    let mut letters_count_max15 = 0;\n    let mut letters_count_index16 = 0;\n\
    \    let mut letters_count_max16 = 0;\n    let mut letters_count_index17 = 0;\n\
    \    let mut letters_count_max17 = 0;\n    let mut letters_count_index18 = 0;\n\
    \    let mut letters_count_max18 = 0;\n    let mut letters_count_index19 = 0;\n\
    \    let mut letters_count_max19 = 0;\n    let mut letters_count_index20 = 0;\n\
    \    let mut letters_count_max20 = 0;\n    let mut letters_count_index21 = 0;\n\
    \    let mut letters_count_max21 = 0;\n    let mut letters_count_index22 = 0;\n\
    \    let mut letters_count_max22 = 0;\n    let mut letters_count_index23 = 0;\n\
    \    let mut letters_count_max23 = 0;\n    let mut letters_count_index24 = 0;\n\
    \    let mut letters_count_max24 = 0;\n    let mut letter\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdnb9jbh9.rs:69:19\n   |\n\
    69 |     let mut letter\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnb9jbh9.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpkyw0ue12.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpkyw0ue12.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    while letters_count_index < letters_count {\n        let letter = &letters[letters_count_index];\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_fumizih.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_iter =\
    \ 0;\n    let mut letters_count_iter2 = 0;\n    let mut letters_count_iter3 =\
    \ 0;\n    let mut letters_count_iter4 = 0;\n    let mut letters_count_iter5 =\
    \ 0;\n    let mut letters_count_iter6 = 0;\n    let mut letters_count_iter7 =\
    \ 0;\n    let mut letters_count_iter8 = 0;\n    let mut letters_count_iter9 =\
    \ 0;\n    let mut letters_count_iter10 = 0;\n    let mut letters_count_iter11\
    \ = 0;\n    let mut letters_count_iter12 = 0;\n    let mut letters_count_iter13\
    \ = 0;\n    let mut letters_count_iter14 = 0;\n    let mut letters_count_iter15\
    \ = 0;\n    let mut letters_count_iter16 = 0;\n    let mut letters_count_iter17\
    \ = 0;\n    let mut letters_count_iter18 = 0;\n    let mut letters_count_iter19\
    \ = 0;\n    let mut letters_count_iter20 = 0;\n    let mut letters_count_iter21\
    \ = 0;\n    let mut letters_count_iter22 = 0;\n    let mut letters_count_iter23\
    \ = 0;\n    let mut letters_count_iter24 = 0;\n    let mut letters_count_iter25\
    \ = 0;\n    let mut letters_count_iter26 = 0;\n    let mut letters_count_iter27\
    \ = 0;\n    let mut letters_count_iter28 = 0;\n    let mut letters_count_iter29\
    \ = 0;\n    let mut letters_count_iter30 = 0;\n    let mut letters_count_iter31\
    \ = 0;\n    let mut letters_count_iter32 = 0;\n    let mut letters_count_iter33\
    \ = 0;\n    let mut letters_count_iter34 = 0;\n    let mut letters_count_iter35\
    \ = 0;\n    let mut letters_count_iter36 = 0;\n    let mut letters_count_iter37\
    \ = 0;\n    let mut letters_count_iter38 = 0;\n    let mut letters_count_iter39\
    \ = 0;\n    let mut letters_count_iter40 = 0;\n    let mut letters_count_iter41\
    \ = 0;\n    let mut letters_count_iter42 = 0;\n    let mut letters_count_iter43\
    \ = 0;\n    let mut letters_count_iter44 = 0;\n    let mut letters_count_iter45\
    \ = 0;\n    let mut letters_count_iter46 = 0;\n    let \n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp7q2yocf_.rs:69:1\n  \
    \ |\n69 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_index2 = 0;\n\
    \    let mut letters_count_max2 = 0;\n    let mut letters_count_index3 = 0;\n\
    \    let mut letters_count_max3 = 0;\n    let mut letters_count_index4 = 0;\n\
    \    let mut letters_count_max4 = 0;\n    let mut letters_count_index5 = 0;\n\
    \    let mut letters_count_max5 = 0;\n    let mut letters_count_index6 = 0;\n\
    \    let mut letters_count_max6 = 0;\n    let mut letters_count_index7 = 0;\n\
    \    let mut letters_count_max7 = 0;\n    let mut letters_count_index8 = 0;\n\
    \    let mut letters_count_max8 = 0;\n    let mut letters_count_index9 = 0;\n\
    \    let mut letters_count_max9 = 0;\n    let mut letters_count_index10 = 0;\n\
    \    let mut letters_count_max10 = 0;\n    let mut letters_count_index11 = 0;\n\
    \    let mut letters_count_max11 = 0;\n    let mut letters_count_index12 = 0;\n\
    \    let mut letters_count_max12 = 0;\n    let mut letters_count_index13 = 0;\n\
    \    let mut letters_count_max13 = 0;\n    let mut letters_count_index14 = 0;\n\
    \    let mut letters_count_max14 = 0;\n    let mut letters_count_index15 = 0;\n\
    \    let mut letters_count_max15 = 0;\n    let mut letters_count_index16 = 0;\n\
    \    let mut letters_count_max16 = 0;\n    let mut letters_count_index17 = 0;\n\
    \    let mut letters_count_max17 = 0;\n    let mut letters_count_index18 = 0;\n\
    \    let mut letters_count_max18 = 0;\n    let mut letters_count_index19 = 0;\n\
    \    let mut letters_count_max19 = 0;\n    let mut letters_count_index20 = 0;\n\
    \    let mut letters_count_max20 = 0;\n    let mut letters_count_index21 = 0;\n\
    \    let mut letters_count_max21 = 0;\n    let mut letters_count_index22 = 0;\n\
    \    let mut letters_count_max22 = 0;\n    let mut letters_count_index23 = 0;\n\
    \    let mut letters_count_max23 = 0;\n    let mut letters_count_index24 = 0;\n\
    \    let mut letters_count_max24 = 0;\n    let mut letter\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdnb9jbh9.rs:69:19\n   |\n\
    69 |     let mut letter\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnb9jbh9.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        histogram.insert(word, histogram.entry(word).or_insert(0));\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpx7y8ge0e.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx7y8ge0e.rs:21:32\n   |\n21 |         histogram.insert(word, histogram.entry(word).or_insert(0));\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ integer, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n21 |         histogram.insert(word, *histogram.entry(word).or_insert(0));\n\
    \   |                                +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc8u35yn.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.collect::<Vec<String>>();\n    let mut letters_count\
    \ = letters.iter().cloned().map(|letter| histogram.entry(letter).or_default(0)).collect::<Vec<_>>();\n\
    \    let mut letters_count = letters_count.iter().cloned().map(|count| {\n   \
    \     if *count > letters_count.iter().max().unwrap() {\n            letters_count.remove(&*count);\n\
    \            count\n        } else {\n            *count\n        }\n    }).collect::<Vec<_>>();\n\
    \    histogram.insert(String::from(\"\"), 0);\n    letters_count.insert(String::from(\"\
    \"), 0);\n    for letter in letters {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp5tpozzjh.rs:20:29\n     |\n20\
    \   |     let mut letters = words.collect::<Vec<String>>();\n     |          \
    \                   ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0061]: this function takes 0 arguments but\
    \ 1 argument was supplied\n    --> /tmp/tmp5tpozzjh.rs:21:90\n     |\n21   | \
    \    let mut letters_count = letters.iter().cloned().map(|letter| histogram.entry(letter).or_default(0)).collect::<Vec<_>>();\n\
    \     |                                                                      \
    \                    ^^^^^^^^^^ - supplied 1 argument\n     |                \
    \                                                                          |\n\
    \     |                                                                      \
    \                    expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror[E0277]: the trait bound `&mut _: Clone` is not satisfied\n   \
    \ --> /tmp/tmp5tpozzjh.rs:22:50\n     |\n22   |     let mut letters_count = letters_count.iter().cloned().map(|count|\
    \ {\n     |                                                  ^^^^^^ the trait\
    \ `Clone` is not implemented for `&mut _`\n     |\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `map` exists for struct `Cloned<std::slice::Iter<'_,\
    \ &mut _>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp5tpozzjh.rs:22:59\n\
    \   |\n22 |       let mut letters_count = letters_count.iter().cloned().map(|count|\
    \ {\n   |                                                             ^^^ method\
    \ cannot be called on `Cloned<std::slice::Iter<'_, &mut _>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Cloned<std::slice::Iter<'_, &mut _>>: Iterator`\n   "
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        for letter in letters {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmptn3rr349.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmptn3rr349.rs:23:13\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------^^^^^\n   |             |\n   | \
    \            cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmptn3rr349.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.next().unwrap();\n    while let Some(letter) = letters\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n        letters = words.next().unwrap();\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r5o5zya.rs:21:15\n   |\n\
    21 |     while let Some(letter) = letters {\n   |               ^^^^^^^^^^^^ \
    \  ------- this expression has type `&str`\n   |               |\n   |       \
    \        expected `str`, found enum `Option`\n   |\n   = note: expected type `str`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_r5o5zya.rs:26:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_max_index = 0;\n    let mut letters_count_max_letter\
    \ = String::new();\n    let mut letters_count_max_letter_count = 0;\n\n    for\
    \ letter in letters {\n        if let Some(count) = histogram.get(&letter) {\n\
    \            histogram.insert(letter, count + 1);\n        } else {\n        \
    \    histogram.insert(letter, 1);\n        }\n        if count > letters_count_max\
    \ {\n            letters_count_max = count;\n            letters_count_max_index\
    \ = letters.iter().position(|&x| x == letter);\n            letters_count_max_letter\
    \ = letter;\n            letters_count_max_letter_count = count;\n        }\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `count` in this scope\n  --> /tmp/tmp18vr8odo.rs:32:12\n\
    \   |\n32 |         if count > letters_count_max {\n   |            ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `count` in this scope\n\
    \  --> /tmp/tmp18vr8odo.rs:33:33\n   |\n33 |             letters_count_max = count;\n\
    \   |                                 ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `count` in this scope\n  --> /tmp/tmp18vr8odo.rs:36:46\n \
    \  |\n36 |             letters_count_max_letter_count = count;\n   |         \
    \                                     ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp18vr8odo.rs:34:39\n   |\n22 |     let mut letters_count_max_index\
    \ = 0;\n   |                                       - expected due to this value\n\
    ...\n34 |             letters_count_max_index = letters.iter().position(|&x| x\
    \ == letter);\n   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<usize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp18vr8odo.rs:35:40\n   |\n23 |     let mut letters_count_max_letter\
    \ = String::new();\n   |                                        -------------\
    \ expected due to this value\n...\n35 |             letters_count_max_letter =\
    \ letter;\n   |                                        ^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                                  \
    \      |\n   |                                        expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp18vr8odo.rs:40:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n40 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<char, {integer}>`\n\nerror: abortin"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.clone(), histogram.get(&letters).unwrap_or(0)\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb2j4j_xy.rs:22:77\n   |\n\
    22 |         histogram.insert(letters.clone(), histogram.get(&letters).unwrap_or(0)\
    \ + 1);\n   |                                                                \
    \             ^\n   |                                                        \
    \                     |\n   |                                                \
    \                             expected reference, found integer\n   |        \
    \                                                                     help: consider\
    \ borrowing here: `&0`\n   |\n   = note: expected reference `&_`\n           \
    \        found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb2j4j_xy.rs:24:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, _>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_index = letters.clone();\n\
    \    let mut letters_repeated_count_max_value = letters.clone();\n    let mut\
    \ letters_repeated_count_max_value_count = letters.clone();\n    let mut letters_repeated_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_value_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_value_\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm1nqgkk4.rs:44:110\n   |\n\
    44 |     let mut letters_repeated_count_max_value_count_max_value_count_max_value_count_max_value_count_max_value_\n\
    \   |                                                                        \
    \                                      ^ help: add `;` here\n45 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm1nqgkk4.rs:17:31\n \
    \  |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|&x| x.to_string());\n    let mut count = 1;\n    for\
    \ letter in letters {\n        histogram.insert(letter, count);\n        count\
    \ += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4pr23bml.rs:26:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_olqkifp.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_max\
    \ = 0;\n    let mut letters_count_count_min = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9q6owlhy.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9q6owlhy.rs:17:31\n \
    \  |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.iter().map(|word| word.chars().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|letter| letter);\n    let mut letters_count = letters.iter().cloned().count();\n\
    \    let mut letters_count_max = letters_count.iter().max();\n    let mut letters_count_min\
    \ = letters_count.iter().min();\n    let mut letters_count_sum = 0;\n    let mut\
    \ letters_count_count_max = letters_count.iter().cloned().count();\n    let mut\
    \ letters_count_count_min = letters_count.iter().cloned().count();\n    let mut\
    \ letters_count_count_sum = 0;\n    let mut letters_count_count_count_max = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_min = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count.iter().cloned().count();\n    let mut letters_count_count_count_count_min\
    \ = letters_count.iter().cloned().count();\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_min = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_max\
    \ = letters_count.iter().cloned().count();\n    let mut letters_count_count_count_count_count_count_min\
    \ = letters_count.iter().cloned().count();\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_count_count_min = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_max = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_count_count_min = letters_count.iter().cloned().count();\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmptvrv6m5g.rs:20:29\n   |\n20 |     let mut\
    \ letters = words.iter().map(|word| word.chars().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \   |                             ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptvrv6m5g.rs:17:31\n   |\n17 |\
    \ fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------  \
    \                ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0) += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp74c3hswf.rs:20:9\n   |\n20 |         histogram.entry(c.to_string()).or_insert(0)\
    \ += 1;\n   |         -------------------------------------------^^^^^\n   | \
    \        |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(c.to_string()).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(c.to_string()).or_insert(0) += 1;\n   | \
    \        +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp74c3hswf.rs:20:53\n\
    \   |\n20 |         histogram.entry(c.to_string()).or_insert(0) += 1;\n   |  \
    \       ------------------------------------------- ^^\n   |         |\n   | \
    \        cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        if histogram.contains_key(&word) {\n       \
    \     histogram.entry(word).or_insert(0) += 1;\n        } else {\n           \
    \ histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcxl0d548.rs:22:13\n   |\n22 |             histogram.entry(word).or_insert(0)\
    \ += 1;\n   |             ----------------------------------^^^^^\n   |      \
    \       |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n\
    \   |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |      \
    \       +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcxl0d548.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpcxl0d548.rs:27:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters_repeated.len();\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.clone();\n        let mut letters_count\
    \ = letters.len();\n        while letters_count > 0 {\n            histogram.insert(letter.pop(),\
    \ histogram.get(&letter).unwrap_or(0));\n            letters_count -= 1;\n   \
    \     }\n        letters_repeated_count -= 1;\n        if letters_repeated_count\
    \ == 0 {\n            break;\n        }\n        letters_repeated = letters_repeated.clone();\n\
    \        letters_repeated_count = letters_repeated.len();\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptmbln8_j.rs:27:58\n   |\n\
    27 |             histogram.insert(letter.pop(), histogram.get(&letter).unwrap_or(0));\n\
    \   |                                                          ^^^^^^^ expected\
    \ enum `Option`, found struct `Vec`\n   |\n   = note: expected reference `&Option<char>`\n\
    \              found reference `&Vec<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptmbln8_j.rs:27:77\n   |\n27 |             histogram.insert(letter.pop(),\
    \ histogram.get(&letter).unwrap_or(0));\n   |                                \
    \                                             ^\n   |                        \
    \                                                     |\n   |                \
    \                                                             expected reference,\
    \ found integer\n   |                                                        \
    \                     help: consider borrowing here: `&0`\n   |\n   = note: expected\
    \ reference `&_`\n                   found type `{integer}`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptmbln8_j.rs:27:44\n   |\n27 |             histogram.insert(letter.pop(),\
    \ histogram.get(&letter).unwrap_or(0));\n   |                                \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                            |\n\
    \   |                                            cyclic type of infinite size\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptmbln8_j.rs:37:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n37 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found enum `Option`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Option<char>, _>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0e8bdgxd.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0e8bdgxd.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_sum = 0;\n    let mut letters_count_count_max = 0;\n\
    \    let mut letters_count_count_min = 0;\n    let mut letters_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf_87s4cb.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_set = HashSet::new();\n    let mut letters_count = HashMap::new();\n\
    \    let mut letters_count_max = HashMap::new();\n    let mut letters_count_min\
    \ = HashMap::new();\n    let mut letters_count_max_index = HashMap::new();\n \
    \   let mut letters_count_min_index = HashMap::new();\n    let mut letters_count_max_value\
    \ = HashMap::new();\n    let mut letters_count_min_value = HashMap::new();\n \
    \   let mut letters_count_max_value_count = HashMap::new();\n    let mut letters_count_min_value_count\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_index = HashMap::new();\n\
    \    let mut letters_count_min_value_count_index = HashMap::new();\n    let mut\
    \ letters_count_max_value_count_value = HashMap::new();\n    let mut letters_count_min_value_count_value\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_value_count = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count = HashMap::new();\n   \
    \ let mut letters_count_max_value_count_value_count_index = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count_index = HashMap::new();\n\
    \    let mut letters_count_max_value_count_value_count_value = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count_value = HashMap::new();\n\
    \    let mut letters_count_max_value_count_value_count_value_count = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count_value_count = HashMap::new();\n\
    \    let mut letters_count_max_value_count_value_count_value_count_index = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count_value_count_index = HashMap::new();\n\
    \    let mut letters_count_max_value_count_value_count_value_count_value = HashMap::new();\n\
    \    let mut letters_count_min_value_count_value_count_value_count_value = HashMap::new();\n\
    \    let mut letters_count_max_value_count_value_count_value_count_value_count\
    \ = HashMap::new();\n    let mut letters_count_min_value_count_value_count_value_count_value_count\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_value_count_value_count_value_count_index\
    \ = HashMap::\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmppvctzzb6.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmppvctzzb6.rs:20:27\n   |\n20\
    \ |     let mut letters_set = HashSet::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter = String::from(\"\
    \");\n    let mut letter_count = usize::MAX;\n    while let Some(letter) = letters.pop()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n        if letter_count > letter_counts.entry(letter).or_insert(0) {\n\
    \            letter_count = letter_counts.entry(letter).or_insert(0);\n      \
    \      letter = String::from(\"\");\n        }\n        letter += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpjois1cls.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjois1cls.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpjois1cls.rs:25:9\n   |\n25 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpjois1cls.rs:25:50\n\
    \   |\n25 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjois1cls.rs:26:27\n\
    \   |\n26 |         if letter_count > letter_counts.entry(letter).or_insert(0)\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n26 |         if letter_count > *letter_counts.entry(letter).or_insert(0)\
    \ {\n   |                           +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpjois1cls.rs:27:28\n   |\n22 |     let mut letter_count = usize::MAX;\n\
    \   |  "
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        for letter in letters {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpa2suawb4.rs:23:13\n   |\n23 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpa2suawb4.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoymluw35.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplwwdssox.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplwwdssox.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwwdssox.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplwwdssox.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = String::from(word);\n        if\
    \ histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpm701dq35.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpm701dq35.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpm701dq35.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpm701dq35.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0);\n        histogram.entry(c.to_string()).or_insert(0);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 0, \" \": 0, \"b\": 0}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpnmiardno.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplwwdssox.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplwwdssox.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwwdssox.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplwwdssox.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_count = letters.len();\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        letters_count\
    \ -= 1;\n    }\n    if letters_count > 0 {\n        histogram.insert(String::from(\"\
    \"), letters_count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp99zlh1yx.rs:23:9\n   |\n23 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp99zlh1yx.rs:23:46\n\
    \   |\n23 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp99zlh1yx.rs:27:26\n   |\n27 |         histogram.insert(String::from(\"\
    \"), letters_count);\n   |                          ^^^^^^^^^^^^^^^^\n   |   \
    \                       |\n   |                          expected `&String`, found\
    \ struct `String`\n   |                          help: consider borrowing here:\
    \ `&String::from(\"\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99zlh1yx.rs:29:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, usize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter_count = 1;\n \
    \   let mut letter = String::from(\"\");\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(letter_count).cloned() += 1;\n\
    \        letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmpalodx38q.rs:24:57\n\
    \   |\n24 |         histogram.entry(letter).or_insert(letter_count).cloned() +=\
    \ 1;\n   |                                                         ^^^^^^ `&mut\
    \ {integer}` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `{integer}: Iterator`\n           which is required\
    \ by `&mut {integer}: Iterator`\n           `&mut {integer}: Iterator`\n     \
    \      which is required by `&mut &mut {integer}: Iterator`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpalodx38q.rs:24:66\n   |\n24 |  \
    \       histogram.entry(letter).or_insert(letter_count).cloned() += 1;\n   | \
    \        -------------------------------------------------------- ^^\n   |   \
    \      |\n   |         cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpalodx38q.rs:27:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp5gz_0gun.rs:23:13\n   |\n23 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp5gz_0gun.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5gz_0gun.rs:28:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut letters_count = String::new();\n\
    \    let mut letters_count_mut_ref = String::new();\n    let mut letters_count_mut_ref_mut_ref\
    \ = String::new();\n    let mut letters_count_mut_ref_mut_ref_mut_ref = String::new();\n\
    \    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref = String::new();\n\
    \    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref = String::new();\n\
    \    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref = String::new();\n\
    \    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref\
    \ = String::new();\n    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref\
    \ = String::new();\n    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref\
    \ = String::new();\n    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref\
    \ = String::new();\n    let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mu\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpm_sel6kt.rs:32:461\n   |\n\
    32 |     let mut letters_count_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mut_ref_mu\n\
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \         ^ help: add `;` here\n33 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm_sel6kt.rs:17:31\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), letters.iter().count());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6pqc_ty.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_set = HashSet::new();\n\
    \    let mut letters_count = HashMap::new();\n    while let Some(letter) = letters.iter().next()\
    \ {\n        histogram.insert(letter, 0);\n        letters_set.insert(letter);\n\
    \        letters_count.insert(letter, 0);\n    }\n    for letter in letters_set\
    \ {\n        let count = letters_count.get(&letter).unwrap();\n        histogram.insert(letter,\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpei317b8o.rs:20:27\n   |\n20 |     let mut letters_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpei317b8o.rs:29:34\n   |\n29 |         histogram.insert(letter,\
    \ count);\n   |                                  ^^^^^ expected integer, found\
    \ `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n29 |    \
    \     histogram.insert(letter, *count);\n   |                                \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpei317b8o.rs:31:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n31 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letter = word.chars().collect::<Vec<_>>().sort();\n\
    \        let mut count = 0;\n        for letter in letter {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n            count += 1;\n        }\n        histogram.insert(word.to_string(),\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `()` is not an iterator\n  --> /tmp/tmprsv6llvz.rs:23:23\n\
    \   |\n23 |         for letter in letter {\n   |                       ^^^^^^\
    \ `()` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `()`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `()`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmprsv6llvz.rs:24:13\n   |\n24 |      \
    \       histogram.entry(letter).or_insert(0) += 1;\n   |             ------------------------------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&mut {integer}`\n\
    \   |\nhelp: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmprsv6llvz.rs:24:50\n\
    \   |\n24 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0277, E0368.\nFor\
    \ more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut occurrences = histogram.entry(word.clone()).or_insert(0);\n \
    \       *occurrences += 1;\n        for letter in letters {\n            histogram.entry(letter.clone()).or_insert(0);\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2xd2r5ng.rs:25:29\n   |\n\
    25 |             histogram.entry(letter.clone()).or_insert(0);\n   |         \
    \                    ^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2xd2r5ng.rs:28:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    loop {\n        let mut letters_repeated = letters_repeated.clone();\n  \
    \      let mut letters_count = letters_count.clone();\n        for letter in letters_repeated.iter()\
    \ {\n            histogram.entry(letter).or_insert(0) += 1;\n        }\n     \
    \   if letters_count == letters.len() {\n            break;\n        }\n     \
    \   letters_count -= 1;\n        letters = letters_repeated;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpmiqhrbw2.rs:26:13\n   |\n26 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n26 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpmiqhrbw2.rs:26:50\n\
    \   |\n26 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmiqhrbw2.rs:34:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n34 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0067, E0308, E0368.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = 0;\n    let mut letters_repeated_count_index2 = 0;\n    let mut letters_repeated_count_index3\
    \ = 0;\n    let mut letters_repeated_count_index4 = 0;\n    let mut letters_repeated_count_index5\
    \ = 0;\n    let mut letters_repeated_count_index6 = 0;\n    let mut letters_repeated_count_index7\
    \ = 0;\n    let mut letters_repeated_count_index8 = 0;\n    let mut letters_repeated_count_index9\
    \ = 0;\n    let mut letters_repeated_count_index10 = 0;\n    let mut letters_repeated_count_index11\
    \ = 0;\n    let mut letters_repeated_count_index12 = 0;\n    let mut letters_repeated_count_index13\
    \ = 0;\n    let mut letters_repeated_count_index14 = 0;\n    let mut letters_repeated_count_index15\
    \ = 0;\n    let mut letters_repeated_count_index16 = 0;\n    let mut letters_repeated_count_index17\
    \ = 0;\n    let mut letters_repeated_count_index18 = 0;\n    let mut letters_repeated_count_index19\
    \ = 0;\n    let mut letters_repeated_count_index20 = 0;\n    let mut letters_repeated_count_index21\
    \ = 0;\n    let mut letters_repeated_count_index22 = 0;\n    let mut letters_repeated_count_index23\
    \ = 0;\n    let mut letters_repeated_count_index24 = 0;\n    let mut letters_repeated_count_index25\
    \ = 0;\n    let mut letters_repeated_count_index26 = 0;\n    let mut letters_repeated_count_index27\
    \ = 0;\n    let mut letters_repeated_count_index28 = 0;\n    let mut letters_repeated_count_index29\
    \ = 0;\n    let mut letters_repeated_count_index30 = 0;\n    let mut letters_repeated_count_index31\
    \ = 0;\n    let mut letters_repeated_count_index32 = 0;\n    let mut letters_repeated_count_index33\
    \ = 0;\n    let mut letters_repeated_count_index34 = 0;\n    let mut letters_repeated_count_index35\
    \ = 0;\n    let mut letters_repeated_count_index36 = 0;\n    let mut letters_repeated_count_index37\
    \ = 0;\n    let mut letters_repeated_count_index38 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2vklk0x2.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| {\n        let mut count = HashMap::new();\n   \
    \     count.entry(c.to_string()).or_insert(0);\n        count.entry(c.to_string()).or_insert(0);\n\
    \        count.entry(c.to_string()).or_insert(0);\n        count.entry(c.to_string()).or_insert(0);\n\
    \        count\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<String, isize>` cannot be built\
    \ from an iterator over elements of type `HashMap<String, {integer}>`\n    -->\
    \ /tmp/tmpttzezoai.rs:25:8\n     |\n25   |     }).collect()\n     |        ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=HashMap<String,\
    \ {integer}>>`\n     |\n     = help: the trait `FromIterator<HashMap<String, {integer}>>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let count = histogram.entry(word).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpbymiypx7.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    while let Some(letter) = letters.pop() {\n      \
    \  histogram.insert(letter, count);\n        count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp52mlgp3m.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          histogram.insert(letter, count + 1);\n        } else {\n          \
    \  histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpox1oi60g.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          *count += 1;\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmp82dvg67m.rs:21:13\n   |\n20 |         if let Some(count) = histogram.get(&letter)\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n21 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_olqkifp.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), letters.iter().count());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6pqc_ty.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    for word in\
    \ words {\n        letters = letters.to_owned() + word.to_owned();\n        histogram.entry(letters).or_insert(count).cloned().unwrap();\n\
    \        count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxr_chvjv.rs:23:40\n   |\n\
    23 |         letters = letters.to_owned() + word.to_owned();\n   |           \
    \                             ^^^^^^^^^^^^^^^\n   |                          \
    \              |\n   |                                        expected `&str`,\
    \ found struct `String`\n   |                                        help: consider\
    \ borrowing here: `&word.to_owned()`\n\nerror[E0599]: `&mut {integer}` is not\
    \ an iterator\n  --> /tmp/tmpxr_chvjv.rs:24:51\n   |\n24 |         histogram.entry(letters).or_insert(count).cloned().unwrap();\n\
    \   |                                                   ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), letters.iter().count());\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk6pqc_ty.rs:24:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n24 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.iter().map(|word| word.chars().collect::<String>()).collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|letter| histogram.entry(letter).or_default(0)).collect::<Vec<_>>();\n\
    \    letters_count.sort_by_key(|&(_, count)| {\n        count.cmp(&letters_count[letters_count.len()\
    \ - 1])\n    });\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp8sj71t4v.rs:20:29\n   |\n20 |     let mut\
    \ letters = words.iter().map(|word| word.chars().collect::<String>()).collect::<Vec<_>>();\n\
    \   |                             ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp8sj71t4v.rs:21:90\n     |\n21   |     let mut letters_count =\
    \ letters.iter().cloned().map(|letter| histogram.entry(letter).or_default(0)).collect::<Vec<_>>();\n\
    \     |                                                                      \
    \                    ^^^^^^^^^^ - supplied 1 argument\n     |                \
    \                                                                          |\n\
    \     |                                                                      \
    \                    expected 0 arguments\n     |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_max = 0;\n   \
    \ let mut letters_count_max_iter = 0;\n    let mut letters_count_max_letter =\
    \ String::new();\n    let mut letters_count_max_letter_iter = 0;\n    let mut\
    \ letters_count_max_letter_count = 0;\n    let mut letters_count_max_letter_count_iter\
    \ = 0;\n    while let Some(letter) = letters_iter.next() {\n        histogram.insert(\n\
    \            letter.to_string(),\n            histogram.entry(letter.to_string()).or_insert(0),\n\
    \        );\n        letters_count_iter += 1;\n        if letters_count_iter >\
    \ letters_count {\n            letters_count_iter = letters_count;\n        }\n\
    \        if letters_count_iter > letters_count_max {\n            letters_count_max\
    \ = letters_count_iter;\n            letters_count_max_letter = letter;\n    \
    \        letters_count_max_letter_iter = letters_count_iter;\n            letters_count_max_letter_count\
    \ = histogram.get(letter).unwrap();\n        }\n        if letters_count_iter\
    \ == letters_count_max {\n            if letters_count_iter > letters_count_max_letter_iter\
    \ {\n                letters_count_max_letter_iter = letters_count_iter;\n   \
    \             letters_count_max_letter_count_iter = letters_count_iter;\n    \
    \            letters_count_max_letter_count = histogram.get(letter).unwrap();\n\
    \            }\n            if letters_count_iter == letters_count_max_letter_iter\
    \ {\n                if letters_count_iter > letters_count_max_letter_count_iter\
    \ {\n                    letters_count_max_letter_count_iter = letters_count_iter;\n\
    \                    letters_count_max_letter_count_iter = letters_count_iter;\n\
    \                    letters_count_max_letter_count = histogram.get(letter).unwrap();\n\
    \                }\n                if letters_count_iter == letters_count_max_letter_count_iter\
    \ {\n                    if letters_count_iter > letters_count_max_letter_count\
    \ {\n                        letters_count_max_letter_count_iter = letters_count_iter;\n\
    \                        letters_count_max_letter_count_iter = letters_count_iter;\n\
    \                        letters_count_max_letter_count = histogram.get(letter).unwrap();\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpigh1r2sd.rs:21:37\n   |\n21 |     let mut letters_count\
    \ = letters.count();\n   |                                     ^^^^^\n   |   \
    \                                  |\n   |                                   \
    \  method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n  \
    \ |                                     help: consider using `len` instead\n \
    \  |\n   = note: `count` is defined on `Iterator`, which `Vec<char>` does not\
    \ implement\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpigh1r2sd.rs:32:13\n\
    \   |\n32 |             histogram.entry(letter.to_string()).or_insert(0),\n  \
    \ |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    32 |             *histogram.entry(letter.to_string()).or_insert(0),\n   |    \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpigh1r2sd.rs:40:40\n\
    \   |\n25 |     let mut letters_count_max_letter = String::new();\n   |      \
    \                                  ------------- expected due to this value\n\
    ...\n40 |             letters_count_max_letter = letter;\n   |               \
    \                         ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `&char`\n\nerror[E0277]: the trait\
    \ bound `String: Borrow<char>` is not satisfied\n   --> /tmp/tmpigh1r2sd.rs:42:56\n\
    \    |\n42  |             letters_count_max_letter_count = histogram.get(letter).unwrap();\n\
    \    |                                                        ^^^ the trait `Borrow<char>`\
    \ is not implemented for `String`\n    |\n    = help: the trait `Borrow<str>`\
    \ is implemented for `String`\nnote: required by a bound in `HashMap::<K, V, S>::get`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpigh1r2sd.rs:42:46\n   |\n27 |\
    \     let mut letters_count_max_letter_count = 0;\n   |                      \
    \                        - expected du"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmphf3866yb.rs:21:13\n   |\n21 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n21 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphf3866yb.rs:21:51\n\
    \   |\n21 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphf3866yb.rs:23:30\n   |\n23 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphf3866yb.rs:26:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().map(|c|\
    \ c.to_string());\n        let mut count = histogram.entry(letters.clone()).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphh6j4fmr.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().filter_map(|c|\
    \ c.is_ascii_lowercase()).collect::<Vec<_>>() {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3kv0dhvd.rs:19:47\n   |\n\
    19 |     for letter in test.chars().filter_map(|c| c.is_ascii_lowercase()).collect::<Vec<_>>()\
    \ {\n   |                                               ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n19 |     for letter in test.chars().filter_map(|c| Some(c.is_ascii_lowercase())).collect::<Vec<_>>()\
    \ {\n   |                                               +++++                \
    \      +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n        let mut count = histogram.entry(letters.clone()).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpq2mf9ogv.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = String::from(word);\n        if\
    \ histogram.contains_key(&letter) {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpli8o81uf.rs:23:13\n   |\n23 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpli8o81uf.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| {\n        let mut count = HashMap::new();\n   \
    \     let mut letter = String::from(*c);\n        count.entry(letter).or_insert(0);\n\
    \        count.entry(letter).and_modify(|x| {\n            *x += 1;\n        });\n\
    \        count\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpa_zpkgh2.rs:20:39\n\
    \   |\n20 |         let mut letter = String::from(*c);\n   |                 \
    \                      ^^\n\nerror[E0277]: a value of type `HashMap<String, isize>`\
    \ cannot be built from an iterator over elements of type `HashMap<String, {integer}>`\n\
    \    --> /tmp/tmpa_zpkgh2.rs:26:8\n     |\n26   |     }).collect()\n     |   \
    \     ^^^^^^^ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=HashMap<String,\
    \ {integer}>>`\n     |\n     = help: the trait `FromIterator<HashMap<String, {integer}>>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letter = String::from(\"\");\n    let mut letter_count = letters.count();\n\
    \    while let Some(letter) = letters_iter.next() {\n        histogram.entry(letter).or_insert(0)\
    \ += 1;\n        if histogram.contains_key(&letter) {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `count` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpm9rekek9.rs:21:37\n   |\n21 |     let mut letters_count\
    \ = letters.count();\n   |                                     ^^^^^\n   |   \
    \                                  |\n   |                                   \
    \  method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n  \
    \ |                                     help: consider using `len` instead\n \
    \  |\n   = note: `count` is defined on `Iterator`, which `Vec<char>` does not\
    \ implement\n\nerror[E0599]: no method named `count` found for struct `Vec<char>`\
    \ in the current scope\n  --> /tmp/tmpm9rekek9.rs:23:36\n   |\n23 |     let mut\
    \ letter_count = letters.count();\n   |                                    ^^^^^\n\
    \   |                                    |\n   |                             \
    \       method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n\
    \   |                                    help: consider using `len` instead\n\
    \   |\n   = note: `count` is defined on `Iterator`, which `Vec<char>` does not\
    \ implement\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&mut {integer}`\n  --> /tmp/tmpm9rekek9.rs:25:9\n   |\n25 |       \
    \  histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpm9rekek9.rs:25:46\n\
    \   |\n25 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmpm9rekek9.rs:27:13\n   |\n27 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ---------------------"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpcupkzx1f.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpcupkzx1f.rs:22:13\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ----------------------------------^^^^^\n   |             |\n   |     \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n \
    \  |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcupkzx1f.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_olqkifp.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    letters.sort_by_key(|&x| x.to_ascii_lowercase());\n    let mut letters_iter\
    \ = letters.iter();\n    let mut letter = String::from(\"\");\n    let mut count\
    \ = 1;\n    while let Some(letter) = letters_iter.next() {\n        histogram.insert(letter,\
    \ count);\n        count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4jkq_5g3.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut counts = HashMap::new();\n\
    \    let mut letter = String::new();\n    let mut count = isize::MAX;\n    while\
    \ let Some(letter) = words.next() {\n        letters.push_str(letter);\n     \
    \   counts.entry(letter).or_insert(0) += 1;\n        if count > counts.entry(letter).or_insert(0)\
    \ {\n            count = counts.entry(letter).or_insert(0);\n        }\n    }\n\
    \    histogram.insert(letters.clone(), count);\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp2u1g80ka.rs:26:9\n   |\n26 |         counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ---------------------------------^^^^^\n   |         |\n\
    \   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `counts.entry(letter).or_insert(0)`\n\
    \   |\n26 |         *counts.entry(letter).or_insert(0) += 1;\n   |         +\n\
    \nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp2u1g80ka.rs:26:43\n\
    \   |\n26 |         counts.entry(letter).or_insert(0) += 1;\n   |         ---------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2u1g80ka.rs:27:20\n   |\n27 |         if count\
    \ > counts.entry(letter).or_insert(0) {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `&mut {integer}`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n27 |         if count > *counts.entry(letter).or_insert(0)\
    \ {\n   |                    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2u1g80ka.rs:28:21\n\
    \   |\n23 |     let mut count = isize::MAX;\n   |                     ----------\
    \ expected due to this value\n...\n28 |             count = counts.entry(letter).or_insert(0);\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&mut {integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    28 |             count = *counts.entry(letter).or_insert(0);\n   |           \
    \          +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        if histogram.contains_key(&letter)\
    \ {\n            count += 1;\n        }\n    }\n    histogram.insert(String::from(\"\
    \"), count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpv1o3onfu.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpv1o3onfu.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv1o3onfu.rs:29:22\n   |\n29 |     histogram.insert(String::from(\"\
    \"), count);\n   |                      ^^^^^^^^^^^^^^^^ expected `&char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv1o3onfu.rs:30:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_max = 0;\n    let mut\
    \ letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpmgsigdzc.rs:58:27\n   |\n\
    58 |     let mut letters_count_\n   |                           ^ help: add `;`\
    \ here\n59 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpmgsigdzc.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += 1;\n        count += 1;\n\
    \        if count == 1 {\n            letter = String::from(\"\");\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpbasv5xz_.rs:24:9\n   |\n24 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpbasv5xz_.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbasv5xz_.rs:27:22\n   |\n23 |     while let\
    \ Some(letter) = letters_iter.next() {\n   |                    ------ expected\
    \ due to the type of this binding\n...\n27 |             letter = String::from(\"\
    \");\n   |                      ^^^^^^^^^^^^^^^^ expected `&char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbasv5xz_.rs:30:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_iter2 = 0;\n \
    \   let mut letters_count_iter3 = 0;\n    let mut letters_count_iter4 = 0;\n \
    \   let mut letters_count_iter5 = 0;\n    let mut letters_count_iter6 = 0;\n \
    \   let mut letters_count_iter7 = 0;\n    let mut letters_count_iter8 = 0;\n \
    \   let mut letters_count_iter9 = 0;\n    let mut letters_count_iter10 = 0;\n\
    \    let mut letters_count_iter11 = 0;\n    let mut letters_count_iter12 = 0;\n\
    \    let mut letters_count_iter13 = 0;\n    let mut letters_count_iter14 = 0;\n\
    \    let mut letters_count_iter15 = 0;\n    let mut letters_count_iter16 = 0;\n\
    \    let mut letters_count_iter17 = 0;\n    let mut letters_count_iter18 = 0;\n\
    \    let mut letters_count_iter19 = 0;\n    let mut letters_count_iter20 = 0;\n\
    \    let mut letters_count_iter21 = 0;\n    let mut letters_count_iter22 = 0;\n\
    \    let mut letters_count_iter23 = 0;\n    let mut letters_count_iter24 = 0;\n\
    \    let mut letters_count_iter25 = 0;\n    let mut letters_count_iter26 = 0;\n\
    \    let mut letters_count_iter27 = 0;\n    let mut letters_count_iter28 = 0;\n\
    \    let mut letters_count_iter29 = 0;\n    let mut letters_count_iter30 = 0;\n\
    \    let mut letters_count_iter31 = 0;\n    let mut letters_count_iter32 = 0;\n\
    \    let mut letters_count_iter33 = 0;\n    let mut letters_count_iter34 = 0;\n\
    \    let mut letters_count_iter35 = 0;\n    let mut letters_count_iter36 = 0;\n\
    \    let mut letters_count_iter37 = 0;\n    let mut letters_count_iter38 = 0;\n\
    \    let mut letters_count_iter39 = 0;\n    let mut letters_count_iter40 = 0;\n\
    \    let mut letters_count_iter41 = 0;\n    let mut letters_count_iter42 = 0;\n\
    \    let mut letters_count_iter43 = 0;\n    let mut letters_count_iter44 = 0;\n\
    \    let mut letters_count_iter45 = 0;\n    let mut letters_count_iter46 = 0;\n\
    \    let mut letters_count_iter47\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9a4lm2mo.rs:68:33\n   |\n\
    68 |     let mut letters_count_iter47\n   |                                 ^\
    \ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `count` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmp9a4lm2mo.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9a4lm2mo.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap().to_string();\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpombn_k6h.rs:22:9\n   |\n22 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n22 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpombn_k6h.rs:22:46\n\
    \   |\n22 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = 1;\n        for letter in letters {\n            histogram.entry(letter).and_modify(|count|\
    \ {\n                count += 1;\n            });\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut _`\n  --> /tmp/tmpefstcckf.rs:25:17\n   |\n25 |                 count\
    \ += 1;\n   |                 -----^^^^^\n   |                 |\n   |       \
    \          cannot use `+=` on type `&mut _`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpefstcckf.rs:29:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n29 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, _>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = letters_count;\n    let mut letters_count_sum\
    \ = 0;\n    let mut letters_count_count_max = 0;\n    let mut letters_count_count_min\
    \ = letters_count_count;\n    let mut letters_count_count_sum = 0;\n    let mut\
    \ letters_count_count_count_max = 0;\n    let mut letters_count_count_count_min\
    \ = letters_count_count_count;\n    let mut letters_count_count_count_sum = 0;\n\
    \    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_count;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count_count;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_count_count_count;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count_count_count_count;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = letters_count_count_count_count_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_min = letters_count_count_count_count_count_count_count_count_count;\n\
    \    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_count_count_count_count;\n    let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count_count_count_count_count;\n    let mut\
    \ letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_max\
    \ = letters_count_count_count_count_count_count_count_count_count;\n    let mu\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt9kjnnu0.rs:52:11\n   |\n\
    52 |     let mu\n   |           ^ help: add `;` here\n53 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `letters_count_count` in this scope\n\
    \  --> /tmp/tmpt9kjnnu0.rs:25:39\n   |\n25 |     let mut letters_count_count_min\
    \ = letters_count_count;\n   |                                       ^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `letters_count_count_max`\n\
    \nerror[E0425]: cannot find value `letters_count_count_count` in this scope\n\
    \  --> /tmp/tmpt9kjnnu0.rs:28:45\n   |\n28 |     let mut letters_count_count_count_min\
    \ = letters_count_count_count;\n   |                                         \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `letters_count_count_count_max`\n\nerror[E0425]: cannot find value `letters_count_count_count_count`\
    \ in this scope\n  --> /tmp/tmpt9kjnnu0.rs:31:51\n   |\n31 |     let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count;\n   |                                   \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a\
    \ similar name exists: `letters_count_count_count_count_max`\n\nerror[E0425]:\
    \ cannot find value `letters_count_count_count_count` in this scope\n  --> /tmp/tmpt9kjnnu0.rs:33:51\n\
    \   |\n33 |     let mut letters_count_count_count_count_max = letters_count_count_count_count;\n\
    \   |                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `letters_count_count_count_count_max`\n\
    \nerror[E0425]: cannot find value `letters_count_count_count_count_count` in this\
    \ scope\n  --> /tmp/tmpt9kjnnu0.rs:34:51\n   |\n34 |     let mut letters_count_count_count_count_min\
    \ = letters_count_count_count_count_count;\n   |                             \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `letters_count_count_count_count_min`\n\nerror[E0425]:\
    \ cannot find value `letters_count_count_count_count_count` in t"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let count = histogram.entry(word).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpbymiypx7.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |mut acc, c| {\n        let mut count\
    \ = acc.entry(c.to_string()).or_insert(0);\n        *count += 1;\n        acc\n\
    \    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpdv6vnehl.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgkioibhw.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:23:37\n\
    \   |\n23 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:25:37\n\
    \   |\n25 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:27:37\n\
    \   |\n27 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc8u35yn.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.clone(), histogram.get(&letters).unwrap().clone()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `HashMap<Vec<String>, V>`\n \
    \ --> /tmp/tmp403malo8.rs:22:53\n   |\n18 |     let mut histogram = HashMap::new();\n\
    \   |         ------------- consider giving `histogram` the explicit type `HashMap<Vec<_>,\
    \ V>`, where the type parameter `V` is specified\n...\n22 |         histogram.insert(letters.clone(),\
    \ histogram.get(&letters).unwrap().clone() + 1);\n   |                       \
    \                              ^^^ cannot infer type for type parameter `V`\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_maxi = 0;\n    let mut letters_count_maxj = 0;\n  \
    \  let mut letters_count_maxk = 0;\n    let mut letters_count_maxl = 0;\n    let\
    \ mut letters_count_maxm = 0;\n    let mut letters_count_maxn = 0;\n    let mut\
    \ letters_count_maxo = 0;\n    let mut letters_count_maxp = 0;\n    let mut letters_count_maxq\
    \ = 0;\n    let mut letters_count_maxr = 0;\n    let mut letters_count_maxs =\
    \ 0;\n    let mut letters_count_maxt = 0;\n    let mut letters_count_maxu = 0;\n\
    \    let mut letters_count_maxv = 0;\n    let mut letters_count_maxw = 0;\n  \
    \  let mut letters_count_maxx = 0;\n    let mut letters_count_maxy = 0;\n    let\
    \ mut letters_count_maxz = 0;\n    let mut letters_count_max = 0;\n    let mut\
    \ letters_count_maxi = 0;\n    let mut letters_count_maxj = 0;\n    let mut letters_count_maxk\
    \ = 0;\n    let mut letters_count_maxl = 0;\n    let mut letters_count_maxm =\
    \ 0;\n    let mut letters_count_maxn = 0;\n    let mut letters_count_maxo = 0;\n\
    \    let mut letters_count_maxp = 0;\n    let mut letters_count_maxq = 0;\n  \
    \  let mut letters_count_maxr = 0;\n    let mut letters_count_maxs = 0;\n    let\
    \ mut letters_count_maxt = 0;\n    let mut letters_count_maxu = 0;\n    let mut\
    \ letters_count_maxv = 0;\n    let mut letters_count_maxw = 0;\n    let mut letters_count_maxx\
    \ = 0;\n    let mut letters_count_maxy = 0;\n    let mut letters_count_maxz =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_maxi = 0;\n\
    \    let mut letters_count_maxj = 0;\n    let mut letters_count_maxk = 0;\n  \
    \  let mut letters_count_maxl = 0;\n    let mut letters_count_maxm = 0;\n    let\
    \ mut letters_count_maxn = 0;\n    let mut letters_count_maxo = 0;\n    let mut\
    \ letters_count_maxp = 0;\n    let mut letters_count_maxq = 0;\n    let mut letter\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpu750p7zx.rs:69:19\n   |\n\
    69 |     let mut letter\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu750p7zx.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |mut acc, c| {\n        let mut count\
    \ = acc.entry(c.to_string()).or_insert(0);\n        *count += 1;\n        acc\n\
    \    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpdv6vnehl.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letter_counts = letters.into_iter().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    letter_counts.for_each(|(letter, count)|\
    \ histogram.insert(letter, count));\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfg08kj5q.rs:21:29\n   |\n\
    21 |     letter_counts.for_each(|(letter, count)| histogram.insert(letter, count));\n\
    \   |                             ^^^^^^^^^^^^^^-\n   |                      \
    \       |             |\n   |                             |             expected\
    \ due to this\n   |                             expected integer, found tuple\n\
    \   |\n   = note: expected type `{integer}`\n             found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfg08kj5q.rs:21:46\n   |\n21 |\
    \     letter_counts.for_each(|(letter, count)| histogram.insert(letter, count));\n\
    \   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found enum `Option`\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<{integer}>`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n\n    while letters_count\
    \ > 0 {\n        let mut letter = letters.remove(0);\n        let mut count =\
    \ letters_repeated_count.remove(0);\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|x| {\n                *x\
    \ += *count;\n            });\n        } else {\n            histogram.insert(letter,\
    \ count);\n        }\n        letters_count -= 1;\n        letters_repeated_count\
    \ -= 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9h76rdch.rs:29:23\n\
    \   |\n29 |                 *x += *count;\n   |                       ^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9h76rdch.rs:32:30\n   |\n32 |\
    \             histogram.insert(letter, count);\n   |                         \
    \     ^^^^^^\n   |                              |\n   |                      \
    \        expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0277]: cannot add-assign `_` to\
    \ `char`\n  --> /tmp/tmp9h76rdch.rs:29:20\n   |\n29 |                 *x += *count;\n\
    \   |                    ^^ no implementation for `char += _`\n   |\n   = help:\
    \ the trait `AddAssign<_>` is not implemented for `char`\n\nerror[E0368]: binary\
    \ assignment operation `-=` cannot be applied to type `Vec<char>`\n  --> /tmp/tmp9h76rdch.rs:35:9\n\
    \   |\n35 |         letters_repeated_count -= 1;\n   |         ----------------------^^^^^\n\
    \   |         |\n   |         cannot use `-=` on type `Vec<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9h76rdch.rs:37:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n37 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ char>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0368, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    let mut letters_count_max\
    \ = 0;\n    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n\
    \    let mut letters_count_product = 1;\n    let mut letters_count_product2 =\
    \ 0;\n    let mut letters_count_product3 = 0;\n    let mut letters_count_product4\
    \ = 0;\n    let mut letters_count_product5 = 0;\n    let mut letters_count_product6\
    \ = 0;\n    let mut letters_count_product7 = 0;\n    let mut letters_count_product8\
    \ = 0;\n    let mut letters_count_product9 = 0;\n    let mut letters_count_product10\
    \ = 0;\n    let mut letters_count_product11 = 0;\n    let mut letters_count_product12\
    \ = 0;\n    let mut letters_count_product13 = 0;\n    let mut letters_count_product14\
    \ = 0;\n    let mut letters_count_product15 = 0;\n    let mut letters_count_product16\
    \ = 0;\n    let mut letters_count_product17 = 0;\n    let mut letters_count_product18\
    \ = 0;\n    let mut letters_count_product19 = 0;\n    let mut letters_count_product20\
    \ = 0;\n    let mut letters_count_product21 = 0;\n    let mut letters_count_product22\
    \ = 0;\n    let mut letters_count_product23 = 0;\n    let mut letters_count_product24\
    \ = 0;\n    let mut letters_count_product25 = 0;\n    let mut letters_count_product26\
    \ = 0;\n    let mut letters_count_product27 = 0;\n    let mut letters_count_product28\
    \ = 0;\n    let mut letters_count_product29 = 0;\n    let mut letters_count_product30\
    \ = 0;\n    let mut letters_count_product31 = 0;\n    let mut letters_count_product32\
    \ = 0;\n    let mut letters_count_product33 = 0;\n    let mut letters_count_product34\
    \ = 0;\n    let mut letters_count_product35 = 0;\n    let mut letters_count_product36\
    \ = 0;\n    let mut letters_count_product37 = 0;\n    let mut letters_count_product38\
    \ = 0;\n    let mut letters_count_product39 = 0;\n    let mut letters_count_product40\
    \ = 0;\n    let mut letters_count_product41 = 0;\n    let mut letters_count_product42\
    \ = 0;\n    let mut letters_count_product43 = 0;\n    let mut letters_count_product44\
    \ = 0;\n    let mut letters_count_product\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpof4uddy3.rs:68:34\n   |\n\
    68 |     let mut letters_count_product\n   |                                 \
    \ ^ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpof4uddy3.rs:17:31\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().filter(|&c| !c.is_ascii()).count();\n\
    \        histogram.insert(String::from(word), count);\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp0r1smc4l.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect::<Vec<_>>();\n\
    \    while let Some(letter) = letters.iter().next() {\n        histogram.entry(letter).and_modify(|count|\
    \ {\n            count += 1;\n            letters_count.remove(&letter);\n   \
    \         letters_count.push(count);\n        });\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoqckub7i.rs:22:25\n   |\n\
    22 |         histogram.entry(letter).and_modify(|count| {\n   |              \
    \           ^^^^^^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n22 |         histogram.entry(*letter).and_modify(|count| {\n\
    \   |                         +\n\nerror[E0368]: binary assignment operation `+=`\
    \ cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpoqckub7i.rs:23:13\n\
    \   |\n23 |             count += 1;\n   |             -----^^^^^\n   |       \
    \      |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\nhelp:\
    \ `+=` can be used on `{integer}`, you can dereference `count`\n   |\n23 |   \
    \          *count += 1;\n   |             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpoqckub7i.rs:24:34\n   |\n24 |             letters_count.remove(&letter);\n\
    \   |                                  ^^^^^^^ expected `usize`, found `&&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoqckub7i.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0368.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.clone(), histogram.get(&letters).unwrap().clone()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `HashMap<Vec<String>, V>`\n \
    \ --> /tmp/tmp403malo8.rs:22:53\n   |\n18 |     let mut histogram = HashMap::new();\n\
    \   |         ------------- consider giving `histogram` the explicit type `HashMap<Vec<_>,\
    \ V>`, where the type parameter `V` is specified\n...\n22 |         histogram.insert(letters.clone(),\
    \ histogram.get(&letters).unwrap().clone() + 1);\n   |                       \
    \                              ^^^ cannot infer type for type parameter `V`\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_count = letters.iter().cloned().map(|c|\
    \ histogram.entry(c).or_insert(0));\n    let mut letters_count_iter = letters_count.iter();\n\
    \    loop {\n        let letter = letters_count_iter.next().unwrap().0;\n    \
    \    let count = letters_count_iter.next().unwrap().1;\n        histogram.insert(letter,\
    \ count + 1);\n        if letters_count_iter.next().is_none() {\n            break;\n\
    \        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmp46qxvwao.rs:21:48\n   |\n21 |     let mut letters_count_iter\
    \ = letters_count.iter();\n   |                                              \
    \  ^^^^ private field, not a method\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_lowercase()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `ToLowercase: Eq` is not satisfied\n   -->\
    \ /tmp/tmprngdviv1.rs:22:37\n    |\n22  |         let count = histogram.entry(letter).or_insert(0);\n\
    \    |                               ----- ^^^^^^ the trait `Eq` is not implemented\
    \ for `ToLowercase`\n    |                               |\n    |            \
    \                   required by a bound introduced by this call\n    |\n    =\
    \ help: the trait `Eq` is implemented for `Vec<T, A>`\n    = note: required because\
    \ of the requirements on the impl of `Eq` for `Vec<ToLowercase>`\nnote: required\
    \ by a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0277]: the trait bound `ToLowercase:\
    \ Hash` is not satisfied\n   --> /tmp/tmprngdviv1.rs:22:37\n    |\n22  |     \
    \    let count = histogram.entry(letter).or_insert(0);\n    |                \
    \               ----- ^^^^^^ the trait `Hash` is not implemented for `ToLowercase`\n\
    \    |                               |\n    |                               required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Hash` is implemented\
    \ for `Vec<T, A>`\n    = note: required because of the requirements on the impl\
    \ of `Hash` for `Vec<ToLowercase>`\nnote: required by a bound in `HashMap::<K,\
    \ V, S>::entry`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprngdviv1.rs:25:5\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |     \
    \                          ---------------------- expected `HashMap<String, isize>`\
    \ because of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<ToLowercase>, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    while let Some(letter)\
    \ = words.next() {\n        if histogram.contains_key(&letter) {\n           \
    \ histogram.entry(&letter).or_insert(count).cloned() as isize\n        } else\
    \ {\n            histogram.insert(letter, count);\n        }\n        count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmpo7e3647p.rs:24:55\n\
    \   |\n24 |             histogram.entry(&letter).or_insert(count).cloned() as\
    \ isize\n   |                                                       ^^^^^^ `&mut\
    \ {integer}` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `{integer}: Iterator`\n           which is required\
    \ by `&mut {integer}: Iterator`\n           `&mut {integer}: Iterator`\n     \
    \      which is required by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo7e3647p.rs:26:30\n   |\n26 |             histogram.insert(letter,\
    \ count);\n   |                              ^^^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo7e3647p.rs:30:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n30 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&&str, {integer}>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.next().unwrap();\n    while let Some(letter) = letters\
    \ {\n        let count = histogram.entry(letter).or_insert(0);\n        *count\
    \ += 1;\n        letters = words.next().unwrap();\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_r5o5zya.rs:21:15\n   |\n\
    21 |     while let Some(letter) = letters {\n   |               ^^^^^^^^^^^^ \
    \  ------- this expression has type `&str`\n   |               |\n   |       \
    \        expected `str`, found enum `Option`\n   |\n   = note: expected type `str`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_r5o5zya.rs:26:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        if histogram.contains_key(&word) {\n       \
    \     histogram.entry(word).and_modify(|count| {\n                *count += 1;\n\
    \            });\n        } else {\n            histogram.insert(word, 1);\n \
    \       }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuvfyfjte.rs:29:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      histogram.entry(c.to_string()).or_insert(0);\n        histogram.entry(c.to_string()).or_insert(0);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 0, \" \": 0, \"b\": 0}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmpnmiardno.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_lowercase()).collect::<Vec<_>>();\n\
    \        for letter in letters {\n            histogram.entry(letter).or_insert(0)\
    \ += 1;\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `ToLowercase: Eq` is not satisfied\n   -->\
    \ /tmp/tmphu_fp668.rs:23:29\n    |\n23  |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n    |                       ----- ^^^^^^ the trait `Eq` is not implemented\
    \ for `ToLowercase`\n    |                       |\n    |                    \
    \   required by a bound introduced by this call\n    |\nnote: required by a bound\
    \ in `HashMap::<K, V, S>::entry`\n\nerror[E0277]: the trait bound `ToLowercase:\
    \ Hash` is not satisfied\n   --> /tmp/tmphu_fp668.rs:23:29\n    |\n23  |     \
    \        histogram.entry(letter).or_insert(0) += 1;\n    |                   \
    \    ----- ^^^^^^ the trait `Hash` is not implemented for `ToLowercase`\n    |\
    \                       |\n    |                       required by a bound introduced\
    \ by this call\n    |\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ {integer}`\n  --> /tmp/tmphu_fp668.rs:23:13\n   |\n23 |             histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |             ------------------------------------^^^^^\n   |    \
    \         |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(letter).or_insert(0) += 1;\n   |    \
    \         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphu_fp668.rs:23:50\n\
    \   |\n23 |             histogram.entry(letter).or_insert(0) += 1;\n   |     \
    \        ------------------------------------ ^^\n   |             |\n   |   \
    \          cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphu_fp668.rs:26:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n26 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found struct `ToLowercase`\n   |\n\
    \   = note: expected struct `HashMap<String, isize>`\n              f"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          *count += 1;\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0594]: cannot assign to `*count`, which is behind a `&` reference\n\
    \  --> /tmp/tmp82dvg67m.rs:21:13\n   |\n20 |         if let Some(count) = histogram.get(&letter)\
    \ {\n   |                     ----- help: consider changing this to be a mutable\
    \ reference: `&mut isize`\n21 |             *count += 1;\n   |             ^^^^^^^^^^^\
    \ `count` is a `&` reference, so the data it refers to cannot be written\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0594`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    for word in\
    \ words {\n        if let Ok(letter) = word.chars().next().unwrap() {\n      \
    \      letters.push_str(&letter);\n            histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \            count += 1;\n        }\n    }\n    histogram.entry(letters.clone()).or_insert(count).cloned().unwrap()\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7mblj2_n.rs:23:16\n   |\n\
    23 |         if let Ok(letter) = word.chars().next().unwrap() {\n   |        \
    \        ^^^^^^^^^^   ---------------------------- this expression has type `char`\n\
    \   |                |\n   |                expected `char`, found enum `Result`\n\
    \   |\n   = note: expected type `char`\n              found enum `Result<_, _>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp7mblj2_n.rs:23:19\n   |\n23 |         if let Ok(letter)\
    \ = word.chars().next().unwrap() {\n   |                   ^^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = note: all local variables must have a statically known size\n\
    \   = help: unsized locals are gated as an unstable feature\n\nerror[E0277]: the\
    \ size for values of type `str` cannot be known at compilation time\n   --> /tmp/tmp7mblj2_n.rs:23:16\n\
    \    |\n23  |         if let Ok(letter) = word.chars().next().unwrap() {\n   \
    \ |                ^^^^^^^^^^ doesn't have a size known at compile-time\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Ok`\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmp7mblj2_n.rs:25:29\n    |\n25  |  \
    \           histogram.entry(letter).or_insert(count).cloned().unwrap();\n    |\
    \                       ----- ^^^^^^ doesn't have a size known at compile-time\n\
    \    |                       |\n    |                       required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `HashMap::<K, V, S>::entry`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp7mblj2_n.rs:18:25\n    |\n18  |     let mut histogram = HashMap::new();\n\
    \    |                         ^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.collect::<Vec<_>>();\n    let mut letters_count =\
    \ letters.iter().cloned().map(|letter| histogram.entry(letter).or_insert(0));\n\
    \    letters_count.for_each(|(letter, count)| {\n        histogram.entry(letter).and_modify(|count|\
    \ {\n            *count += 1;\n        });\n    });\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwidsh7hs.rs:22:29\n   |\n\
    22 |     letters_count.for_each(|(letter, count)| {\n   |                    \
    \         ^^^^^^^^^^^^^^-\n   |                             |             |\n\
    \   |                             |             expected due to this\n   |   \
    \                          expected integer, found tuple\n   |\n   = note: expected\
    \ type `{integer}`\n             found tuple `(_, _)`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwidsh7hs.rs:27:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n27 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&str, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpcupkzx1f.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmpcupkzx1f.rs:22:13\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ----------------------------------^^^^^\n   |             |\n   |     \
    \        cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(word).or_insert(0)`\n \
    \  |\n22 |             *histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcupkzx1f.rs:22:48\n\
    \   |\n22 |             histogram.entry(word).or_insert(0) += 1;\n   |       \
    \      ---------------------------------- ^^\n   |             |\n   |       \
    \      cannot assign to this expression\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n\n    while letters_count\
    \ > 0 {\n        let mut letter_count = letters_repeated_count.clone();\n    \
    \    let mut letter = letters_repeated.clone();\n        let mut letter_index\
    \ = letters.len();\n\n        while letter_count > 0 {\n            histogram.insert(\n\
    \                String::from(letter),\n                histogram.entry(String::from(letter))\n\
    \                    .or_insert(histogram.len()),\n            );\n          \
    \  histogram.entry(String::from(letter)).or_insert(0);\n            letter_count\
    \ -= 1;\n            letter += 1;\n            letter_index += 1;\n        }\n\
    \n        letters_count -= 1;\n        letters_repeated_count -= 1;\n        letters_repeated_count\
    \ += letters[letter_index..].len();\n        letters_repeated = letters[letter_index..];\n\
    \    }\n\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n  \
    \  assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7cqp37rn.rs:29:30\n   |\n\
    29 |         while letter_count > 0 {\n   |                              ^ expected\
    \ struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<char>`\n\
    \                found type `{integer}`\n\nerror[E0277]: the trait bound `String:\
    \ From<Vec<char>>` is not satisfied\n  --> /tmp/tmp7cqp37rn.rs:31:17\n   |\n31\
    \ |                 String::from(letter),\n   |                 ^^^^^^^^^^^^ the\
    \ trait `From<Vec<char>>` is not implemented for `String`\n   |\n   = help: the\
    \ following other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the trait bound\
    \ `String: From<Vec<char>>` is not satisfied\n  --> /tmp/tmp7cqp37rn.rs:32:33\n\
    \   |\n32 |                 histogram.entry(String::from(letter))\n   |      \
    \                           ^^^^^^^^^^^^ the trait `From<Vec<char>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7cqp37rn.rs:32:17\n   |\n32 |\
    \ /                 histogram.entry(String::from(letter))\n33 | |            \
    \         .or_insert(histogram.len()),\n   | |_______________________________________________^\
    \ expected `usize`, found `&mut usize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n32 |                 *histogram.entry(String::from(letter))\n\
    \   |                 +\n\nerror[E0277]: the trait bound `String: From<Vec<char>>`\
    \ is not satisfied\n  --> /tmp/tmp7cqp37rn.rs:35:29\n   |\n35 |             histogram.entry(String::from(letter)).or_insert(0);\n\
    \   |                             ^^^^^^^^^^^^ the trait `Fr"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().count();\n    while let Some(letter)\
    \ = letters.iter().max_by_key(|&letter| letters_count) {\n        histogram.insert(letter,\
    \ letters_count);\n        letters_count -= 1;\n    }\n    histogram\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxodkl_p_.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, usize>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_by_key(|&x| x.to_ascii_lowercase());\n        histogram.insert(String::from(letters.iter().max().unwrap()),\
    \ letters.iter().count());\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpefwd43m3.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    while let Some(letter)\
    \ = words.next() {\n        histogram.entry(letter).or_insert(count).cloned().unwrap();\n\
    \        letters.push_str(&letter);\n        count += 1;\n    }\n    histogram.insert(String::from(\"\
    \"), 1);\n    histogram.insert(String::from(\"a\"), 1);\n    histogram.insert(String::from(\"\
    b\"), 1);\n    histogram.insert(String::from(\"c\"), 1);\n    histogram.insert(String::from(\"\
    d\"), 1);\n    histogram.insert(String::from(\"e\"), 1);\n    histogram.insert(String::from(\"\
    f\"), 1);\n    histogram.insert(String::from(\"g\"), 1);\n    histogram.insert(String::from(\"\
    h\"), 1);\n    histogram.insert(String::from(\"i\"), 1);\n    histogram.insert(String::from(\"\
    j\"), 1);\n    histogram.insert(String::from(\"k\"), 1);\n    histogram.insert(String::from(\"\
    l\"), 1);\n    histogram.insert(String::from(\"m\"), 1);\n    histogram.insert(String::from(\"\
    n\"), 1);\n    histogram.insert(String::from(\"o\"), 1);\n    histogram.insert(String::from(\"\
    p\"), 1);\n    histogram.insert(String::from(\"q\"), 1);\n    histogram.insert(String::from(\"\
    r\"), 1);\n    histogram.insert(String::from(\"s\"), 1);\n    histogram.insert(String::from(\"\
    t\"), 1);\n    histogram.insert(String::from(\"u\"), 1);\n    histogram.insert(String::from(\"\
    v\"), 1);\n    histogram.insert(String::from(\"w\"), 1);\n    histogram.insert(String::from(\"\
    x\"), 1);\n    histogram.insert(String::from(\"y\"), 1);\n    histogram.insert(String::from(\"\
    z\"), 1);\n    histogram.insert(String::from(\"A\"), 1);\n    histogram.insert(String::from(\"\
    B\"), 1);\n    histogram.insert(String::from(\"C\"), 1);\n    histogram.insert(String::from(\"\
    D\"), 1);\n    histogram.insert(String::from(\"E\"), 1);\n    histogram.insert(String::from(\"\
    F\"), 1);\n    histogram.insert(String::from(\"G\"), 1);\n    histogram.insert(String::from(\"\
    H\"), 1);\n    histogram.insert(String::from(\"I\"), 1);\n    histo\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `histo` in this scope\n  --> /tmp/tmpyh2j6rs5.rs:63:5\n\
    \   |\n63 |     histo\n   |     ^^^^^ not found in this scope\n\nerror[E0599]:\
    \ `&mut {integer}` is not an iterator\n  --> /tmp/tmpyh2j6rs5.rs:23:50\n   |\n\
    23 |         histogram.entry(letter).or_insert(count).cloned().unwrap();\n   |\
    \                                                  ^^^^^^ `&mut {integer}` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpyh2j6rs5.rs:27:22\n   |\n27 |     histogram.insert(String::from(\"\"\
    ), 1);\n   |                      ^^^^^^^^^^^^^^^^\n   |                     \
    \ |\n   |                      expected `&str`, found struct `String`\n   |  \
    \                    help: consider borrowing here: `&String::from(\"\")`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpyh2j6rs5.rs:28:22\n   |\n28 |  \
    \   histogram.insert(String::from(\"a\"), 1);\n   |                      ^^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&String::from(\"\
    a\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyh2j6rs5.rs:29:22\n   |\n\
    29 |     histogram.insert(String::from(\"b\"), 1);\n   |                     \
    \ ^^^^^^^^^^^^^^^^^\n   |                      |\n   |                      expected\
    \ `&str`, found struct `String`\n   |                      help: consider borrowing\
    \ here: `&String::from(\"b\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyh2j6rs5.rs:30:22\n\
    \   |\n30 |     histogram.insert(String::from(\"c\"), 1);\n   |              \
    \        ^^^^^^^^^^^^^^^^^\n   |                      |\n   |                \
    \      expected `&str`, found struct `String`\n   |                      help:\
    \ consider borrowing here: `&String::from(\"c\")`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyh2j6rs5.rs:31"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    while letters_count_index != letters_count\
    \ {\n        let letter = &letters[letters_count_index];\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n        letters_count_index\
    \ += 1;\n        if letters_count_index == letters_count {\n            letters_count_index\
    \ = 0;\n            letters_count_max += 1;\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp84knwt7z.rs:26:13\n   |\n26 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n26 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp84knwt7z.rs:26:51\n\
    \   |\n26 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp84knwt7z.rs:28:30\n   |\n28 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^ expected `&char`, found `char`\n\
    \   |\n   = note: expected reference `&&char`\n              found reference `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp84knwt7z.rs:36:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n36 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&&char`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&&char, {integer}>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_set = HashSet::new();\n    let mut letters_counter = HashMap::new();\n\
    \    let mut letters_counter_set = HashSet::new();\n    let mut letters_counter_counter\
    \ = HashMap::new();\n\n    while let Some(letter) = letters.pop() {\n        histogram.insert(letter,\
    \ 0);\n        letters_set.insert(letter);\n        letters_counter.entry(letter).or_insert(0);\n\
    \        letters_counter_set.entry(letter).or_insert(0);\n        letters_counter_counter.entry(letter).or_insert(0);\n\
    \    }\n\n    for letter in letters {\n        histogram.entry(letter).or_insert(0);\n\
    \        letters_counter.entry(letter).or_insert(0);\n        letters_counter_set.entry(letter).or_insert(0);\n\
    \        letters_counter_counter.entry(letter).or_insert(0);\n    }\n\n    for\
    \ letter in letters_set {\n        let mut letter_counter = letters_counter.get(&letter).unwrap();\n\
    \        let mut letter_counter_counter = letters_counter_counter.get(&letter).unwrap();\n\
    \        let mut letter_counter_set = letters_counter_set.get(&letter).unwrap();\n\
    \        let mut letter_counter_counter_set = letters_counter_counter_set.get(&letter).unwrap();\n\
    \n        for _ in 0..letter_counter {\n            letter_counter_counter++;\n\
    \        }\n\n        for _ in 0..letter_counter_counter {\n            letter_counter_set++;\n\
    \        }\n\n        for _ in 0..letter_counter_counter_set {\n            letter_counter_counter_set++;\n\
    \        }\n\n        histogram.entry(letter).or_insert(letter_counter + letter_counter_counter\
    \ + letter_counter_counter_set + letter_counter_set);\n    }\n\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpdj4f6fgb.rs:47:35\n\
    \   |\n47 |             letter_counter_counter++;\n   |                      \
    \             ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n47 |             { let tmp = letter_counter_counter; letter_counter_counter\
    \ += 1; tmp };\n   |             +++++++++++                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    47 -             letter_counter_counter++;\n47 +             letter_counter_counter\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpdj4f6fgb.rs:51:31\n\
    \   |\n51 |             letter_counter_set++;\n   |                          \
    \     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n\
    51 |             { let tmp = letter_counter_set; letter_counter_set += 1; tmp\
    \ };\n   |             +++++++++++                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    51 -             letter_counter_set++;\n51 +             letter_counter_set +=\
    \ 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpdj4f6fgb.rs:55:39\n\
    \   |\n55 |             letter_counter_counter_set++;\n   |                  \
    \                     ^^ not a valid postfix operator\n   |\nhelp: use `+= 1`\
    \ instead\n   |\n55 |             { let tmp = letter_counter_counter_set; letter_counter_counter_set\
    \ += 1; tmp };\n   |             +++++++++++                           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    55 -             letter_counter_counter_set++;\n55 +             letter_counter_counter_set\
    \ += 1;\n   | \n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpdj4f6fgb.rs:20:27\n   |\n20 |     let mut letters_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpdj4f6fgb.rs:22:35\n\
    \   |\n22 |     let mut letters_counter_set = HashSet::new();\n   |          \
    \                         ^^^^^^^ not found in this scope\n  "
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_set = HashSet::new();\n    let mut letters_count = HashMap::new();\n\
    \    let mut letters_count_max = HashMap::new();\n\n    while let Some(letter)\
    \ = letters.iter().next() {\n        if !letters_set.contains(letter) {\n    \
    \        letters_set.insert(letter);\n            letters_count.insert(letter,\
    \ 0);\n            letters_count_max.insert(letter, 0);\n        }\n        letters_count.entry(letter).or_insert(0)\
    \ += 1;\n        if letters_count.entry(letter).or_insert(0) >= letters_count_max.entry(letter).or_insert(0)\
    \ {\n            letters_count_max.entry(letter).or_insert(0) = letters_count.entry(letter).or_insert(0);\n\
    \        }\n    }\n\n    for letter in letters_count_max.keys() {\n        histogram.insert(String::from(letter),\
    \ letters_count_max.entry(letter).or_insert(0));\n    }\n\n    histogram\n}\n\n\
    fn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp780b7xdu.rs:20:27\n   |\n20 |     let mut letters_set = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp780b7xdu.rs:30:9\n   |\n30 |         letters_count.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letters_count.entry(letter).or_insert(0)`\n\
    \   |\n30 |         *letters_count.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp780b7xdu.rs:30:50\n\
    \   |\n30 |         letters_count.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0070]: invalid left-hand side of\
    \ assignment\n  --> /tmp/tmp780b7xdu.rs:32:58\n   |\n32 |             letters_count_max.entry(letter).or_insert(0)\
    \ = letters_count.entry(letter).or_insert(0);\n   |             --------------------------------------------\
    \ ^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: the trait bound `String: From<&&char>` is not satisfied\n  --> /tmp/tmp780b7xdu.rs:37:26\n\
    \   |\n37 |         histogram.insert(String::from(letter), letters_count_max.entry(letter).or_insert(0));\n\
    \   |                          ^^^^^^^^^^^^ the trait `From<&&char>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> "
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgkioibhw.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:23:37\n\
    \   |\n23 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:25:37\n\
    \   |\n25 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:27:37\n\
    \   |\n27 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        if histogram.contains_key(&word)\
    \ {\n            histogram.entry(word).and_modify(|count| count += 1);\n     \
    \   } else {\n            histogram.insert(word, 1);\n        }\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmphdgyrjbj.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut _`\n  --> /tmp/tmphdgyrjbj.rs:22:54\n \
    \  |\n22 |             histogram.entry(word).and_modify(|count| count += 1);\n\
    \   |                                                      -----^^^^^\n   |  \
    \                                                    |\n   |                 \
    \                                     cannot use `+=` on type `&mut _`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0599.\nFor more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = words.next().unwrap();\n    let mut count = 1;\n    while\
    \ let Some(letter) = letters {\n        histogram.entry(letter).and_modify(|count|\
    \ {\n            *count += 1;\n        });\n        letters = words.next().unwrap();\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwwz_wrdg.rs:22:15\n   |\n\
    22 |     while let Some(letter) = letters {\n   |               ^^^^^^^^^^^^ \
    \  ------- this expression has type `&str`\n   |               |\n   |       \
    \        expected `str`, found enum `Option`\n   |\n   = note: expected type `str`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwwz_wrdg.rs:28:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found reference\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&_,\
    \ _>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut letters_count = String::new();\n\
    \    let mut letters_count_mut : &mut isize = &mut 0;\n    let mut letters_count_mut_2\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_3 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_4 : &mut isize = &mut 0;\n    let mut letters_count_mut_5\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_6 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_7 : &mut isize = &mut 0;\n    let mut letters_count_mut_8\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_9 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_10 : &mut isize = &mut 0;\n    let mut letters_count_mut_11\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_12 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_13 : &mut isize = &mut 0;\n    let mut letters_count_mut_14\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_15 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_16 : &mut isize = &mut 0;\n    let mut letters_count_mut_17\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_18 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_19 : &mut isize = &mut 0;\n    let mut letters_count_mut_20\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_21 : &mut isize = &mut\
    \ 0;\n    let mut letters_count_mut_22 : &mut isize = &mut 0;\n    let mut letters_count_mut_23\
    \ : &mut isize = &mut 0;\n    let mut letters_count_mut_24 : &mut i\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp99uxmxxq.rs:45:42\n   |\n\
    45 |     let mut letters_count_mut_24 : &mut i\n   |                         \
    \                 ^ help: add `;` here\n46 | }\n   | - unexpected token\n\nerror[E0412]:\
    \ cannot find type `i` in this scope\n  --> /tmp/tmp99uxmxxq.rs:45:41\n   |\n\
    45 |     let mut letters_count_mut_24 : &mut i\n   |                         \
    \                ^ help: a builtin type with a similar name exists: `i8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp99uxmxxq.rs:17:31\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_unstable();\n        let mut count = 1;\n        for letter\
    \ in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmprfv7d1hv.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: `&mut {integer}` is not\
    \ an iterator\n  --> /tmp/tmprfv7d1hv.rs:25:54\n   |\n25 |             histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n   |                                                      ^^^^^^ `&mut\
    \ {integer}` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `{integer}: Iterator`\n           which is required\
    \ by `&mut {integer}: Iterator`\n           `&mut {integer}: Iterator`\n     \
    \      which is required by `&mut &mut {integer}: Iterator`\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmprfv7d1hv.rs:25:63\n   |\n25 |  \
    \           histogram.entry(letter).or_insert(count).cloned() += 1;\n   |    \
    \         ------------------------------------------------- ^^\n   |         \
    \    |\n   |             cannot assign to this expression\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0067, E0599.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 1;\n    while let Some(letter) = letters_iter.next()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|x|\
    \ *x += count);\n        } else {\n            histogram.insert(letter, count);\n\
    \        }\n        count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_du4qwi.rs:27:30\n   |\n\
    27 |             histogram.insert(letter, count);\n   |                      \
    \        ^^^^^^ expected `&char`, found `char`\n   |\n   = note: expected reference\
    \ `&&char`\n              found reference `&char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo_du4qwi.rs:31:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n31 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&&char`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&&char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let count = histogram.entry(word).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpbymiypx7.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    while let Some(letter)\
    \ = words.next() {\n        if histogram.contains_key(&letter) {\n           \
    \ histogram.entry(&letter).or_insert(count).cloned() as isize\n        } else\
    \ {\n            histogram.insert(letter, count);\n            letters.push_str(&letter);\n\
    \            count += 1;\n        }\n    }\n    histogram.insert(letters.clone(),\
    \ count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmpesb0xn2g.rs:24:55\n\
    \   |\n24 |             histogram.entry(&letter).or_insert(count).cloned() as\
    \ isize\n   |                                                       ^^^^^^ `&mut\
    \ {integer}` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `{integer}: Iterator`\n           which is required\
    \ by `&mut {integer}: Iterator`\n           `&mut {integer}: Iterator`\n     \
    \      which is required by `&mut &mut {integer}: Iterator`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpesb0xn2g.rs:26:30\n   |\n26 |             histogram.insert(letter,\
    \ count);\n   |                              ^^^^^^ expected `&str`, found `str`\n\
    \   |\n   = note: expected reference `&&str`\n              found reference `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpesb0xn2g.rs:31:22\n   |\n31 |\
    \     histogram.insert(letters.clone(), count);\n   |                      ^^^^^^^^^^^^^^^\
    \ expected `&&str`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpesb0xn2g.rs:32:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n32 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&&str`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&&str,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if let Some(count) = histogram.entry(letter).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmh730o9v.rs:20:16\n   |\n\
    20 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_max\
    \ = letters.clone();\n    let mut letters_repeated_count_min = letters.clone();\n\
    \    let mut letters_repeated_count_max_index = letters.clone();\n    let mut\
    \ letters_repeated_count_min_index = letters.clone();\n    let mut letters_repeated_count_max_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value = letters.clone();\n\
    \    let mut letters_repeated_count_max_value_count = letters.clone();\n    let\
    \ mut letters_repeated_count_min_value_count = letters.clone();\n    let mut letters_repeated_count_max_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_value\
    \ = letters.clone();\n    let mut letters_repeated_count_max_value_count_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_min_value_count_value_count_value_count_value_count\
    \ = letters.clone();\n    let mut letters_repeated_count_\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpzmfy3pyz.rs:49:36\n   |\n\
    49 |     let mut letters_repeated_count_\n   |                               \
    \     ^ help: add `;` here\n50 | }\n   | - unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzmfy3pyz.rs:17:31\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letter = String::from(word);\n     \
    \   let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpiqyt0o0i.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011380
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut letter = String::from(\"\");\n    while let\
    \ Some(letter) = letters.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|x| {\n                *x\
    \ += *count\n            });\n        } else {\n            histogram.insert(letter,\
    \ count);\n        }\n        count += 1;\n        letter = String::from(\"\"\
    );\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n \
    \   assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpnrlqmlgw.rs:22:38\n   |\n22 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n\
    \  --> /tmp/tmpnrlqmlgw.rs:25:23\n   |\n25 |                 *x += *count\n  \
    \ |                       ^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnrlqmlgw.rs:28:30\n\
    \   |\n28 |             histogram.insert(letter, count);\n   |               \
    \               ^^^^^^\n   |                              |\n   |            \
    \                  cyclic type of infinite size\n   |                        \
    \      help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnrlqmlgw.rs:33:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n33 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter = String::from(\"\
    \");\n    let mut letter_count = 1;\n    while let Some(letter) = letters.next()\
    \ {\n        histogram.entry(letter).or_insert(0) += letter_count;\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n        letter_count += 1;\n    }\n    histogram\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp_2r9k_5q.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp_2r9k_5q.rs:24:9\n   |\n\
    24 |         histogram.entry(letter).or_insert(0) += letter_count;\n   |     \
    \    ------------------------------------^^^^^^^^^^^^^^^^\n   |         |\n  \
    \ |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be\
    \ used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += letter_count;\n \
    \  |         +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp_2r9k_5q.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += letter_count;\n  \
    \ |         ------------------------------------ ^^\n   |         |\n   |    \
    \     cannot assign to this expression\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&mut {integer}`\n  --> /tmp/tmp_2r9k_5q.rs:25:9\n\
    \   |\n25 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ----------------------------------------^^^^^\n   |         |\n   |     \
    \    cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used on\
    \ `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp_2r9k_5q.rs:25:50\n\
    \   |\n25 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0067, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          histogram.insert(letter, count + 1);\n        } else {\n          \
    \  histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpox1oi60g.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_set = HashSet::new();\n    let mut letters_count = HashMap::new();\n\
    \    let mut letters_count_max = HashMap::new();\n    let mut letters_count_min\
    \ = HashMap::new();\n    let mut letters_count_max_index = HashMap::new();\n \
    \   let mut letters_count_min_index = HashMap::new();\n    let mut letters_count_max_value\
    \ = HashMap::new();\n    let mut letters_count_min_value = HashMap::new();\n \
    \   let mut letters_count_max_value_count = HashMap::new();\n    let mut letters_count_min_value_count\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_max = HashMap::new();\n\
    \    let mut letters_count_min_value_count_max = HashMap::new();\n    let mut\
    \ letters_count_max_value_count_min = HashMap::new();\n    let mut letters_count_min_value_count_min\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_max_index = HashMap::new();\n\
    \    let mut letters_count_min_value_count_max_index = HashMap::new();\n    let\
    \ mut letters_count_max_value_count_min_index = HashMap::new();\n    let mut letters_count_min_value_count_min_index\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_max_value = HashMap::new();\n\
    \    let mut letters_count_min_value_count_max_value = HashMap::new();\n    let\
    \ mut letters_count_max_value_count_min_value = HashMap::new();\n    let mut letters_count_min_value_count_min_value\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_max_value_count\
    \ = HashMap::new();\n    let mut letters_count_min_value_count_max_value_count\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_min_value_count\
    \ = HashMap::new();\n    let mut letters_count_min_value_count_min_value_count\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_max_value_count_max\
    \ = HashMap::new();\n    let mut letters_count_min_value_count_max_value_count_max\
    \ = HashMap::new();\n    let mut letters_count_max_value_count_min_value_count_max\
    \ = HashMap::new();\n    let mut letters_count_min_value_count_min_value_count_max\
    \ = HashMap::new();\n    let \n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpghb8qo_i.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpghb8qo_i.rs:20:27\n   |\n20 |     let\
    \ mut letters_set = HashSet::new();\n   |                           ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = 0;\n    let mut letters_repeated_count_index2 = 0;\n    let mut letters_repeated_count_index3\
    \ = 0;\n    let mut letters_repeated_count_index4 = 0;\n    let mut letters_repeated_count_index5\
    \ = 0;\n    let mut letters_repeated_count_index6 = 0;\n    let mut letters_repeated_count_index7\
    \ = 0;\n    let mut letters_repeated_count_index8 = 0;\n    let mut letters_repeated_count_index9\
    \ = 0;\n    let mut letters_repeated_count_index10 = 0;\n    let mut letters_repeated_count_index11\
    \ = 0;\n    let mut letters_repeated_count_index12 = 0;\n    let mut letters_repeated_count_index13\
    \ = 0;\n    let mut letters_repeated_count_index14 = 0;\n    let mut letters_repeated_count_index15\
    \ = 0;\n    let mut letters_repeated_count_index16 = 0;\n    let mut letters_repeated_count_index17\
    \ = 0;\n    let mut letters_repeated_count_index18 = 0;\n    let mut letters_repeated_count_index19\
    \ = 0;\n    let mut letters_repeated_count_index20 = 0;\n    let mut letters_repeated_count_index21\
    \ = 0;\n    let mut letters_repeated_count_index22 = 0;\n    let mut letters_repeated_count_index23\
    \ = 0;\n    let mut letters_repeated_count_index24 = 0;\n    let mut letters_repeated_count_index25\
    \ = 0;\n    let mut letters_repeated_count_index26 = 0;\n    let mut letters_repeated_count_index27\
    \ = 0;\n    let mut letters_repeated_count_index28 = 0;\n    let mut letters_repeated_count_index29\
    \ = 0;\n    let mut letters_repeated_count_index30 = 0;\n    let mut letters_repeated_count_index31\
    \ = 0;\n    let mut letters_repeated_count_index32 = 0;\n    let mut letters_repeated_count_index33\
    \ = 0;\n    let mut letters_repeated_count_index34 = 0;\n    let mut letters_repeated_count_index35\
    \ = 0;\n    let mut letters_repeated_count_index36 = 0;\n    let mut letters_repeated_count_index37\
    \ = 0;\n    let mut letters_repeated_count_index38 = 0;\n}\n\nfn main() {\n  \
    \  let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\"\
    )), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n  \
    \  assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2vklk0x2.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_repeated = letters.clone();\n\
    \    let mut letters_repeated_count = letters.clone();\n    let mut letters_repeated_count_index\
    \ = letters.clone();\n    let mut letters_repeated_count_index2 = letters.clone();\n\
    \    let mut letters_repeated_count_index3 = letters.clone();\n    let mut letters_repeated_count_index4\
    \ = letters.clone();\n    let mut letters_repeated_count_index5 = letters.clone();\n\
    \    let mut letters_repeated_count_index6 = letters.clone();\n    let mut letters_repeated_count_index7\
    \ = letters.clone();\n    let mut letters_repeated_count_index8 = letters.clone();\n\
    \    let mut letters_repeated_count_index9 = letters.clone();\n    let mut letters_repeated_count_index10\
    \ = letters.clone();\n    let mut letters_repeated_count_index11 = letters.clone();\n\
    \    let mut letters_repeated_count_index12 = letters.clone();\n    let mut letters_repeated_count_index13\
    \ = letters.clone();\n    let mut letters_repeated_count_index14 = letters.clone();\n\
    \    let mut letters_repeated_count_index15 = letters.clone();\n    let mut letters_repeated_count_index16\
    \ = letters.clone();\n    let mut letters_repeated_count_index17 = letters.clone();\n\
    \    let mut letters_repeated_count_index18 = letters.clone();\n    let mut letters_repeated_count_index19\
    \ = letters.clone();\n    let mut letters_repeated_count_index20 = letters.clone();\n\
    \    let mut letters_repeated_count_index21 = letters.clone();\n    let mut letters_repeated_count_index22\
    \ = letters.clone();\n    let mut letters_repeated_count_index23 = letters.clone();\n\
    \    let mut letters_repeated_count_index24 = letters.clone();\n    let mut letters_repeated_count_index25\
    \ = letters.clone();\n    let mut letters_repeated_count_index26 = letters.clone();\n\
    \    let mut letters_repeated_count_index27 = letters.clone();\n    let mut letters_repeated_count_index28\
    \ = letters.clone();\n    let mut letters_repeated_count_index29 = letters.clone();\n\
    \    let mut letters_repeated_count_index30 = letters.clone();\n    let mut letters_repeated_count_index31\
    \ = letters.\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpytza_mo8.rs:54:1\n   |\n54\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpytza_mo8.rs:53:54\n\
    \   |\n53 |     let mut letters_repeated_count_index31 = letters.\n   |      \
    \                                                ^ help: add `;` here\n54 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpytza_mo8.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoymluw35.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_iter =\
    \ letters_count.iter();\n    let mut letters_count_iter_next = letters_count_iter.next();\n\
    \    while let Some(letter) = letters_iter_next() {\n        histogram.entry(letter).or_default()\
    \ += 1;\n        letters_count_iter_next = letters_count_iter.next();\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `letters_iter_next` in this scope\n\
    \  --> /tmp/tmp0k1_mcq_.rs:24:30\n   |\n24 |     while let Some(letter) = letters_iter_next()\
    \ {\n   |                              ^^^^^^^^^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `letters_iter`\n\nerror[E0599]: no method named\
    \ `iter` found for type `usize` in the current scope\n  --> /tmp/tmp0k1_mcq_.rs:22:48\n\
    \   |\n22 |     let mut letters_count_iter = letters_count.iter();\n   |     \
    \                                           ^^^^ method not found in `usize`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&mut\
    \ _`\n  --> /tmp/tmp0k1_mcq_.rs:25:9\n   |\n25 |         histogram.entry(letter).or_default()\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut _`\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmp0k1_mcq_.rs:25:46\n   |\n25 |         histogram.entry(letter).or_default()\
    \ += 1;\n   |         ------------------------------------ ^^\n   |         |\n\
    \   |         cannot assign to this expression\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0067, E0368, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        histogram.entry(letter).or_insert(0) += 1;\n    }\n\
    \    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpcaz1cg7z.rs:20:9\n   |\n20 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n20 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpcaz1cg7z.rs:20:46\n\
    \   |\n20 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc8u35yn.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoymluw35.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \"b\": 2, \" \": 3}`,\n right: `{\"a\": 2, \"b\": 2}`', /tmp/tmp4x1gdp3w.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    while letters_count_index < letters_count {\n        let letter = &letters[letters_count_index];\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n        letters_count_index += 1;\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_fumizih.rs:28:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = vec![];\n    let mut letter = String::from(\"\");\n    let\
    \ mut letter_count = 0;\n    while let Some(letter) = letters.next() {\n     \
    \   if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \        counts.push((letter, histogram.get(&letter).unwrap()));\n        letter_count\
    \ += histogram.get(&letter).unwrap();\n        letter = String::from(\"\");\n\
    \    }\n    histogram.insert(String::from(\"\"), letter_count);\n    histogram.into_iter().map(|(_,\
    \ count)| {\n        let mut letters = count.iter().map(|(_, count)| String::from(\"\
    \")).collect::<Vec<_>>();\n        let mut letter = String::from(\"\");\n    \
    \    let mut letter_count = 0;\n        while let Some(letter) = letters.next()\
    \ {\n            if histogram.contains_key(&letter) {\n                histogram.entry(&letter).or_insert(0)\
    \ += 1;\n            } else {\n                histogram.insert(letter, 1);\n\
    \            }\n            letter_count += histogram.get(&letter).unwrap();\n\
    \            letter = String::from(\"\");\n        }\n        (count, letters)\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmpv05rbqjg.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmpv05rbqjg.rs:25:13\n   |\n\
    25 |             histogram.entry(&letter).or_insert(0) += 1;\n   |           \
    \  -------------------------------------^^^^^\n   |             |\n   |      \
    \       cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n25 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpv05rbqjg.rs:25:51\n\
    \   |\n25 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv05rbqjg.rs:27:30\n   |\n27 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              cyclic type of infinite size\n   |\
    \                              help: consider borrowing here: `&letter`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv05rbqjg.rs:33:22\n   |\n33 |     histogram.insert(String::from(\"\
    \"), letter_count);\n   |                      ^^^^^^^^^^^^^^^^\n   |        \
    \              |\n   |                      expected `&String`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&String::from(\"\"\
    )`\n\nerror[E0599]: no method named `iter` found for type `{integer}` in the current\
    \ scope\n  --> /tmp/tmpv05rbqjg.rs:35:33\n   |\n35 |         let mut letters =\
    \ count.iter().map(|(_, count)| String::from(\"\")).collect::<Vec<_>>();\n   |\
    \                                 ^^^^ method not found in `{integer}`\n\nerror[E0368]:\
    \ binary assignme"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let \n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgkioibhw.rs:65:1\n  \
    \ |\n65 | }\n   | ^ expected pattern\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:23:37\n\
    \   |\n23 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:25:37\n\
    \   |\n25 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0599]: no method named `count`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpgkioibhw.rs:27:37\n\
    \   |\n27 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|count| {\n             \
    \   *count += 1;\n            });\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj7zakghq.rs:25:30\n   |\n\
    25 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&String`, found struct `String`\n   |                      \
    \        help: consider borrowing here: `&letter`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpj7zakghq.rs:28:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&String,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().fold(HashMap::new(), |mut acc, c| {\n        let mut count\
    \ = acc.entry(c.to_string()).or_insert(0);\n        *count += 1;\n        acc\n\
    \    })\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\" \": 3, \"b\": 2, \"a\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpdv6vnehl.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_iter = letters_iter.into_iter();\n\
    \    let mut letters_iter = letters_iter.map(|&c| c.to_string());\n    let mut\
    \ letters_iter = letters_iter.collect::<Vec<_>>();\n    let mut letters_iter =\
    \ letters_iter.into_iter();\n    let mut letters_iter = letters_iter.map(|&c|\
    \ c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let mut letters_iter = letters_iter.collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters_iter.into_iter();\n    let mut letters_iter\
    \ = letters_iter.map(|&c| c.to_string());\n    let \n}\n\nfn main() {\n    let\
    \ candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")),\
    \ HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpvt915qz5.rs:51:1\n  \
    \ |\n51 | }\n   | ^ expected pattern\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpvt915qz5.rs:25:46\n   |\n25 |     let mut letters_iter = letters_iter.map(|&c|\
    \ c.to_string());\n   |                                              ^--\n   |\
    \                                              ||\n   |                      \
    \                        |expected due to this\n   |                         \
    \                     expected struct `String`, found reference\n   |        \
    \                                      help: did you mean `c`: `&String`\n   |\n\
    \   = note: expected struct `String`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_index2 = 0;\n\
    \    let mut letters_count_max2 = 0;\n    let mut letters_count_index3 = 0;\n\
    \    let mut letters_count_max3 = 0;\n    let mut letters_count_index4 = 0;\n\
    \    let mut letters_count_max4 = 0;\n    let mut letters_count_index5 = 0;\n\
    \    let mut letters_count_max5 = 0;\n    let mut letters_count_index6 = 0;\n\
    \    let mut letters_count_max6 = 0;\n    let mut letters_count_index7 = 0;\n\
    \    let mut letters_count_max7 = 0;\n    let mut letters_count_index8 = 0;\n\
    \    let mut letters_count_max8 = 0;\n    let mut letters_count_index9 = 0;\n\
    \    let mut letters_count_max9 = 0;\n    let mut letters_count_index10 = 0;\n\
    \    let mut letters_count_max10 = 0;\n    let mut letters_count_index11 = 0;\n\
    \    let mut letters_count_max11 = 0;\n    let mut letters_count_index12 = 0;\n\
    \    let mut letters_count_max12 = 0;\n    let mut letters_count_index13 = 0;\n\
    \    let mut letters_count_max13 = 0;\n    let mut letters_count_index14 = 0;\n\
    \    let mut letters_count_max14 = 0;\n    let mut letters_count_index15 = 0;\n\
    \    let mut letters_count_max15 = 0;\n    let mut letters_count_index16 = 0;\n\
    \    let mut letters_count_max16 = 0;\n    let mut letters_count_index17 = 0;\n\
    \    let mut letters_count_max17 = 0;\n    let mut letters_count_index18 = 0;\n\
    \    let mut letters_count_max18 = 0;\n    let mut letters_count_index19 = 0;\n\
    \    let mut letters_count_max19 = 0;\n    let mut letters_count_index20 = 0;\n\
    \    let mut letters_count_max20 = 0;\n    let mut letters_count_index21 = 0;\n\
    \    let mut letters_count_max21 = 0;\n    let mut letters_count_index22 = 0;\n\
    \    let mut letters_count_max22 = 0;\n    let mut letters_count_index23 = 0;\n\
    \    let mut letters_count_max23 = 0;\n    let mut letters_count_index24 = 0;\n\
    \    let mut letters_count_max24 = 0;\n    let mut letter\n}\n\nfn main() {\n\
    \    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"a b b\
    \ a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpdnb9jbh9.rs:69:19\n   |\n\
    69 |     let mut letter\n   |                   ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdnb9jbh9.rs:17:31\n\
    \   |\n17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| c.to_string()).collect()\n        .into_iter()\n\
    \        .map(|c| c.to_ascii_lowercase())\n        .collect()\n        .into_iter()\n\
    \        .fold(HashMap::new(), |mut acc, c| {\n            acc.entry(c).or_insert(0)\
    \ += 1;\n            acc\n        })\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpao8ev5aw.rs:18:41\n\
    \   |\n18 |     test.chars().map(|c| c.to_string()).collect()\n   |          \
    \                               ^^^^^^^ cannot infer type for type parameter `B`\
    \ declared on the associated function `collect`\n   |\n   = note: type must be\
    \ known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n18 |     test.chars().map(|c| c.to_string()).collect::<B>()\n  \
    \ |                                                +++++\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpao8ev5aw.rs:24:39\n   |\n24 |  \
    \           acc.entry(c).or_insert(0) += 1;\n   |             -------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0282.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoymluw35.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_index =\
    \ 0;\n    let mut letters_count_max = 0;\n    let mut letters_count_max_index\
    \ = 0;\n    let mut letters_count_max_letter = String::new();\n    while letters_count_index\
    \ != letters_count {\n        let letter = letters[letters_count_index];\n   \
    \     let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \        if *count > letters_count_max {\n            letters_count_max = *count;\n\
    \            letters_count_max_index = letters_count_index;\n            letters_count_max_letter\
    \ = letter;\n        }\n        letters_count_index += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5l62on1p.rs:32:40\n   |\n\
    24 |     let mut letters_count_max_letter = String::new();\n   |             \
    \                           ------------- expected due to this value\n...\n32\
    \ |             letters_count_max_letter = letter;\n   |                     \
    \                   ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp5l62on1p.rs:36:5\n   |\n17 | fn histogram(test: String)\
    \ -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n36 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = 1;\n        for letter in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmphf2__e9j.rs:24:54\n\
    \   |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |                                                      ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0067]: invalid left-hand side of\
    \ assignment\n  --> /tmp/tmphf2__e9j.rs:24:63\n   |\n24 |             histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n   |             ------------------------------------------------- ^^\n\
    \   |             |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphf2__e9j.rs:28:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        let count = histogram.entry(letter).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmp4n5ap_i3.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011380
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).or_insert(0) += 1;\n        } else {\n\
    \            histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmphf3866yb.rs:21:13\n   |\n21 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n21 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmphf3866yb.rs:21:51\n\
    \   |\n21 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphf3866yb.rs:23:30\n   |\n23 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&String`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphf3866yb.rs:26:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<&String, {integer}>`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_iter = letters.iter();\n    let mut letters_count = letters.count();\n\
    \    let mut letters_count_iter = 0;\n    let mut letters_count_iter2 = 0;\n \
    \   let mut letters_count_iter3 = 0;\n    let mut letters_count_iter4 = 0;\n \
    \   let mut letters_count_iter5 = 0;\n    let mut letters_count_iter6 = 0;\n \
    \   let mut letters_count_iter7 = 0;\n    let mut letters_count_iter8 = 0;\n \
    \   let mut letters_count_iter9 = 0;\n    let mut letters_count_iter10 = 0;\n\
    \    let mut letters_count_iter11 = 0;\n    let mut letters_count_iter12 = 0;\n\
    \    let mut letters_count_iter13 = 0;\n    let mut letters_count_iter14 = 0;\n\
    \    let mut letters_count_iter15 = 0;\n    let mut letters_count_iter16 = 0;\n\
    \    let mut letters_count_iter17 = 0;\n    let mut letters_count_iter18 = 0;\n\
    \    let mut letters_count_iter19 = 0;\n    let mut letters_count_iter20 = 0;\n\
    \    let mut letters_count_iter21 = 0;\n    let mut letters_count_iter22 = 0;\n\
    \    let mut letters_count_iter23 = 0;\n    let mut letters_count_iter24 = 0;\n\
    \    let mut letters_count_iter25 = 0;\n    let mut letters_count_iter26 = 0;\n\
    \    let mut letters_count_iter27 = 0;\n    let mut letters_count_iter28 = 0;\n\
    \    let mut letters_count_iter29 = 0;\n    let mut letters_count_iter30 = 0;\n\
    \    let mut letters_count_iter31 = 0;\n    let mut letters_count_iter32 = 0;\n\
    \    let mut letters_count_iter33 = 0;\n    let mut letters_count_iter34 = 0;\n\
    \    let mut letters_count_iter35 = 0;\n    let mut letters_count_iter36 = 0;\n\
    \    let mut letters_count_iter37 = 0;\n    let mut letters_count_iter38 = 0;\n\
    \    let mut letters_count_iter39 = 0;\n    let mut letters_count_iter40 = 0;\n\
    \    let mut letters_count_iter41 = 0;\n    let mut letters_count_iter42 = 0;\n\
    \    let mut letters_count_iter43 = 0;\n    let mut letters_count_iter44 = 0;\n\
    \    let mut letters_count_iter45 = 0;\n    let mut letters_count_iter46 = 0;\n\
    \    let mut letters_count_iter47\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9a4lm2mo.rs:68:33\n   |\n\
    68 |     let mut letters_count_iter47\n   |                                 ^\
    \ help: add `;` here\n69 | }\n   | - unexpected token\n\nerror[E0599]: no method\
    \ named `count` found for struct `Vec<char>` in the current scope\n  --> /tmp/tmp9a4lm2mo.rs:21:37\n\
    \   |\n21 |     let mut letters_count = letters.count();\n   |               \
    \                      ^^^^^\n   |                                     |\n   |\
    \                                     method cannot be called on `Vec<char>` due\
    \ to unsatisfied trait bounds\n   |                                     help:\
    \ consider using `len` instead\n   |\n   = note: `count` is defined on `Iterator`,\
    \ which `Vec<char>` does not implement\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9a4lm2mo.rs:17:31\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |    ---------                  ^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `HashMap`, found `()`\n   |    |\n   |    implicitly returns `()` as\
    \ its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `HashMap<String, isize>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_count = letters.iter().cloned().count();\n\
    \    while letters_count > 0 {\n        let letter = letters.remove(0);\n    \
    \    histogram.insert(letter, letters_count);\n        letters_count -= 1;\n \
    \   }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplytz2kus.rs:26:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n26 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.len();\n    let mut letters_count_max = 0;\n\
    \    let mut letters_count_min = 0;\n    let mut letters_count_sum = 0;\n    let\
    \ mut letters_count_count_max = 0;\n    let mut letters_count_count_min = 0;\n\
    \    let mut letters_count_count_sum = 0;\n    let mut letters_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_min = 0;\n    let mut letters_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_max = 0;\n    let mut letters_count_count_count_count_min\
    \ = 0;\n    let mut letters_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_max = 0;\n   \
    \ let mut letters_count_count_count_count_count_min = 0;\n    let mut letters_count_count_count_count_count_sum\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_max = 0;\n\
    \    let mut letters_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_min = 0;\n   \
    \ let mut letters_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_min = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_sum = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_count_max = 0;\n    let\
    \ mut letters_count_count_count_count_count_count_count_min = 0;\n    let mut\
    \ letters_count_count_count_count_count_count_count_sum = 0;\n    let mut letters_count_count_count_count_count_count_count_count_max\
    \ = 0;\n    let mut letters_count_count_count_count_count_count_count_min = 0;\n\
    \    let mut letters_count_count_count_count_count_count_count_sum = 0;\n\n}\n\
    \nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_olqkifp.rs:17:31\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |    ---------\
    \                  ^^^^^^^^^^^^^^^^^^^^^^ expected struct `HashMap`, found `()`\n\
    \   |    |\n   |    implicitly returns `()` as its body has no tail or `return`\
    \ expression\n   |\n   = note: expected struct `HashMap<String, isize>`\n    \
    \       found unit type `()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0e8bdgxd.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letter_counts = HashMap::new();\n    let mut letter = String::from(\"\
    \");\n    let mut count = 0;\n    while let Some(letter) = letters.next() {\n\
    \        histogram.entry(letter).or_insert(0) += 1;\n        letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n        if letter_counts.entry(letter).or_insert(0) >= count {\n    \
    \        letter = String::from(\"\");\n            count = 0;\n        }\n   \
    \     letter += String::from(\" \");\n        count += 1;\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for struct `Vec<char>` in the\
    \ current scope\n  --> /tmp/tmp35olf7nr.rs:23:38\n   |\n23 |     while let Some(letter)\
    \ = letters.next() {\n   |                                      ^^^^ method not\
    \ found in `Vec<char>`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&mut {integer}`\n  --> /tmp/tmp35olf7nr.rs:24:9\n   |\n\
    24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n24 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp35olf7nr.rs:24:46\n\
    \   |\n24 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut {integer}`\n\
    \  --> /tmp/tmp35olf7nr.rs:25:9\n   |\n25 |         letter_counts.entry(letter).or_insert(0)\
    \ += 1;\n   |         ----------------------------------------^^^^^\n   |    \
    \     |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=`\
    \ can be used on `{integer}`, you can dereference `letter_counts.entry(letter).or_insert(0)`\n\
    \   |\n25 |         *letter_counts.entry(letter).or_insert(0) += 1;\n   |    \
    \     +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp35olf7nr.rs:25:50\n\
    \   |\n25 |         letter_counts.entry(letter).or_insert(0) += 1;\n   |     \
    \    ---------------------------------------- ^^\n   |         |\n   |       \
    \  cannot assign to this expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp35olf7nr.rs:26:56\n\
    \   |\n26 |         if letter_counts.entry(letter).or_insert(0) >= count {\n \
    \  |                                                        ^^^^^\n   |      \
    \                                                  |\n   |         "
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>() {\n        if let Some(count) = histogram.entry(letter).or_insert(0)\
    \ {\n            *count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmh730o9v.rs:20:16\n   |\n\
    20 |         if let Some(count) = histogram.entry(letter).or_insert(0) {\n   |\
    \                ^^^^^^^^^^^   ------------------------------------ this expression\
    \ has type `&mut {integer}`\n   |                |\n   |                expected\
    \ integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n \
    \             found enum `Option<_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut counts = Vec::new();\n    while let Some(letter) = letters.pop()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).and_modify(|count|\
    \ {\n                *count += 1;\n            });\n        } else {\n       \
    \     histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdx28csl0.rs:27:30\n   |\n\
    27 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdx28csl0.rs:30:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n30 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().map(|c| {\n        let mut count = HashMap::new();\n   \
    \     count.entry(c.to_string()).or_insert(0);\n        count.entry(c.to_string()).or_insert(0);\n\
    \        count\n    }).collect()\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `HashMap<String, isize>` cannot be built\
    \ from an iterator over elements of type `HashMap<String, {integer}>`\n    -->\
    \ /tmp/tmpkjveiss4.rs:23:8\n     |\n23   |     }).collect()\n     |        ^^^^^^^\
    \ value of type `HashMap<String, isize>` cannot be built from `std::iter::Iterator<Item=HashMap<String,\
    \ {integer}>>`\n     |\n     = help: the trait `FromIterator<HashMap<String, {integer}>>`\
    \ is not implemented for `HashMap<String, isize>`\n     = help: the trait `FromIterator<(K,\
    \ V)>` is implemented for `HashMap<K, V, S>`\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = Vec::new();\n    while let Some(letter) = letters.pop()\
    \ {\n        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \        letters_count.push(histogram.get(&letter).unwrap());\n    }\n    histogram\n\
    }\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmpftp0ze_4.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpftp0ze_4.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpftp0ze_4.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpftp0ze_4.rs:29:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n29 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        if let Some(count) = histogram.get(&word) {\n\
    \            histogram.insert(word, count + 1);\n        } else {\n          \
    \  histogram.insert(word, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl5it9btj.rs:27:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n27 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for letter in test.chars().map(|c|\
    \ c.to_string()) {\n        if let Some(count) = histogram.get(&letter) {\n  \
    \          histogram.insert(letter, count + 1);\n        } else {\n          \
    \  histogram.insert(letter, 1);\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"a\": 2, \" \": 3, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpox1oi60g.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = histogram.entry(letters.clone()).or_insert(0);\n    \
    \    *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0e8bdgxd.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<char>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc8u35yn.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().map(|c|\
    \ c.to_string()).collect::<Vec<_>>();\n    let mut letters_iter = letters.iter();\n\
    \    let mut letter_count = 1;\n    let mut letter = String::from(\"\");\n   \
    \ while let Some(letter) = letters_iter.next() {\n        if histogram.contains_key(&letter)\
    \ {\n            histogram.entry(&letter).and_modify(|count| {\n             \
    \   *count += 1;\n            });\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxyxi04ic.rs:29:30\n   |\n\
    29 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^ expected `&String`, found struct `String`\n   |\n   = note: expected\
    \ reference `&&String`\n              found reference `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxyxi04ic.rs:32:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n32 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `&&String`\n   |\n   = note:\
    \ expected struct `HashMap<String, isize>`\n              found struct `HashMap<&&String,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        histogram.insert(letters.iter().max().unwrap().to_string(), histogram.get(letters.iter().max().unwrap()).unwrap()\
    \ + 1);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp02xtvsta.rs:22:114

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011380
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().next().unwrap();\n\
    \        if histogram.contains_key(&letter) {\n            histogram.entry(&letter).or_insert(0)\
    \ += 1;\n        } else {\n            histogram.insert(letter, 1);\n        }\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmplwwdssox.rs:23:13\n   |\n23 |             histogram.entry(&letter).or_insert(0)\
    \ += 1;\n   |             -------------------------------------^^^^^\n   |   \
    \          |\n   |             cannot use `+=` on type `&mut {integer}`\n   |\n\
    help: `+=` can be used on `{integer}`, you can dereference `histogram.entry(&letter).or_insert(0)`\n\
    \   |\n23 |             *histogram.entry(&letter).or_insert(0) += 1;\n   |   \
    \          +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmplwwdssox.rs:23:51\n\
    \   |\n23 |             histogram.entry(&letter).or_insert(0) += 1;\n   |    \
    \         ------------------------------------- ^^\n   |             |\n   | \
    \            cannot assign to this expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmplwwdssox.rs:25:30\n   |\n25 |             histogram.insert(letter,\
    \ 1);\n   |                              ^^^^^^\n   |                        \
    \      |\n   |                              expected `&char`, found `char`\n \
    \  |                              help: consider borrowing here: `&letter`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmplwwdssox.rs:28:5\n   |\n17 | fn\
    \ histogram(test: String) -> HashMap<String, isize> {\n   |                  \
    \             ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&char, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = 1;\n        for letter in letters {\n            histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n            count += 1;\n        }\n    }\n    histogram\n}\n\nfn main()\
    \ {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `&mut {integer}` is not an iterator\n  --> /tmp/tmphf2__e9j.rs:24:54\n\
    \   |\n24 |             histogram.entry(letter).or_insert(count).cloned() += 1;\n\
    \   |                                                      ^^^^^^ `&mut {integer}`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `{integer}: Iterator`\n           which is required by `&mut {integer}:\
    \ Iterator`\n           `&mut {integer}: Iterator`\n           which is required\
    \ by `&mut &mut {integer}: Iterator`\n\nerror[E0067]: invalid left-hand side of\
    \ assignment\n  --> /tmp/tmphf2__e9j.rs:24:63\n   |\n24 |             histogram.entry(letter).or_insert(count).cloned()\
    \ += 1;\n   |             ------------------------------------------------- ^^\n\
    \   |             |\n   |             cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphf2__e9j.rs:28:5\n   |\n17 | fn histogram(test:\
    \ String) -> HashMap<String, isize> {\n   |                               ----------------------\
    \ expected `HashMap<String, isize>` because of return type\n...\n28 |     histogram\n\
    \   |     ^^^^^^^^^ expected struct `String`, found `char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<char, {integer}>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0067, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 101
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letter = String::from(word);\n     \
    \   let count = histogram.entry(letter).or_insert(0);\n        *count += 1;\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `{\"c\": 1, \"a\": 2, \"b\": 2}`,\n right: `{\"b\": 2, \"a\": 2}`', /tmp/tmpiqyt0o0i.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011380
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut count = 1;\n    let mut max_count = 0;\n    while let Some(letter)\
    \ = letters.pop() {\n        if histogram.contains_key(&letter) {\n          \
    \  histogram.entry(&letter).and_modify(|count| {\n                *count += 1;\n\
    \                if *count > max_count {\n                    max_count = *count;\n\
    \                }\n            });\n        } else {\n            histogram.insert(letter,\
    \ 1);\n        }\n    }\n    histogram\n}\n\nfn main() {\n    let candidate =\
    \ histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk07_hw1h.rs:31:30\n   |\n\
    31 |             histogram.insert(letter, 1);\n   |                          \
    \    ^^^^^^\n   |                              |\n   |                       \
    \       expected `&char`, found `char`\n   |                              help:\
    \ consider borrowing here: `&letter`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpk07_hw1h.rs:34:5\n   |\n17 | fn histogram(test: String) -> HashMap<String,\
    \ isize> {\n   |                               ---------------------- expected\
    \ `HashMap<String, isize>` because of return type\n...\n34 |     histogram\n \
    \  |     ^^^^^^^^^ expected struct `String`, found `&char`\n   |\n   = note: expected\
    \ struct `HashMap<String, isize>`\n              found struct `HashMap<&char,\
    \ {integer}>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        let mut count = letters.iter().cloned().count();\n        histogram.insert(word.to_string(),\
    \ count);\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu246mihn.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `HashMap<_, isize>`\n      \
    \        found struct `HashMap<_, usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let count = histogram.entry(word).or_insert(0);\n\
    \        *count += 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate\
    \ = histogram;\n    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpbymiypx7.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    test.chars().group_by(|c| c.to_ascii_lowercase()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp16p0c2jw.rs:18:18\n   |\n18 |     test.chars().group_by(|c|\
    \ c.to_ascii_lowercase()).collect()\n   |                  ^^^^^^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    let mut letters = String::new();\n    let mut count = 1;\n    while let Some(letter)\
    \ = words.next() {\n        histogram.entry(letter).or_insert(0) += 1;\n     \
    \   letters.push_str(letter);\n        count += 1;\n    }\n    histogram.insert(String::from(\"\
    \"), count);\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&mut {integer}`\n  --> /tmp/tmp83591ikp.rs:23:9\n   |\n23 |         histogram.entry(letter).or_insert(0)\
    \ += 1;\n   |         ------------------------------------^^^^^\n   |        \
    \ |\n   |         cannot use `+=` on type `&mut {integer}`\n   |\nhelp: `+=` can\
    \ be used on `{integer}`, you can dereference `histogram.entry(letter).or_insert(0)`\n\
    \   |\n23 |         *histogram.entry(letter).or_insert(0) += 1;\n   |        \
    \ +\n\nerror[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmp83591ikp.rs:23:46\n\
    \   |\n23 |         histogram.entry(letter).or_insert(0) += 1;\n   |         ------------------------------------\
    \ ^^\n   |         |\n   |         cannot assign to this expression\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp83591ikp.rs:27:22\n   |\n27 |     histogram.insert(String::from(\"\
    \"), count);\n   |                      ^^^^^^^^^^^^^^^^\n   |               \
    \       |\n   |                      expected `&str`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&String::from(\"\"\
    )`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83591ikp.rs:28:5\n   |\n17\
    \ | fn histogram(test: String) -> HashMap<String, isize> {\n   |             \
    \                  ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n28 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<&str, {integer}>`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0067, E0308,\
    \ E0368.\nFor more information about an error, try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    while let Some(word) = words.pop() {\n        let mut letters = word.chars().collect::<Vec<_>>();\n\
    \        letters.sort_by_key(|&x| x.to_ascii_lowercase());\n        let mut letter\
    \ = String::from(\"\");\n        let mut count = 0;\n        for &c in letters\
    \ {\n            count += histogram.entry(c).or_insert(0);\n            letter\
    \ += c.to_ascii_lowercase();\n        }\n        histogram.insert(letter, count);\n\
    \    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp28vk_5iq.rs:20:34\n   |\n20 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0277]: cannot add-assign `&mut\
    \ {integer}` to `{integer}`\n  --> /tmp/tmp28vk_5iq.rs:26:19\n   |\n26 |     \
    \        count += histogram.entry(c).or_insert(0);\n   |                   ^^\
    \ no implementation for `{integer} += &mut {integer}`\n   |\n   = help: the trait\
    \ `AddAssign<&mut {integer}>` is not implemented for `{integer}`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    for c in test.chars() {\n  \
    \      let count = histogram.entry(c).or_insert(0);\n        *count += 1;\n  \
    \  }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n    assert_eq!(candidate(String::from(\"\
    a b b a\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)]));\n\
    \    assert_eq!(candidate(String::from(\"a b c a b\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c d g\")), HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1), (String::from(\"d\"), 1), (String::from(\"g\"\
    ), 1)]));\n    assert_eq!(candidate(String::from(\"r t g\")), HashMap::from([(String::from(\"\
    r\"), 1), (String::from(\"t\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    b b b b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptc8u35yn.rs:23:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n23 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `HashMap<String, isize>`\n\
    \              found struct `HashMap<char, {integer}>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut words = test.split_whitespace();\n\
    \    for word in words {\n        let letter = word.chars().map(|c| c.to_string()).collect::<Vec<_>>();\n\
    \        let count = histogram.entry(letter).or_insert(0);\n        *count +=\
    \ 1;\n    }\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkii6_isi.rs:25:5\n   |\n\
    17 | fn histogram(test: String) -> HashMap<String, isize> {\n   |            \
    \                   ---------------------- expected `HashMap<String, isize>` because\
    \ of return type\n...\n25 |     histogram\n   |     ^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `HashMap<String,\
    \ isize>`\n              found struct `HashMap<Vec<String>, {integer}>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011379
- exit_code: 1
  program: "use std::collections::HashMap;\n\n/// Given a string representing a space\
    \ separated lowercase letters, return a dictionary\n/// of the letter with the\
    \ most repetition and containing the corresponding count.\n/// If several letters\
    \ have the same occurrence, return all of them.\n/// Example:\n/// >>> histogram(String::from(\"\
    a b c\"))\n/// HashMap::from([(String::from(\"a\"), 1), (String::from(\"b\"),\
    \ 1), (String::from(\"c\"), 1)])\n/// >>> histogram(String::from(\"a b b a\"))\n\
    /// HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"), 2)])\n/// >>>\
    \ histogram(String::from(\"a b c a b\"))\n/// HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)])\n/// >>> histogram(String::from(\"b b b b\
    \ a\"))\n/// HashMap::from([(String::from(\"b\"), 4)])\n/// >>> histogram(String::from(\"\
    \"))\n/// HashMap::from([])\nfn histogram(test: String) -> HashMap<String, isize>\
    \ {\n    let mut histogram = HashMap::new();\n    let mut letters = test.chars().collect::<Vec<_>>();\n\
    \    let mut letters_count = letters.iter().cloned().map(|c| histogram.entry(c).or_insert(0)).collect::<Vec<_>>();\n\
    \    let mut letters_count_max = letters_count.iter().cloned().max().unwrap();\n\
    \    loop {\n        let mut letters_count_min = letters_count.iter().cloned().min().unwrap();\n\
    \        let mut letters_count_index = letters_count.iter().cloned().enumerate().filter(|(_,\
    \ count)| count > 0).next().unwrap();\n        if letters_count_max.0 > letters_count_min\
    \ {\n            break;\n        }\n        letters_count_max = letters_count_min;\n\
    \        letters_count_min = letters_count_index.1;\n        letters_count_index\
    \ = letters_count.iter().cloned().enumerate().filter(|(_, count)| count > 0).next().unwrap();\n\
    \    }\n    letters_count_max.iter().cloned().for_each(|count| histogram.entry(String::from(&letters[count.0])).and_modify(|count|\
    \ count += 1));\n    histogram\n}\n\nfn main() {\n    let candidate = histogram;\n\
    \    assert_eq!(candidate(String::from(\"a b b a\")), HashMap::from([(String::from(\"\
    a\"), 2), (String::from(\"b\"), 2)]));\n    assert_eq!(candidate(String::from(\"\
    a b c a b\")), HashMap::from([(String::from(\"a\"), 2), (String::from(\"b\"),\
    \ 2)]));\n    assert_eq!(candidate(String::from(\"a b c d g\")), HashMap::from([(String::from(\"\
    a\"), 1), (String::from(\"b\"), 1), (String::from(\"c\"), 1), (String::from(\"\
    d\"), 1), (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"b b b\
    \ b a\")), HashMap::from([(String::from(\"b\"), 4)]));\n    assert_eq!(candidate(String::from(\"\
    r t g\")), HashMap::from([(String::from(\"r\"), 1), (String::from(\"t\"), 1),\
    \ (String::from(\"g\"), 1)]));\n    assert_eq!(candidate(String::from(\"\")),\
    \ HashMap::from([]));\n    assert_eq!(candidate(String::from(\"a\")), HashMap::from([(String::from(\"\
    a\"), 1)]));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `&mut {integer}: Clone` is not satisfied\n\
    \    --> /tmp/tmp6qhdw_hn.rs:21:54\n     |\n21   |     let mut letters_count_max\
    \ = letters_count.iter().cloned().max().unwrap();\n     |                    \
    \                                  ^^^^^^ the trait `Clone` is not implemented\
    \ for `&mut {integer}`\n     |\n     = help: the following other types implement\
    \ trait `Clone`:\n               f32\n               f64\n               i128\n\
    \               i16\n               i32\n               i64\n               i8\n\
    \               isize\n             and 6 others\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: the method `max` exists for struct `Cloned<std::slice::Iter<'_,\
    \ &mut {integer}>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp6qhdw_hn.rs:21:63\n\
    \   |\n21 |       let mut letters_count_max = letters_count.iter().cloned().max().unwrap();\n\
    \   |                                                                 ^^^ method\
    \ cannot be called on `Cloned<std::slice::Iter<'_, &mut {integer}>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `Cloned<std::slice::Iter<'_, &mut {integer}>>: Ord`\n           which\
    \ is required by `&Cloned<std::slice::Iter<'_, &mut {integer}>>: Ord`\n      \
    \     `Cloned<std::slice::Iter<'_, &mut {integer}>>: Ord`\n           which is\
    \ required by `&mut Cloned<std::slice::Iter<'_, &mut {integer}>>: Ord`\n     \
    \      `Cloned<std::slice::Iter<'_, &mut {integer}>>: Iterator`\n           which\
    \ is required by `&mut Cloned<std::slice::Iter<'_, &mut {integer}>>: Iterator`\n\
    \nerror[E0277]: the trait bound `&mut {integer}: Clone` is not satisfied\n   \
    \ --> /tmp/tmp6qhdw_hn.rs:23:58\n     |\n23   |         let mut letters_count_min\
    \ = letters_count.iter().cloned().min().unwrap();\n     |                    \
    \                                      ^^^^^^ the trait `Clone` is not implemented\
    \ for `&mut {integer}`\n     |\n     = help: the following other types implement\
    \ trait `Clone`:\n               f32\n               f64\n               i128\n\
    \             "
  stdout: ''
  timestamp: 1660011379
