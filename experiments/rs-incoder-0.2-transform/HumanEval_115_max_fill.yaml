name: HumanEval_115_max_fill
language: rs
prompt: "/// You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n/// and each 1 in a row represents a single unit of water.\n/// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n/// and\
  \ all buckets have the same capacity.\n/// Your task is to use the buckets to empty\
  \ the wells.\n/// Output the number of times you need to lower the buckets.\n///\
  \ Example 1:\n/// >>> max_fill(vec![vec![0, 0, 1, 0], vec![0, 1, 0, 0], vec![1,\
  \ 1, 1, 1]], 1)\n/// 6\n/// Example 2:\n/// >>> max_fill(vec![vec![0, 0, 1, 1],\
  \ vec![0, 0, 0, 0], vec![1, 1, 1, 1], vec![0, 1, 1, 1]], 2)\n/// 5\n/// Example\
  \ 3:\n/// >>> max_fill(vec![vec![0, 0, 0], vec![0, 0, 0]], 5)\n/// 0\n/// Constraints:\n\
  /// * all wells have the same length\n/// * 1 <= grid.length <= 10^2\n/// * 1 <=\
  \ grid[:,1].length <= 10^2\n/// * grid[i][j] -> 0 | 1\n/// * 1 <= capacity <= 10\n\
  fn max_fill(grid: Vec<Vec<isize>>, capacity: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = max_fill;\n    assert_eq!({left}, {right});\n\
  \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
  \ {right});\n    assert_eq!({left}, {right});\n}\n"
completions: ["    let mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid\
    \ = grid.clone();\n    for row in 0..grid.len() {\n        for col in 0..grid[row].len()\
    \ {\n            if grid[row][col] == 1 {\n                cnt += 1;\n       \
    \         max_cnt = std::cmp::max(max_cnt, cnt);\n                max_grid[row][col]\
    \ = 0;\n            }\n        }\n    }\n    for row in 0..grid.len() {\n    \
    \    for col in 0..grid[row].len() {\n            if grid[row][col] == 0 {\n \
    \               cnt -= 1;\n                max_cnt = std::cmp::max(max_cnt, cnt);\n\
    \                max_grid[row][col] = 1;\n            }\n        }\n    }\n  \
    \  if max_cnt > capacity {\n        max_cnt -= 1;\n    }\n    max_cnt", "    let\
    \ mut ans = isize::MAX;\n    let mut row = 0;\n    let mut col = 0;\n    let mut\
    \ cnt = 0;\n    while row < grid.len() {\n        while col < grid[row].len()\
    \ {\n            if grid[row][col] == 1 {\n                cnt += 1;\n       \
    \         if cnt > ans {\n                    ans = cnt;\n                }\n\
    \            }\n            col += 1;\n        }\n        row += 1;\n        col\
    \ = 0;\n        cnt = 0;\n    }\n    ans", "    let mut counter = 0;\n    let\
    \ mut max_bucket = grid[0].len();\n    for row in grid.iter() {\n        let mut\
    \ max_well = row[0].len();\n        for bucket in row.iter() {\n            if\
    \ bucket > max_well {\n                max_well = bucket;\n            }\n   \
    \     }\n        if max_well > max_bucket {\n            max_bucket = max_well;\n\
    \        }\n    }\n    for row in grid.iter() {\n        for bucket in row.iter()\
    \ {\n            if bucket > max_bucket {\n                counter += 1;\n   \
    \             max_bucket = bucket;\n            }\n        }\n    }\n    counter",
  "    let mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = grid[0].len();\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt", " \
    \   let mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in grid.iter() {\n        let mut cnt = 0;\n        for col in row.iter()\
    \ {\n            if *col == 1 {\n                cnt += 1;\n            }\n  \
    \      }\n        if cnt > max_cnt {\n            max_cnt = cnt;\n           \
    \ max_grid = row.clone();\n        }\n    }\n    for row in max_grid.iter() {\n\
    \        let mut cnt = 0;\n        for col in row.iter() {\n            if *col\
    \ == 0 {\n                cnt += 1;\n            }\n        }\n        if cnt\
    \ > max_cnt {\n            max_cnt = cnt;\n        }\n    }\n    if max_cnt >\
    \ capacity {\n        max_cnt\n    } else {\n        max_cnt + 1\n    }", "  \
    \  let mut cnt = 0;\n    let mut min_bucket = grid[0].len();\n    for row in grid.iter()\
    \ {\n        let mut min_bucket = row[0].len();\n        for bucket in row.iter()\
    \ {\n            if bucket < min_bucket {\n                min_bucket = bucket;\n\
    \            }\n        }\n        cnt += min_bucket - 1;\n    }\n    cnt", " \
    \   let mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid = grid.clone();\n\
    \    for row in 0..grid.len() {\n        for col in 0..grid[row].len() {\n   \
    \         if grid[row][col] == 1 {\n                cnt += 1;\n              \
    \  if cnt > max_cnt {\n                    max_cnt = cnt;\n                  \
    \  max_grid = grid.clone();\n                }\n            }\n        }\n   \
    \ }\n    if cnt > max_cnt {\n        max_cnt = cnt;\n        max_grid = grid.clone();\n\
    \    }\n    cnt", "    let mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n\
    \    for row in grid.iter() {\n        for col in row.iter() {\n            if\
    \ col == 0 {\n                buckets[col] += 1;\n            }\n        }\n \
    \   }\n    for bucket in buckets.iter() {\n        if bucket > capacity {\n  \
    \          cnt += bucket - capacity;\n        }\n    }\n    cnt", "    let mut\
    \ counter = 0;\n    let mut max_capacity = 0;\n    let mut max_capacity_row =\
    \ vec![];\n    let mut max_capacity_col = vec![];\n    for i in 0..grid.len()\
    \ {\n        let mut row = grid[i];\n        let mut col = vec![];\n        for\
    \ j in 0..row.len() {\n            if row[j] == 1 {\n                col.push(j);\n\
    \            }\n        }\n        if col.len() > max_capacity {\n           \
    \ max_capacity = col.len();\n            max_capacity_row = i;\n            max_capacity_col\
    \ = col;\n        }\n    }\n    for i in 0..max_capacity {\n        for j in max_capacity_col\
    \ {\n            grid[max_capacity_row][j] -= 1;\n        }\n    }\n    counter\
    \ = max_capacity;\n    for i in 0..grid.len() {\n        for j in max_capacity_col\
    \ {\n            grid[i][j] += 1;\n        }\n    }\n    counter", "    let mut\
    \ ans = isize::MAX;\n    let mut buckets = Vec::new();\n    for row in grid.iter()\
    \ {\n        let mut bucket = Vec::new();\n        for cell in row.iter() {\n\
    \            bucket.push(cell as isize);\n        }\n        buckets.push(bucket);\n\
    \    }\n    for bucket in buckets.iter() {\n        if bucket.len() == capacity\
    \ {\n            ans = bucket.iter().max().unwrap_or(ans);\n        }\n    }\n\
    \    ans", "    let mut res = 0;\n    for row in grid.iter() {\n        let mut\
    \ cur_capacity = capacity;\n        for cell in row.iter() {\n            if cell\
    \ == 1 {\n                cur_capacity -= 1;\n            }\n        }\n     \
    \   if cur_capacity > 0 {\n            res += 1;\n        }\n    }\n    res",
  "    let mut cnt = 0;\n    for row in grid.iter() {\n        let mut cnt = 0;\n\
    \        for col in row.iter() {\n            if col == 0 {\n                cnt\
    \ += 1;\n            }\n        }\n        if cnt > capacity {\n            cnt\
    \ -= 1;\n        }\n    }\n    cnt", "    let mut cnt = 0;\n    let mut max_cnt\
    \ = 0;\n    let mut max_bucket = 0;\n    for row in grid.iter() {\n        let\
    \ mut cnt = 0;\n        let mut max_cnt = 0;\n        let mut max_bucket = 0;\n\
    \        for col in row.iter() {\n            if col == 1 {\n                cnt\
    \ += 1;\n                if cnt > max_cnt {\n                    max_cnt = cnt;\n\
    \                    max_bucket = col;\n                }\n            }\n   \
    \     }\n        cnt += 1;\n        if cnt > max_cnt {\n            max_cnt =\
    \ cnt;\n            max_bucket = row[0];\n        }\n    }\n    if max_cnt ==\
    \ 0 {\n        return 0;\n    }\n    if max_cnt == 1 {\n        return 1;\n  \
    \  }\n    if max_cnt == capacity {\n        return capacity - max_bucket;\n  \
    \  }\n    if max_cnt > capacity {\n        return max_cnt;\n    }\n    if max_cnt\
    \ > capacity / 2 {\n        return max_cnt - capacity;\n    }\n    if max_cnt\
    \ > capacity / 3 {\n        return max_cnt - capacity / 2;\n    }\n    if max_cnt\
    \ > capacity / 4 {\n        return max_cnt - capacity / 3;\n    }\n    if max_cnt\
    \ > capacity / 5 {\n        return max_cnt - capacity / 4;\n    }\n    if max_cnt\
    \ > capacity / 6 {\n        return max_cnt - capacity / 5;\n    }\n    if max_cnt\
    \ > capacity / 7 {\n        return max_cnt - capacity / 6;\n    }\n    if max_cnt\
    \ > capacity / 8 {\n        return max_cnt - capacity / 7;\n    }\n    if max_cnt\
    \ > capacity / 9 {\n        return max_cnt - capacity / 8;\n    }\n    if max_cnt\
    \ > capacity / 10 {\n        return max_cnt - capacity / 9;\n    }\n    if max_cnt\
    \ > capacity / 11 {\n        return max_cnt - capacity / 10;\n    }\n    if max_cnt\
    \ > capacity / 12 {\n        return max_cnt - capacity / 11;\n    }\n    if max_cnt\
    \ > capacity / 13 {\n        return max_cnt - capacity / 12;\n    }\n    if max_cnt\
    \ > capacity / 14 {\n        return max_cnt - capacity / 13;\n    }\n    if max_cnt\
    \ > capacity / 15 {\n        return max_cnt - capacity / 14;\n    }\n    if max_cnt\
    \ > capacity / 16 {\n        return max_cnt - capacity / 15;\n    }\n    if max_cnt\
    \ > capacity / 17 {\n        return max_cnt - capacity / 16;\n    }\n    if max_cnt\
    \ > capacity / 18 {\n        return max_cnt - capacity / 17;\n    }\n    if max_cnt\
    \ > capacity / 19 {\n        return max_cnt - capacity / 18;\n    }\n    if max_cnt\
    \ > ", "    let mut cnt = 0;\n    let mut max_capacity = capacity;\n    let mut\
    \ max_well = Vec::new();\n    let mut min_well = Vec::new();\n    let mut min_well_idx\
    \ = Vec::new();\n    let mut min_well_cap = Vec::new();\n    let mut min_well_cap_idx\
    \ = Vec::new();\n    let mut min_well_cap_val = Vec::new();\n    let mut min_well_cap_val_idx\
    \ = Vec::new();\n    let mut min_well_cap_val_min = Vec::new();\n    let mut min_well_cap_val_min_idx\
    \ = Vec::new();\n    let mut min_well_cap_val_min_val = Vec::new();\n    let mut\
    \ min_well_cap_val_min_val_idx = Vec::new();\n    let mut min_well_cap_val_min_val_min\
    \ = Vec::new();\n    let mut min_well_cap_val_min_val_min_idx = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val = Vec::new();\n    let mut min_well_cap_val_min_val_min_val_idx\
    \ = Vec::new();\n    let mut min_well_cap_val_min_val_min_val_min = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_idx_min = Vec::new();\n    let mut\
    \ min_well_cap_val_min_val_min_val_min_idx = Vec::new();\n    let mut min_well_cap_val_min_val_min_val_min_val\
    \ = Vec::new();\n    let mut min_well_cap_val_min_val_min_val_idx_min_val = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_min_val_idx = Vec::new();\n    let\
    \ mut min_well_cap_val_min_val_min_val_min_val_min = Vec::new();\n    let mut\
    \ min_well_cap_val_min_val_min_val_idx_min_val_min = Vec::new();\n    let mut\
    \ min_well_cap_val_min_val_min_val_min_val_idx_min_val_min = Vec::new();\n   \
    \ let mut min_well_cap_val_min_val_min_val_idx_min_val_min_val = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_idx_min_val_min_val_idx = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_idx_min_val_min_val_min = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_idx_min_val_min_val_idx_min = Vec::new();\n\
    \    let mut min_well_cap_val_min_val_min_val_idx_min_val_", "    let mut cnt\
    \ = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in grid.iter()\
    \ {\n        let mut bucket = buckets[row.len() - 1];\n        for cell in row.iter()\
    \ {\n            if cell == 1 {\n                bucket += 1;\n            }\n\
    \        }\n        if bucket > capacity {\n            cnt += 1;\n          \
    \  bucket = capacity - 1;\n        }\n        buckets[row.len() - 1] = bucket;\n\
    \    }\n    cnt", "    let mut ans = isize::MAX;\n    for row in grid.iter() {\n\
    \        let mut cur_capacity = capacity;\n        for cell in row.iter() {\n\
    \            if cell == 1 {\n                cur_capacity -= 1;\n            }\n\
    \        }\n        if cur_capacity < ans {\n            ans = cur_capacity;\n\
    \        }\n    }\n    ans", "    let mut ans = isize::MAX;\n    let mut buckets\
    \ = vec![vec![0; capacity]; grid.len()];\n    for i in 0..grid.len() {\n     \
    \   for j in 0..grid[i].len() {\n            buckets[i][j] = grid[i][j];\n   \
    \     }\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len()\
    \ {\n            if buckets[i][j] == 0 {\n                buckets[i][j] = 1;\n\
    \                ans = ans.min(buckets[i][j]);\n            }\n        }\n   \
    \ }\n    ans", "    let mut cnt = 0;\n    for row in grid.iter() {\n        for\
    \ col in row.iter() {\n            if col == 0 {\n                cnt += 1;\n\
    \            }\n        }\n    }\n    cnt += max_fill_helper(grid, capacity);\n\
    \    cnt", "    let mut cnt = 0;\n    let mut max_cnt = 0;\n    let mut max_grid\
    \ = grid.clone();\n    for row in grid.iter() {\n        for col in row.iter()\
    \ {\n            if col == 0 {\n                cnt += 1;\n                if\
    \ cnt > max_cnt {\n                    max_cnt = cnt;\n                    max_grid\
    \ = row.clone();\n                }\n            }\n        }\n    }\n    max_cnt",
  "    let mut cnt = 0;\n    let mut buckets = vec![0; grid.len()];\n    for row in\
    \ grid.iter() {\n        let mut bucket = buckets[row.len() - 1];\n        for\
    \ cell in row.iter() {\n            if cell == 1 {\n                bucket +=\
    \ 1;\n            }\n        }\n        if bucket > capacity {\n            cnt\
    \ += 1;\n            buckets[row.len() - 1] = bucket;\n        }\n    }\n    cnt"]
stop_tokens:
- "\n}"
