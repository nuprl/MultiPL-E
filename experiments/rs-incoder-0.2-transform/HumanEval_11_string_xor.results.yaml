language: rs
name: HumanEval_11_string_xor
results:
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpop8dz728.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.chars().chain(b.iter()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |       ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n --> /tmp/tmpop8dz728.rs:6:22\n\
    \  |\n6 |     a.iter().chain(b.iter()).filter(|&b| b == '1').collect::<String>()\n\
    \  |                      ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n6 |     a.iter().chain(b.chars()).filter(|&b|\
    \ b == '1').collect::<String>()\n  |                      ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor(a.as_bytes(),\
    \ b.as_bytes())))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmpqv0gsbnd.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor(a.as_bytes(),\
    \ b.as_bytes())))\n  |                                  ^^^^^^^ use of undeclared\
    \ crate or module `bincode`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).filter(|&x| x == b'0').collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpg1h5g_f3.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).filter(|&x|\
    \ x == b'0').collect::<String>()\n  |       ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.chars().chain(b.iter()).filter(|&x|\
    \ x == b'0').collect::<String>()\n  |       ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n --> /tmp/tmpg1h5g_f3.rs:6:22\n\
    \  |\n6 |     a.iter().chain(b.iter()).filter(|&x| x == b'0').collect::<String>()\n\
    \  |                      ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n6 |     a.iter().chain(b.chars()).filter(|&x|\
    \ x == b'0').collect::<String>()\n  |                      ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmphke9bp2o.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor_encode(a.as_bytes(),\
    \ b.as_bytes())));\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmp14elj644.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor_encode(a.as_bytes(),\
    \ b.as_bytes())));\n  |                                  ^^^^^^^ use of undeclared\
    \ crate or module `bincode`\n\nerror[E0308]: mismatched types\n --> /tmp/tmp14elj644.rs:5:40\n\
    \  |\n5 | fn string_xor(a: String, b: String) -> String {\n  |    ---------- \
    \                         ^^^^^^ expected struct `String`, found `()`\n  |   \
    \ |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    6 |     String::from(format!(\"{:b}\", bincode::xor_encode(a.as_bytes(), b.as_bytes())));\n\
    \  |                                                                         \
    \          - help: remove this semicolon\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in a.chars().zip(b.chars()).map(|(a,\
    \ b)| {\n        match a {\n            b'0' => b'1',\n            b'1' => b'0',\n\
    \            _ => panic!(\"Invalid input\"),\n        }\n        match b {\n \
    \           b'0' => b'1',\n            b'1' => b'0',\n            _ => panic!(\"\
    Invalid input\"),\n        }\n    }) {\n        (a, b) => result.push(*a ^ *b),\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpt1yol5x1.rs:19:16\n   |\n19 |         (a, b) => result.push(*a\
    \ ^ *b),\n   |                ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpt1yol5x1.rs:9:13\n  |\n8 |    \
    \     match a {\n  |               - this expression has type `char`\n9 |    \
    \         b'0' => b'1',\n  |             ^^^^ expected `char`, found `u8`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpt1yol5x1.rs:10:13\n   |\n8  |  \
    \       match a {\n   |               - this expression has type `char`\n9  |\
    \             b'0' => b'1',\n10 |             b'1' => b'0',\n   |            \
    \ ^^^^ expected `char`, found `u8`\n\nerror[E0308]: `match` arms have incompatible\
    \ types\n  --> /tmp/tmpt1yol5x1.rs:11:18\n   |\n8  | /         match a {\n9  |\
    \ |             b'0' => b'1',\n   | |                     ---- this is found to\
    \ be of type `u8`\n10 | |             b'1' => b'0',\n   | |                  \
    \   ---- this is found to be of type `u8`\n11 | |             _ => panic!(\"Invalid\
    \ input\"),\n   | |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `u8`, found\
    \ `()`\n12 | |         }\n   | |_________- `match` arms have incompatible types\n\
    \   |\n   = note: this error originates in the macro `$crate::panic::panic_2015`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt1yol5x1.rs:14:13\n   |\n13 |         match\
    \ b {\n   |               - this expression has type `char`\n14 |            \
    \ b'0' => b'1',\n   |             ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpt1yol5x1.rs:15:13\n   |\n13 |         match\
    \ b {\n   |               - this expression has type `char`\n14 |            \
    \ b'0' => b'1',\n15 |             b'1' => b'0',\n   |             ^^^^ expected\
    \ `char`, found `u8`\n\nerror: aborting due to 6 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        match c {\n            '0' => result.push('0'),\n          \
    \  '1' => result.push('1'),\n            _ => panic!(\"String contains invalid\
    \ character: {}\", c),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl6favcfq.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push_str(&a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpm0bm6uyk.rs:8:26\n\
    \  |\n8 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \  ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpm0bm6uyk.rs:8:33\n\
    \  |\n8 |         result.push_str(&a[i] ^ b[i]);\n  |                        \
    \         ^^^^ `String` cannot be indexed by `usize`\n  |\n  = help: the trait\
    \ `Index<usize>` is not implemented for `String`\n  = help: the following other\
    \ types implement trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n\
    \            <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a {\
    \ res.push(c); }\n    for &c in &b { res.push(c); }\n    res\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpl0yln94h.rs:7:15\n\
    \  |\n7 |     for &c in &a { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpl0yln94h.rs:8:15\n\
    \  |\n8 |     for &c in &b { res.push(c); }\n  |               ^^ `&String` is\
    \ not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmp4nxdz1mw.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor_str(a, b))\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor_str` in this scope\n -->\
    \ /tmp/tmpi3txo244.rs:6:18\n  |\n6 |     String::from(binary_xor_str(a, b))\n\
    \  |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        match c {\n            '0' => result.push('0'),\n          \
    \  '1' => result.push('1'),\n            _ => panic!(\"String contains invalid\
    \ character\"),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmp1r0yvowc.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpafwq4ltq.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp5i3mhdkb.rs:6:19\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                   ^^^^ method not found\
    \ in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n6 |\
    \     a.to_string().chars().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                   ~~~~~\n\nerror[E0599]: no method named `iter` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp5i3mhdkb.rs:6:44\n  |\n6\
    \ |     a.to_string().iter().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                            ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.to_string().iter().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                                        \
    \    ~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            res.push_str(&format!(\"{}\", a[i]\
    \ ^ b[i]));\n        } else {\n            res.push_str(&a[i]);\n        }\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpf2zlv0fc.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpf2zlv0fc.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpf2zlv0fc.rs:9:41\n\
    \  |\n9 |             res.push_str(&format!(\"{}\", a[i] ^ b[i]));\n  |      \
    \                                   ^^^^ `String` cannot be indexed by `usize`\n\
    \  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n  =\
    \ help: the following other types implement trait `Index<Idx>`:\n            <String\
    \ as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n    \
    \        <String as Index<RangeInclusive<usize>>>\n            <String as Index<RangeTo<usize>>>\n\
    \            <String as Index<RangeToInclusive<usize>>>\n            <String as\
    \ Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        match c {\n            '0' => result.push('0'),\n          \
    \  '1' => result.push('1'),\n            _ => panic!(\"String contains invalid\
    \ character: {}\", c),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"),\
    \ String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpl6favcfq.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu9gq6rus.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpu9gq6rus.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbvs9s29o.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bin::Xor::new(a,\
    \ b).unwrap()))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bin`\n\
    \ --> /tmp/tmpngfpy2hc.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bin::Xor::new(a,\
    \ b).unwrap()))\n  |                                  ^^^ use of undeclared crate\
    \ or module `bin`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.chars().zip(b.chars()).map(|(a, b)|\
    \ a ^ b).collect())\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmphg7oikog.rs:6:58\n\
    \  |\n6 |     String::from(a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect())\n\
    \  |                                                        - ^ - char\n  |  \
    \                                                      |\n  |                \
    \                                        char\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a |\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpd8_zzhcc.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpafwq4ltq.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmp4nxdz1mw.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpafwq4ltq.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmphke9bp2o.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for (a, b)\
    \ in a.chars().zip(b.chars()) {\n        *result .= if *a != *b { 1 } else { 0\
    \ };\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n \
    \   assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `=`\n --> /tmp/tmpq2eid7cg.rs:8:18\n  |\n8 | \
    \        *result .= if *a != *b { 1 } else { 0 };\n  |                  ^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpq2eid7cg.rs:8:23\n\
    \  |\n8 |         *result .= if *a != *b { 1 } else { 0 };\n  |              \
    \         ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpq2eid7cg.rs:8:29\n\
    \  |\n8 |         *result .= if *a != *b { 1 } else { 0 };\n  |              \
    \               ^^\n\nerror[E0308]: mismatched types\n --> /tmp/tmpq2eid7cg.rs:8:34\n\
    \  |\n8 |         *result .= if *a != *b { 1 } else { 0 };\n  |              \
    \                    ^ expected `str`, found integer\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpq2eid7cg.rs:8:45\n  |\n8 |         *result .= if *a != *b\
    \ { 1 } else { 0 };\n  |                                             ^ expected\
    \ `str`, found integer\n\nerror[E0277]: the size for values of type `str` cannot\
    \ be known at compilation time\n --> /tmp/tmpq2eid7cg.rs:8:9\n  |\n8 |       \
    \  *result .= if *a != *b { 1 } else { 0 };\n  |         ^^^^^^^ doesn't have\
    \ a size known at compile-time\n  |\n  = help: the trait `Sized` is not implemented\
    \ for `str`\n  = note: the left-hand-side of an assignment must have a statically\
    \ known size\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpt6t5x9i6.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars())\n\
    \        .map(|(a, b)| a ^ b)\n        .collect()\n        .to_string()\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpbvs9s29o.rs:7:25\n\
    \  |\n7 |         .map(|(a, b)| a ^ b)\n  |                       - ^ - char\n\
    \  |                       |\n  |                       char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyldypbr1.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).map(|x| x ^ 1).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmphztk7xm9.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).map(|x|\
    \ x ^ 1).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n6 |     a.chars().chain(b.iter()).map(|x|\
    \ x ^ 1).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter` found\
    \ for struct `String` in the current scope\n --> /tmp/tmphztk7xm9.rs:6:22\n  |\n\
    6 |     a.iter().chain(b.iter()).map(|x| x ^ 1).collect()\n  |               \
    \       ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().chain(b.chars()).map(|x| x ^ 1).collect()\n\
    \  |                      ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyldypbr1.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpwidu4wnh.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(format!(\"{:b}\", bincode::xor_u8(a.as_bytes(),\
    \ b.as_bytes())))\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `bincode`\n\
    \ --> /tmp/tmps4_iprnr.rs:6:34\n  |\n6 |     String::from(format!(\"{:b}\", bincode::xor_u8(a.as_bytes(),\
    \ b.as_bytes())))\n  |                                  ^^^^^^^ use of undeclared\
    \ crate or module `bincode`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor_impl(a.to_string(), b.to_string()).to_string())\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor_impl` in this scope\n -->\
    \ /tmp/tmphdxud8jv.rs:6:18\n  |\n6 |     String::from(binary_xor_impl(a.to_string(),\
    \ b.to_string()).to_string())\n  |                  ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmphke9bp2o.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ | &b {\n        if *c != 0 {\n            result.push(*c);\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmp4nxdz1mw.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpyldypbr1.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        if *c != '0' {\n            result.push(*c);\n        }\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmphke9bp2o.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        result.push(a[i] ^ b[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:21\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                     ^^^^ `String`\
    \ cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n  = help: the following other types implement trait\
    \ `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n           \
    \ <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmpyi46pjsg.rs:8:28\n\
    \  |\n8 |         result.push(a[i] ^ b[i]);\n  |                            ^^^^\
    \ `String` cannot be indexed by `usize`\n  |\n  = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n  = help: the following other types implement\
    \ trait `Index<Idx>`:\n            <String as Index<RangeFrom<usize>>>\n     \
    \       <String as Index<RangeFull>>\n            <String as Index<RangeInclusive<usize>>>\n\
    \            <String as Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a[i..].iter().filter(|&b| b == '1').collect::<String>());\n\
    \    }\n    for i in 0..b.len() {\n        res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n --> /tmp/tmp6efh3vuh.rs:8:30\n  |\n8 |         res.push_str(&a[i..].iter().filter(|&b|\
    \ b == '1').collect::<String>());\n  |                              ^^^^ method\
    \ not found in `str`\n\nerror[E0599]: no method named `iter` found for type `str`\
    \ in the current scope\n  --> /tmp/tmp6efh3vuh.rs:11:30\n   |\n11 |         res.push_str(&b[i..].iter().filter(|&a|\
    \ a == '1').collect::<String>());\n   |                              ^^^^ method\
    \ not found in `str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in a.chars()\
    \ {\n        res.push_str(&format!(\"{:b}\", i ^ b.chars().nth(i)));\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpy4jhqzn6.rs:8:57\n  |\n8 |\
    \         res.push_str(&format!(\"{:b}\", i ^ b.chars().nth(i)));\n  |       \
    \                                                  ^ expected `usize`, found `char`\n\
    \nerror[E0369]: no implementation for `char ^ Option<char>`\n --> /tmp/tmpy4jhqzn6.rs:8:41\n\
    \  |\n8 |         res.push_str(&format!(\"{:b}\", i ^ b.chars().nth(i)));\n  |\
    \                                       - ^ ---------------- Option<char>\n  |\
    \                                       |\n  |                               \
    \        char\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for i in 0..a.len()\
    \ {\n        res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n --> /tmp/tmp1fl1l36k.rs:8:23\n\
    \  |\n8 |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n \
    \ |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ no implementation for `usize ^ char`\n --> /tmp/tmp1fl1l36k.rs:8:35\n  |\n8\
    \ |         res.push_str(&a.chars()[i ^ b.chars().nth(i).unwrap()]);\n  |    \
    \                               ^ no implementation for `usize ^ char`\n  |\n\
    \  = help: the trait `BitXor<char>` is not implemented for `usize`\n  = help:\
    \ the following other types implement trait `BitXor<Rhs>`:\n            <&'a i128\
    \ as BitXor<i128>>\n            <&'a i16 as BitXor<i16>>\n            <&'a i32\
    \ as BitXor<i32>>\n            <&'a i64 as BitXor<i64>>\n            <&'a i8 as\
    \ BitXor<i8>>\n            <&'a isize as BitXor<isize>>\n            <&'a u128\
    \ as BitXor<u128>>\n            <&'a u16 as BitXor<u16>>\n          and 40 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0608.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).map(|x| x ^ 1).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpx_2p_p7z.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).map(|x|\
    \ x ^ 1).collect::<String>()\n  |       ^^^^ method not found in `String`\n  |\n\
    help: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.chars().chain(b.iter()).map(|x|\
    \ x ^ 1).collect::<String>()\n  |       ~~~~~\n\nerror[E0599]: no method named\
    \ `iter` found for struct `String` in the current scope\n --> /tmp/tmpx_2p_p7z.rs:6:22\n\
    \  |\n6 |     a.iter().chain(b.iter()).map(|x| x ^ 1).collect::<String>()\n  |\
    \                      ^^^^ method not found in `String`\n  |\nhelp: because of\
    \ the in-memory representation of `&str`, to obtain an `Iterator` over each of\
    \ its codepoint use method `chars`\n  |\n6 |     a.iter().chain(b.chars()).map(|x|\
    \ x ^ 1).collect::<String>()\n  |                      ~~~~~\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in a.chars().zip(b.chars())\
    \ {\n        result.push((*c[0]) ^ (*c[1]));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmplycy7_jq.rs:7:9\n  |\n7 |\
    \     for &c in a.chars().zip(b.chars()) {\n  |         ^^    ------------------------\
    \ this expression has type `Option<(char, char)>`\n  |         |\n  |        \
    \ expected tuple, found reference\n  |         help: you can probably remove the\
    \ explicit borrow: `c`\n  |\n  = note:  expected tuple `(char, char)`\n      \
    \    found reference `&_`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (mut a, mut b)| {\n            acc.push_str(&format!(\"{:b}\", a ^\
    \ b));\n            acc\n        }),\n    )\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmprrdo_ut_.rs:8:45\n\
    \  |\n8 |             acc.push_str(&format!(\"{:b}\", a ^ b));\n  |          \
    \                                 - ^ - char\n  |                            \
    \               |\n  |                                           char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a |\
    \ &b {\n        if *c != 0 {\n            res.push(*c);\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String | &String`\n --> /tmp/tmpz_i_x3c4.rs:7:18\n\
    \  |\n7 |     for &c in &a | &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpnx6fvtw7.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string()).to_string()\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpcnuc9uqb.rs:6:45\n\
    \  |\n6 |     a.chars().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n  |    \
    \                                       - ^ - char\n  |                      \
    \                     |\n  |                                           char\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() + b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp4353dd9v.rs:6:33\n  |\n6 |\
    \     String::from(a.to_owned() + b.to_owned())\n  |                         \
    \        ^^^^^^^^^^^^\n  |                                 |\n  |            \
    \                     expected `&str`, found struct `String`\n  |            \
    \                     help: consider borrowing here: `&b.to_owned()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &b in &b\
    \ {\n        if *b == '1' {\n            result.push(*a);\n        }\n       \
    \ *a = *a ^ *b;\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpjwpanfa7.rs:7:15\n\
    \  |\n7 |     for &b in &b {\n  |               ^^ `&String` is not an iterator\n\
    \  |\n  = help: the trait `Iterator` is not implemented for `&String`\n  = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpjwpanfa7.rs:9:25\n  |\n9 |    \
    \         result.push(*a);\n  |                         ^^ expected `char`, found\
    \ `str`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmpjwpanfa7.rs:11:9\n   |\n11 |         *a = *a\
    \ ^ *b;\n   |         ^^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor_str(a, b))\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor_str` in this scope\n -->\
    \ /tmp/tmpi3txo244.rs:6:18\n  |\n6 |     String::from(binary_xor_str(a, b))\n\
    \  |                  ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(binary_xor(a.as_bytes(), b.as_bytes()))\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `binary_xor` in this scope\n --> /tmp/tmpsbameoto.rs:6:18\n\
    \  |\n6 |     String::from(binary_xor(a.as_bytes(), b.as_bytes()))\n  |      \
    \            ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ & &b {\n        result .= if *c != 0 {\n            *c as char\n        } else\
    \ {\n            *c as char\n        };\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `=`\n --> /tmp/tmpk41cgfac.rs:8:17\n  |\n8 | \
    \        result .= if *c != 0 {\n  |                 ^\n\nerror[E0369]: no implementation\
    \ for `&String & &String`\n --> /tmp/tmpk41cgfac.rs:7:18\n  |\n7 |     for &c\
    \ in &a & &b {\n  |               -- ^ -- &String\n  |               |\n  |  \
    \             &String\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().chain(b.iter()).map(|x| x ^ 1).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmphztk7xm9.rs:6:7\n  |\n6 |     a.iter().chain(b.iter()).map(|x|\
    \ x ^ 1).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n  |\n6 |     a.chars().chain(b.iter()).map(|x|\
    \ x ^ 1).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter` found\
    \ for struct `String` in the current scope\n --> /tmp/tmphztk7xm9.rs:6:22\n  |\n\
    6 |     a.iter().chain(b.iter()).map(|x| x ^ 1).collect()\n  |               \
    \       ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().chain(b.chars()).map(|x| x ^ 1).collect()\n\
    \  |                      ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().chars().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect()\n}\n\nfn main() {\n    let candidate = string_xor;\n  \
    \  assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")), String::from(\"\
    010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"1\"\
    )), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"), String::from(\"\
    0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmp0_pnva7p.rs:6:69\n\
    \  |\n6 |     a.to_string().chars().zip(b.to_string().chars()).map(|(a, b)| a\
    \ ^ b).collect()\n  |                                                        \
    \           - ^ - char\n  |                                                  \
    \                 |\n  |                                                     \
    \              char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(\n        a.as_bytes().iter().zip(b.as_bytes().iter()).map(|(a,\
    \ b)| a ^ b).collect(),\n    )\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp42lqvse_.rs:6:5\n  |\n5 |\
    \   fn string_xor(a: String, b: String) -> String {\n  |                     \
    \                     ------ expected `String` because of return type\n6 | / \
    \    String::from_utf8(\n7 | |         a.as_bytes().iter().zip(b.as_bytes().iter()).map(|(a,\
    \ b)| a ^ b).collect(),\n8 | |     )\n  | |_____^ expected struct `String`, found\
    \ enum `Result`\n  |\n  = note: expected struct `String`\n               found\
    \ enum `Result<String, FromUtf8Error>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(\n        a.chars().zip(b.chars()).fold(String::new(),\
    \ |mut acc, (mut a, mut b)| {\n            *acc += *a ^ *b;\n            acc\n\
    \        }),\n    )\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmpagpkg_pw.rs:8:21\n\
    \  |\n8 |             *acc += *a ^ *b;\n  |                     ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n --> /tmp/tmpagpkg_pw.rs:8:26\n  |\n8 |\
    \             *acc += *a ^ *b;\n  |                          ^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[i] {\n            result.push('a');\n        } else\
    \ {\n            result.push('0');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_7ru_8t2.rs:8:12\n\
    \  |\n8 |         if a[i] != b[i] {\n  |            ^^^^ `String` cannot be indexed\
    \ by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented for `String`\n\
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \   <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n --> /tmp/tmp_7ru_8t2.rs:8:20\n\
    \  |\n8 |         if a[i] != b[i] {\n  |                    ^^^^ `String` cannot\
    \ be indexed by `usize`\n  |\n  = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_(b).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_` found for struct `String` in the current\
    \ scope\n --> /tmp/tmppmokjpoa.rs:6:19\n  |\n6 |     a.to_string().xor_(b).to_string()\n\
    \  |                   ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().xor_eq(&b.to_string())\n        .map(|x|\
    \ x.to_string())\n        .unwrap_or(String::from(\"0\"))\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `xor_eq` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpkeg7x767.rs:6:19\n  |\n6 |     a.to_string().xor_eq(&b.to_string())\n\
    \  |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_owned() & b.to_owned()\n}\n\nfn main() {\n\
    \    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"\
    ), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpeugh5wkd.rs:6:18\n\
    \  |\n6 |     a.to_owned() & b.to_owned()\n  |     ------------ ^ ------------\
    \ String\n  |     |\n  |     String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() & b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String & String`\n --> /tmp/tmpjq9ldjxl.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() & b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu9gq6rus.rs:6:23\n  |\n6 |\
    \     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n  |\
    \                       ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \  |                       |\n  |                       expected struct `Vec`,\
    \ found `&[u8]`\n  |\n  = note: expected struct `Vec<u8>`\n          found reference\
    \ `&[u8]`\n\nerror[E0599]: no method named `xor_utf8` found for enum `Result`\
    \ in the current scope\n --> /tmp/tmpu9gq6rus.rs:6:37\n  |\n6 |     String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()\n\
    \  |                                     ^^^^^^^^ method not found in `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n\
    }\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmpbmgxg_jw.rs:6:7\n  |\n6 |     a.iter().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ^^^^ method not found in `String`\n  |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n  |\n6 |     a.chars().zip(b.iter()).map(|(a,\
    \ b)| a ^ b).collect()\n  |       ~~~~~\n\nerror[E0599]: no method named `iter`\
    \ found for struct `String` in the current scope\n --> /tmp/tmpbmgxg_jw.rs:6:20\n\
    \  |\n6 |     a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()\n  |      \
    \              ^^^^ method not found in `String`\n  |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n  |\n6 |     a.iter().zip(b.chars()).map(|(a, b)| a ^ b).collect()\n\
    \  |                    ~~~~~\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &b in &b\
    \ {\n        if *b == 1 {\n            result.push(*a);\n        }\n        *a\
    \ = *a ^ *b;\n    }\n    result\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmp_ewq0pvr.rs:7:15\n\
    \  |\n7 |     for &b in &b {\n  |               ^^ `&String` is not an iterator\n\
    \  |\n  = help: the trait `Iterator` is not implemented for `&String`\n  = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&String`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmp_ewq0pvr.rs:9:25\n  |\n9 |    \
    \         result.push(*a);\n  |                         ^^ expected `char`, found\
    \ `str`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmp_ewq0pvr.rs:11:9\n   |\n11 |         *a = *a\
    \ ^ *b;\n   |         ^^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: the left-hand-side\
    \ of an assignment must have a statically known size\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.chars().zip(b.chars()).filter(|(a,\
    \ b)| a != b).map(|(a, b)| a ^ b).collect())\n}\n\nfn main() {\n    let candidate\
    \ = string_xor;\n    assert_eq!(candidate(String::from(\"111000\"), String::from(\"\
    101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ char`\n --> /tmp/tmpqphi6v7k.rs:6:82\n\
    \  |\n6 |     String::from(a.chars().zip(b.chars()).filter(|(a, b)| a != b).map(|(a,\
    \ b)| a ^ b).collect())\n  |                                                 \
    \                               - ^ - char\n  |                              \
    \                                                  |\n  |                    \
    \                                                            char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut result = String::new();\n    for &c in &a\
    \ { result.push(c); }\n    for &c in &b { result.push(c); }\n    result\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:7:15\n\
    \  |\n7 |     for &c in &a { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0277]: `&String` is not an iterator\n --> /tmp/tmpsubsoc06.rs:8:15\n\
    \  |\n8 |     for &c in &b { result.push(c); }\n  |               ^^ `&String`\
    \ is not an iterator\n  |\n  = help: the trait `Iterator` is not implemented for\
    \ `&String`\n  = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    let mut res = String::new();\n    for &c in &a &\
    \ &b {\n        if *c != 0 {\n            res.push_str(&*c as char);\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `&String & &String`\n --> /tmp/tmpt6t5x9i6.rs:7:18\n\
    \  |\n7 |     for &c in &a & &b {\n  |               -- ^ -- &String\n  |    \
    \           |\n  |               &String\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n}\n\nfn main() {\n    let candidate = string_xor;\n\
    \    assert_eq!(candidate(String::from(\"111000\"), String::from(\"101010\")),\
    \ String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"1\"), String::from(\"\
    1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"0101\"),\
    \ String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n --> /tmp/tmp5i3mhdkb.rs:6:19\n  |\n6 |     a.to_string().iter().zip(b.to_string().iter()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                   ^^^^ method not found\
    \ in `String`\n  |\nhelp: because of the in-memory representation of `&str`, to\
    \ obtain an `Iterator` over each of its codepoint use method `chars`\n  |\n6 |\
    \     a.to_string().chars().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                   ~~~~~\n\nerror[E0599]: no method named `iter` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp5i3mhdkb.rs:6:44\n  |\n6\
    \ |     a.to_string().iter().zip(b.to_string().iter()).map(|(a, b)| a ^ b).collect::<String>()\n\
    \  |                                            ^^^^ method not found in `String`\n\
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n  |\n6 |     a.to_string().iter().zip(b.to_string().chars()).map(|(a,\
    \ b)| a ^ b).collect::<String>()\n  |                                        \
    \    ~~~~~\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009002
- exit_code: 1
  program: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
    \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
    010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
    \ b: String) -> String {\n    String::from(a.to_owned() ^ b.to_owned())\n}\n\n\
    fn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
    111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
    1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
    0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `String ^ String`\n --> /tmp/tmpct_loap1.rs:6:31\n\
    \  |\n6 |     String::from(a.to_owned() ^ b.to_owned())\n  |                 \
    \ ------------ ^ ------------ String\n  |                  |\n  |            \
    \      String\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009001
