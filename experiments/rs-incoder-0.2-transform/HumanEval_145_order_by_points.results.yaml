language: rs
name: HumanEval_145_order_by_points
results:
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpu6pxmqfm.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpu6pxmqfm.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpu6pxmqfm.rs:18:37\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpu6pxmqfm.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums.sort_by_key(|x| {\n        let mut sum = 0;\n        for x in nums.iter()\
    \ {\n            sum += *x;\n        }\n        sum\n    });\n    nums\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp_4tidzwj.rs:11:23\n   |\n\
    11 |     nums.sort_by_key(|x| {\n   |                       ^ help: if this is\
    \ intentional, prefix it with an underscore: `_x`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nerror[E0596]: cannot borrow `nums` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp_4tidzwj.rs:11:5\n   |\n10 |   fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |                      ---- help: consider changing\
    \ this to be mutable: `mut nums`\n11 | /     nums.sort_by_key(|x| {\n12 | |  \
    \       let mut sum = 0;\n13 | |         for x in nums.iter() {\n14 | |      \
    \       sum += *x;\n15 | |         }\n16 | |         sum\n17 | |     });\n   |\
    \ |______^ cannot borrow as mutable\n\nerror[E0502]: cannot borrow `nums` as immutable\
    \ because it is also borrowed as mutable\n  --> /tmp/tmp_4tidzwj.rs:11:22\n  \
    \ |\n11 |       nums.sort_by_key(|x| {\n   |       -    ----------- ^^^ immutable\
    \ borrow occurs here\n   |       |    |\n   |  _____|    mutable borrow later\
    \ used by call\n   | |\n12 | |         let mut sum = 0;\n13 | |         for x\
    \ in nums.iter() {\n   | |                  ---- second borrow occurs due to use\
    \ of `nums` in closure\n14 | |             sum += *x;\n15 | |         }\n16 |\
    \ |         sum\n17 | |     });\n   | |______- mutable borrow occurs here\n\n\
    error: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0502, E0596.\nFor more information about an error, try\
    \ `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums_copy.len() {\n        nums_sum += nums_copy[nums_index];\n        if\
    \ nums_sum < 0 {\n            nums_sum = 0;\n            nums_index += 1;\n  \
    \      } else {\n            nums_sorted.swap(nums_index, nums_sum.checked_sub(1).unwrap());\n\
    \            nums_index += 1;\n        }\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvlhf074w.rs:21:42\n   |\n\
    21 |             nums_sorted.swap(nums_index, nums_sum.checked_sub(1).unwrap());\n\
    \   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n21 |           \
    \  nums_sorted.swap(nums_index, nums_sum.checked_sub(1).unwrap().try_into().unwrap());\n\
    \   |                                                                        \
    \  ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit to compare with next one\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.digits().sum()\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp0fehk08b.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &d in &nums_copy {\n            sum += d;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr6sy17w9.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpr6sy17w9.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n13 | |         let mut sum = 0;\n\
    14 | |         for &d in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n15 | |             sum +=\
    \ d;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit\n        while index < nums_copy.len()\
    \ {\n            let digit = nums_copy[index];\n            if digit > 0 {\n \
    \               sum += digit;\n                index += 1;\n            } else\
    \ {\n                break;\n            }\n        }\n        if sum < 0 {\n\
    \            sum = 0;\n        }\n        nums_copy.swap(index, nums_copy.len()\
    \ - 1);\n    }\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `nums_copy` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpflsi3j3d.rs:29:31\n   |\n29 |         nums_copy.swap(index,\
    \ nums_copy.len() - 1);\n   |         ----------------------^^^^^^^^^^^^^^^-----\n\
    \   |         |         |           |\n   |         |         |           immutable\
    \ borrow occurs here\n   |         |         mutable borrow later used by call\n\
    \   |         mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpflsi3j3d.rs:29:31\n   |\n29 |         nums_copy.swap(index,\
    \ nums_copy.len() - 1);\n   |                               ^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpflsi3j3d.rs:29:9\n\
    \   |\n29 |         nums_copy.swap(index, nums_copy.len() - 1);\n   |        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // increment index\n    }\n    let mut nums_copy = nums.clone();\n\
    \    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum::<isize>()\n  \
    \  });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpzm2lwt1i.rs:20:17\n   |\n20 |         sum -\
    \ x.digits().sum::<isize>()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        if sum < 0 {\n            sum = 0;\n            index += 1;\n       \
    \ } else {\n            index += 1;\n        }\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp2s1zz0wf.rs:24:17\n   |\n24 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .enumerate()\n        .sort_by(|(idx, &num)|\
    \ *num.try_into().unwrap().to_digits())\n        .map(|(idx, num)| idx)\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmprxzem6ym.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ &num)| *num.try_into().unwrap().to_digits())\n   |          ^^^^^^^ method not\
    \ found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .cloned()\n        .enumerate()\n        .sort_by(|(idx,\
    \ &n), &(mut a, mut b)| {\n            let mut a = a as isize;\n            let\
    \ mut b = b as isize;\n            if a > b {\n                (b, a)\n      \
    \      } else {\n                (a, b)\n            }\n        })\n        .map(|(idx,\
    \ &n)| nums[idx])\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpu75sk7kj.rs:15:10\n   |\n15 |         .sort_by(|(idx,\
    \ &n), &(mut a, mut b)| {\n   |          ^^^^^^^ method not found in `Enumerate<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|num| {\n        sum.partial_cmp(&num).unwrap()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmpojkwnjan.rs:16:5\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for num in nums_copy\
    \ {\n    |                  --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  | /     nums_copy.sort_by_key(|num| {\n17  | | \
    \        sum.partial_cmp(&num).unwrap()\n18  | |     });\n    | |______^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `nums_copy`\nhelp: consider iterating over a slice\
    \ of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n13\
    \  |     for num in &nums_copy {\n    |                +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.len()\
    \ - 1;\n    let mut max_sum = 0;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n    let\
    \ mut min_idx = nums.len() - \n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9xm5puxd.rs:59:1\n\
    \   |\n59 | }\n   | ^ expected expression\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut min_sum = std::isize::MAX;\n    let mut max_index = -1;\n\
    \    let mut min_index = -1;\n    for i in nums_copy.iter() {\n        sum +=\
    \ *i;\n        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n        if sum < min_sum {\n            min_sum = sum;\n  \
    \          min_index = i;\n        }\n    }\n    if max_sum < min_sum {\n    \
    \    nums_copy.swap(0, min_index);\n        nums_copy.swap(min_index, max_index);\n\
    \    }\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0tm6pret.rs:21:25\n   |\n\
    15 |     let mut max_index = -1;\n   |                         -- expected due\
    \ to this value\n...\n21 |             max_index = i;\n   |                  \
    \       ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n21 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0tm6pret.rs:25:25\n\
    \   |\n16 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n25 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n25 |             min_index = *i;\n   |                   \
    \      +\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmp0tm6pret.rs:16:25\n   |\n16 |     let mut min_index = -1;\n   |    \
    \                     ^^ the trait `Neg` is not implemented for `usize`\n   |\n\
    \   = help: the following other types implement trait `Neg`:\n             &f32\n\
    \             &f64\n             &i128\n             &i16\n             &i32\n\
    \             &i64\n             &i8\n             &isize\n           and 8 others\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp0tm6pret.rs:15:25\n\
    \   |\n15 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .cloned()\n        .sort_by_key(|x| x.checked_mul(10).unwrap())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmp3ellrakw.rs:14:10\n   |\n14 |         .sort_by_key(|x|\
    \ x.checked_mul(10).unwrap())\n   |          ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum += x;\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp43fdj0ww.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        while sum > 10 {\n            sum\
    \ -= 10;\n            nums_sorted[index] = index - 1;\n            index += 1;\n\
    \        }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiu97vnqw.rs:19:34\n   |\n\
    19 |             nums_sorted[index] = index - 1;\n   |             ------------------\
    \   ^^^^^^^^^ expected `isize`, found `usize`\n   |             |\n   |      \
    \       expected due to the type of this binding\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for &n in\
    \ &nums_sorted {\n        sum += n;\n    }\n    nums_sorted.sort_by_key(|n| {\n\
    \        sum - n\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpx_0lcsqx.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpc8gjfsxh.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in\
    \ nums_sorted {\n        sum += num;\n        nums_sorted.swap_remove(|x| x >\
    \ sum);\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_etgk5eb.rs:15:33\n   |\n\
    15 |         nums_sorted.swap_remove(|x| x > sum);\n   |                     \
    \            ^^^^^^^^^^^ expected `usize`, found closure\n   |\n   = note: expected\
    \ type `usize`\n           found closure `[closure@/tmp/tmp_etgk5eb.rs:15:33:\
    \ 15:44]`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        let digit = nums_copy[index];\n\
    \        sum += digit;\n        if sum > 0 {\n            nums_copy[index] = sum\
    \ % 10;\n            sum += nums_copy[index];\n            index += 1;\n     \
    \   } else {\n            index += 1;\n        }\n    }\n    nums_copy.sort_by_key(|&x|\
    \ x.partial_cmp(&sum).unwrap());\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 3, 5, 9, 6]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpgx6_pyx5.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_index = 0;\n    for i in nums_copy {\n        sum += i;\n\
    \        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0siwjhri.rs:22:27\n   |\n\
    22 |     nums_copy.swap_remove(max_index);\n   |                           ^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n22 |     nums_copy.swap_remove(max_index.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit we already have\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum += x;\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmppn9r3yuw.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        let digit = nums_copy[index].unwrap();\n        sum += digit;\n \
    \       nums_sorted.insert(index, sum);\n        index += 1;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpwkryqvnk.rs:16:38\n   |\n16 |         let digit = nums_copy[index].unwrap();\n\
    \   |                                      ^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_sorted.len() {\n        sum += nums_sorted[index];\n\
    \        if sum < 0 {\n            sum = 0;\n        }\n        index += 1;\n\
    \    }\n    nums_sorted.sort_by_key(|x| {\n        sum - x.digits().sum().unwrap()\n\
    \    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp7hx4dsdu.rs:22:17\n   |\n22 |         sum -\
    \ x.digits().sum().unwrap()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum += x;\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp43fdj0ww.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .cloned()\n        .sort_by(|a, b| {\n   \
    \         let mut sum = 0;\n            for &d in &[a, b] {\n                sum\
    \ += *d;\n            }\n            sum\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpk46fqhjt.rs:14:10\n   |\n14 |         .sort_by(|a,\
    \ b| {\n   |          ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_index = 0;\n    for &i in nums_copy {\n        sum +=\
    \ i;\n        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgag20vyw.rs:15:9\n   |\n\
    15 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum += x;\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp43fdj0ww.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit we just added\n        while index < nums_copy.len()\
    \ {\n            if nums_copy[index] == 0 {\n                nums_copy[index]\
    \ = 0;\n                nums_copy.swap(index, index + 1);\n                index\
    \ += 1;\n            } else {\n                break;\n            }\n       \
    \ }\n    }\n    nums_copy.sort_unstable_by_key(|x| {\n        sum - x.0\n    });\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmprnkgnm_v.rs:28:17\n\
    \   |\n28 |         sum - x.0\n   |                 ^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0609`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum < 0 {\n            sum =\
    \ 0;\n        }\n        if sum > 0 {\n            nums_sorted.push(index);\n\
    \        }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpig0zyvo5.rs:21:30\n   |\n\
    21 |             nums_sorted.push(index);\n   |                              ^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n21 |           \
    \  nums_sorted.push(index.try_into().unwrap());\n   |                        \
    \           ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in\
    \ nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|num|\
    \ {\n        sum.partial_cmp(&num)\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmpgi8289d8.rs:16:5\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n16  | /     nums_sorted.sort_by_key(|num| {\n17\
    \  | |         sum.partial_cmp(&num)\n18  | |     });\n    | |______^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n13  |\
    \     for num in &nums_sorted {\n    |                +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        sum += nums_sorted.pop();\n        if sum > 0 {\n            index\
    \ += 1;\n        }\n    }\n    nums_sorted.sort_by_key(|x| {\n        sum - x;\n\
    \    });\n    nums_sorted.extend(nums_copy.iter().cloned());\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmpz0f3tp_3.rs:16:13\n\
    \   |\n16 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x;\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp_6cny8c2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = Vec::new();\n    let mut sum_of_digits = nums.iter().map(|x|\
    \ x.digits()).sum();\n    let mut sorted_nums_index = 0;\n    let mut sorted_nums_len\
    \ = nums.len();\n    while sum_of_digits != 0 {\n        if sum_of_digits < nums[sorted_nums_index].digits()\
    \ {\n            sorted_nums.push(nums[sorted_nums_index]);\n            sorted_nums_index\
    \ += 1;\n            sum_of_digits -= nums[sorted_nums_index].digits();\n    \
    \    } else {\n            sorted_nums.push(nums[sorted_nums_index]);\n      \
    \      sorted_nums_index += 1;\n            sum_of_digits -= nums[sorted_nums_index].digits();\n\
    \        }\n    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp97tstiye.rs:12:51\n   |\n12 |     let mut sum_of_digits\
    \ = nums.iter().map(|x| x.digits()).sum();\n   |                             \
    \                      ^^^^^^ method not found in `&isize`\n\nerror[E0599]: no\
    \ method named `digits` found for type `isize` in the current scope\n  --> /tmp/tmp97tstiye.rs:16:52\n\
    \   |\n16 |         if sum_of_digits < nums[sorted_nums_index].digits() {\n  \
    \ |                                                    ^^^^^^ method not found\
    \ in `isize`\n\nerror[E0599]: no method named `digits` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmp97tstiye.rs:19:54\n   |\n19 |          \
    \   sum_of_digits -= nums[sorted_nums_index].digits();\n   |                 \
    \                                     ^^^^^^ method not found in `isize`\n\nerror[E0599]:\
    \ no method named `digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp97tstiye.rs:23:54\n   |\n23 |             sum_of_digits -= nums[sorted_nums_index].digits();\n\
    \   |                                                      ^^^^^^ method not found\
    \ in `isize`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .enumerate()\n        .sort_by(|(idx, (idx,\
    \ num))| {\n            let mut sum = 0;\n            for d in num.digits() {\n\
    \                sum += d;\n            }\n            sum\n        })\n     \
    \   .map(|(idx, num)| num)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0415]: identifier `idx` is bound more than once in this parameter\
    \ list\n  --> /tmp/tmpsygnzxzc.rs:14:26\n   |\n14 |         .sort_by(|(idx, (idx,\
    \ num))| {\n   |                          ^^^ used as parameter more than once\n\
    \nerror[E0599]: no method named `sort_by` found for struct `Enumerate` in the\
    \ current scope\n  --> /tmp/tmpsygnzxzc.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ (idx, num))| {\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0415, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0415`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum < 0 {\n            sum\
    \ = 0;\n            index += 1;\n            continue;\n        }\n        if\
    \ sum > 0 {\n            sum = 0;\n            index += 1;\n            continue;\n\
    \        }\n        nums_sorted.swap(index, nums_sorted.len() - 1);\n        index\
    \ -= 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpj84x588a.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpj84x588a.rs:27:33\n   |\n27 |\
    \         nums_sorted.swap(index, nums_sorted.len() - 1);\n   |         ------------------------^^^^^^^^^^^^^^^^^-----\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpj84x588a.rs:27:33\n   |\n27\
    \ |         nums_sorted.swap(index, nums_sorted.len() - 1);\n   |            \
    \                     ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local as\
    \ the argument to this call\n  --> /tmp/tmpj84x588a.rs:27:9\n   |\n27 |      \
    \   nums_sorted.swap(index, nums_sorted.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits(10)\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp69os26lh.rs:20:17\n   |\n20 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `nums_copy`\n  --> /tmp/tmpc0dtmawr.rs:11:13\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_nums_copy`\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpc0dtmawr.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpc0dtmawr.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpc0dtmawr.rs:18:37\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpc0dtmawr.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        let mut digit = 0;\n        while nums_copy[index] >= 10 {\n    \
    \        digit += nums_copy[index] / 10;\n            index += 1;\n        }\n\
    \        sum += digit;\n        nums_sorted.push(nums_copy[index]);\n        index\
    \ += 1;\n    }\n    nums_sorted.sort_by_key(|x| sum.partial_cmp(&x.partial_cmp(&sum)));\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_joh5qgw.rs:25:49\n   |\n\
    25 |     nums_sorted.sort_by_key(|x| sum.partial_cmp(&x.partial_cmp(&sum)));\n\
    \   |                                                 ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n\
    \              found reference `&Option<std::cmp::Ordering>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sorted = nums_sorted.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut sum = 0;\n    let mut min_sum = nums_sorted.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut min_sum_index = nums_sorted.iter().cloned().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    }).unwrap();\n    let mut max_sum = nums_sorted.iter().cloned().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut max_sum_index = nums_sorted.iter().cloned().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    }).unwrap();\n    while nums_sorted.len()\
    \ > 1 {\n        let mut min_sum = nums_sorted.iter().cloned().min_by_key(|&x|\
    \ {\n            sum += x;\n            sum\n        });\n        let mut min_sum_index\
    \ = nums_sorted.iter().cloned().min_by_key(|&x| {\n            sum += x;\n   \
    \         sum\n        }).unwrap();\n        let mut max_sum = nums_sorted.iter().cloned().max_by_key(|&x|\
    \ {\n            sum += x;\n            sum\n        });\n        let mut max_sum_index\
    \ = nums_sorted.iter().cloned().max_by_key(|&x| {\n            sum += x;\n   \
    \         sum\n        }).unwrap();\n        if min_sum == max_sum {\n       \
    \     nums_sorted.remove(min_sum_index);\n            nums_sorted.remove(min_sum_index);\n\
    \        } else {\n            nums_sorted.remove(min_sum_index);\n          \
    \  nums_sorted.remove(max_sum_index);\n        }\n    }\n    nums_sorted\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vlz_4cc.rs:49:32\n   |\n\
    49 |             nums_sorted.remove(min_sum_index);\n   |                    \
    \            ^^^^^^^^^^^^^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n49 |             nums_sorted.remove(min_sum_index.try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_vlz_4cc.rs:50:32\n   |\n50 |             nums_sorted.remove(min_sum_index);\n\
    \   |                                ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n50 |             nums_sorted.remove(min_sum_index.try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_vlz_4cc.rs:52:32\n   |\n52 |             nums_sorted.remove(min_sum_index);\n\
    \   |                                ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n52 |             nums_sorted.remove(min_sum_index.try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_vlz_4cc.rs:53:32\n   |\n53 |             nums_sorted.remove(max_sum_index);\n\
    \   |                                ^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n53 |             nums_sorted.remove(max_sum_index.try_into().unwrap());\n\
    \   |                                             ++++++++++++++++++++\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpk_si_9yp.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums_copy.len() {\n        nums_sum += nums_copy[nums_index];\n        while\
    \ nums_sum > 0 {\n            nums_sorted[nums_index] = nums_sum % 10;\n     \
    \       nums_sum = (nums_sum / 10).unwrap();\n            nums_index += 1;\n \
    \       }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp1eash8zz.rs:19:40\n   |\n19 |             nums_sum = (nums_sum\
    \ / 10).unwrap();\n   |                                        ^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        sum += nums_sorted.pop();\n        if sum < 0 {\n            sum\
    \ = 0;\n        }\n        if sum > 0 {\n            nums_sorted.push(index);\n\
    \        }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n  \
    \  let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmp_thue3ed.rs:16:13\n\
    \   |\n16 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum < 0 {\n            sum =\
    \ 0;\n            index += 1;\n            continue;\n        }\n        nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x + sum).unwrap());\n        index += 1;\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq98z8rq3.rs:22:66\n   |\n\
    22 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x + sum).unwrap());\n\
    \   |                                                                  ^^^^^^^\
    \ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        match sum {\n            0 => break,\n\
    \            _ => nums_sorted.push(index),\n        }\n        index += 1;\n \
    \   }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmnajqzm.rs:19:35\n   |\n\
    19 |             _ => nums_sorted.push(index),\n   |                         \
    \          ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    19 |             _ => nums_sorted.push(index.try_into().unwrap()),\n   |     \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum.cmp(&num)\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_muqprk.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        let mut digit = 0;\n        while digit < 10 {\n            sum +=\
    \ nums_copy[index] % 10;\n            digit += 1;\n            index += 1;\n \
    \       }\n        if sum > 0 {\n            nums_sorted.swap(index, nums_sorted.len()\
    \ - 1);\n        }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpatbrxj03.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpatbrxj03.rs:23:37\n   |\n23 |\
    \             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |          \
    \   ------------------------^^^^^^^^^^^^^^^^^-----\n   |             |       \
    \    |           |\n   |             |           |           immutable borrow\
    \ occurs here\n   |             |           mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpatbrxj03.rs:23:37\n   |\n23 |             nums_sorted.swap(index,\
    \ nums_sorted.len() - 1);\n   |                                     ^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpatbrxj03.rs:23:13\n\
    \   |\n23 |             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    let mut nums_sum_index\
    \ = 0;\n    let mut nums_sum_digit = 0;\n    let mut nums_sum_digit_index = 0;\n\
    \    let mut nums_sum_digit_index2 = 0;\n    let mut nums_sum_digit_index3 = 0;\n\
    \    let mut nums_sum_digit_index4 = 0;\n    let mut nums_sum_digit_index5 = 0;\n\
    \    let mut nums_sum_digit_index6 = 0;\n    let mut nums_sum_digit_index7 = 0;\n\
    \    let mut nums_sum_digit_index8 = 0;\n    let mut nums_sum_digit_index9 = 0;\n\
    \    let mut nums_sum_digit_index10 = 0;\n    let mut nums_sum_digit_index11 =\
    \ 0;\n    let mut nums_sum_digit_index12 = 0;\n    let mut nums_sum_digit_index13\
    \ = 0;\n    let mut nums_sum_digit_index14 = 0;\n    let mut nums_sum_digit_index15\
    \ = 0;\n    let mut nums_sum_digit_index16 = 0;\n    let mut nums_sum_digit_index17\
    \ = 0;\n    let mut nums_sum_digit_index18 = 0;\n    let mut nums_sum_digit_index19\
    \ = 0;\n    let mut nums_sum_digit_index20 = 0;\n    let mut nums_sum_digit_index21\
    \ = 0;\n    let mut nums_sum_digit_index22 = 0;\n    let mut nums_sum_digit_index23\
    \ = 0;\n    let mut nums_sum_digit_index24 = 0;\n    let mut nums_sum_digit_index25\
    \ = 0;\n    let mut nums_sum_digit_index26 = 0;\n    let mut nums_sum_digit_index27\
    \ = 0;\n    let mut nums_sum_digit_index28 = 0;\n    let mut nums_sum_digit_index29\
    \ = 0;\n    let mut nums_sum_digit_index30 = 0;\n    let mut nums_sum_digit_index31\
    \ = 0;\n    let mut nums_sum_digit_index32 = 0;\n    let mut nums_sum_digit_index33\
    \ = 0;\n    let mut nums_sum_digit_index34 = 0;\n    let mut nums_sum_digit_index35\
    \ = 0;\n    let mut nums_sum_digit_index36 = 0;\n    let mut nums_sum_digit_index37\
    \ = 0;\n    let mut nums_sum_digit_index38 = 0;\n    let mut nums_sum_digit_index39\
    \ = 0;\n    let mut nums_sum_digit_index40 = 0;\n    let mut nums_sum_digit_index41\
    \ = 0;\n    let mut nums_sum_digit_index42 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmaty7eua.rs:10:41\n   |\n\
    10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_index = 0;\n    for i in nums_copy {\n        sum += i;\n\
    \        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0siwjhri.rs:22:27\n   |\n\
    22 |     nums_copy.swap_remove(max_index);\n   |                           ^^^^^^^^^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n22 |     nums_copy.swap_remove(max_index.try_into().unwrap());\n\
    \   |                                    ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits().unwrap()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmppw4lhubx.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits().unwrap()\n   |                 ^^^^^^^^^ method not found in\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum < 0 {\n            sum\
    \ = 0;\n            index += 1;\n            continue;\n        }\n        let\
    \ mut i = 0;\n        while i < nums_sorted.len() && nums_sorted[i] < sum {\n\
    \            i += 1;\n        }\n        nums_sorted.swap(i, index);\n       \
    \ index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmpq3tsz4oi.rs:26:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for n in nums_sorted\
    \ {\n        sum += n;\n        nums_sorted.swap_remove(|x| {\n            match\
    \ x {\n                x if x > sum => x,\n                x if x < sum => sum,\n\
    \                _ => x,\n            }\n        });\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgyxjd_3y.rs:15:33\n   |\n\
    15 |           nums_sorted.swap_remove(|x| {\n   |  _________________________________^\n\
    16 | |             match x {\n17 | |                 x if x > sum => x,\n18 |\
    \ |                 x if x < sum => sum,\n19 | |                 _ => x,\n20 |\
    \ |             }\n21 | |         });\n   | |_________^ expected `usize`, found\
    \ closure\n   |\n   = note: expected type `usize`\n           found closure `[closure@/tmp/tmpgyxjd_3y.rs:15:33:\
    \ 21:10]`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    let mut sorted_nums = nums_copy.clone();\n\
    \    sorted_nums.sort_by_key(|num| {\n        sum - num\n    });\n    sorted_nums\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpuq9fp2ir.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmpuq9fp2ir.rs:16:27\n\
    \    |\n11  |     let mut nums_copy = nums.clone();\n    |         -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |     let mut sum = 0;\n13  |     for num in nums_copy\
    \ {\n    |                --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  |     let mut sorted_nums = nums_copy.clone();\n\
    \    |                           ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpc8gjfsxh.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .enumerate()\n        .sort_by(|(idx, &n),\
    \ (_, sum)| sum.cmp(&n))\n        .map(|(idx, &n)| idx)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmptob5f4hf.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ &n), (_, sum)| sum.cmp(&n))\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut i = 0;\n    while i < nums_copy.len() {\n \
    \       sum += nums_copy[i];\n        nums_sorted.swap(i, nums_sorted.iter().position(|&x|\
    \ x + sum).unwrap());\n        i += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5fogy0n8.rs:17:62\n   |\n\
    17 |         nums_sorted.swap(i, nums_sorted.iter().position(|&x| x + sum).unwrap());\n\
    \   |                                                              ^^^^^^^ expected\
    \ `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &n in &nums_copy {\n            sum += *n as\
    \ isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptsyw5aqw.rs:15:20\n\
    \   |\n15 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums.len() {\n        nums_sum += nums_copy[nums_index];\n        nums_index\
    \ += 1;\n    }\n    while nums_sum > 0 {\n        nums_sorted.swap(0, nums_index);\n\
    \        nums_sum += nums_copy[nums_index];\n        nums_index += 1;\n    }\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpv72ayuxs.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|&x| {\n   \
    \     let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp0e4e8h68.rs:12:29\n   |\n\
    12 |     nums_copy.sort_by_key(|&x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmp0e4e8h68.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|&x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmp0e4e8h68.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|&x| {\n   |       -                 \
    \    ^^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |  \
    \       let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |        \
    \          --------- move occurs due to use in closure\n15 | |             sum\
    \ += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmp0e4e8h68.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy`"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = std::i32::MAX;\n\
    \    let mut min_idx = nums.len() - 1;\n    let mut max_idx = nums.len() - 1;\n\
    \    while nums_sorted.len() > 0 {\n        let mut idx = nums_sorted.len() -\
    \ 1;\n        while idx > 0 && nums_sorted[idx] == nums_sorted[idx - 1] {\n  \
    \          idx -= 1;\n        }\n        let mut cur = nums_sorted[idx];\n   \
    \     nums_sorted.swap(idx, nums_sorted.len() - 1);\n        sum += cur;\n   \
    \     if sum > max_sum {\n            max_sum = sum;\n            max_idx = idx;\n\
    \        }\n        if sum < min_sum {\n            min_sum = sum;\n         \
    \   min_idx = idx;\n        }\n    }\n    nums_sorted.swap(min_idx, max_idx);\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdz03sjhj.rs:30:18\n   |\n\
    30 |         if sum < min_sum {\n   |                  ^^^^^^^ expected `isize`,\
    \ found `i32`\n   |\nhelp: you can convert an `i32` to an `isize` and panic if\
    \ the converted value doesn't fit\n   |\n30 |         if sum < min_sum.try_into().unwrap()\
    \ {\n   |                         ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdz03sjhj.rs:31:23\n   |\n15 |     let mut min_sum = std::i32::MAX;\n\
    \   |                       ------------- expected due to this value\n...\n31\
    \ |             min_sum = sum;\n   |                       ^^^ expected `i32`,\
    \ found `isize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|&x| {\n        sum - x;\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp0vcunt4x.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap().sum()\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpkiri9p8l.rs:20:17\n   |\n20 |         sum\
    \ - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^ method not found\
    \ in `&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpc8gjfsxh.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut result = Vec::new();\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        if sum < nums_copy[index]\
    \ {\n            result.push(nums_copy[index]);\n            sum += nums_copy[index];\n\
    \            index += 1;\n        } else {\n            index += 1;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = order_by_points;\n \
    \   assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp9u7ckcia.rs:34:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut i = 0;\n    while i < nums_copy.len() {\n \
    \       sum += nums_copy[i];\n        if sum > 0 {\n            nums_sorted.swap(i,\
    \ nums_sorted.len() - 1);\n            i += 1;\n        }\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpc7wtpfrn.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpc7wtpfrn.rs:18:33\n   |\n18 |\
    \             nums_sorted.swap(i, nums_sorted.len() - 1);\n   |             --------------------^^^^^^^^^^^^^^^^^-----\n\
    \   |             |           |       |\n   |             |           |      \
    \ immutable borrow occurs here\n   |             |           mutable borrow later\
    \ used by call\n   |             mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpc7wtpfrn.rs:18:33\n   |\n18\
    \ |             nums_sorted.swap(i, nums_sorted.len() - 1);\n   |            \
    \                     ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local as\
    \ the argument to this call\n  --> /tmp/tmpc7wtpfrn.rs:18:13\n   |\n18 |     \
    \        nums_sorted.swap(i, nums_sorted.len() - 1);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x;\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp_6cny8c2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums_copy.len() {\n        nums_sum += nums_copy[nums_index];\n        while\
    \ nums_sum > 0 {\n            nums_sorted[nums_index] = nums_sum % 10;\n     \
    \       nums_sum += nums_sum / 10;\n            nums_index += 1;\n        }\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmpvuw87zkg.rs:18:13

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = Vec::<isize>::new();\n    let mut num_sum = 0;\n  \
    \  for num in nums {\n        num_sum += num;\n        sorted_nums.push(num);\n\
    \    }\n    sorted_nums.sort_by_key(|num| num_sum.partial_cmp(&num).unwrap());\n\
    \    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpaad0j3o1.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index +=\n            if nums_copy[index] > 0 { 1 } else { -1 };\n  \
    \  }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits().unwrap().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp4roohuxz.rs:17:50\n\
    \   |\n17 |             if nums_copy[index] > 0 { 1 } else { -1 };\n   |     \
    \                                             ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0599]: no method named `to_digits` found for\
    \ reference `&isize` in the current scope\n  --> /tmp/tmp4roohuxz.rs:20:17\n \
    \  |\n20 |         sum - x.to_digits().unwrap().sum()\n   |                 ^^^^^^^^^\
    \ method not found in `&isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum < 0 {\n            sum =\
    \ 0;\n            index += 1;\n            continue;\n        }\n        nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        index += 1;\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbsurujtu.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpbsurujtu.rs:22:33\n   |\n22 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpbsurujtu.rs:22:33\n   |\n22\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpbsurujtu.rs:22:9\n  \
    \ |\n22 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut nums_sorted_by_sum: Vec<isize> = Vec::new();\n    let mut nums_sorted_by_index:\
    \ Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_index: Vec<isize> =\
    \ Vec::new();\n    let mut nums_sorted_by_sum_and_index: Vec<isize> = Vec::new();\n\
    \    let mut nums_sorted_by_sum_and_index_2: Vec<isize> = Vec::new();\n    let\
    \ mut nums_sorted_by_sum_and_index_3: Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_4:\
    \ Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_5: Vec<isize>\
    \ = Vec::new();\n    let mut nums_sorted_by_sum_and_index_6: Vec<isize> = Vec::new();\n\
    \    let mut nums_sorted_by_sum_and_index_7: Vec<isize> = Vec::new();\n    let\
    \ mut nums_sorted_by_sum_and_index_8: Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_9:\
    \ Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_10: Vec<isize>\
    \ = Vec::new();\n    let mut nums_sorted_by_sum_and_index_11: Vec<isize> = Vec::new();\n\
    \    let mut nums_sorted_by_sum_and_index_12: Vec<isize> = Vec::new();\n    let\
    \ mut nums_sorted_by_sum_and_index_13: Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_14:\
    \ Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_15: Vec<isize>\
    \ = Vec::new();\n    let mut nums_sorted_by_sum_and_index_16: Vec<isize> = Vec::new();\n\
    \    let mut nums_sorted_by_sum_and_index_17: Vec<isize> = Vec::new();\n    let\
    \ mut nums_sorted_by_sum_and_index_18: Vec<isize> = Vec::new();\n    let mut nums_sorted_by_sum_and_index_19:\
    \ Vec<isize> = Vec::new();\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph9wqvel0.rs:10:41\n   |\n\
    10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmpf5q4q8mi.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut min_sum = nums.iter().min().unwrap();\n   \
    \ let mut max_sum = nums.iter().max().unwrap();\n    let mut min_num = nums.iter().min().unwrap();\n\
    \    let mut max_num = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().min().unwrap();\n\
    \    let mut max_idx = nums.iter().max().unwrap();\n    let mut min_idx = nums.iter().\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmpi8_om2gh.rs:49:1\n   |\n49\
    \ | }\n   | ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpi8_om2gh.rs:48:35\n\
    \   |\n48 |     let mut min_idx = nums.iter().\n   |                         \
    \          ^ help: add `;` here\n49 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi8_om2gh.rs:10:41\n   |\n10 | fn order_by_points(nums:\
    \ Vec<isize>) -> Vec<isize> {\n   |    ---------------                      ^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &d in &nums_copy {\n            sum += *d;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptum112tn.rs:15:20\n\
    \   |\n15 |             sum += *d;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut min_sum = 0;\n    let mut max_sum = 0;\n  \
    \  let mut min_idx = nums_sorted.iter().min_by_key(|&x| {\n        sum += x;\n\
    \        sum\n    });\n    let mut max_idx = nums_sorted.iter().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    while let Some(idx) = min_idx\
    \ {\n        if sum < min_sum {\n            min_sum = sum;\n            min_idx\
    \ = idx;\n        }\n        if sum > max_sum {\n            max_sum = sum;\n\
    \            max_idx = idx;\n        }\n        sum -= nums_sorted[idx];\n   \
    \     nums_sorted.remove(idx);\n    }\n    while let Some(idx) = max_idx {\n \
    \       if sum < min_sum {\n            min_sum = sum;\n            min_idx =\
    \ idx;\n        }\n        if sum > max_sum {\n            max_sum = sum;\n  \
    \          max_idx = idx;\n        }\n        sum -= nums_sorted[idx];\n     \
    \   nums_sorted.remove(idx);\n    }\n    nums_sorted.extend(nums_sorted.iter().cloned());\n\
    \    nums_sorted.sort_by_key(|&x| {\n        sum\n    });\n    nums_sorted\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp87tk1dy6.rs:27:23\n   |\n\
    16 |       let mut min_idx = nums_sorted.iter().min_by_key(|&x| {\n   |  _______________________-\n\
    17 | |         sum += x;\n18 | |         sum\n19 | |     });\n   | |______- expected\
    \ due to this value\n...\n27 |               min_idx = idx;\n   |            \
    \             ^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n27 |             min_idx = Some(idx);\n   |\
    \                       +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp87tk1dy6.rs:31:23\n\
    \   |\n20 |       let mut max_idx = nums_sorted.iter().max_by_key(|&x| {\n   |\
    \  _______________________-\n21 | |         sum += x;\n22 | |         sum\n23\
    \ | |     });\n   | |______- expected due to this value\n...\n31 |           \
    \    max_idx = idx;\n   |                         ^^^ expected enum `Option`,\
    \ found `&isize`\n   |\n   = note:   expected enum `Option<&isize>`\n        \
    \   found reference `&isize`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n31 |             max_idx = Some(idx);\n   |                       +++++ \
    \  +\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  -->\
    \ /tmp/tmp87tk1dy6.rs:33:16\n   |\n33 |         sum -= nums_sorted[idx];\n   |\
    \                ^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<&isize>`\
    \ for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp87tk1dy6.rs:34:28\n\
    \   |\n34 |         nums_sorted.remove(idx);\n   |                           \
    \ ^^^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp87tk1dy6.rs:39:23\n   |\n16 |       let mut min_idx = nums_sorted.iter().min_by_key(|&x|\
    \ {\n   |  _______________________-\n17 | |         sum += x;\n18 | |        \
    \ sum\n19 | |     });\n   | "
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for &d in &nums_sorted {\n            sum +=\
    \ d;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpn3c_gwhy.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_sorted`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpn3c_gwhy.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -           -----------\
    \ ^^^ immutable borrow occurs here\n   |       |           |\n   |  _____|   \
    \        mutable borrow later used by call\n   | |\n13 | |         let mut sum\
    \ = 0;\n14 | |         for &d in &nums_sorted {\n   | |                    -----------\
    \ second borrow occurs due to use of `nums_sorted` in closure\n15 | |        \
    \     sum += d;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut min_sum\
    \ = 0;\n    let mut min_idx = nums.iter().min_by_key(|&x| {\n        sum += x;\n\
    \        sum\n    });\n    let mut max_idx = nums.iter().max_by_key(|&x| {\n \
    \       sum += x;\n        sum\n    });\n    while min_idx != max_idx {\n    \
    \    if sum < min_sum {\n            min_sum = sum;\n            min_idx = nums_copy.iter().min_by_key(|&x|\
    \ {\n                sum += x;\n                sum\n            });\n       \
    \ } else if sum > min_sum {\n            max_idx = nums_copy.iter().max_by_key(|&x|\
    \ {\n                sum += x;\n                sum\n            });\n       \
    \ } else {\n            break;\n        }\n    }\n    nums_copy.swap_remove(min_idx);\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp41_2pzps.rs:38:27\n   |\n\
    38 |     nums_copy.swap_remove(min_idx);\n   |                           ^^^^^^^\
    \ expected `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Option<&isize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc99nr4z.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x > sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `nums_copy`\n  --> /tmp/tmpievmarl2.rs:11:13\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_nums_copy`\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpievmarl2.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpievmarl2.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x > sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^---------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpievmarl2.rs:18:37\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x > sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpievmarl2.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x > sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for &d in &x {\n            sum += d;\n   \
    \     }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&&isize` is not an iterator\n  --> /tmp/tmp1u2fuzjn.rs:14:19\n\
    \   |\n14 |         for &d in &x {\n   |                   ^^ `&&isize` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&&isize`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = -1;\n\
    \    let mut min_sum = 0;\n    let mut min_index = -1;\n    let mut min_value\
    \ = nums_copy[0];\n    let mut max_value = nums_copy[0];\n    for i in nums_copy.iter().rev()\
    \ {\n        sum += i;\n        if sum > max_sum {\n            max_sum = sum;\n\
    \            max_index = i;\n        }\n        if sum < min_sum {\n         \
    \   min_sum = sum;\n            min_index = i;\n        }\n    }\n    for i in\
    \ nums_copy.iter_mut() {\n        *i = *i + max_index;\n        if *i < min_index\
    \ {\n            *i = min_index;\n        }\n    }\n    for i in nums_sorted.iter_mut()\
    \ {\n        *i = *i + max_index;\n        if *i < min_index {\n            *i\
    \ = min_index;\n        }\n    }\n    nums_sorted.reverse();\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj3m_qovc.rs:24:25\n   |\n\
    15 |     let mut max_index = -1;\n   |                         -- expected due\
    \ to this value\n...\n24 |             max_index = i;\n   |                  \
    \       ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n24 |             max_index = *i;\n   |                   \
    \      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3m_qovc.rs:28:25\n\
    \   |\n17 |     let mut min_index = -1;\n   |                         -- expected\
    \ due to this value\n...\n28 |             min_index = i;\n   |              \
    \           ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n28 |             min_index = *i;\n   |                   \
    \      +\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = std::isize::MAX;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::MAX;\n    let mut max_idx = std::isize::MIN;\n\
    \    let mut min_idx = std::isize::\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmphbl5iet0.rs:55:1\n\
    \   |\n55 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum < 0 {\n            sum =\
    \ 0;\n            index += 1;\n            continue;\n        }\n        nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        index += 1;\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpbsurujtu.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpbsurujtu.rs:22:33\n   |\n22 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpbsurujtu.rs:22:33\n   |\n22\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpbsurujtu.rs:22:9\n  \
    \ |\n22 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &d in &nums_copy {\n            sum += d;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr6sy17w9.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmpr6sy17w9.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n13 | |         let mut sum = 0;\n\
    14 | |         for &d in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n15 | |             sum +=\
    \ d;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|&num|\
    \ {\n        sum - num\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7sej_2sj.rs:13:9\n   |\n\
    13 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in &mut sorted_nums {\n            sum\
    \ += *x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpamlfwqc4.rs:12:30\n   |\n\
    12 |     sorted_nums.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `sorted_nums`\
    \ as mutable more than once at a time\n  --> /tmp/tmpamlfwqc4.rs:12:29\n   |\n\
    12 |       sorted_nums.sort_by_key(|x| {\n   |       -           ----------- ^^^\
    \ second mutable borrow occurs here\n   |       |           |\n   |  _____|  \
    \         first borrow later used by call\n   | |\n13 | |         let mut sum\
    \ = 0;\n14 | |         for x in &mut sorted_nums {\n   | |                   \
    \    ----------- second borrow occurs due to use of `sorted_nums` in closure\n\
    15 | |             sum += *x;\n16 | |         }\n17 | |         sum\n18 | |  \
    \   });\n   | |______- first mutable borrow occurs here\n\nerror: aborting due\
    \ to previous error; 1 warning emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_sorted.len() {\n        sum += nums_sorted[index];\n\
    \        if sum < 0 {\n            sum = 0;\n            index += 1;\n       \
    \ } else {\n            sum -= nums_sorted[index];\n            index += 1;\n\
    \        }\n    }\n    nums_sorted.sort_by_key(|x| sum);\n    nums_sorted\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp8kqwpnge.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut min_sum = 0;\n    let mut min_idx = nums.iter().cloned().enumerate().min_by_key(|(_,\
    \ v)| {\n        sum += v;\n        if sum > max_sum {\n            max_sum =\
    \ sum;\n            Some(v.0)\n        } else if sum < min_sum {\n           \
    \ min_sum = sum;\n            Some(v.0)\n        } else {\n            None\n\
    \        }\n    });\n    let mut max_idx = nums.iter().cloned().enumerate().max_by_key(|(_,\
    \ v)| {\n        sum += v;\n        if sum > max_sum {\n            max_sum =\
    \ sum;\n            Some(v.0)\n        } else if sum < min_sum {\n           \
    \ min_sum = sum;\n            Some(v.0)\n        } else {\n            None\n\
    \        }\n    });\n    let mut sorted_nums = nums_copy.clone();\n    sorted_nums.sort_by_key(|&x|\
    \ {\n        let mut i = x;\n        let mut j = nums_copy.iter().cloned().enumerate().min_by_key(|(_,\
    \ v)| {\n            i += v;\n            if i > j {\n                Some(v.0)\n\
    \            } else {\n                None\n            }\n        });\n    \
    \    j\n    });\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `j` in this scope\n  --> /tmp/tmpimlklv1o.rs:44:20\n\
    \   |\n44 |             if i > j {\n   |                    ^ help: a local variable\
    \ with a similar name exists: `i`\n\nerror[E0609]: no field `0` on type `&isize`\n\
    \  --> /tmp/tmpimlklv1o.rs:19:20\n   |\n19 |             Some(v.0)\n   |     \
    \               ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpimlklv1o.rs:22:20\n\
    \   |\n22 |             Some(v.0)\n   |                    ^\n\nerror[E0609]:\
    \ no field `0` on type `&isize`\n  --> /tmp/tmpimlklv1o.rs:31:20\n   |\n31 | \
    \            Some(v.0)\n   |                    ^\n\nerror[E0609]: no field `0`\
    \ on type `&isize`\n  --> /tmp/tmpimlklv1o.rs:34:20\n   |\n34 |             Some(v.0)\n\
    \   |                    ^\n\nerror[E0609]: no field `0` on type `&isize`\n  -->\
    \ /tmp/tmpimlklv1o.rs:45:24\n   |\n45 |                 Some(v.0)\n   |      \
    \                  ^\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0609.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_index = -1;\n    for &i in nums_copy {\n        sum +=\
    \ i;\n        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = i;\n        }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpflh7l5r7.rs:15:9\n   |\n\
    15 |     for &i in nums_copy {\n   |         ^^    --------- this expression has\
    \ type `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `i`\n   |\n \
    \  = note:   expected type `isize`\n           found reference `&_`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpflh7l5r7.rs:14:25\n\
    \   |\n14 |     let mut max_index = -1;\n   |                         ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums.len() {\n        nums_sum += nums_copy[nums_index];\n        if nums_sum\
    \ < 0 {\n            nums_sum = 0;\n            nums_index += 1;\n        }\n\
    \        while nums_index < nums.len() {\n            if nums_sum == nums_copy[nums_index]\
    \ {\n                nums_sorted.swap(nums_index, nums_index + 1);\n         \
    \       nums_index += 1;\n            }\n            nums_index += 1;\n      \
    \  }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[11, 1, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpvz59pzgy.rs:34:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &i in &nums_copy {\n            sum += i;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp2rflyw83.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp2rflyw83.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n13 | |         let mut sum = 0;\n\
    14 | |         for &i in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n15 | |             sum +=\
    \ i;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- mutable\
    \ borrow occurs here\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        let digit = nums_copy[index].unwrap();\n\
    \        sum += digit;\n        if sum > 0 {\n            index += 1;\n      \
    \      sum -= digit;\n        } else {\n            nums_copy[index].swap(index);\n\
    \            index += 1;\n        }\n    }\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpxaokubrk.rs:15:38\n   |\n15 |         let digit = nums_copy[index].unwrap();\n\
    \   |                                      ^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `swap` found for type `isize` in the current scope\n\
    \  --> /tmp/tmpxaokubrk.rs:21:30\n   |\n21 |             nums_copy[index].swap(index);\n\
    \   |                              ^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in\
    \ nums_sorted {\n        sum += num;\n        nums_sorted.swap_remove(|x| {\n\
    \            match x.checked_mul(10).unwrap() {\n                Some(x) => x\
    \ > sum,\n                None => false,\n            }\n        });\n    }\n\
    \    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpbdkb3qtn.rs:15:34\n\
    \   |\n15 |         nums_sorted.swap_remove(|x| {\n   |                      \
    \            ^ consider giving this closure parameter a type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmpc8gjfsxh.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut min_sum\
    \ = nums_copy.iter().min().unwrap();\n    let mut max_sum = nums_copy.iter().max().unwrap();\n\
    \    let mut min_idx = nums_copy.iter().min_by_key(|&x| x).unwrap();\n    let\
    \ mut max_idx = nums_copy.iter().max_by_key(|&x| x).unwrap();\n\n    while nums_copy.len()\
    \ > 0 {\n        let mut idx = nums_copy.iter().position(|&x| x >= 0).unwrap();\n\
    \        let mut digit = nums_copy[idx].to_digit();\n        let mut next_digit\
    \ = nums_copy[idx + 1].to_digit();\n        let mut next_next_digit = nums_copy[idx\
    \ + 2].to_digit();\n        let mut next_next_next_digit = nums_copy[idx + 3].to_digit();\n\
    \n        if digit + next_digit + next_next_digit + next_next_next_digit > sum\
    \ {\n            sum = digit + next_digit + next_next_digit + next_next_next_digit;\n\
    \            min_sum = min_sum.min(digit);\n            max_sum = max_sum.max(digit);\n\
    \            min_idx = min_idx.min(idx);\n            max_idx = max_idx.max(idx);\n\
    \        }\n        nums_copy.remove(&idx);\n    }\n    nums_copy.sort_by_key(|&x|\
    \ x.cmp(&min_sum));\n    nums_copy.sort_by_key(|&x| x.cmp(&max_sum));\n    nums_copy.sort_by_key(|&x|\
    \ x.cmp(&min_idx));\n    nums_copy.sort_by_key(|&x| x.cmp(&max_idx));\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digit` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpf5pi4jar.rs:20:40\n   |\n20 |         let mut digit\
    \ = nums_copy[idx].to_digit();\n   |                                        ^^^^^^^^\
    \ method not found in `isize`\n\nerror[E0599]: no method named `to_digit` found\
    \ for type `isize` in the current scope\n  --> /tmp/tmpf5pi4jar.rs:21:49\n   |\n\
    21 |         let mut next_digit = nums_copy[idx + 1].to_digit();\n   |       \
    \                                          ^^^^^^^^ method not found in `isize`\n\
    \nerror[E0599]: no method named `to_digit` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpf5pi4jar.rs:22:54\n   |\n22 |         let mut next_next_digit\
    \ = nums_copy[idx + 2].to_digit();\n   |                                     \
    \                 ^^^^^^^^ method not found in `isize`\n\nerror[E0599]: no method\
    \ named `to_digit` found for type `isize` in the current scope\n  --> /tmp/tmpf5pi4jar.rs:23:59\n\
    \   |\n23 |         let mut next_next_next_digit = nums_copy[idx + 3].to_digit();\n\
    \   |                                                           ^^^^^^^^ method\
    \ not found in `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5pi4jar.rs:29:35\n\
    \   |\n29 |             min_idx = min_idx.min(idx);\n   |                    \
    \               ^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpf5pi4jar.rs:30:35\n   |\n30 |             max_idx = max_idx.max(idx);\n\
    \   |                                   ^^^ expected `&isize`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpf5pi4jar.rs:32:26\n   |\n32 |\
    \         nums_copy.remove(&idx);\n   |                          ^^^^ expected\
    \ `usize`, found `&usize`\n   |\nhelp: consider removing the borrow\n   |\n32\
    \ -         nums_copy.remove(&idx);\n32 +         nums_copy.remove(idx);\n   |\
    \ \n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        if sum > 0 {\n            break;\n        }\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|&x| {\n        let mut\
    \ y = x;\n        let mut z = y;\n        while z > 0 {\n            y /= 10;\n\
    \            z /= 10;\n        }\n        y - z\n    });\n    nums_copy\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpgzfqolol.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in\
    \ nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|num|\
    \ {\n        sum - num\n    });\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_sorted`\n   --> /tmp/tmpj5gbow_n.rs:16:5\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ move occurs because `nums_sorted` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for num in nums_sorted\
    \ {\n    |                  ----------- `nums_sorted` moved due to this implicit\
    \ call to `.into_iter()`\n...\n16  | /     nums_sorted.sort_by_key(|num| {\n17\
    \  | |         sum - num\n18  | |     });\n    | |______^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `nums_sorted`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_sorted\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &n in &nums_copy {\n            sum += *n as\
    \ isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptsyw5aqw.rs:15:20\n\
    \   |\n15 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums_copy.len() {\n        nums_sum += nums_copy[nums_index];\n        if\
    \ nums_sum < 0 {\n            nums_sum = 0;\n            nums_index += 1;\n  \
    \      }\n        if nums_sum == 0 {\n            nums_sorted[nums_index] = nums_index;\n\
    \            nums_index += 1;\n        }\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplvtkma91.rs:22:39\n   |\n\
    22 |             nums_sorted[nums_index] = nums_index;\n   |             -----------------------\
    \   ^^^^^^^^^^ expected `isize`, found `usize`\n   |             |\n   |     \
    \        expected due to the type of this binding\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .cloned()\n        .sort_by_key(|&x| {\n \
    \           let mut sum = 0;\n            let mut digit = 0;\n            for\
    \ &d in &x {\n                sum += d;\n                digit += d / 10;\n  \
    \          }\n            sum\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Cloned` in\
    \ the current scope\n  --> /tmp/tmpchxtf4fv.rs:14:10\n   |\n14 |         .sort_by_key(|&x|\
    \ {\n   |          ^^^^^^^^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for num in\
    \ nums_sorted {\n        sum += num;\n    }\n    let mut nums_sorted = nums_sorted.iter().cloned().collect::<Vec<_>>();\n\
    \    nums_sorted.sort_by_key(|&x| {\n        sum - x;\n    });\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpujrndwf8.rs:11:9\n\
    \   |\n11 |     let mut nums_sorted = nums.clone();\n   |         ----^^^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `nums_sorted`\n   -->\
    \ /tmp/tmpujrndwf8.rs:16:27\n    |\n11  |     let mut nums_sorted = nums.clone();\n\
    \    |         --------------- move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n12  |     let mut sum = 0;\n13  |\
    \     for num in nums_sorted {\n    |                ----------- `nums_sorted`\
    \ moved due to this implicit call to `.into_iter()`\n...\n16  |     let mut nums_sorted\
    \ = nums_sorted.iter().cloned().collect::<Vec<_>>();\n    |                  \
    \         ^^^^^^^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this\
    \ function takes ownership of the receiver `self`, which moves `nums_sorted`\n\
    \    = note: borrow occurs due to deref coercion to `[isize]`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n13  |     for num in &nums_sorted {\n    |              \
    \  +\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index +=\n            match nums_copy[index] % 10 {\n               \
    \ 0 => 1,\n                1 => 2,\n                2 => 3,\n                3\
    \ => 4,\n                4 => 5,\n                5 => 6,\n                6 =>\
    \ 7,\n                7 => 8,\n                8 => 9,\n                _ => panic!(\"\
    Invalid input\"),\n            };\n    }\n    nums_copy.sort_by_key(|x| sum +\
    \ x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input'', /tmp/tmpgli82228.rs:27:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit we already have\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x;\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp8bpgry4i.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.digits().sum().unwrap()\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `digits` found for reference `&isize` in\
    \ the current scope\n  --> /tmp/tmp0478v0ig.rs:19:17\n   |\n19 |         sum -\
    \ x.digits().sum().unwrap()\n   |                 ^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        sum += nums_sorted.pop();\n        if sum < 0 {\n            sum\
    \ = 0;\n            index += 1;\n        }\n        nums_sorted.push(index);\n\
    \    }\n    nums_sorted.reverse();\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmpyvki8wk4.rs:16:13\n\
    \   |\n16 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum: isize = 0;\n    let mut nums_index: usize = 0;\n    let\
    \ mut nums_sum_index: usize = 0;\n    let mut nums_sum_index2: usize = 0;\n  \
    \  let mut nums_sum_index3: usize = 0;\n    let mut nums_sum_index4: usize = 0;\n\
    \    let mut nums_sum_index5: usize = 0;\n    let mut nums_sum_index6: usize =\
    \ 0;\n    let mut nums_sum_index7: usize = 0;\n    let mut nums_sum_index8: usize\
    \ = 0;\n    let mut nums_sum_index9: usize = 0;\n    let mut nums_sum_index10:\
    \ usize = 0;\n    let mut nums_sum_index11: usize = 0;\n    let mut nums_sum_index12:\
    \ usize = 0;\n    let mut nums_sum_index13: usize = 0;\n    let mut nums_sum_index14:\
    \ usize = 0;\n    let mut nums_sum_index15: usize = 0;\n    let mut nums_sum_index16:\
    \ usize = 0;\n    let mut nums_sum_index17: usize = 0;\n    let mut nums_sum_index18:\
    \ usize = 0;\n    let mut nums_sum_index19: usize = 0;\n    let mut nums_sum_index20:\
    \ usize = 0;\n    let mut nums_sum_index21: usize = 0;\n    let mut nums_sum_index22:\
    \ usize = 0;\n    let mut nums_sum_index23: usize = 0;\n    let mut nums_sum_index24:\
    \ usize = 0;\n    let mut nums_sum_index25: usize = 0;\n    let mut nums_sum_index26:\
    \ usize = 0;\n    let mut nums_sum_index27: usize = 0;\n    let mut nums_sum_index28:\
    \ usize = 0;\n    let mut nums_sum_index29: usize = 0;\n    let mut nums_sum_index30:\
    \ usize = 0;\n    let mut nums_sum_index31: usize = 0;\n    let mut nums_sum_index32:\
    \ usize = 0;\n    let mut nums_sum_index33: usize = 0;\n    let mut nums_sum_index34:\
    \ usize = 0;\n    let mut nums_sum_index35: usize = 0;\n    let mut nums_sum_index36:\
    \ usize = 0;\n    let mut nums_sum_index\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp6tck6d_.rs:51:27\n   |\n\
    51 |     let mut nums_sum_index\n   |                           ^ help: add `;`\
    \ here\n52 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp6tck6d_.rs:10:41\n   |\n10 | fn order_by_points(nums: Vec<isize>) ->\
    \ Vec<isize> {\n   |    ---------------                      ^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum < 0 {\n            sum\
    \ = 0;\n            index += 1;\n        } else {\n            sum += nums_sorted[index];\n\
    \            index += 1;\n        }\n    }\n    while index < nums_sorted.len()\
    \ {\n        nums_sorted.swap(index, nums_sorted.len() - 1);\n        index +=\
    \ 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpojb2vyt5.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpojb2vyt5.rs:26:33\n   |\n26 |\
    \         nums_sorted.swap(index, nums_sorted.len() - 1);\n   |         ------------------------^^^^^^^^^^^^^^^^^-----\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpojb2vyt5.rs:26:33\n   |\n26\
    \ |         nums_sorted.swap(index, nums_sorted.len() - 1);\n   |            \
    \                     ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local as\
    \ the argument to this call\n  --> /tmp/tmpojb2vyt5.rs:26:9\n   |\n26 |      \
    \   nums_sorted.swap(index, nums_sorted.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .enumerate()\n        .sort_by(|(idx, &num),\
    \ (_, other_num)| num.partial_cmp(&other_num).unwrap())\n        .map(|(idx, num)|\
    \ idx)\n        .collect()\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpk_zd4rnu.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ &num), (_, other_num)| num.partial_cmp(&other_num).unwrap())\n   |         \
    \ ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_, isize>>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += *x;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpogaqsgl1.rs:15:20\n\
    \   |\n15 |             sum += *x;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in &mut sorted_nums {\n            sum\
    \ += x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `&mut isize` to `{integer}`\n  --> /tmp/tmp9ztduoqa.rs:15:17\n\
    \   |\n15 |             sum += x;\n   |                 ^^ no implementation for\
    \ `{integer} += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut min_sum\
    \ = 0;\n    let mut max_sum = 0;\n    let mut min_idx = nums.iter().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut max_idx = nums.iter().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    while let Some(idx) = min_idx\
    \ {\n        if sum < min_sum {\n            min_sum = sum;\n            min_idx\
    \ = idx;\n        }\n        if sum > max_sum {\n            max_sum = sum;\n\
    \            max_idx = idx;\n        }\n        sum -= nums[idx];\n        nums_copy.remove(&idx);\n\
    \    }\n    while let Some(idx) = max_idx {\n        if sum < min_sum {\n    \
    \        min_sum = sum;\n            min_idx = idx;\n        }\n        if sum\
    \ > max_sum {\n            max_sum = sum;\n            max_idx = idx;\n      \
    \  }\n        sum -= nums[idx];\n        nums_copy.remove(&idx);\n    }\n    nums_copy.extend(nums.iter().cloned());\n\
    \    nums_copy.sort();\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5b72jr57.rs:26:23\n   |\n\
    15 |       let mut min_idx = nums.iter().min_by_key(|&x| {\n   |  _______________________-\n\
    16 | |         sum += x;\n17 | |         sum\n18 | |     });\n   | |______- expected\
    \ due to this value\n...\n26 |               min_idx = idx;\n   |            \
    \             ^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n26 |             min_idx = Some(idx);\n   |\
    \                       +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5b72jr57.rs:30:23\n\
    \   |\n19 |       let mut max_idx = nums.iter().max_by_key(|&x| {\n   |  _______________________-\n\
    20 | |         sum += x;\n21 | |         sum\n22 | |     });\n   | |______- expected\
    \ due to this value\n...\n30 |               max_idx = idx;\n   |            \
    \             ^^^ expected enum `Option`, found `&isize`\n   |\n   = note:   expected\
    \ enum `Option<&isize>`\n           found reference `&isize`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n30 |             max_idx = Some(idx);\n   |\
    \                       +++++   +\n\nerror[E0277]: the type `[isize]` cannot be\
    \ indexed by `&isize`\n  --> /tmp/tmp5b72jr57.rs:32:16\n   |\n32 |         sum\
    \ -= nums[idx];\n   |                ^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5b72jr57.rs:33:26\n\
    \   |\n33 |         nums_copy.remove(&idx);\n   |                          ^^^^\
    \ expected `usize`, found `&&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5b72jr57.rs:38:23\n\
    \   |\n15 |       let mut min_idx = nums.iter().min_by_key(|&x| {\n   |  _______________________-\n\
    16 | |         sum += x;\n17 | |         sum\n18 | |     });\n   | |______- expected\
    \ due to this value\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut min_sum = 0;\n  \
    \  let mut min_idx = 0;\n    let mut max_idx = 0;\n    let mut min_idx = nums.iter().min_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    let mut max_idx = nums.iter().max_by_key(|&x|\
    \ {\n        sum += x;\n        sum\n    });\n    while nums_sorted.len() > 0\
    \ {\n        let mut min_idx = nums_sorted.iter().min_by_key(|&x| {\n        \
    \    sum += x;\n            sum\n        });\n        let mut max_idx = nums_sorted.iter().max_by_key(|&x|\
    \ {\n            sum += x;\n            sum\n        });\n        if min_idx ==\
    \ max_idx {\n            break;\n        }\n        if min_idx < max_idx {\n \
    \           if sum < nums_sorted[min_idx] {\n                nums_sorted.swap(min_idx,\
    \ max_idx);\n                sum -= nums_sorted[min_idx];\n                min_idx\
    \ = nums_sorted.iter().min_by_key(|&x| {\n                    sum += x;\n    \
    \                sum\n                });\n            }\n        } else {\n \
    \           if sum > nums_sorted[max_idx] {\n                nums_sorted.swap(max_idx,\
    \ min_idx);\n                sum -= nums_sorted[max_idx];\n                max_idx\
    \ = nums_sorted.iter().max_by_key(|&x| {\n                    sum += x;\n    \
    \                sum\n                });\n            }\n        }\n    }\n \
    \   nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpkxo2m2wy.rs:39:22\n   |\n39 |             if sum < nums_sorted[min_idx]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<&isize>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkxo2m2wy.rs:40:34\n   |\n40 |              \
    \   nums_sorted.swap(min_idx, max_idx);\n   |                                \
    \  ^^^^^^^ expected `usize`, found enum `Option`\n   |\n   = note: expected type\
    \ `usize`\n              found enum `Option<&isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkxo2m2wy.rs:40:43\n   |\n40 |                 nums_sorted.swap(min_idx,\
    \ max_idx);\n   |                                           ^^^^^^^ expected `usize`,\
    \ found enum `Option`\n   |\n   = note: expected type `usize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `Option<&isize>`\n  --> /tmp/tmpkxo2m2wy.rs:41:24\n   |\n41 |           \
    \      sum -= nums_sorted[min_idx];\n   |                        ^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[isize]>` is not implemented for `Option<&isize>`\n   = note:\
    \ required because of the requirements on the impl of `Index<Option<&isize>>`\
    \ for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `Option<&isize>`\n\
    \  --> /tmp/tmpkxo2m2wy.rs:48:22\n   |\n48 |             if sum > nums_sorted[max_idx]\
    \ {\n   |                      ^^^^^^^^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `Option<&isize>`\n   = note: required because of the\
    \ requirements on the impl of `Index<Option<&isize>>` for `Vec<isize>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkxo2m2wy.rs:49:34\n   |\n49 |              \
    \   nums_sorted"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut min_sum\
    \ = nums.iter().min().unwrap();\n    let mut max_sum = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = nums.iter().max().unwrap();\n\
    \    let mut min_idx = nums.iter().min().unwrap();\n    let mut max_idx = num\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1jb9euac.rs:48:26\n   |\n\
    48 |     let mut max_idx = num\n   |                          ^ help: add `;`\
    \ here\n49 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `num`\
    \ in this scope\n  --> /tmp/tmp1jb9euac.rs:48:23\n   |\n48 |     let mut max_idx\
    \ = num\n   |                       ^^^ help: a local variable with a similar\
    \ name exists: `nums`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1jb9euac.rs:10:41\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x + sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnoeaql4g.rs:18:70\n   |\n\
    18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x +\
    \ sum).unwrap());\n   |                                                      \
    \                ^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        if sum > 0 {\n            index += 1;\n        } else {\n           \
    \ sum -= nums_copy[index];\n            index += 1;\n        }\n    }\n    nums_copy.sort_by_key(|&x|\
    \ x.checked_mul(10).unwrap());\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-12, -11, -1, 1, 11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpe58ss6zr.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sum = 0;\n    let mut nums_index = 0;\n    while nums_index\
    \ < nums.len() {\n        nums_sum += nums_copy[nums_index];\n        if nums_sum\
    \ < 0 {\n            nums_sum = 0;\n            nums_index += 1;\n        }\n\
    \        while nums_sum > nums_copy[nums_index] {\n            nums_sum -= nums_copy[nums_index];\n\
    \            nums_index += 1;\n        }\n        nums_sorted.swap(nums_index,\
    \ nums_index + 1);\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 5 but the
    index is 5'', /tmp/tmpejdgxbrd.rs:21:26

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.len() - 1);\n            index -= 1;\n        } else {\n       \
    \     index += 1;\n        }\n    }\n    nums_sorted\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpgwdzima_.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpgwdzima_.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |          \
    \   ------------------------^^^^^^^^^^^^^^^^^-----\n   |             |       \
    \    |           |\n   |             |           |           immutable borrow\
    \ occurs here\n   |             |           mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpgwdzima_.rs:18:37\n   |\n18 |             nums_sorted.swap(index,\
    \ nums_sorted.len() - 1);\n   |                                     ^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpgwdzima_.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        sum += nums_sorted.pop().unwrap();\n        if sum < 0 {\n      \
    \      sum = 0;\n        }\n        if index == nums_sorted.len() {\n        \
    \    break;\n        }\n        let mut cur = nums_sorted.pop();\n        while\
    \ sum > cur {\n            nums_sorted.push(nums_sorted.pop().unwrap());\n   \
    \     }\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmkvlebd7.rs:24:21\n   |\n\
    24 |         while sum > cur {\n   |                     ^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x;\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp_6cny8c2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut nums_sorted = nums_sorted.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    let mut digit = 0;\n    let\
    \ mut max_digit = 0;\n    let mut max_digit_index = 0;\n    let mut max_digit_sum\
    \ = 0;\n    let mut max_digit_sum_index = 0;\n    let mut max_digit_sum_index2\
    \ = 0;\n    let mut max_digit_sum_index3 = 0;\n    let mut max_digit_sum_index4\
    \ = 0;\n    let mut max_digit_sum_index5 = 0;\n    let mut max_digit_sum_index6\
    \ = 0;\n    let mut max_digit_sum_index7 = 0;\n    let mut max_digit_sum_index8\
    \ = 0;\n    let mut max_digit_sum_index9 = 0;\n    let mut max_digit_sum_index10\
    \ = 0;\n    let mut max_digit_sum_index11 = 0;\n    let mut max_digit_sum_index12\
    \ = 0;\n    let mut max_digit_sum_index13 = 0;\n    let mut max_digit_sum_index14\
    \ = 0;\n    let mut max_digit_sum_index15 = 0;\n    let mut max_digit_sum_index16\
    \ = 0;\n    let mut max_digit_sum_index17 = 0;\n    let mut max_digit_sum_index18\
    \ = 0;\n    let mut max_digit_sum_index19 = 0;\n    let mut max_digit_sum_index20\
    \ = 0;\n    let mut max_digit_sum_index21 = 0;\n    let mut max_digit_sum_index22\
    \ = 0;\n    let mut max_digit_sum_index23 = 0;\n    let mut max_digit_sum_index24\
    \ = 0;\n    let mut max_digit_sum_index25 = 0;\n    let mut max_digit_sum_index26\
    \ = 0;\n    let mut max_digit_sum_index27 = 0;\n    let mut max_digit_sum_index28\
    \ = 0;\n    let mut max_digit_sum_index29 = 0;\n    let mut max_digit_sum_index30\
    \ = 0;\n    let mut max_digit_sum_index31 = 0;\n    let mut max_digit_sum_index32\
    \ = 0;\n    let mut max_digit_sum_index33 = 0;\n    let mut max_digit_sum_index34\
    \ = 0;\n    let mut max_digit_sum_index35 = 0;\n    let mut max_digit_sum_index36\
    \ = 0;\n    let mut max_digit_sum_index37 = 0;\n    let mut max_digit_sum_index38\
    \ = 0;\n    let mut max_digit_sum_index39 = 0;\n    let mut max_digit_sum_index40\
    \ = 0;\n    let mut max_digit_sum_index41 = 0;\n    let mut max_digit_sum_index42\
    \ = 0;\n    let mut max_digit_sum_index43 = 0;\n    let \n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8bvflfa8.rs:64:1\n  \
    \ |\n64 | }\n   | ^ expected pattern\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in nums_sorted {\n            sum\
    \ += x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmplz57rtq_.rs:12:39\n   |\n\
    12 |     nums_sorted.sort_unstable_by_key(|x| {\n   |                        \
    \               ^ help: if this is intentional, prefix it with an underscore:\
    \ `_x`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]:\
    \ cannot move out of `nums_sorted`, a captured variable in an `FnMut` closure\n\
    \   --> /tmp/tmplz57rtq_.rs:14:18\n    |\n11  |       let mut nums_sorted = nums.clone();\n\
    \    |           --------------- captured outer variable\n12  |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n    |  ______________________________________-\n13  | |         let mut sum\
    \ = 0;\n14  | |         for x in nums_sorted {\n    | |                  ^^^^^^^^^^^\n\
    \    | |                  |\n    | |                  `nums_sorted` moved due\
    \ to this implicit call to `.into_iter()`\n    | |                  move occurs\
    \ because `nums_sorted` has type `Vec<isize>`, which does not implement the `Copy`\
    \ trait\n15  | |             sum += x;\n16  | |         }\n17  | |         sum\n\
    18  | |     });\n    | |_____- captured by this `FnMut` closure\n    |\nnote:\
    \ this function takes ownership of the receiver `self`, which moves `nums_sorted`\n\
    help: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving\
    \ into the `for` loop\n    |\n14  |         for x in &nums_sorted {\n    |   \
    \               +\n\nerror[E0505]: cannot move out of `nums_sorted` because it\
    \ is borrowed\n  --> /tmp/tmplz57rtq_.rs:12:38\n   |\n12 |       nums_sorted.sort_unstable_by_key(|x|\
    \ {\n   |       -                                ^^^ move out of `nums_sorted`\
    \ occurs here\n   |  _____|\n   | |\n13 | |         let mut sum = 0;\n14 | | \
    \        for x in nums_sorted {\n   | |                  ----------- move occurs\
    \ due to use in closure\n15 | |             sum += x;\n16 | |         }\n17 |\
    \ |         sum\n18 | |     });\n   | |______- borrow of `nums_sorted` occurs\
    \ here\n\nerror[E0382]: use of moved value: `nums_sorted`\n  --> /tmp/tmplz57rtq_.rs:19:5\n\
    \   |\n11 |     let mut nums_sorted = nums.clone();\n   |         -----------"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = nums.clone();\n    sorted_nums.sort_unstable_by_key(|x|\
    \ {\n        let mut sum = 0;\n        for x in &mut sorted_nums {\n         \
    \   sum += x;\n        }\n        sum\n    });\n    sorted_nums\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `&mut isize` to `{integer}`\n  --> /tmp/tmp1rbehn22.rs:15:17\n\
    \   |\n15 |             sum += x;\n   |                 ^^ no implementation for\
    \ `{integer} += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index +=\n            match nums_copy[index] % 10 {\n               \
    \ 0 => 1,\n                1 => 2,\n                2 => 3,\n                3\
    \ => 4,\n                4 => 5,\n                5 => 6,\n                6 =>\
    \ 7,\n                7 => 8,\n                8 => 9,\n                _ => panic!(\"\
    Sum of digits should be in range from 0 to 9\"),\n            };\n    }\n    nums_copy.sort_by_key(|&x|\
    \ sum - x);\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Sum of digits should be in range from 0 to
    9'', /tmp/tmppu5la5ry.rs:27:22

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .enumerate()\n        .sort_by(|(idx, &num)|\
    \ *num.clone() as isize)\n        .map(|(idx, num)| idx)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Enumerate` in\
    \ the current scope\n  --> /tmp/tmpjuubm5mf.rs:14:10\n   |\n14 |         .sort_by(|(idx,\
    \ &num)| *num.clone() as isize)\n   |          ^^^^^^^ method not found in `Enumerate<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc99nr4z.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut num_sum = 0;\n    let mut num_sum_index = 0;\n    let mut num_sum_index2\
    \ = 0;\n    let mut num_sum_index3 = 0;\n    let mut num_sum_index4 = 0;\n   \
    \ let mut num_sum_index5 = 0;\n    let mut num_sum_index6 = 0;\n    let mut num_sum_index7\
    \ = 0;\n    let mut num_sum_index8 = 0;\n    let mut num_sum_index9 = 0;\n   \
    \ let mut num_sum_index10 = 0;\n    let mut num_sum_index11 = 0;\n    let mut\
    \ num_sum_index12 = 0;\n    let mut num_sum_index13 = 0;\n    let mut num_sum_index14\
    \ = 0;\n    let mut num_sum_index15 = 0;\n    let mut num_sum_index16 = 0;\n \
    \   let mut num_sum_index17 = 0;\n    let mut num_sum_index18 = 0;\n    let mut\
    \ num_sum_index19 = 0;\n    let mut num_sum_index20 = 0;\n    let mut num_sum_index21\
    \ = 0;\n    let mut num_sum_index22 = 0;\n    let mut num_sum_index23 = 0;\n \
    \   let mut num_sum_index24 = 0;\n    let mut num_sum_index25 = 0;\n    let mut\
    \ num_sum_index26 = 0;\n    let mut num_sum_index27 = 0;\n    let mut num_sum_index28\
    \ = 0;\n    let mut num_sum_index29 = 0;\n    let mut num_sum_index30 = 0;\n \
    \   let mut num_sum_index31 = 0;\n    let mut num_sum_index32 = 0;\n    let mut\
    \ num_sum_index33 = 0;\n    let mut num_sum_index34 = 0;\n    let mut num_sum_index35\
    \ = 0;\n    let mut num_sum_index36 = 0;\n    let mut num_sum_index37 = 0;\n \
    \   let mut num_sum_index38 = 0;\n    let mut num_sum_index39 = 0;\n    let mut\
    \ num_sum_index40 = 0;\n    let mut num_sum_index41 = 0;\n    let mut num_sum_index42\
    \ = 0;\n    let mut num_sum_index43 = 0;\n    let mut num_sum_index44 = 0;\n \
    \   let mut num_sum_index45 = 0;\n    let mut num_sum_index46 = 0;\n    let mut\
    \ num_sum_index47 = 0;\n    let mut num_sum_index48 = 0;\n    let mut num_sum_index49\
    \ = 0;\n    let mut num_sum_index50 = 0;\n    let mut num_sum_index51 = 0;\n \
    \   let mut num_sum_index52 = 0;\n    let mut num_sum_index53 = 0;\n    let mut\
    \ num_sum_index54 = 0;\n    let mut \n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpx2vm8c0s.rs:69:1\n\
    \   |\n69 | }\n   | ^ expected identifier\n\nerror: aborting due to previous error\n\
    \n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x;\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp_6cny8c2.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for n in nums_sorted\
    \ {\n        sum += n;\n    }\n    nums_sorted.sort_by_key(|n| {\n        sum.saturating_sub(n).expect(\"\
    sum of digits should be positive\")\n    });\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_9p79wkt.rs:17:28\n   |\n\
    17 |         sum.saturating_sub(n).expect(\"sum of digits should be positive\"\
    )\n   |                            ^ expected `isize`, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n17 |         sum.saturating_sub(*n).expect(\"\
    sum of digits should be positive\")\n   |                            +\n\nerror[E0599]:\
    \ no method named `expect` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmp_9p79wkt.rs:17:31\n   |\n17 |         sum.saturating_sub(n).expect(\"\
    sum of digits should be positive\")\n   |                               ^^^^^^\
    \ method not found in `isize`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut max_sum\
    \ = 0;\n    let mut max_index = 0;\n    for &num in nums_copy {\n        sum +=\
    \ num;\n        if sum > max_sum {\n            max_sum = sum;\n            max_index\
    \ = num;\n        }\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy.sort_unstable();\n\
    \    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnx3_evcg.rs:15:9\n   |\n\
    15 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums\n        .iter()\n        .cloned()\n        .enumerate()\n        .map(|(i,\
    \ &n)| {\n            let mut sum = 0;\n            for d in n.to_string().chars().filter(|&c|\
    \ c >= '0' && c <= '9') {\n                sum += *d as usize;\n            }\n\
    \            (*i, sum)\n        })\n        .sort_by_key(|&(i, sum)| sum)\n  \
    \      .map(|i| nums[*i])\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8xlno78y.rs:15:19\n   |\n\
    15 |         .map(|(i, &n)| {\n   |                   ^^- expected due to this\n\
    \   |                   |\n   |                   expected `isize`, found reference\n\
    \   |                   help: you can probably remove the explicit borrow: `n`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp8xlno78y.rs:20:14\n\
    \   |\n20 |             (*i, sum)\n   |              ^^\n\nerror[E0599]: no method\
    \ named `sort_by_key` found for struct `Map` in the current scope\n  --> /tmp/tmp8xlno78y.rs:22:10\n\
    \   |\n22 |         .sort_by_key(|&(i, sum)| sum)\n   |          ^^^^^^^^^^^ method\
    \ not found in `Map<Enumerate<Cloned<std::slice::Iter<'_, isize>>>, _>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit we just added\n    }\n    let mut result\
    \ = Vec::<isize>::new();\n    while index < nums_copy.len() {\n        let mut\
    \ index = index + 1; // skip the digit we just added\n        while index < nums_copy.len()\
    \ {\n            if nums_copy[index] > sum {\n                result.push(nums_copy[index]);\n\
    \                nums_copy[index] = 0;\n                break;\n            }\n\
    \            index += 1; // skip the digit we just added\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpxyffoj1h.rs:35:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpu6pxmqfm.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpu6pxmqfm.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |             ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |             |           |           |\n   |             |           |  \
    \         immutable borrow occurs here\n   |             |           mutable borrow\
    \ later used by call\n   |             mutable borrow occurs here\n   |\nhelp:\
    \ try adding a local storing this argument...\n  --> /tmp/tmpu6pxmqfm.rs:18:37\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpu6pxmqfm.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    let mut i\
    \ = 0;\n    while i < nums_sorted.len() {\n        sum += nums_sorted[i];\n  \
    \      if sum > 0 {\n            swap(&mut nums_sorted, i, 0);\n            swap(&mut\
    \ nums_sorted, i, i);\n        }\n        i += 1;\n    }\n    nums_sorted\n}\n\
    \nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpky4yk_r0.rs:17:13\n\
    \   |\n17 |             swap(&mut nums_sorted, i, 0);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0425]:\
    \ cannot find function `swap` in this scope\n  --> /tmp/tmpky4yk_r0.rs:18:13\n\
    \   |\n18 |             swap(&mut nums_sorted, i, i);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    nums_copy.sort_by_key(|x| {\n        sum - x.to_digits(10)\n\
    \    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp4drl7fcl.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits(10)\n   |                 ^^^^^^^^^ method not found in `&isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for n in nums_copy\
    \ {\n        sum += n;\n    }\n    nums_copy.sort_by_key(|n| {\n        sum -\
    \ n\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmp0nfjh7f6.rs:16:5\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for n in nums_copy\
    \ {\n    |                --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  | /     nums_copy.sort_by_key(|n| {\n17  | |   \
    \      sum - n\n18  | |     });\n    | |______^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n13  |     for n in &nums_copy {\n\
    \    |              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum.cmp(&num)\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe_muqprk.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|num| {\n        sum\
    \ - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmphqtnckbd.rs:16:5\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for num in nums_copy\
    \ {\n    |                  --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  | /     nums_copy.sort_by_key(|num| {\n17  | | \
    \        sum - num\n18  | |     });\n    | |______^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1;\n    }\n    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum += x;\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n\
    \    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[-1, -11, -12, 11, 1]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmp43fdj0ww.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|num| {\n        sum\
    \ - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmphqtnckbd.rs:16:5\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |       let mut sum = 0;\n13  |       for num in nums_copy\
    \ {\n    |                  --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  | /     nums_copy.sort_by_key(|num| {\n17  | | \
    \        sum - num\n18  | |     });\n    | |______^ value borrowed here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.len() - 1);\n            index -= 1;\n        }\n        index +=\
    \ 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `nums_copy`\n  --> /tmp/tmpymyg57kz.rs:11:13\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_nums_copy`\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpymyg57kz.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpymyg57kz.rs:18:37\n   |\n18 |\
    \             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |          \
    \   ------------------------^^^^^^^^^^^^^^^^^-----\n   |             |       \
    \    |           |\n   |             |           |           immutable borrow\
    \ occurs here\n   |             |           mutable borrow later used by call\n\
    \   |             mutable borrow occurs here\n   |\nhelp: try adding a local storing\
    \ this argument...\n  --> /tmp/tmpymyg57kz.rs:18:37\n   |\n18 |             nums_sorted.swap(index,\
    \ nums_sorted.len() - 1);\n   |                                     ^^^^^^^^^^^^^^^^^\n\
    help: ...and then using that local as the argument to this call\n  --> /tmp/tmpymyg57kz.rs:18:13\n\
    \   |\n18 |             nums_sorted.swap(index, nums_sorted.len() - 1);\n   |\
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = Vec::<isize>::new();\n    let mut num_sum = 0;\n  \
    \  for num in nums {\n        num_sum += num;\n        sorted_nums.push(num);\n\
    \    }\n    let mut num_sums = Vec::<isize>::new();\n    let mut num_sums_idx\
    \ = 0;\n    while num_sum < num_sums.len() {\n        num_sums.push(num_sum);\n\
    \        num_sums_idx += 1;\n        num_sum += num_sums[num_sums_idx];\n    }\n\
    \    sorted_nums.sort_by_key(|num| num_sums.iter().position(|&n| n == num).unwrap());\n\
    \    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n   \
    \ assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp04a_wdk.rs:19:21\n   |\n\
    19 |     while num_sum < num_sums.len() {\n   |                     ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n19 |     while num_sum\
    \ < num_sums.len().try_into().unwrap() {\n   |                               \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp04a_wdk.rs:24:70\n\
    \   |\n24 |     sorted_nums.sort_by_key(|num| num_sums.iter().position(|&n| n\
    \ == num).unwrap());\n   |                                                   \
    \                   ^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n24 |     sorted_nums.sort_by_key(|num| num_sums.iter().position(|&n|\
    \ n == *num).unwrap());\n   |                                                \
    \                      +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_sorted.len()\
    \ {\n        sum += nums_sorted[index];\n        while sum > 10 {\n          \
    \  sum -= 10;\n            index += 1;\n        }\n        nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x == sum).unwrap());\n        index += 1;\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `nums_copy`\n  --> /tmp/tmpl6p17sx2.rs:11:13\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |             ^^^^^^^^^\
    \ help: if this is intentional, prefix it with an underscore: `_nums_copy`\n \
    \  |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmpl6p17sx2.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpl6p17sx2.rs:21:33\n   |\n21 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpl6p17sx2.rs:21:33\n   |\n21\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpl6p17sx2.rs:21:9\n  \
    \ |\n21 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut min_sum = nums.iter().map(|x| x).sum();\n \
    \   let mut min_idx = nums.iter().map(|x| x).min_by_key(|x| x).unwrap();\n   \
    \ let mut max_idx = nums.iter().map(|x| x).max_by_key(|x| x).unwrap();\n\n   \
    \ while nums_copy.len() > 0 {\n        let mut idx = nums_sorted.iter().position(|x|\
    \ x == &min_sum).unwrap();\n        if idx < nums_sorted.len() {\n           \
    \ min_sum = nums_sorted[idx];\n            min_idx = idx;\n        }\n       \
    \ idx = nums_sorted.iter().position(|x| x == &max_sum).unwrap();\n        if idx\
    \ < nums_sorted.len() {\n            max_sum = nums_sorted[idx];\n           \
    \ max_idx = idx;\n        }\n        sum += nums_sorted.iter().filter(|x| x ==\
    \ &min_sum).count();\n        nums_sorted.swap_remove(min_idx);\n        nums_sorted.swap_remove(max_idx);\n\
    \    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_sum` in this scope\n  --> /tmp/tmp0kjh51do.rs:24:53\n\
    \   |\n24 |         idx = nums_sorted.iter().position(|x| x == &max_sum).unwrap();\n\
    \   |                                                     ^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_sum`\n\nerror[E0425]: cannot find\
    \ value `max_sum` in this scope\n  --> /tmp/tmp0kjh51do.rs:26:13\n   |\n26 | \
    \            max_sum = nums_sorted[idx];\n   |             ^^^^^^^ help: a local\
    \ variable with a similar name exists: `min_sum`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0kjh51do.rs:22:23\n   |\n15 |     let mut min_idx = nums.iter().map(|x|\
    \ x).min_by_key(|x| x).unwrap();\n   |                       -------------------------------------------------\
    \ expected due to this value\n...\n22 |             min_idx = idx;\n   |     \
    \                  ^^^ expected `&isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0kjh51do.rs:27:23\n   |\n16 |     let mut max_idx = nums.iter().map(|x|\
    \ x).max_by_key(|x| x).unwrap();\n   |                       -------------------------------------------------\
    \ expected due to this value\n...\n27 |             max_idx = idx;\n   |     \
    \                  ^^^ expected `&isize`, found `usize`\n\nerror[E0277]: can't\
    \ compare `&isize` with `isize`\n  --> /tmp/tmp0kjh51do.rs:29:48\n   |\n29 | \
    \        sum += nums_sorted.iter().filter(|x| x == &min_sum).count();\n   |  \
    \                                              ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n   = note: required because of the requirements on the impl\
    \ of `PartialEq<&isize>` for `&&isize`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0kjh51do.rs:30:33\n   |\n30 |         nums_sorted.swap_remove(min_idx);\n\
    \   |                                 ^^^^^^^ e"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut index = 0;\n    while index < nums_sorted.len() {\n        let mut\
    \ min_num = nums_sorted[index];\n        let mut min_pos = index;\n        for\
    \ pos in index..nums_sorted.len() {\n            if nums_sorted[pos] < min_num\
    \ {\n                min_num = nums_sorted[pos];\n                min_pos = pos;\n\
    \            }\n        }\n        nums_sorted[min_pos] = nums_sorted[index];\n\
    \        nums_sorted[index] = min_num;\n        index += 1;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `sum` is assigned to, but never used\n  --> /tmp/tmp78l8o_ox.rs:12:13\n\
    \   |\n12 |     let mut sum = 0;\n   |             ^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_sum` instead\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp78l8o_ox.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmp78l8o_ox.rs:16:27\n\
    \    |\n11  |     let mut nums_copy = nums.clone();\n    |         -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |     let mut sum = 0;\n13  |     for num in nums_copy\
    \ {\n    |                --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  |     let mut nums_sorted = nums_copy.clone();\n\
    \    |                           ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc99nr4z.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n    while index\
    \ < nums_copy.len() {\n        sum += nums_copy[index];\n        if sum > max_sum\
    \ {\n            max_sum = sum;\n            max_index = index;\n        }\n \
    \       index += 1;\n    }\n    nums_copy.swap_remove(max_index);\n    nums_copy\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, -12, -1, -11]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpwc_kbc13.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum > 0 {\n            nums_sorted.swap(index,\
    \ nums_sorted.iter().position(|&x| x + sum).unwrap());\n        }\n        index\
    \ += 1;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpely18z2j.rs:18:70\n   |\n\
    18 |             nums_sorted.swap(index, nums_sorted.iter().position(|&x| x +\
    \ sum).unwrap());\n   |                                                      \
    \                ^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &n in &nums_copy {\n            sum += *n as\
    \ isize;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n \
    \   let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1,\
    \ -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmptsyw5aqw.rs:15:20\n\
    \   |\n15 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        if sum < 0 {\n            sum =\
    \ 0;\n            index += 1;\n        }\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpm1jj46m0.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpm1jj46m0.rs:21:33\n   |\n21 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpm1jj46m0.rs:21:33\n   |\n21\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpm1jj46m0.rs:21:9\n  \
    \ |\n21 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for &d in &nums_copy {\n            sum += d *\
    \ 10;\n        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp0r2jakrd.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp0r2jakrd.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -         -----------\
    \ ^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|     \
    \    mutable borrow later used by call\n   | |\n13 | |         let mut sum = 0;\n\
    14 | |         for &d in &nums_copy {\n   | |                    --------- second\
    \ borrow occurs due to use of `nums_copy` in closure\n15 | |             sum +=\
    \ d * 10;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut num_sum = 0;\n    let mut num_digits = 0;\n    let mut num_digits_sum\
    \ = 0;\n    let mut num_digits_index = 0;\n    let mut num_digits_sum_index =\
    \ 0;\n    let mut num_digits_index2 = 0;\n    let mut num_digits_sum_index2 =\
    \ 0;\n    let mut num_digits_index3 = 0;\n    let mut num_digits_sum_index3 =\
    \ 0;\n    let mut num_digits_index4 = 0;\n    let mut num_digits_sum_index4 =\
    \ 0;\n    let mut num_digits_index5 = 0;\n    let mut num_digits_sum_index5 =\
    \ 0;\n    let mut num_digits_index6 = 0;\n    let mut num_digits_sum_index6 =\
    \ 0;\n    let mut num_digits_index7 = 0;\n    let mut num_digits_sum_index7 =\
    \ 0;\n    let mut num_digits_index8 = 0;\n    let mut num_digits_sum_index8 =\
    \ 0;\n    let mut num_digits_index9 = 0;\n    let mut num_digits_sum_index9 =\
    \ 0;\n    let mut num_digits_index10 = 0;\n    let mut num_digits_sum_index10\
    \ = 0;\n    let mut num_digits_index11 = 0;\n    let mut num_digits_sum_index11\
    \ = 0;\n    let mut num_digits_index12 = 0;\n    let mut num_digits_sum_index12\
    \ = 0;\n    let mut num_digits_index13 = 0;\n    let mut num_digits_sum_index13\
    \ = 0;\n    let mut num_digits_index14 = 0;\n    let mut num_digits_sum_index14\
    \ = 0;\n    let mut num_digits_index15 = 0;\n    let mut num_digits_sum_index15\
    \ = 0;\n    let mut num_digits_index16 = 0;\n    let mut num_digits_sum_index16\
    \ = 0;\n    let mut num_digits_index17 = 0;\n    let mut num_digits_sum_index17\
    \ = 0;\n    let mut num_digits_index18 = 0;\n    let mut num_digits_sum_index18\
    \ = 0;\n    let mut num_digits_index19 = 0;\n    let mut num_digits_sum_index19\
    \ = 0;\n    let mut num_digits_index20 = 0;\n    let mut num_digits_sum_index20\
    \ = 0;\n    let mut num_digits_index21 = 0;\n    let mut num_digits_sum_index21\
    \ = 0;\n    let mut num_digits_index22 = 0;\n    let mut num_digits_sum_index22\
    \ = 0;\n    let mut num_digits_index23 = 0;\n    let mut num_digits_\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_ltzolec.rs:61:24\n   |\n\
    61 |     let mut num_digits_\n   |                        ^ help: add `;` here\n\
    62 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_ltzolec.rs:10:41\n\
    \   |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_copy {\n        sum += num;\n    }\n    nums_copy.sort_by_key(|&num| {\n\
    \        sum - num\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplc99nr4z.rs:13:9\n   |\n\
    13 |     for &num in nums_copy {\n   |         ^^^^    --------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        index = nums_sorted.iter().position(|&x| x > 0).unwrap();\n     \
    \   sum += nums_sorted[index];\n        nums_sorted.swap_remove(index);\n    }\n\
    \    nums_sorted.reverse();\n    nums_sorted.sort_by_key(|&x| sum + x);\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmp3yi6k6qh.rs:16:57

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while index < nums_copy.len()\
    \ {\n        sum += nums_copy[index];\n        nums_sorted.swap(index, nums_sorted.iter().position(|&x|\
    \ x == sum).unwrap());\n        index += 1;\n    }\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable does not need to be mutable\n  --> /tmp/tmpkfhw2125.rs:11:9\n\
    \   |\n11 |     let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n\
    \   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0502]: cannot borrow `nums_sorted` as immutable because\
    \ it is also borrowed as mutable\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17 |\
    \         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |         ------------------------^^^^^^^^^^^^^^^^^^----------------------------------\n\
    \   |         |           |           |\n   |         |           |          \
    \ immutable borrow occurs here\n   |         |           mutable borrow later\
    \ used by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpkfhw2125.rs:17:33\n   |\n17\
    \ |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x == sum).unwrap());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using\
    \ that local as the argument to this call\n  --> /tmp/tmpkfhw2125.rs:17:9\n  \
    \ |\n17 |         nums_sorted.swap(index, nums_sorted.iter().position(|&x| x ==\
    \ sum).unwrap());\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|x| {\n    \
    \    let mut sum = 0;\n        for x in nums_copy {\n            sum += x;\n \
    \       }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpl_zxuzms.rs:12:28\n   |\n\
    12 |     nums_copy.sort_by_key(|x| {\n   |                            ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_copy`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpl_zxuzms.rs:14:18\n\
    \    |\n11  |       let mut nums_copy = nums.clone();\n    |           -------------\
    \ captured outer variable\n12  |       nums_copy.sort_by_key(|x| {\n    |  ___________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_copy {\n    |\
    \ |                  ^^^^^^^^^\n    | |                  |\n    | |          \
    \        `nums_copy` moved due to this implicit call to `.into_iter()`\n    |\
    \ |                  move occurs because `nums_copy` has type `Vec<isize>`, which\
    \ does not implement the `Copy` trait\n15  | |             sum += x;\n16  | |\
    \         }\n17  | |         sum\n18  | |     });\n    | |_____- captured by this\
    \ `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_copy`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |   \
    \      for x in &nums_copy {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_copy` because it is borrowed\n  --> /tmp/tmpl_zxuzms.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|x| {\n   |       -                  \
    \   ^^^ move out of `nums_copy` occurs here\n   |  _____|\n   | |\n13 | |    \
    \     let mut sum = 0;\n14 | |         for x in nums_copy {\n   | |          \
    \        --------- move occurs due to use in closure\n15 | |             sum +=\
    \ x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______- borrow\
    \ of `nums_copy` occurs here\n\nerror[E0382]: use of moved value: `nums_copy`\n\
    \  --> /tmp/tmpl_zxuzms.rs:19:5\n   |\n11 |     let mut nums_copy = nums.clone();\n\
    \   |         ------------- move occurs because `nums_copy` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trai"
  stdout: ''
  timestamp: 1660010993
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    nums.sort_by_key(|x| {\n        let mut sum = 0;\n        for &d in &nums\
    \ {\n            sum += *d;\n        }\n        sum\n    });\n    nums\n}\n\n\
    fn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpbnbjicoy.rs:14:20\n\
    \   |\n14 |             sum += *d;\n   |                    ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        let digit = nums_copy[index].checked_sub(10).unwrap();\n\
    \        sum += digit;\n        if sum > 0 {\n            nums_copy[index] = digit\
    \ + nums_copy[index];\n        } else {\n            nums_copy[index] = -digit\
    \ + nums_copy[index];\n        }\n        index += 1;\n    }\n    nums_copy.sort_by_key(|&x|\
    \ x.checked_mul(10).unwrap());\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[10, 10, 10, 10, 10]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpl_1vfzxb.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut num_sum = 0;\n    let mut num_sum_index = 0;\n    let mut num_sum_index2\
    \ = 0;\n    let mut num_sum_index3 = 0;\n    let mut num_sum_index4 = 0;\n   \
    \ let mut num_sum_index5 = 0;\n    let mut num_sum_index6 = 0;\n    let mut num_sum_index7\
    \ = 0;\n    let mut num_sum_index8 = 0;\n    let mut num_sum_index9 = 0;\n   \
    \ let mut num_sum_index10 = 0;\n    let mut num_sum_index11 = 0;\n    let mut\
    \ num_sum_index12 = 0;\n    let mut num_sum_index13 = 0;\n    let mut num_sum_index14\
    \ = 0;\n    let mut num_sum_index15 = 0;\n    let mut num_sum_index16 = 0;\n \
    \   let mut num_sum_index17 = 0;\n    let mut num_sum_index18 = 0;\n    let mut\
    \ num_sum_index19 = 0;\n    let mut num_sum_index20 = 0;\n    let mut num_sum_index21\
    \ = 0;\n    let mut num_sum_index22 = 0;\n    let mut num_sum_index23 = 0;\n \
    \   let mut num_sum_index24 = 0;\n    let mut num_sum_index25 = 0;\n    let mut\
    \ num_sum_index26 = 0;\n    let mut num_sum_index27 = 0;\n    let mut num_sum_index28\
    \ = 0;\n    let mut num_sum_index29 = 0;\n    let mut num_sum_index30 = 0;\n \
    \   let mut num_sum_index31 = 0;\n    let mut num_sum_index32 = 0;\n    let mut\
    \ num_sum_index33 = 0;\n    let mut num_sum_index34 = 0;\n    let mut num_sum_index35\
    \ = 0;\n    let mut num_sum_index36 = 0;\n    let mut num_sum_index37 = 0;\n \
    \   let mut num_sum_index38 = 0;\n    let mut num_sum_index39 = 0;\n    let mut\
    \ num_sum_index40 = 0;\n    let mut num_sum_index41 = 0;\n    let mut num_sum_index42\
    \ = 0;\n    let mut num_sum_index43 = 0;\n    let mut num_sum_index44 = 0;\n \
    \   let mut num_sum_index45 = 0;\n    let mut num_sum_index46 = 0;\n    let mut\
    \ num_sum_index47 = 0;\n    let mut num_sum_index48 = 0;\n    let mut num_sum_index49\
    \ = 0;\n    let mut num_sum_index50 = 0;\n    let mut num_sum_index51 = 0;\n \
    \   let mut num_sum_index52 = 0;\n    let mut num_sum_index53 = 0;\n    let mut\
    \ num_sum_index54 = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpl4mkrs86.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl4mkrs86.rs:10:41\n \
    \  |\n10 | fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    for num in nums_copy\
    \ {\n        sum += num;\n    }\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut index = 0;\n    while index < nums_sorted.len() {\n        let mut\
    \ min_num = nums_sorted[index];\n        let mut min_pos = index;\n        for\
    \ pos in index..nums_sorted.len() {\n            if nums_sorted[pos] < min_num\
    \ {\n                min_num = nums_sorted[pos];\n                min_pos = pos;\n\
    \            }\n        }\n        nums_sorted[min_pos] = nums_sorted[index];\n\
    \        nums_sorted[index] = min_num;\n        index += 1;\n    }\n    nums_sorted\n\
    }\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `sum` is assigned to, but never used\n  --> /tmp/tmp78l8o_ox.rs:12:13\n\
    \   |\n12 |     let mut sum = 0;\n   |             ^^^\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n   = note: consider using `_sum` instead\n\nwarning: variable\
    \ does not need to be mutable\n  --> /tmp/tmp78l8o_ox.rs:11:9\n   |\n11 |    \
    \ let mut nums_copy = nums.clone();\n   |         ----^^^^^^^^^\n   |        \
    \ |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `nums_copy`\n   --> /tmp/tmp78l8o_ox.rs:16:27\n\
    \    |\n11  |     let mut nums_copy = nums.clone();\n    |         -------------\
    \ move occurs because `nums_copy` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n12  |     let mut sum = 0;\n13  |     for num in nums_copy\
    \ {\n    |                --------- `nums_copy` moved due to this implicit call\
    \ to `.into_iter()`\n...\n16  |     let mut nums_sorted = nums_copy.clone();\n\
    \    |                           ^^^^^^^^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `nums_copy`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content\
    \ to avoid moving into the `for` loop\n    |\n13  |     for num in &nums_copy\
    \ {\n    |                +\n\nerror: aborting due to previous error; 2 warnings\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for &n in &nums_sorted {\n            sum +=\
    \ *n as isize;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpj9qhkzcn.rs:15:20\n\
    \   |\n15 |             sum += *n as isize;\n   |                    ^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = Vec::new();\n    let mut sorted_nums_len = nums.len();\n\
    \    let mut sum_of_digits = nums.iter().map(|x| x.digits()).sum();\n    let mut\
    \ num_sums = Vec::new();\n    let mut num_sums_len = nums.len();\n    let mut\
    \ num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum\
    \ = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n\
    \    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let\
    \ mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len\
    \ = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n\
    \    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let\
    \ mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum\
    \ = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n\
    \    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let\
    \ mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len\
    \ = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n\
    \    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let\
    \ mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum\
    \ = 0;\n    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n\
    \    let mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let\
    \ mut num_sums_len = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len\
    \ = nums.len();\n    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n\
    \    let mut num_sums_sum = 0;\n    let mut num_sums_len = nums.len();\n    let\
    \ mut num_\n}\n\nfn main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpytsqm21a.rs:58:17\n   |\n\
    58 |     let mut num_\n   |                 ^ help: add `;` here\n59 | }\n   |\
    \ - unexpected token\n\nerror[E0599]: no method named `digits` found for reference\
    \ `&isize` in the current scope\n  --> /tmp/tmpytsqm21a.rs:13:51\n   |\n13 | \
    \    let mut sum_of_digits = nums.iter().map(|x| x.digits()).sum();\n   |    \
    \                                               ^^^^^^ method not found in `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpytsqm21a.rs:10:41\n   |\n10 |\
    \ fn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n   |    ---------------\
    \                      ^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums_copy.clone();\n\
    \    let mut sum = 0;\n    for i in nums_copy.iter() {\n        sum += *i;\n \
    \       nums_sorted.push(i);\n    }\n    nums_sorted.sort_by_key(|&x| {\n    \
    \    sum - x.to_digits(10).unwrap()\n    });\n    nums_sorted\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpczyywbvq.rs:16:26\n   |\n\
    16 |         nums_sorted.push(i);\n   |                          ^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n16 |  \
    \       nums_sorted.push(*i);\n   |                          +\n\nerror[E0599]:\
    \ no method named `to_digits` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpczyywbvq.rs:19:17\n   |\n19 |         sum - x.to_digits(10).unwrap()\n\
    \   |                 ^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    let mut sum = 0;\n    for &num in\
    \ nums_sorted {\n        sum += num;\n    }\n    nums_sorted.sort_by_key(|&num|\
    \ {\n        sum.partial_cmp(&num).unwrap()\n    });\n    nums_sorted\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdzk208pv.rs:13:9\n   |\n\
    13 |     for &num in nums_sorted {\n   |         ^^^^    ----------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `num`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_sorted = nums.clone();\n    nums_sorted.sort_by_key(|x| {\n\
    \        let mut sum = 0;\n        for x in nums_sorted {\n            sum +=\
    \ x;\n        }\n        sum\n    });\n    nums_sorted\n}\n\nfn main() {\n   \
    \ let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmpr5f8j_gw.rs:12:30\n   |\n\
    12 |     nums_sorted.sort_by_key(|x| {\n   |                              ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of\
    \ `nums_sorted`, a captured variable in an `FnMut` closure\n   --> /tmp/tmpr5f8j_gw.rs:14:18\n\
    \    |\n11  |       let mut nums_sorted = nums.clone();\n    |           ---------------\
    \ captured outer variable\n12  |       nums_sorted.sort_by_key(|x| {\n    |  _____________________________-\n\
    13  | |         let mut sum = 0;\n14  | |         for x in nums_sorted {\n   \
    \ | |                  ^^^^^^^^^^^\n    | |                  |\n    | |      \
    \            `nums_sorted` moved due to this implicit call to `.into_iter()`\n\
    \    | |                  move occurs because `nums_sorted` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n15  | |             sum += x;\n16\
    \  | |         }\n17  | |         sum\n18  | |     });\n    | |_____- captured\
    \ by this `FnMut` closure\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `nums_sorted`\nhelp: consider iterating over a slice of\
    \ the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n14  |\
    \         for x in &nums_sorted {\n    |                  +\n\nerror[E0505]: cannot\
    \ move out of `nums_sorted` because it is borrowed\n  --> /tmp/tmpr5f8j_gw.rs:12:29\n\
    \   |\n12 |       nums_sorted.sort_by_key(|x| {\n   |       -                \
    \       ^^^ move out of `nums_sorted` occurs here\n   |  _____|\n   | |\n13 |\
    \ |         let mut sum = 0;\n14 | |         for x in nums_sorted {\n   | |  \
    \                ----------- move occurs due to use in closure\n15 | |       \
    \      sum += x;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ borrow of `nums_sorted` occurs here\n\nerror[E0382]: use of moved value: `nums_sorted`\n\
    \  --> /tmp/tmpr5f8j_gw.rs:19:5\n   |\n11 |     let mut nums_sorted = nums.clone();\n\
    \   |         --------------- move occurs because `nums_sorted` has type `Vec<i"
  stdout: ''
  timestamp: 1660010993
- exit_code: 101
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut sorted_nums = Vec::new();\n    let mut total_sum = 0;\n    for num\
    \ in nums {\n        let digits = num % 10;\n        total_sum += digits;\n  \
    \      sorted_nums.push(num);\n    }\n    if total_sum > 0 {\n        sorted_nums.sort();\n\
    \    }\n    sorted_nums\n}\n\nfn main() {\n    let candidate = order_by_points;\n\
    \    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n\
    \    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457,\
    \ 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463,\
    \ 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<isize>::new());\n\
    \    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98, 2, -3]), vec![-3, -32,\
    \ -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n    assert_eq!(candidate(vec![0,\
    \ 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4, 23, 6, 6]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 11, -1, -11, -12]`,\n right: `[-1, -11, 1, -12, 11]`', /tmp/tmpyfuzv_km.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    nums_copy.sort_by_key(|&x| {\n   \
    \     let mut sum = 0;\n        for &d in &nums_copy {\n            sum += d;\n\
    \        }\n        sum\n    });\n    nums_copy\n}\n\nfn main() {\n    let candidate\
    \ = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11, -12]), vec![-1,\
    \ -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423, 463, 145, 2, 423,\
    \ 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53, 423, 423, 423, 1234,\
    \ 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `x`\n  --> /tmp/tmp0ico1ui5.rs:12:29\n   |\n\
    12 |     nums_copy.sort_by_key(|&x| {\n   |                             ^ help:\
    \ if this is intentional, prefix it with an underscore: `_x`\n   |\n   = note:\
    \ `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `nums_copy`\
    \ as immutable because it is also borrowed as mutable\n  --> /tmp/tmp0ico1ui5.rs:12:27\n\
    \   |\n12 |       nums_copy.sort_by_key(|&x| {\n   |       -         -----------\
    \ ^^^^ immutable borrow occurs here\n   |       |         |\n   |  _____|    \
    \     mutable borrow later used by call\n   | |\n13 | |         let mut sum =\
    \ 0;\n14 | |         for &d in &nums_copy {\n   | |                    ---------\
    \ second borrow occurs due to use of `nums_copy` in closure\n15 | |          \
    \   sum += d;\n16 | |         }\n17 | |         sum\n18 | |     });\n   | |______-\
    \ mutable borrow occurs here\n\nerror: aborting due to previous error; 1 warning\
    \ emitted\n\nFor more information about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit to compare with next one\n    }\n    nums_copy.sort_by_key(|x|\
    \ {\n        sum - x.to_digits().unwrap()\n    });\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_digits` found for reference `&isize`\
    \ in the current scope\n  --> /tmp/tmp_zgs7_s2.rs:19:17\n   |\n19 |         sum\
    \ - x.to_digits().unwrap()\n   |                 ^^^^^^^^^ method not found in\
    \ `&isize`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut max_sum = 0;\n    let mut max_index = 0;\n\
    \    let mut min_sum = 0;\n    let mut min_index = 0;\n    for i in nums_copy.iter()\
    \ {\n        sum += *i;\n        if sum > max_sum {\n            max_sum = sum;\n\
    \            max_index = i;\n        }\n        if sum < min_sum {\n         \
    \   min_sum = sum;\n            min_index = i;\n        }\n    }\n    for i in\
    \ nums_copy.iter_mut() {\n        *i = *max_index;\n    }\n    for i in nums_sorted.iter_mut()\
    \ {\n        *i = *min_index;\n    }\n    nums_sorted\n}\n\nfn main() {\n    let\
    \ candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11, -1, -11,\
    \ -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234, 423,\
    \ 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6, 53,\
    \ 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps0_7wb1w.rs:22:25\n   |\n\
    15 |     let mut max_index = 0;\n   |                         - expected due to\
    \ this value\n...\n22 |             max_index = i;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n22 |             max_index = *i;\n   |                       \
    \  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps0_7wb1w.rs:26:25\n   |\n\
    17 |     let mut min_index = 0;\n   |                         - expected due to\
    \ this value\n...\n26 |             min_index = i;\n   |                     \
    \    ^ expected integer, found `&isize`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n26 |             min_index = *i;\n   |                       \
    \  +\n\nerror[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmps0_7wb1w.rs:30:14\n\
    \   |\n30 |         *i = *max_index;\n   |              ^^^^^^^^^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmps0_7wb1w.rs:33:14\n \
    \  |\n33 |         *i = *min_index;\n   |              ^^^^^^^^^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0614.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut nums_sorted = nums.clone();\n\
    \    let mut sum = 0;\n    let mut index = 0;\n    while nums_sorted.len() > 0\
    \ {\n        sum += nums_sorted.pop();\n        if sum < 0 {\n            sum\
    \ = 0;\n            index += 1;\n        }\n        nums_sorted.push(nums_sorted.len()\
    \ - 1);\n    }\n    nums_sorted.reverse();\n    for i in nums_sorted {\n     \
    \   nums_copy[i] = index;\n        index += 1;\n    }\n    nums_copy\n}\n\nfn\
    \ main() {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1,\
    \ 11, -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmpq7qld1ko.rs:16:13\n\
    \   |\n16 |         sum += nums_sorted.pop();\n   |             ^^ no implementation\
    \ for `{integer} += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq7qld1ko.rs:21:26\n\
    \   |\n21 |         nums_sorted.push(nums_sorted.len() - 1);\n   |           \
    \               ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n21 |         nums_sorted.push((nums_sorted.len() - 1).try_into().unwrap());\n\
    \   |                          +                     +++++++++++++++++++++\n\n\
    error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpq7qld1ko.rs:25:9\n\
    \   |\n25 |         nums_copy[i] = index;\n   |         ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660010994
- exit_code: 1
  program: "/// Write a function which sorts the given list of integers\n/// in ascending\
    \ order according to the sum of their digits.\n/// Note: if there are several\
    \ items with similar sum of their digits,\n/// order them based on their index\
    \ in original list.\n/// For example:\n/// >>> order_by_points(vec![1, 11, -1,\
    \ -11, -12])\n/// vec![-1, -11, 1, -12, 11]\n/// >>> order_by_points(vec![])\n\
    /// Vec::<isize>::new()\nfn order_by_points(nums: Vec<isize>) -> Vec<isize> {\n\
    \    let mut nums_copy = nums.clone();\n    let mut sum = 0;\n    let mut index\
    \ = 0;\n    while index < nums_copy.len() {\n        sum += nums_copy[index];\n\
    \        index += 1; // skip the digit already processed\n    }\n    let mut nums_copy\
    \ = nums.clone();\n    let mut index = 0;\n    while index < nums_copy.len() {\n\
    \        if nums_copy[index] > sum {\n            nums_copy[index], nums_copy[index\
    \ - 1] = nums_copy[index - 1], nums_copy[index];\n        }\n        index +=\
    \ 1; // skip the digit already processed\n    }\n    nums_copy\n}\n\nfn main()\
    \ {\n    let candidate = order_by_points;\n    assert_eq!(candidate(vec![1, 11,\
    \ -1, -11, -12]), vec![-1, -11, 1, -12, 11]);\n    assert_eq!(candidate(vec![1234,\
    \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]), vec![0, 2, 3, 6,\
    \ 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<isize>::new());\n    assert_eq!(candidate(vec![1, -11, -32, 43, 54, -98,\
    \ 2, -3]), vec![-3, -32, -98, -11, 1, 2, 43, 54]);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]), vec![1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9]);\n\
    \    assert_eq!(candidate(vec![0, 6, 6, -76, -21, 23, 4]), vec![-76, -21, 0, 4,\
    \ 23, 6, 6]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpmg8tffxv.rs:22:29\n   |\n22 |             nums_copy[index], nums_copy[index\
    \ - 1] = nums_copy[index - 1], nums_copy[index];\n   |                       \
    \      ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1660010994
