language: rs
name: HumanEval_105_by_length
results:
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.clone();\n\
    \    digits_reversed.reverse();\n    while digits_len > 0 {\n        let mut digit\
    \ = digits_reversed.pop();\n        if digit < 10 {\n            result.push(String::from(\"\
    One\"));\n        } else if digit < 100 {\n            result.push(String::from(\"\
    Two\"));\n        } else if digit < 1000 {\n            result.push(String::from(\"\
    Three\"));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprs4go864.rs:24:20\n   |\n\
    24 |         if digit < 10 {\n   |                    ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    24 |         if digit < Some(10) {\n   |                    +++++  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprs4go864.rs:26:27\n   |\n26 |         } else\
    \ if digit < 100 {\n   |                           ^^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    26 |         } else if digit < Some(100) {\n   |                           +++++\
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprs4go864.rs:28:27\n   |\n\
    28 |         } else if digit < 1000 {\n   |                           ^^^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n28 |         } else if digit < Some(1000) {\n   |                     \
    \      +++++    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprs4go864.rs:30:27\n\
    \   |\n30 |         } else if digit < 10000 {\n   |                          \
    \ ^^^^^ expected enum `Option`, found integer\n   |\n   = note: expected enum\
    \ `Option<isize>`\n              found type `{integer}`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n30 |         } else if digit < Some(10000) {\n \
    \  |                           +++++     +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprs4go864.rs:32:27\n   |\n32 |         } else if digit < 100000\
    \ {\n   |                           ^^^^^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n32 |         } else if digit\
    \ < Some(100000) {\n   |                           +++++      +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprs4go864.rs:34:27\n   |\n34 |         "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    arr.sort();\n    let mut result = vec![];\n \
    \   for i in arr.iter() {\n        if i <= 9 {\n            result.push(String::from(\"\
    One\"));\n        } else if i <= 99 {\n            result.push(String::from(\"\
    Two\"));\n        } else if i <= 999 {\n            result.push(String::from(\"\
    Three\"));\n        } else if i <= 9999 {\n            result.push(String::from(\"\
    Four\"));\n        } else if i <= 99999 {\n            result.push(String::from(\"\
    Five\"));\n        } else if i <= 999999 {\n            result.push(String::from(\"\
    Six\"));\n        } else if i <= 9999999 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if i <= 999999999 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if i <= 99999999999 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            return vec![];\n        }\n    }\n  \
    \  result.reverse();\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7i4_ietm.rs:21:17\n   |\n\
    21 |         if i <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7i4_ietm.rs:23:24\n\
    \   |\n23 |         } else if i <= 99 {\n   |                        ^^\n   |\
    \                        |\n   |                        expected `&isize`, found\
    \ integer\n   |                        help: consider borrowing here: `&99`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7i4_ietm.rs:25:24\n   |\n25 |  \
    \       } else if i <= 999 {\n   |                        ^^^\n   |          \
    \              |\n   |                        expected `&isize`, found integer\n\
    \   |                        help: consider borrowing here: `&999`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7i4_ietm.rs:27:24\n   |\n27 |         } else\
    \ if i <= 9999 {\n   |                        ^^^^\n   |                     \
    \   |\n   |                        expected `&isize`, found integer\n   |    \
    \                    help: consider borrowing here: `&9999`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7i4_ietm.rs:29:24\n   |\n29 |         } else if i <= 99999\
    \ {\n   |                        ^^^^^\n   |                        |\n   |  \
    \                      expected `&isize`, found integer\n   |                \
    \        help: consider borrowing here: `&99999`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7i4_ietm.rs:31:24\n   |\n31 |         } else if i <= 999999 {\n\
    \   |                        ^^^^^^\n   |                        |\n   |     \
    \                   expected `&isize`, found integer\n   |                   \
    \     help: consider borrowing here: `&999999`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7i4_ietm.rs:33:24\n   |\n33 |         } else if i <= 9999999 {\n\
    \   |                        ^^^^^^^\n   |                        |\n   |    \
    \                    expected `&isize`, found integer\n   |                  \
    \      help: consider borrowing here: `&9999999`\n\nerror[E0308]: mism"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut reversed = vec![];\n    let mut digits = vec![];\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let digit = arr[i];\n\
    \        if digit < 10 {\n            digits.push(digit);\n        } else {\n\
    \            reversed.push(digit - 10);\n            digits.push(digit % 10);\n\
    \        }\n        i += 1;\n    }\n    for i in 0..digits.len() {\n        let\
    \ digit = digits[i];\n        let name = match digit {\n            0 => \"Zero\"\
    ,\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => panic!(\"Unexpected digit {}\", digit),\n \
    \       };\n        result.push(name);\n    }\n    for i in 0..(reversed.len()\
    \ - digits.len()) {\n        let digit = reversed[i];\n        let name = match\
    \ digit {\n            0 => \"Zero\",\n            1 => \"One\",\n           \
    \ 2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n   \
    \         5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"\
    Unexpected digit {}\", digit),\n        };\n        result.push(name);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplvgunr_8.rs:65:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    65 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let digit = arr[i] - 1;\n        if digit\
    \ < 10 {\n            digits.push(digit.to_string());\n        } else {\n    \
    \        result.push(String::from(digits[digit]));\n        }\n        i += 1;\n\
    \    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmpewt4sw1j.rs:26:38\n\
    \   |\n26 |             result.push(String::from(digits[digit]));\n   |      \
    \                                ^^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<String>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n    let mut n = arr.len();\n\n    while i < n {\n       \
    \ if i == 0 {\n            digits.push(arr[i]);\n            i += 1;\n       \
    \     continue;\n        }\n\n        if arr[i] < 10 {\n            digits.push(arr[i]);\n\
    \            i += 1;\n            continue;\n        }\n\n        let mut digit\
    \ = arr[i] - 10;\n        let mut j = i;\n\n        while j > 0 && arr[j - 1]\
    \ > digit {\n            digits.push(arr[j - 1]);\n            j -= 1;\n     \
    \   }\n\n        digits.push(digit);\n        i += 1;\n    }\n\n    let mut i\
    \ = 0;\n    let mut n = digits.len();\n\n    while i < n {\n        let digit\
    \ = digits[i];\n        let name = match digit {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => unreachable!(),\n        };\n\n        result.push(name);\n        i +=\
    \ 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoegu09bl.rs:71:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    71 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i = 0;\n\
    \    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n            i +=\
    \ 1;\n            continue;\n        }\n        let mut j = i;\n        while\
    \ j < len {\n            if arr[j] == arr[i] {\n                j += 1;\n    \
    \            continue;\n            }\n            if arr[j] > arr[i] {\n    \
    \            swap(&mut arr[j], &mut arr[i]);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)).collect::<Vec<_>>()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpwpcfep64.rs:32:17\n\
    \   |\n32 |                 swap(&mut arr[j], &mut arr[i]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpwpcfep64.rs:38:56\n\
    \    |\n38  |       arr.iter().map(|x| String::from(&format!(\"{}\", x)).collect::<Vec<_>>()).collect()\n\
    \    |                                                          ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digit\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_5d2qx1z.rs:71:18\n   |\n\
    71 |     let mut digit\n   |                  ^ help: add `;` here\n72 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_5d2qx1z.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n   \
    \ while i < arr.len() {\n        let mut j = i;\n        while j < arr.len() &&\
    \ arr[j] < 10 {\n            digits.push(arr[j]);\n            j += 1\n      \
    \  }\n        if j == arr.len() {\n            break;\n        }\n        let\
    \ mut reversed = vec![];\n        reversed.push(digits[digits.len() - 1]);\n \
    \       reversed.push(digits[digits.len() - 2]);\n        reversed.push(digits[digits.len()\
    \ - 3]);\n        reversed.push(digits[digits.len() - 4]);\n        reversed.push(digits[digits.len()\
    \ - 5]);\n        reversed.push(digits[digits.len() - 6]);\n        reversed.push(digits[digits.len()\
    \ - 7]);\n        reversed.push(digits[digits.len() - 8]);\n        reversed.push(digits[digits.len()\
    \ - 9]);\n        result.push(String::from(reversed.iter().map(|x| x.to_string()).collect()));\n\
    \        i += j - i;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n  --> /tmp/tmp1azuzetp.rs:39:21\n\
    \   |\n39 |         result.push(String::from(reversed.iter().map(|x| x.to_string()).collect()));\n\
    \   |                     ^^^^^^^^^^^^ cannot infer type for type parameter `T`\
    \ declared on the trait `From`\n   |\n   = note: multiple `impl`s satisfying `String:\
    \ From<_>` found in the following crates: `alloc`, `core`:\n           - impl\
    \ From<Box<str>> for String;\n           - impl From<char> for String;\n     \
    \      - impl<'a> From<Cow<'a, str>> for String;\n           - impl<> From<&String>\
    \ for String;\n           and 3 more\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n39 |         result.push(String::from(reversed.iter().map(|x|\
    \ x.to_string()).collect::<B>()));\n   |                                     \
    \                                           +++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0283`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_len = digits_len.saturating_add((digits_len\
    \ % 10) as usize);\n    let mut i = 0;\n    while i < digits_len {\n        let\
    \ mut j = i;\n        while j < digits_len && digits[j] < 10 {\n            j\
    \ = j + 1;\n        }\n        if j == digits_len {\n            break;\n    \
    \    }\n        let mut digit = digits[j];\n        digits[j] = digits_len - j;\n\
    \        digits_len = digits_len - j;\n        result.push(String::from(&digits[digit]));\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4g4oui82.rs:31:21\n   |\n\
    31 |         digits[j] = digits_len - j;\n   |         ---------   ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |         |\n   |         expected due to\
    \ the type of this binding\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp4g4oui82.rs:33:35\n   |\n33 |         result.push(String::from(&digits[digit]));\n\
    \   |                                   ^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n      \
    \          swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)).to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp5m0on3z_.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_len = digits_len as\
    \ usize;\n    let mut i = 0;\n    while i < digits_len {\n        let mut digit\
    \ = digits[i];\n        let mut digit = digit as usize;\n        let mut digit\
    \ = digit as usize;\n        let mut digit = digit as usize;\n        let mut\
    \ digit = digit as usize;\n        let mut digit = digit as usize;\n        let\
    \ mut digit = digit as usize;\n        let mut digit = digit as usize;\n     \
    \   let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoifikavj.rs:76:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n22 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n67 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n76 | }\n   |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpoifikavj.rs:13:34\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |    ---------                     ^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n   \
    \        found unit type `()`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1; // skip leading zeroes\n        }\n        if j == digits_len\
    \ {\n            break;\n        }\n        let mut digit = digits[j];\n     \
    \   if digit < 10 {\n            digit = digit as usize;\n        }\n        let\
    \ mut digit = digit as usize;\n        let mut digit = digit as usize;\n     \
    \   let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit = digit as usize;\n        let mut digit = digit as usize;\n\
    \        let mut digit\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1h3mycot.rs:81:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n21 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n72 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n81 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  -->\
    \ /tmp/tmp1h3mycot.rs:71:22\n   |\n71 |         let mut digit\n   |          \
    \            ^ help: add `;` here\n72 | }\n   | - unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1h3mycot.rs:31:21\n   |\n29 |         let mut\
    \ digit = digits[j];\n   |                         --------- expected due to this\
    \ value\n30 |         if digit < 10 {\n31 |             digit = digit as usize;\n\
    \   |                     ^^^^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1h3mycot.rs:13:34\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |    ---------                     ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            let mut j = i;\n     \
    \       while j < len {\n                if arr[j] < 1 || arr[j] > 9 {\n     \
    \               break;\n                }\n                j += 1;\n         \
    \   }\n            swap(&mut arr[i], &mut arr[j]);\n            i += 1;\n    \
    \    }\n    }\n    arr.iter().map(|&x| String::from(x)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpv07z9z99.rs:31:13\n\
    \   |\n31 |             swap(&mut arr[i], &mut arr[j]);\n   |             ^^^^\
    \ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ the trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmpv07z9z99.rs:35:25\n\
    \   |\n35 |     arr.iter().map(|&x| String::from(x)).collect()\n   |         \
    \                ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_unstable_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_unstable_by_key(|x| x.checked_mul((10).checked_sub(*x).unwrap()).unwrap());\n\
    \    arr.iter().for_each(|x| {\n        match x {\n            0 => return vec![],\n\
    \            1 => return vec![\"One\"],\n            2 => return vec![\"Two\"\
    ],\n            3 => return vec![\"Three\"],\n            4 => return vec![\"\
    Four\"],\n            5 => return vec![\"Five\"],\n            6 => return vec![\"\
    Six\"],\n            7 => return vec![\"Seven\"],\n            8 => return vec![\"\
    Eight\"],\n            9 => return vec![\"Nine\"],\n            _ => return vec![],\n\
    \        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0689]: can't call method `checked_sub` on ambiguous numeric type\
    \ `{integer}`\n  --> /tmp/tmpdwj862xu.rs:20:53\n   |\n20 |     arr.sort_unstable_by_key(|x|\
    \ x.checked_mul((10).checked_sub(*x).unwrap()).unwrap());\n   |              \
    \                                       ^^^^^^^^^^^\n   |\nhelp: you must specify\
    \ a concrete type for this numeric value, like `i32`\n   |\n20 |     arr.sort_unstable_by_key(|x|\
    \ x.checked_mul((10_i32).checked_sub(*x).unwrap()).unwrap());\n   |          \
    \                                       ~~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdwj862xu.rs:23:25\n   |\n23 |             0 => return vec![],\n\
    \   |                         ^^^^^^ expected `()`, found struct `Vec`\n   |\n\
    \   = note: expected unit type `()`\n                 found struct `Vec<_>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdwj862xu.rs:36:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n36 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0689.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n\
    \        }\n\n        let mut k = j;\n        while k < len && arr[k] > arr[k\
    \ + 1] {\n            k += 1;\n        }\n\n        swap(&mut arr[i], &mut arr[k]);\n\
    \        i += 1;\n        len -= 1;\n    }\n\n    arr.iter().map(|&x| String::from(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpbw_toyvk.rs:37:9\n\
    \   |\n37 |         swap(&mut arr[i], &mut arr[k]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmpbw_toyvk.rs:42:25\n\
    \   |\n42 |     arr.iter().map(|&x| String::from(x)).collect()\n   |         \
    \                ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.iter_mut().for_each(|&x| {\n        if x < 10 {\n            *x = String::from(\"\
    One\");\n        } else if x < 100 {\n            *x = String::from(\"Two\");\n\
    \        } else if x < 1000 {\n            *x = String::from(\"Three\");\n   \
    \     } else if x < 10000 {\n            *x = String::from(\"Four\");\n      \
    \  } else if x < 100000 {\n            *x = String::from(\"Five\");\n        }\
    \ else if x < 1000000 {\n            *x = String::from(\"Six\");\n        } else\
    \ if x < 10000000 {\n            *x = String::from(\"Seven\");\n        } else\
    \ if x < 100000000 {\n            *x = String::from(\"Eight\");\n        } else\
    \ if x < 1000000000 {\n            *x = String::from(\"Nine\");\n        } else\
    \ {\n            *x = String::from(\"Ten\");\n        }\n    });\n    arr\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwquk5pl.rs:19:30\n   |\n\
    19 |     arr.iter_mut().for_each(|&x| {\n   |                              ^--\n\
    \   |                              ||\n   |                              |expected\
    \ due to this\n   |                              types differ in mutability\n\
    \   |                              help: did you mean `x`: `&&mut isize`\n   |\n\
    \   = note: expected mutable reference `&mut isize`\n                      found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptwquk5pl.rs:42:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n42 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n  \
    \  arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x| {\n      \
    \  match x {\n            1 => \"One\",\n            2 => \"Two\",\n         \
    \   3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n\
    \            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => panic!(\"Invalid number in array:\
    \ {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpnz8s30f4.rs:34:8\n     |\n34 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut counter = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i <\
    \ reversed.len() {\n        if reversed[i] < 10 {\n            result.append(&mut\
    \ vec![String::from(\"One\"), reversed[i]]);\n            i += 1;\n        } else\
    \ {\n            result.append(&mut vec![String::from(\"Two\"), reversed[i] -\
    \ 10]);\n            i += 1;\n        }\n    }\n    while j < digits.size() {\n\
    \        if digits[j] < 10 {\n            result.append(&mut vec![String::from(\"\
    One\"), digits[j]]);\n            j += 1;\n        } else {\n            result.append(&mut\
    \ vec![String::from(\"Two\"), digits[j] - 10]);\n            j += 1;\n       \
    \ }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0m9mnseq.rs:26:58\n   |\n\
    26 |             result.append(&mut vec![String::from(\"One\"), reversed[i]]);\n\
    \   |                                                          ^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \                                  |\n   |                                   \
    \                       expected struct `String`, found `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0m9mnseq.rs:29:58\n   |\n29 |             result.append(&mut\
    \ vec![String::from(\"Two\"), reversed[i] - 10]);\n   |                      \
    \                                    ^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `isize`\n   |\nhelp: try using a conversion method\n   |\n29 |       \
    \      result.append(&mut vec![String::from(\"Two\"), (reversed[i] - 10).to_string()]);\n\
    \   |                                                          +             \
    \   +++++++++++++\n\nerror[E0599]: no method named `size` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp0m9mnseq.rs:33:22\n   |\n33 |     while\
    \ j < digits.size() {\n   |                      ^^^^ help: there is an associated\
    \ function with a similar name: `resize`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp0m9mnseq.rs:35:58\n   |\n35 |             result.append(&mut vec![String::from(\"\
    One\"), digits[j]]);\n   |                                                   \
    \       ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   | \
    \                                                         |\n   |            \
    \                                              expected struct `String`, found\
    \ `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0m9mnseq.rs:38:58\n\
    \   |\n38 |             result.append(&mut vec![String::from(\"Two\"), digits[j]\
    \ - 10]);\n   |                                                          ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\nhelp: try using a conversion\
    \ method\n   |\n38 |             result.append(&mut vec![String::from(\"Two\"\
    ), (digits[j] - 10).to_string()]);\n   |"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    for n in arr {\n        let mut reversed =\
    \ n.reverse();\n        let mut digits = reversed.to_string();\n        for &d\
    \ in &mut digits {\n            match d {\n                '0' => result.push(String::from(\"\
    Zero\")),\n                '1' => result.push(String::from(\"One\")),\n      \
    \          '2' => result.push(String::from(\"Two\")),\n                '3' =>\
    \ result.push(String::from(\"Three\")),\n                '4' => result.push(String::from(\"\
    Four\")),\n                '5' => result.push(String::from(\"Five\")),\n     \
    \           '6' => result.push(String::from(\"Six\")),\n                '7' =>\
    \ result.push(String::from(\"Seven\")),\n                '8' => result.push(String::from(\"\
    Eight\")),\n                '9' => result.push(String::from(\"Nine\")),\n    \
    \            _ => (),\n            }\n        }\n    }\n\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmprqeyz7s9.rs:21:30\n   |\n21 |         let mut reversed\
    \ = n.reverse();\n   |                              ^^^^^^^ help: there is an\
    \ associated function with a similar name: `reverse_bits`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        let mut k = j;\n        while k < arr.len() && arr[k]\
    \ > 9 {\n            k += 1\n        }\n        if k > j {\n            result.push(by_length(arr.iter().skip(j).take(k\
    \ - j).collect()));\n            i = k;\n        } else {\n            result.push(by_length(arr.iter().skip(j).take(k\
    \ - j).collect()));\n            i = j;\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmp5hi3wvhe.rs:29:35\n     |\n\
    29   |             result.push(by_length(arr.iter().skip(j).take(k - j).collect()));\n\
    \     |                         --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |                         |\n     |                         required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmp5hi3wvhe.rs:32:35\n     |\n32   |        \
    \     result.push(by_length(arr.iter().skip(j).take(k - j).collect()));\n    \
    \ |                         --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |                         |\n     |                         required by\
    \ a bound introduced by this call\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5hi3wvhe.rs:36:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n36 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let digit = digits[j];\n        let mut reversed = digit;\n\
    \        while reversed > 0 {\n            reversed = reversed / 10;\n       \
    \     result.push(by_digit(digits[reversed as usize]));\n        }\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpcslt7ecl.rs:33:25\n\
    \   |\n33 |             result.push(by_digit(digits[reversed as usize]));\n  \
    \ |                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        let mut k = j;\n        while k < arr.len() && arr[k]\
    \ > 9 {\n            k += 1\n        }\n        if k > i {\n            result.push(by_length(arr.split_off(i).rev()));\n\
    \        }\n        result.push(by_length(arr.split_off(k).rev()));\n        i\
    \ = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpg9fdcoyj.rs:29:52\n\
    \    |\n29  |               result.push(by_length(arr.split_off(i).rev()));\n\
    \    |                                                      ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpg9fdcoyj.rs:31:48\n    |\n31  |           result.push(by_length(arr.split_off(k).rev()));\n\
    \    |                                                  ^^^ `Vec<isize>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg9fdcoyj.rs:34:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n34 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[i] = String::from(&names[arr[i]\
    \ - 1]);\n            i += 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpwowk6zyp.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwowk6zyp.rs:25:22\n   |\n25 |             arr[i]\
    \ = String::from(&names[arr[i] - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwowk6zyp.rs:29:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n29 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut i = 0;\n    while i < reversed.len() {\n        let digit = reversed[i];\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 20 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 30 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 40 {\n            result.push(String::from(\"Four\"\
    ));\n        } else if digit < 50 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if digit < 60 {\n            result.push(String::from(\"Six\"\
    ));\n        } else if digit < 70 {\n            result.push(String::from(\"Seven\"\
    ));\n        } else if digit < 80 {\n            result.push(String::from(\"Eight\"\
    ));\n        } else if digit < 90 {\n            result.push(String::from(\"Nine\"\
    ));\n        } else {\n            result.push(String::from(\"Ten\"));\n     \
    \   }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpteg638q6.rs:52:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        let mut i = x;\n        while i >= 10 {\n            i /= 10;\n \
    \       }\n        i\n    });\n    arr.iter().map(|x| {\n        match x {\n \
    \           x if x <= 9 => \"One\".to_string(),\n            x if x <= 99 => \"\
    Two\".to_string(),\n            x if x <= 999 => \"Three\".to_string(),\n    \
    \        x if x <= 9999 => \"Four\".to_string(),\n            x if x <= 99999\
    \ => \"Five\".to_string(),\n            x if x <= 999999 => \"Six\".to_string(),\n\
    \            x if x <= 9999999 => \"Seven\".to_string(),\n            x if x <=\
    \ 999999999 => \"Eight\".to_string(),\n            x if x <= 99999999999 => \"\
    Nine\".to_string(),\n            _ => panic!(\"Invalid number {:?}\", x),\n  \
    \      }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:20:20\n   |\n\
    20 |         while i >= 10 {\n   |                    ^^\n   |               \
    \     |\n   |                    expected `&isize`, found integer\n   |      \
    \              help: consider borrowing here: `&10`\n\nerror[E0368]: binary assignment\
    \ operation `/=` cannot be applied to type `&isize`\n  --> /tmp/tmpm7a5vzng.rs:21:13\n\
    \   |\n21 |             i /= 10;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `/=` on type `&isize`\n   |\nhelp: `/=` can be used\
    \ on `isize`, you can dereference `i`\n   |\n21 |             *i /= 10;\n   |\
    \             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:27:23\n\
    \   |\n27 |             x if x <= 9 => \"One\".to_string(),\n   |            \
    \           ^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:28:23\n\
    \   |\n28 |             x if x <= 99 => \"Two\".to_string(),\n   |           \
    \            ^^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&99`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:29:23\n\
    \   |\n29 |             x if x <= 999 => \"Three\".to_string(),\n   |        \
    \               ^^^\n   |                       |\n   |                      \
    \ expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:30:23\n\
    \   |\n30 |             x if x <= 9999 => \"Four\".to_string(),\n   |        \
    \               ^^^^\n   |                       |\n   |                     \
    \  expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&9999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm7a5vzng.rs:31:23\n\
    \   |\n31 |             x if x <= 99999 => \"Five\".to_string(),\n   |       \
    \                ^^^^^\n   |                       |\n   |         "
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n            continue;\n        }\n\n        let mut j = i;\n    \
    \    while j < len {\n            if arr[j] == arr[i] {\n                j +=\
    \ 1;\n                continue;\n            }\n            break;\n        }\n\
    \n        let mut tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n\
    \        i += 1;\n        j += 1;\n    }\n\n    let mut result = vec![];\n   \
    \ for i in 0..len {\n        let mut tmp = String::from(\"\");\n        if i <\
    \ len {\n            tmp = String::from(&arr[i]);\n        }\n        result.push(tmp);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp1ydmds8u.rs:47:19\n   |\n47 |             tmp = String::from(&arr[i]);\n\
    \   |                   ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        if j == i {\n            break;\n        }\n      \
    \  let mut k = i;\n        while k < j {\n            result.append(&String::from(&arr[k]));\n\
    \            k += 1\n        }\n        result.append(&String::from(&arr[k]));\n\
    \        i += j - i + 1\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpfd5yelir.rs:29:28\n   |\n29 |             result.append(&String::from(&arr[k]));\n\
    \   |                            ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfd5yelir.rs:29:27\n\
    \   |\n29 |             result.append(&String::from(&arr[k]));\n   |         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n   |\n \
    \  = note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&String`\n\nerror[E0277]: the trait bound `String: From<&isize>`\
    \ is not satisfied\n  --> /tmp/tmpfd5yelir.rs:32:24\n   |\n32 |         result.append(&String::from(&arr[k]));\n\
    \   |                        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfd5yelir.rs:32:23\n   |\n32 |\
    \         result.append(&String::from(&arr[k]));\n   |                       ^^^^^^^^^^^^^^^^^^^^^^\
    \ types differ in mutability\n   |\n   = note: expected mutable reference `&mut\
    \ Vec<_>`\n                      found reference `&String`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.clone();\n\
    \    let mut digits_reversed_len = digits_reversed.len();\n    let mut digits_reversed_len_reversed\
    \ = digits_reversed_len;\n    let mut digits_reversed_len_reversed_len = digits_reversed_len_reversed;\n\
    \    let mut digits_reversed_len_reversed_len_reversed = digits_reversed_len_reversed_len;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len = digits_reversed_len_reversed_len_reversed;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len_reversed = digits_reversed_len_reversed_len_reversed_len;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len_reversed_len = digits_reversed_len_reversed_len_reversed_len_reversed;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \    let mut digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \n    while digits_len > 0 {\n        let mut digit = digits[digits_len - 1];\n\
    \        digits_len -= 1;\n        digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpvg95hnoo.rs:46:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n33 |     while digits_len\
    \ > 0 {\n   |                          - this delimiter might not be properly\
    \ closed...\n...\n37 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n46 | }\n   |   ^\n\nerror[E0425]: cannot find value `digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len`\
    \ in this scope\n  --> /tmp/tmpvg95hnoo.rs:29:83\n   |\n29 | ..._reversed_len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `digits_reversed_len_reversed_len_reversed_len_reversed_len`\n\
    \nerror[E0425]: cannot find value `digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len`\
    \ in this scope\n  --> /tmp/tmpvg95hnoo.rs:30:96\n   |\n30 | ...sed_len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed`\n\
    \nerror[E0425]: cannot find value `digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len`\
    \ in this scope\n  --> /tmp/tmpvg95hnoo.rs:31:109\n   |\n31 | ...len_reversed\
    \ = digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len;\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `digits_reversed_len_reversed_len_reversed_len_reversed_len_reversed_len_reversed`\n\
    \nerror[E0425]: cannot find value `digits_reversed_len_reversed_len_revers"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \n    while digits_len > 0 {\n        let mut digit = digits_reversed.pop();\n\
    \        let mut digits_len = digits_len - 1;\n\n        while digit >= 10 {\n\
    \            digits_len += 1;\n            digits_reversed.push(digit % 10);\n\
    \            digit /= 10;\n        }\n\n        result.push(String::from(&digits[digits_len]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3kjroudf.rs:28:24\n   |\n\
    28 |         while digit >= 10 {\n   |                        ^^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<isize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n28 |         while digit >= Some(10) {\n   |                        +++++\
    \  +\n\nerror[E0369]: cannot mod `Option<isize>` by `{integer}`\n  --> /tmp/tmp3kjroudf.rs:30:40\n\
    \   |\n30 |             digits_reversed.push(digit % 10);\n   |              \
    \                    ----- ^ -- {integer}\n   |                              \
    \    |\n   |                                  Option<isize>\n\nerror[E0368]: binary\
    \ assignment operation `/=` cannot be applied to type `Option<isize>`\n  --> /tmp/tmp3kjroudf.rs:31:13\n\
    \   |\n31 |             digit /= 10;\n   |             -----^^^^^^\n   |     \
    \        |\n   |             cannot use `/=` on type `Option<isize>`\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmp3kjroudf.rs:34:21\n\
    \   |\n34 |         result.push(String::from(&digits[digits_len]));\n   |    \
    \                 ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.clone();\n    let mut reversed = arr.clone();\n    reversed.reverse();\n\
    \    for &i in &mut arr {\n        match i {\n            1 => reversed.remove(1),\n\
    \            2 => reversed.remove(2),\n            3 => reversed.remove(3),\n\
    \            4 => reversed.remove(4),\n            5 => reversed.remove(5),\n\
    \            6 => reversed.remove(6),\n            7 => reversed.remove(7),\n\
    \            8 => reversed.remove(8),\n            9 => reversed.remove(9),\n\
    \            _ => (),\n        }\n    }\n    let mut result = vec![];\n    for\
    \ &i in &mut arr {\n        result.push(String::from(&names[i]))\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpjcnyuvis.rs:36:35\n\
    \   |\n36 |         result.push(String::from(&names[i]))\n   |               \
    \                    ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjcnyuvis.rs:20:9\n   |\n20 |     for &i in &mut arr {\n\
    \   |         ^^    -------- this expression has type `Option<&mut isize>`\n \
    \  |         |\n   |         types differ in mutability\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmpjcnyuvis.rs:31:18\n   |\n\
    21 | /         match i {\n22 | |             1 => reversed.remove(1),\n23 | |\
    \             2 => reversed.remove(2),\n24 | |             3 => reversed.remove(3),\n\
    ...  |\n30 | |             9 => reversed.remove(9),\n   | |                  ------------------\
    \ this and all prior arms are found to be of type `isize`\n31 | |            \
    \ _ => (),\n   | |                  ^^ expected `isize`, found `()`\n32 | |  \
    \       }\n   | |_________- `match` arms have incompatible types\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjcnyuvis.rs:35:9\n   |\n35 |     for &i in &mut\
    \ arr {\n   |         ^^    -------- this expression has type `Option<&mut isize>`\n\
    \   |         |\n   |         types differ in mutability\n   |         help: you\
    \ can probably remove the explicit borrow: `i`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as usize).collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.iter().map(|x| {\n        match x {\n            0 => \"One\",\n    \
    \        1 => \"Two\",\n            2 => \"Three\",\n            3 => \"Four\"\
    ,\n            4 => \"Five\",\n            5 => \"Six\",\n            6 => \"\
    Seven\",\n            7 => \"Eight\",\n            8 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number {:?}\", x),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp1wdjxsfu.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < reversed.len()\
    \ {\n        if reversed[i] < 10 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut digit = reversed[i];\n        let mut name = String::from(\"\
    One\");\n        while digit >= 10 {\n            digit /= 10;\n            name\
    \ += String::from(\"Ten\");\n        }\n        name += String::from(digit.to_string());\n\
    \        result.push(name);\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvcoxm2zf.rs:33:21\n   |\n\
    33 |             name += String::from(\"Ten\");\n   |                     ^^^^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&String::from(\"\
    Ten\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvcoxm2zf.rs:35:17\n \
    \  |\n35 |         name += String::from(digit.to_string());\n   |            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                 |\n   |          \
    \       expected `&str`, found struct `String`\n   |                 help: consider\
    \ borrowing here: `&String::from(digit.to_string())`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_pos = 0;\n\n    while\
    \ digits_pos < digits_len {\n        let mut digit = digits[digits_pos];\n   \
    \     let mut digit_pos = digits_pos;\n\n        while digit_pos < digits_len\
    \ && digit < 10 {\n            digit *= 10;\n            digit_pos += 1;\n   \
    \     }\n\n        if digit > 9 {\n            digit -= 10;\n            digits_pos\
    \ += 1;\n        }\n\n        result.push(String::from(&digits[digits_pos]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpg_9h5hbb.rs:37:21\n   |\n37 |         result.push(String::from(&digits[digits_pos]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n    \
    \            swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j\
    \ += 1;\n        }\n\n        i += 1;\n    }\n\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)))\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpmzkgk4av.rs:30:17\n\
    \   |\n30 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmzkgk4av.rs:38:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    38 |     arr.iter().map(|x| String::from(&format!(\"{}\", x)))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Map`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmpmzkgk4av.rs:38:20: 38:55]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut reversed = vec![];\n    let mut\
    \ i = 0;\n\n    while i < arr.len() {\n        let mut j = i;\n        while j\
    \ < arr.len() && arr[j] < 10 {\n            j += 1\n        }\n\n        reversed.push(String::from(&arr[j..i].to_owned()));\n\
    \        i = j;\n    }\n\n    for i in 0..(reversed.len() - 1) {\n        let\
    \ mut j = i;\n        while j < reversed.len() && reversed[j] < 10 {\n       \
    \     j += 1\n        }\n\n        reversed.swap(i, j);\n    }\n\n    reversed\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&Vec<isize>>` is not satisfied\n\
    \  --> /tmp/tmpi0mf5s8j.rs:28:23\n   |\n28 |         reversed.push(String::from(&arr[j..i].to_owned()));\n\
    \   |                       ^^^^^^^^^^^^ the trait `From<&Vec<isize>>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpi0mf5s8j.rs:34:51\n\
    \   |\n34 |         while j < reversed.len() && reversed[j] < 10 {\n   |     \
    \                                              ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                               \
    \    |\n   |                                                   expected struct\
    \ `String`, found integer\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mu\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpa5eyb4d1.rs:71:11\n   |\n\
    71 |     let mu\n   |           ^ help: add `;` here\n72 | }\n   | - unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa5eyb4d1.rs:13:34\n \
    \  |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    --------- \
    \                    ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result.push(by_length(arr[i..i\
    \ + 1]));\n            i += 1;\n        } else {\n            result.push(by_name(arr[i]));\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmpc0tce1aj.rs:21:25\n\
    \   |\n21 |             result.push(by_name(arr[i]));\n   |                  \
    \       ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpc0tce1aj.rs:18:35\n   |\n18 |             result.push(by_length(arr[i..i\
    \ + 1]));\n   |                                   ^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_vec()`\n   |                                   |\n\
    \   |                                   expected struct `Vec`, found slice `[isize]`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n               found slice `[isize]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc0tce1aj.rs:25:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n25 |\
    \     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n \
    \  |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    let mut result = vec![];\n    for i in arr {\n        let mut s = String::from(\"\
    One\");\n        if i < 10 {\n            s = String::from(\"One\");\n       \
    \ } else if i < 20 {\n            s = String::from(\"Two\");\n        } else if\
    \ i < 30 {\n            s = String::from(\"Three\");\n        } else if i < 40\
    \ {\n            s = String::from(\"Four\");\n        } else if i < 50 {\n   \
    \         s = String::from(\"Five\");\n        } else if i < 60 {\n          \
    \  s = String::from(\"Six\");\n        } else if i < 70 {\n            s = String::from(\"\
    Seven\");\n        } else if i < 80 {\n            s = String::from(\"Eight\"\
    );\n        } else if i < 90 {\n            s = String::from(\"Nine\");\n    \
    \    }\n        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpguioxa0l.rs:50:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        match x {\n            1 => 1,\n            2 => 2,\n           \
    \ 3 => 3,\n            4 => 4,\n            5 => 5,\n            6 => 6,\n   \
    \         7 => 7,\n            8 => 8,\n            9 => 9,\n            _ =>\
    \ panic!(\"Invalid number: {}\", x),\n        }\n    });\n    arr.reverse();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmph78ccbiy.rs:47:8\n     |\n47 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ x.checked_sub(1));\n    arr.sort_by_key(|x| x.checked_sub(2));\n    arr.sort_by_key(|x|\
    \ x.checked_sub(3));\n    arr.sort_by_key(|x| x.checked_sub(4));\n    arr.sort_by_key(|x|\
    \ x.checked_sub(5));\n    arr.sort_by_key(|x| x.checked_sub(6));\n    arr.sort_by_key(|x|\
    \ x.checked_sub(7));\n    arr.sort_by_key(|x| x.checked_sub(8));\n    arr.sort_by_key(|x|\
    \ x.checked_sub(9));\n    arr.iter().map(|x| String::from(&names[*x % 10])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmph6b8bwra.rs:28:38\n\
    \   |\n28 |     arr.iter().map(|x| String::from(&names[*x % 10])).collect()\n\
    \   |                                      ^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut reversed\
    \ = vec![];\n\n    for num in arr {\n        if num < 10 {\n            digits.push(num\
    \ as char);\n        } else {\n            reversed.push(num % 10);\n        \
    \    digits.push(num / 10 as char);\n        }\n    }\n\n    for digit in digits\
    \ {\n        result.push(String::from(&reversed[digit as usize - 1]));\n    }\n\
    \n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot divide `isize` by `char`\n  --> /tmp/tmp9r59h7ks.rs:27:29\n\
    \   |\n27 |             digits.push(num / 10 as char);\n   |                 \
    \            ^ no implementation for `isize / char`\n   |\n   = help: the trait\
    \ `Div<char>` is not implemented for `isize`\n   = help: the following other types\
    \ implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n          \
    \   <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n            \
    \ <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n             <&'a\
    \ i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a isize\
    \ as Div<isize>>\n           and 54 others\n\nerror[E0277]: the trait bound `String:\
    \ From<&isize>` is not satisfied\n  --> /tmp/tmp9r59h7ks.rs:32:21\n   |\n32 |\
    \         result.push(String::from(&reversed[digit as usize - 1]));\n   |    \
    \                 ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0604]: only `u8` can be cast as `char`, not `isize`\n  --> /tmp/tmp9r59h7ks.rs:24:25\n\
    \   |\n24 |             digits.push(num as char);\n   |                      \
    \   ^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a\
    \ `u32`)\n  --> /tmp/tmp9r59h7ks.rs:24:25\n   |\n24 |             digits.push(num\
    \ as char);\n   |                         ^^^^^^^^^^^\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0604.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.clone();\n    arr.sort();\n    arr.iter().rev().for_each(|x| {\n\
    \        match x {\n            x if x <= 9 => arr.push(String::from(\"One\")),\n\
    \            x if x <= 99 => arr.push(String::from(\"Two\")),\n            x if\
    \ x <= 999 => arr.push(String::from(\"Three\")),\n            x if x <= 9999 =>\
    \ arr.push(String::from(\"Four\")),\n            x if x <= 99999 => arr.push(String::from(\"\
    Five\")),\n            x if x <= 999999 => arr.push(String::from(\"Six\")),\n\
    \            x if x <= 9999999 => arr.push(String::from(\"Seven\")),\n       \
    \     x if x <= 999999999 => arr.push(String::from(\"Eight\")),\n            x\
    \ if x <= 99999999999 => arr.push(String::from(\"Nine\")),\n            _ => (),\n\
    \        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:21:23\n   |\n\
    21 |             x if x <= 9 => arr.push(String::from(\"One\")),\n   |       \
    \                ^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:21:37\n\
    \   |\n21 |             x if x <= 9 => arr.push(String::from(\"One\")),\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:22:23\n\
    \   |\n22 |             x if x <= 99 => arr.push(String::from(\"Two\")),\n   |\
    \                       ^^\n   |                       |\n   |               \
    \        expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&99`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:22:38\n\
    \   |\n22 |             x if x <= 99 => arr.push(String::from(\"Two\")),\n   |\
    \                                      ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:23:23\n\
    \   |\n23 |             x if x <= 999 => arr.push(String::from(\"Three\")),\n\
    \   |                       ^^^\n   |                       |\n   |          \
    \             expected `&isize`, found integer\n   |                       help:\
    \ consider borrowing here: `&999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:23:39\n\
    \   |\n23 |             x if x <= 999 => arr.push(String::from(\"Three\")),\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:24:23\n\
    \   |\n24 |             x if x <= 9999 => arr.push(String::from(\"Four\")),\n\
    \   |                       ^^^^\n   |                       |\n   |         \
    \              expected `&isize`, found integer\n   |                       help:\
    \ consider borrowing here: `&9999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsi9qh970.rs:24:40\n\
    \   "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    arr.sort_unstable_by_key(|x| {\n        match\
    \ x {\n            1 => 1,\n            2 => 2,\n            3 => 3,\n       \
    \     4 => 4,\n            5 => 5,\n            6 => 6,\n            7 => 7,\n\
    \            8 => 8,\n            9 => 9,\n            _ => panic!(\"Invalid number\
    \ in array: {}\", x),\n        }\n    });\n    arr.iter().map(|x| {\n        match\
    \ x {\n            1 => \"One\",\n            2 => \"Two\",\n            3 =>\
    \ \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n       \
    \     6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n\
    \            9 => \"Nine\",\n            _ => panic!(\"Invalid number in array:\
    \ {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpkk2wruty.rs:45:8\n     |\n45 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n  \
    \  arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x| String::from(&names[x\
    \ as usize])).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpiyd1ed6g.rs:21:38\n\
    \   |\n21 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                      ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpiyd1ed6g.rs:21:44\n  \
    \ |\n21 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                            -^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \            help: dereference the expression: `*x`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.reverse();\n    let mut result = vec![];\n\
    \    for i in arr {\n        let mut s = String::new();\n        if i < 10 {\n\
    \            s.push_str(&format!(\"One\", i));\n        } else if i < 20 {\n \
    \           s.push_str(&format!(\"Two\", i));\n        } else if i < 30 {\n  \
    \          s.push_str(&format!(\"Three\", i));\n        } else if i < 40 {\n \
    \           s.push_str(&format!(\"Four\", i));\n        } else if i < 50 {\n \
    \           s.push_str(&format!(\"Five\", i));\n        } else if i < 60 {\n \
    \           s.push_str(&format!(\"Six\", i));\n        } else if i < 70 {\n  \
    \          s.push_str(&format!(\"Seven\", i));\n        } else if i < 80 {\n \
    \           s.push_str(&format!(\"Eight\", i));\n        } else if i < 90 {\n\
    \            s.push_str(&format!(\"Nine\", i));\n        } else {\n          \
    \  continue;\n        }\n        result.push(s);\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpvunbpoxh.rs:25:40\n   |\n25 |\
    \             s.push_str(&format!(\"One\", i));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpvunbpoxh.rs:27:40\n   |\n27 |             s.push_str(&format!(\"\
    Two\", i));\n   |                                 -----  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpvunbpoxh.rs:29:42\n\
    \   |\n29 |             s.push_str(&format!(\"Three\", i));\n   |            \
    \                     -------  ^ argument never used\n   |                   \
    \              |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpvunbpoxh.rs:31:41\n   |\n31 |    \
    \         s.push_str(&format!(\"Four\", i));\n   |                           \
    \      ------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpvunbpoxh.rs:33:41\n   |\n33 |             s.push_str(&format!(\"\
    Five\", i));\n   |                                 ------  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpvunbpoxh.rs:35:40\n\
    \   |\n35 |             s.push_str(&format!(\"Six\", i));\n   |              \
    \                   -----  ^ argument never used\n   |                       \
    \          |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpvunbpoxh.rs:37:42\n   |\n37 |    \
    \         s.push_str(&format!(\"Seven\", i));\n   |                          \
    \       -------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n  \
    \  arr.sort_unstable();\n    arr.reverse();\n    arr.iter().map(|x| {\n      \
    \  match x {\n            x if x <= 9 => String::from(\"One\"),\n            x\
    \ if x <= 99 => String::from(\"Two\"),\n            x if x <= 999 => String::from(\"\
    Three\"),\n            x if x <= 9999 => String::from(\"Four\"),\n           \
    \ x if x <= 99999 => String::from(\"Five\"),\n            x if x <= 999999 =>\
    \ String::from(\"Six\"),\n            x if x <= 9999999 => String::from(\"Seven\"\
    ),\n            x if x <= 999999999 => String::from(\"Eight\"),\n            x\
    \ if x <= 99999999999 => String::from(\"Nine\"),\n            _ => String::from(\"\
    Unknown\"),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:23:23\n   |\n\
    23 |             x if x <= 9 => String::from(\"One\"),\n   |                 \
    \      ^\n   |                       |\n   |                       expected `&isize`,\
    \ found integer\n   |                       help: consider borrowing here: `&9`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:24:23\n   |\n24 |\
    \             x if x <= 99 => String::from(\"Two\"),\n   |                   \
    \    ^^\n   |                       |\n   |                       expected `&isize`,\
    \ found integer\n   |                       help: consider borrowing here: `&99`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:25:23\n   |\n25 |\
    \             x if x <= 999 => String::from(\"Three\"),\n   |                \
    \       ^^^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:26:23\n\
    \   |\n26 |             x if x <= 9999 => String::from(\"Four\"),\n   |      \
    \                 ^^^^\n   |                       |\n   |                   \
    \    expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&9999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:27:23\n\
    \   |\n27 |             x if x <= 99999 => String::from(\"Five\"),\n   |     \
    \                  ^^^^^\n   |                       |\n   |                 \
    \      expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&99999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:28:23\n\
    \   |\n28 |             x if x <= 999999 => String::from(\"Six\"),\n   |     \
    \                  ^^^^^^\n   |                       |\n   |                \
    \       expected `&isize`, found integer\n   |                       help: consider\
    \ borrowing here: `&999999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7d_wboh5.rs:29:23\n\
    \   |\n29 |             x if x <= 9999999 => String::from(\"Seven\"),\n   |  \
    \                     ^^^^^^^\n   |             "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while len > 0 {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n\
    \        }\n\n        swap(&mut arr[j], &mut arr[i]);\n        i += 1;\n     \
    \   len -= 1;\n    }\n\n    arr.iter().map(|x| String::from(x)).collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp5w845svu.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmp5w845svu.rs:37:24\n\
    \   |\n37 |     arr.iter().map(|x| String::from(x)).collect()\n   |          \
    \              ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n    let\
    \ mut len = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n        }\n\
    \        let mut j = i;\n        while j < len {\n            if arr[j] > arr[j\
    \ + 1] {\n                let tmp = arr[j];\n                arr[j] = arr[j +\
    \ 1];\n                arr[j + 1] = tmp;\n            }\n            j += 1;\n\
    \        }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)).collect::<Vec<_>>()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpfqcdqhev.rs:36:56\n\
    \    |\n36  |       arr.iter().map(|x| String::from(&format!(\"{}\", x)).collect::<Vec<_>>()).collect()\n\
    \    |                                                          ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            swap(&mut arr[i..i + 1], &mut arr[len\
    \ - i - 1..len - i]);\n            i += 1;\n        }\n    }\n\n    arr.iter().map(|x|\
    \ String::from(&names[x as usize])).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpv309syn6.rs:25:13\n\
    \   |\n25 |             swap(&mut arr[i..i + 1], &mut arr[len - i - 1..len - i]);\n\
    \   |             ^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ one of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpv309syn6.rs:30:38\n\
    \   |\n30 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                      ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpv309syn6.rs:30:44\n  \
    \ |\n30 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                            -^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \            help: dereference the expression: `*x`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[i] = String::from(&names[arr[i]\
    \ - 1]);\n            i += 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpwowk6zyp.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwowk6zyp.rs:25:22\n   |\n25 |             arr[i]\
    \ = String::from(&names[arr[i] - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwowk6zyp.rs:29:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n29 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index\
    \ = 0;\n    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n\
    \    let mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let\
    \ mut digits_len = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len\
    \ = digits.len();\n    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n\
    \    let mut digits_index = 0;\n    let mut digits_len = digits.len();\n    let\
    \ mut digits_index = 0;\n    let mut digit\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_5d2qx1z.rs:71:18\n   |\n\
    71 |     let mut digit\n   |                  ^ help: add `;` here\n72 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_5d2qx1z.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011867
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n\
    \n    while i < arr.len() {\n        if arr[i] < 10 {\n            digits.push(String::from(\"\
    0\".to_string()));\n            digits.push(String::from(format!(\"{}\", arr[i])));\n\
    \        } else {\n            digits.push(String::from(format!(\"{}\", arr[i])));\n\
    \            digits.push(String::from(\"0\".to_string()));\n        }\n\n    \
    \    i += 1;\n    }\n\n    for digit in digits {\n        if digit == \"0\".to_string()\
    \ {\n            continue;\n        }\n\n        let mut reversed = digit;\n \
    \       reversed.chars().for_each(|c| {\n            if c < '0' || c > '9' {\n\
    \                return;\n            }\n\n            reversed = reversed.to_string()\
    \ + c.to_string();\n        });\n\n        result.push(String::from(reversed));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_jk8z5wj.rs:45:47\n   |\n\
    45 |             reversed = reversed.to_string() + c.to_string();\n   |      \
    \                                         ^^^^^^^^^^^^^\n   |                \
    \                               |\n   |                                      \
    \         expected `&str`, found struct `String`\n   |                       \
    \                        help: consider borrowing here: `&c.to_string()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        if x < 1 || x > 9 {\n            0\n        } else {\n          \
    \  x\n        }\n    });\n    arr.iter().map(|x| {\n        match x {\n      \
    \      x if x <= 9 => String::from(\"One\"),\n            x if x <= 99 => String::from(\"\
    Two\"),\n            x if x <= 999 => String::from(\"Three\"),\n            x\
    \ if x <= 9999 => String::from(\"Four\"),\n            x if x <= 99999 => String::from(\"\
    Five\"),\n            x if x <= 999999 => String::from(\"Six\"),\n           \
    \ x if x <= 9999999 => String::from(\"Seven\"),\n            x if x <= 999999999\
    \ => String::from(\"Eight\"),\n            x if x <= 99999999999 => String::from(\"\
    Nine\"),\n            _ => String::from(\"Zero\"),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:19:16\n   |\n\
    19 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:19:25\n\
    \   |\n19 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp115pcn80.rs:22:13\n\
    \   |\n19 | /         if x < 1 || x > 9 {\n20 | |             0\n   | |      \
    \       - expected because of this\n21 | |         } else {\n22 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n23 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             *x\n   |             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:27:23\n   |\n27 |  \
    \           x if x <= 9 => String::from(\"One\"),\n   |                      \
    \ ^\n   |                       |\n   |                       expected `&isize`,\
    \ found integer\n   |                       help: consider borrowing here: `&9`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:28:23\n   |\n28 |\
    \             x if x <= 99 => String::from(\"Two\"),\n   |                   \
    \    ^^\n   |                       |\n   |                       expected `&isize`,\
    \ found integer\n   |                       help: consider borrowing here: `&99`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:29:23\n   |\n29 |\
    \             x if x <= 999 => String::from(\"Three\"),\n   |                \
    \       ^^^\n   |                       |\n   |                       expected\
    \ `&isize`, found integer\n   |                       help: consider borrowing\
    \ here: `&999`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp115pcn80.rs:30:23\n\
    \   |\n30 |             x if x <= 9999 => String::from(\"Four\"),\n "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    let mut result = vec![];\n    for i in arr {\n      \
    \  let num = i as usize;\n        let name = match num {\n            1 => \"\
    One\",\n            2 => \"Two\",\n            3 => \"Three\",\n            4\
    \ => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n      \
    \      7 => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\"\
    ,\n            _ => panic!(\"Unexpected number {}\", num),\n        };\n     \
    \   result.push(name);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpceuj1bog.rs:38:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    38 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = arr.clone();\n\
    \    reversed.reverse();\n    for &i in &reversed {\n        arr.push(String::from(&format!(\"\
    {}\", i)));\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoyxoi3pc.rs:21:18\n   |\n\
    21 |         arr.push(String::from(&format!(\"{}\", i)));\n   |              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoyxoi3pc.rs:23:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n23 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    arr.sort();\n    arr.reverse();\n\n    let\
    \ mut result = vec![];\n    for i in arr {\n        let mut s = String::new();\n\
    \        if i < 10 {\n            s.push_str(&format!(\"One\", i));\n        }\
    \ else if i < 20 {\n            s.push_str(&format!(\"Two\", i));\n        } else\
    \ if i < 30 {\n            s.push_str(&format!(\"Three\", i));\n        } else\
    \ if i < 40 {\n            s.push_str(&format!(\"Four\", i));\n        } else\
    \ if i < 50 {\n            s.push_str(&format!(\"Five\", i));\n        } else\
    \ if i < 60 {\n            s.push_str(&format!(\"Six\", i));\n        } else if\
    \ i < 70 {\n            s.push_str(&format!(\"Seven\", i));\n        } else if\
    \ i < 80 {\n            s.push_str(&format!(\"Eight\", i));\n        } else if\
    \ i < 90 {\n            s.push_str(&format!(\"Nine\", i));\n        } else {\n\
    \            continue;\n        }\n        result.push(s);\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmp0tikp9eg.rs:26:40\n   |\n26 |\
    \             s.push_str(&format!(\"One\", i));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp0tikp9eg.rs:28:40\n   |\n28 |             s.push_str(&format!(\"\
    Two\", i));\n   |                                 -----  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmp0tikp9eg.rs:30:42\n\
    \   |\n30 |             s.push_str(&format!(\"Three\", i));\n   |            \
    \                     -------  ^ argument never used\n   |                   \
    \              |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmp0tikp9eg.rs:32:41\n   |\n32 |    \
    \         s.push_str(&format!(\"Four\", i));\n   |                           \
    \      ------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp0tikp9eg.rs:34:41\n   |\n34 |             s.push_str(&format!(\"\
    Five\", i));\n   |                                 ------  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmp0tikp9eg.rs:36:40\n\
    \   |\n36 |             s.push_str(&format!(\"Six\", i));\n   |              \
    \                   -----  ^ argument never used\n   |                       \
    \          |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmp0tikp9eg.rs:38:42\n   |\n38 |    \
    \         s.push_str(&format!(\"Seven\", i));\n   |                          \
    \       -------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let mut digit = digits[j];\n        let mut reversed_digit\
    \ = digit as isize;\n        while reversed_digit > 9 {\n            reversed_digit\
    \ /= 10;\n        }\n        result.push(by_digit(digits[reversed_digit]));\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpbgtcbadl.rs:34:21\n\
    \   |\n34 |         result.push(by_digit(digits[reversed_digit]));\n   |     \
    \                ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[isize]`\
    \ cannot be indexed by `isize`\n  --> /tmp/tmpbgtcbadl.rs:34:30\n   |\n34 |  \
    \       result.push(by_digit(digits[reversed_digit]));\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented\
    \ for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<isize>`\
    \ for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n    let mut len\
    \ = arr.len();\n    let mut i = 0;\n    while i < len {\n        if arr[i] < 1\
    \ || arr[i] > 9 {\n            i += 1;\n        } else {\n            arr[i] =\
    \ String::from(&names[arr[i] - 1]);\n            i += 1;\n        }\n    }\n \
    \   arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpbuija0ta.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0271]:\
    \ type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpbuija0ta.rs:18:35\n     |\n18   |     let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \     |                                   ^^^^^^ expected reference, found `isize`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `isize`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<std::vec::IntoIter<isize>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmpbuija0ta.rs:18:44\n   |\n18 |       let mut\
    \ arr = arr.into_iter().cloned().collect::<Vec<_>>();\n   |                  \
    \                            ^^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<isize>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n            continue;\n        }\n\n        let mut j = i;\n    \
    \    while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n        }\n\n\
    \        let mut k = j;\n        while k < len && arr[k] > arr[k + 1] {\n    \
    \        k += 1;\n        }\n\n        let mut tmp = arr[k];\n        arr[k] =\
    \ arr[j];\n        arr[j] = tmp;\n        i += 1;\n        j += 1;\n        len\
    \ -= 1;\n    }\n\n    arr.iter().map(|x| String::from(&format!(\"{}\", x)).to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"1\", \"1\", \"2\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp30kj7yh9.rs:50:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let mut digit = digits[j];\n        let mut reversed_digit\
    \ = digit as usize;\n        while reversed_digit > 0 {\n            reversed_digit\
    \ /= 10;\n            result.push(by_digit(digit as usize));\n        }\n    \
    \    digit = digits[j];\n        digits[j] = digit;\n        digits[j] = digit;\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpkhzxdecz.rs:34:25\n\
    \   |\n34 |             result.push(by_digit(digit as usize));\n   |         \
    \                ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    arr.sort_unstable();\n    arr.reverse();\n  \
    \  arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n      \
    \      2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n\
    \            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"\
    Invalid number: {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpsw69kes_.rs:33:8\n     |\n33 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.to_owned();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[i] = \"One\".to_string();\n\
    \            i += 1;\n            arr[i] = \"Two\".to_string();\n            i\
    \ += 1;\n            arr[i] = \"Three\".to_string();\n            i += 1;\n  \
    \          arr[i] = \"Four\".to_string();\n            i += 1;\n            arr[i]\
    \ = \"Five\".to_string();\n            i += 1;\n            arr[i] = \"Six\".to_string();\n\
    \            i += 1;\n            arr[i] = \"Seven\".to_string();\n          \
    \  i += 1;\n            arr[i] = \"Eight\".to_string();\n            i += 1;\n\
    \            arr[i] = \"Nine\".to_string();\n            i += 1;\n        }\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptmuov9hf.rs:21:22\n   |\n\
    21 |             arr[i] = \"One\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptmuov9hf.rs:23:22\n   |\n23 |             arr[i] = \"Two\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptmuov9hf.rs:25:22\n   |\n25 |\
    \             arr[i] = \"Three\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptmuov9hf.rs:27:22\n   |\n27 |             arr[i] = \"Four\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptmuov9hf.rs:29:22\n   |\n29 |\
    \             arr[i] = \"Five\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptmuov9hf.rs:31:22\n   |\n31 |             arr[i] = \"Six\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptmuov9hf.rs:33:22\n   |\n33 |\
    \             arr[i] = \"Seven\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmptmuov9hf.rs:35:22\n   |\n35 |             arr[i] = \"Eight\".to_string"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = vec![];\n\
    \    let mut digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n      \
    \      digits.push(arr[j - 1]);\n            j -= 1;\n        }\n        reversed.push(digits[..].iter().cloned().collect::<Vec<_>>());\n\
    \        i += 1;\n    }\n    let mut i = 0;\n    while i < reversed.len() {\n\
    \        let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j]\
    \ {\n            digits.push(reversed[j - 1]);\n            j -= 1;\n        }\n\
    \        arr.push(digits[..].iter().cloned().collect::<Vec<_>>());\n        i\
    \ += 1;\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfc7b8wnn.rs:34:25\n   |\n\
    34 |             digits.push(reversed[j - 1]);\n   |                         ^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n\
    \            found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfc7b8wnn.rs:37:18\n   |\n37 |         arr.push(digits[..].iter().cloned().collect::<Vec<_>>());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found struct `Vec`\n   |\n   = note: expected type `isize`\n      \
    \      found struct `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfc7b8wnn.rs:40:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n40 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \    arr.sort_unstable();\n    arr.iter().map(|x| {\n        match x {\n     \
    \       0 => \"Zero\",\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid\
    \ number: {}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqtpmsk_w.rs:15:5\n\
    \   |\n14 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n15 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: -1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n\
    \            continue;\n        }\n        let mut j = i;\n        while j < arr.len()\
    \ {\n            if arr[j] < 1 || arr[j] > 9 {\n                j += 1;\n    \
    \            continue;\n            }\n            if arr[j] < arr[i] {\n    \
    \            result.push(String::from(\"One\"));\n                i += 1;\n  \
    \              break;\n            }\n            if arr[j] > arr[i] {\n     \
    \           result.push(String::from(\"Nine\"));\n                i += 1;\n  \
    \              break;\n            }\n            j += 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1660011873
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_len = digits_reversed.len();\n    let mut digits_reversed_reversed\
    \ = digits_reversed.iter().cloned().rev().collect::<Vec<_>>();\n    let mut digits_reversed_reversed_len\
    \ = digits_reversed_reversed.len();\n    let mut digits_reversed_reversed_reversed\
    \ = digits_reversed_reversed.iter().cloned().rev().collect::<Vec<_>>();\n    let\
    \ mut digits_reversed_reversed_reversed_len = digits_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_len = digits_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed_reversed.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_len = digits_reversed_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed_reversed_reversed.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed.len();\n    let\
    \ mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed =\
    \ digits_reversed_reversed_reversed_reversed_reversed_reversed.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = digit\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwoybfi6i.rs:34:99\n   |\n\
    34 |     let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = digit\n   |                                                              \
    \                                     ^ help: add `;` here\n35 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `digit` in this scope\n  --> /tmp/tmpwoybfi6i.rs:34:94\n\
    \   |\n34 |     let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = digit\n   |                                                              \
    \                                ^^^^^ help: a local variable with a similar name\
    \ exists: `digits`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwoybfi6i.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] < 1 || arr[j] > 9 {\n \
    \               break;\n            }\n            i += 1;\n        }\n      \
    \  swap(&mut arr[i], &mut arr[j]);\n    }\n    let mut result = vec![];\n    for\
    \ i in 0..len {\n        result.push(String::from(&arr[i]));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpeu8z8wyx.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[i], &mut arr[j]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpeu8z8wyx.rs:36:21\n\
    \   |\n36 |         result.push(String::from(&arr[i]));\n   |                \
    \     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.to_owned();\n    if arr.len() == 0 {\n\
    \        return vec![];\n    }\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = arr.len() - 1;\n    let mut cur = String::from(\"One\");\n    while\
    \ i <= k {\n        if arr[i] < 10 {\n            i += 1;\n            continue;\n\
    \        }\n        if arr[i] > 9 {\n            j += 1;\n            i += 1;\n\
    \            continue;\n        }\n        if j == 0 {\n            cur = String::from(\"\
    One\");\n            j = 1;\n        }\n        if j == 1 {\n            cur =\
    \ String::from(\"Two\");\n            j = 2;\n        }\n        if j == 2 {\n\
    \            cur = String::from(\"Three\");\n            j = 3;\n        }\n \
    \       if j == 3 {\n            cur = String::from(\"Four\");\n            j\
    \ = 4;\n        }\n        if j == 4 {\n            cur = String::from(\"Five\"\
    );\n            j = 5;\n        }\n        if j == 5 {\n            cur = String::from(\"\
    Six\");\n            j = 6;\n        }\n        if j == 6 {\n            cur =\
    \ String::from(\"Seven\");\n            j = 7;\n        }\n        if j == 7 {\n\
    \            cur = String::from(\"Eight\");\n            j = 8;\n        }\n \
    \       if j == 8 {\n            cur = String::from(\"Nine\");\n            j\
    \ = 9;\n        }\n        if j == 9 {\n            cur = String::from(\"Ten\"\
    );\n            j = 10;\n        }\n        if j == 10 {\n            cur = String::from(\"\
    Eleven\");\n            j = 11;\n        }\n        if j == 11 {\n           \
    \ cur = String::from(\"Twelve\");\n            j = 12;\n        }\n        if\
    \ j == 12 {\n            cur = String::from(\"Thirteen\");\n            j = 13;\n\
    \        }\n        if j == 13 {\n            cur = String::from(\"Fourteen\"\
    );\n            j = 14;\n        }\n        if j == 14 {\n            cur = String::from(\"\
    Fifteen\");\n            j = 15;\n        }\n        if j == 15 {\n          \
    \  cur = String::from(\"Sixteen\");\n            j = 16;\n        }\n        if\
    \ j == 16 {\n            cur = String::from(\"Seventeen\");\n            j = 17;\n\
    \        }\n        if j == 17 {\n            cur = String::from(\"Eighteen\"\
    );\n            j = 18;\n        }\n        if j == 18 {\n            cur = String::from(\"\
    Nineteen\");\n            j = 19;\n        }\n        if j == 19 {\n         \
    \   cur = String::from(\"Twenty\");\n            j = 20;\n        }\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgis523xx.rs:121:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n22  |     while\
    \ i <= k {\n    |                  - this delimiter might not be properly closed...\n\
    ...\n112 | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n121 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgis523xx.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while len > 0 {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[i] = String::from(&names[arr[i]\
    \ - 1]);\n            len -= 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp49b_y7p9.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&names[arr[i] - 1]);\n   |     \
    \                               ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp49b_y7p9.rs:25:22\n   |\n25 |             arr[i]\
    \ = String::from(&names[arr[i] - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp49b_y7p9.rs:29:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n29 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            let index = arr[i] - 1;\n         \
    \   arr[i] = String::from(&names[index]);\n            i += 1;\n        }\n  \
    \  }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpwlgkbbvq.rs:26:36\n\
    \   |\n26 |             arr[i] = String::from(&names[index]);\n   |          \
    \                          ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwlgkbbvq.rs:26:22\n   |\n26 |             arr[i] = String::from(&names[index]);\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n   |             |\n   |             expected due to the type\
    \ of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwlgkbbvq.rs:30:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n30 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n\n    while digits_len > 0 {\n      \
    \  let mut digit = digits.remove(0);\n        let mut digits_len = digits.len();\n\
    \n        while digits_len > 0 {\n            let mut digit = digits.remove(0);\n\
    \            let mut digits_len = digits.len();\n\n            if digit < 10 {\n\
    \                let mut digit = digit as usize;\n                let mut digits_len\
    \ = digits.len();\n\n                while digits_len > 0 {\n                \
    \    let mut digit = digits.remove(0);\n                    let mut digits_len\
    \ = digits.len();\n\n                    if digit < 10 {\n                   \
    \     let mut digit = digit as usize;\n                        let mut digits_len\
    \ = digits.len();\n\n                        while digits_len > 0 {\n        \
    \                    let mut digit = digits.remove(0);\n                     \
    \       let mut digits_len = digits.len();\n\n                            if digit\
    \ < 10 {\n                                let mut digit = digit as usize;\n  \
    \                              let mut digits_len = digits.len();\n          \
    \                  } else {\n                                break;\n        \
    \                    }\n                        }\n\n                        result.push(String::from(&names[digit]));\n\
    \                    } else {\n                        break;\n              \
    \      }\n                }\n            } else {\n                break;\n  \
    \          }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpga6g8i1r.rs:54:51\n\
    \   |\n54 |                         result.push(String::from(&names[digit]));\n\
    \   |                                                   ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().collect::<Vec<_>>();\n    let mut reversed =\
    \ vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n    let mut j = 0;\n\
    \n    while i < arr.len() {\n        if arr[i] < 10 {\n            digits.push(String::from(format!(\"\
    {}\", arr[i])));\n            i += 1;\n        } else {\n            reversed.push(rev::<isize>::reverse(arr[i]));\n\
    \            i += 1;\n        }\n    }\n\n    while j < digits.length {\n    \
    \    let mut i = 0;\n        while i < digits.length {\n            if digits[i]\
    \ != digits[j] {\n                reversed.push(rev::<isize>::reverse(digits[i]));\n\
    \                i += 1;\n            } else {\n                i += 1;\n    \
    \        }\n        }\n        j += 1;\n    }\n\n    reversed.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rev`\n\
    \  --> /tmp/tmpu5p7snam.rs:29:27\n   |\n29 |             reversed.push(rev::<isize>::reverse(arr[i]));\n\
    \   |                           ^^^ use of undeclared crate or module `rev`\n\n\
    error[E0433]: failed to resolve: use of undeclared crate or module `rev`\n  -->\
    \ /tmp/tmpu5p7snam.rs:38:31\n   |\n38 |                 reversed.push(rev::<isize>::reverse(digits[i]));\n\
    \   |                               ^^^ use of undeclared crate or module `rev`\n\
    \nerror[E0609]: no field `length` on type `Vec<String>`\n  --> /tmp/tmpu5p7snam.rs:34:22\n\
    \   |\n34 |     while j < digits.length {\n   |                      ^^^^^^ unknown\
    \ field\n\nerror[E0609]: no field `length` on type `Vec<String>`\n  --> /tmp/tmpu5p7snam.rs:36:26\n\
    \   |\n36 |         while i < digits.length {\n   |                          ^^^^^^\
    \ unknown field\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0433, E0609.\nFor more information about an error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = arr.clone();\n    reversed.reverse();\n    for &i in &reversed {\n       \
    \ arr.push(String::from(&format!(\"{}\", i)));\n    }\n    arr\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<isize> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpml1ez4tz.rs:17:35\n     |\n17   |     let mut arr =\
    \ arr.into_iter().cloned().collect::<Vec<_>>();\n     |                      \
    \             ^^^^^^ expected reference, found `isize`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `isize`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<std::vec::IntoIter<isize>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpml1ez4tz.rs:17:44\n \
    \  |\n17 |       let mut arr = arr.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<isize>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<isize>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<isize>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<isize>>: Iterator`\n      \
    \     which is required by `&mut Cloned<std::vec::IntoIter<isize>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    let mut result = vec![];\n    let mut i = 0;\n\
    \    while i < arr.len() {\n        let mut j = i;\n        while j < arr.len()\
    \ && arr[j] < 10 {\n            j += 1\n        }\n        let mut k = j;\n  \
    \      while k < arr.len() && arr[k] > 9 {\n            k += 1\n        }\n  \
    \      if k == j {\n            result.push(String::from(&arr[i]));\n        \
    \    i += 1;\n        } else {\n            result.push(by_length(arr.split_off(j..k)));\n\
    \            i = k;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpkn9y3_m7.rs:30:25\n   |\n30 |             result.push(String::from(&arr[i]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkn9y3_m7.rs:33:49\n   |\n33 |\
    \             result.push(by_length(arr.split_off(j..k)));\n   |             \
    \                                    ^^^^ expected `usize`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `usize`\n            found struct `std::ops::Range<usize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkn9y3_m7.rs:33:25\n   |\n33 |\
    \             result.push(by_length(arr.split_off(j..k)));\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut digits_reversed = reversed.iter().cloned().collect::<Vec<_>>();\n \
    \   let mut i = 0;\n    while i < digits_reversed.len() {\n        let mut j =\
    \ i;\n        while j < digits_reversed.len() {\n            if digits_reversed[j]\
    \ < 10 {\n                result.push(String::from(&digits_reversed[j]));\n  \
    \              j += 1;\n            } else {\n                let mut k = j;\n\
    \                while k < digits_reversed.len() {\n                    if digits_reversed[k]\
    \ == digits_reversed[j] {\n                        break;\n                  \
    \  }\n                    k += 1;\n                }\n                result.push(String::from(&digits_reversed[k]));\n\
    \                digits_reversed.swap(j, k);\n                j += 1;\n      \
    \      }\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp6gy_ylcs.rs:23:29\n   |\n23 |                 result.push(String::from(&digits_reversed[j]));\n\
    \   |                             ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0277]: the trait bound `String: From<&isize>`\
    \ is not satisfied\n  --> /tmp/tmp6gy_ylcs.rs:33:29\n   |\n33 |              \
    \   result.push(String::from(&digits_reversed[k]));\n   |                    \
    \         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = vec![];\n\n    for i in arr.iter().rev() {\n        let digit = i as usize;\n\
    \        let index = digit as usize;\n        let name = match index {\n     \
    \       0 => \"One\",\n            1 => \"Two\",\n            2 => \"Three\",\n\
    \            3 => \"Four\",\n            4 => \"Five\",\n            5 => \"Six\"\
    ,\n            6 => \"Seven\",\n            7 => \"Eight\",\n            8 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid digit {}\", digit),\n        };\n\
    \        reversed.push(name);\n    }\n\n    arr.iter_mut().for_each(|i| {\n  \
    \      let digit = i as usize;\n        let index = digit as usize;\n        let\
    \ name = match index {\n            0 => \"One\",\n            1 => \"Two\",\n\
    \            2 => \"Three\",\n            3 => \"Four\",\n            4 => \"\
    Five\",\n            5 => \"Six\",\n            6 => \"Seven\",\n            7\
    \ => \"Eight\",\n            8 => \"Nine\",\n            _ => panic!(\"Invalid\
    \ digit {}\", digit),\n        };\n        *i = name;\n    });\n\n    reversed\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc00bkdr3.rs:54:14\n   |\n\
    54 |         *i = name;\n   |         --   ^^^^ expected `isize`, found `&str`\n\
    \   |         |\n   |         expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc00bkdr3.rs:57:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n57 |     reversed\n   |\
    \     ^^^^^^^^ expected struct `String`, found `&str`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&str>`\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmpc00bkdr3.rs:22:21\n  \
    \ |\n22 |         let digit = i as usize;\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `usize`\n   |                     help: dereference the expression: `*i`\n\n\
    error[E0606]: casting `&mut isize` as `usize` is invalid\n  --> /tmp/tmpc00bkdr3.rs:40:21\n\
    \   |\n40 |         let digit = i as usize;\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&mut isize`\
    \ as `usize`\n   |                     help: dereference the expression: `*i`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i = 0;\n\
    \    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n            i +=\
    \ 1;\n            continue;\n        }\n        let mut j = i;\n        while\
    \ j < len {\n            if arr[j] > arr[i] {\n                break;\n      \
    \      }\n            i += 1;\n        }\n        swap(&mut arr[j], &mut arr[i]);\n\
    \    }\n    let mut result = vec![];\n    for i in 0..len {\n        result.push(String::from(&arr[i]));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpf_flkkf0.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpf_flkkf0.rs:36:21\n\
    \   |\n36 |         result.push(String::from(&arr[i]));\n   |                \
    \     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            let mut j = i;\n     \
    \       while j > 0 && arr[j - 1] > arr[j] {\n                j -= 1;\n      \
    \      }\n            arr[i] = by_digit(arr[j]);\n            i += 1;\n      \
    \  }\n    }\n    arr.iter().cloned().collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp6uzb57a_.rs:28:22\n\
    \   |\n28 |             arr[i] = by_digit(arr[j]);\n   |                     \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `isize`\n    --> /tmp/tmp6uzb57a_.rs:32:25\n\
    \     |\n32   |     arr.iter().cloned().collect()\n     |                    \
    \     ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            let j = i;\n            while j > 0\
    \ && arr[j - 1] > arr[j] {\n                j -= 1;\n            }\n         \
    \   arr[j] = String::from(&arr[i - j]);\n            i += j - 1;\n        }\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpdkwtssbc.rs:29:22\n   |\n29 |             arr[j] = String::from(&arr[i\
    \ - j]);\n   |                      ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <String as From<&str>>\n             <String\
    \ as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n          \
    \   <String as From<char>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdkwtssbc.rs:29:22\n\
    \   |\n29 |             arr[j] = String::from(&arr[i - j]);\n   |            \
    \ ------   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdkwtssbc.rs:33:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n33 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while len > 0 {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[arr.len() - len -\
    \ 1] = String::from(&name[arr[i] - 1]);\n            len -= 1;\n        }\n  \
    \  }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmp_dfnkh9r.rs:24:54\n\
    \   |\n24 |             arr[arr.len() - len - 1] = String::from(&name[arr[i] -\
    \ 1]);\n   |                                                      ^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_dfnkh9r.rs:24:40\n\
    \   |\n24 |             arr[arr.len() - len - 1] = String::from(&name[arr[i] -\
    \ 1]);\n   |             ------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_dfnkh9r.rs:28:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n28 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.iter().map(|x| {\n        match x % 10 {\n            0 => \"Zero\",\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n      \
    \  }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpyz7r441_.rs:33:8\n     |\n33 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n  \
    \  let mut reversed = vec![];\n\n    for i in arr.iter_mut() {\n        if i >=\
    \ 1 && i <= 9 {\n            reversed.push(i.to_string());\n        }\n    }\n\
    \n    for i in reversed.iter_mut() {\n        if i >= 1 && i <= 9 {\n        \
    \    *i = String::from(&format!(\"{}\", i));\n        }\n    }\n\n    reversed\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplwlwlayc.rs:22:17\n   |\n\
    22 |         if i >= 1 && i <= 9 {\n   |                 ^\n   |             \
    \    |\n   |                 expected `&mut isize`, found integer\n   |      \
    \           help: consider mutably borrowing here: `&mut 1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplwlwlayc.rs:22:27\n   |\n22 |         if i >= 1 && i <=\
    \ 9 {\n   |                           ^\n   |                           |\n  \
    \ |                           expected `&mut isize`, found integer\n   |     \
    \                      help: consider mutably borrowing here: `&mut 9`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplwlwlayc.rs:28:17\n   |\n28 |         if i >=\
    \ 1 && i <= 9 {\n   |                 ^ expected `&mut String`, found integer\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplwlwlayc.rs:28:27\n   |\n28 |\
    \         if i >= 1 && i <= 9 {\n   |                           ^ expected `&mut\
    \ String`, found integer\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut digits_iter = reversed.iter().cloned();\n    let mut digits_iter =\
    \ digits_iter.map(|&x| {\n        if x <= 9 {\n            String::from(&format!(\"\
    {}\", x))\n        } else {\n            String::from(&format!(\"{}\", x - 10))\n\
    \        }\n    });\n\n    let mut i = 0;\n    while i < digits_iter.len() {\n\
    \        let mut j = i;\n        while j < digits_iter.len() && digits_iter[j]\
    \ == digits_iter[j - 1] {\n            j += 1\n        }\n        if j - i > 1\
    \ {\n            result.push(digits_iter.iter().skip(i).take(j - i).collect::<String>());\n\
    \            i += j - i;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3jwkruhh.rs:22:44\n   |\n\
    22 |     let mut digits_iter = digits_iter.map(|&x| {\n   |                  \
    \                          ^--\n   |                                         \
    \   ||\n   |                                            |expected due to this\n\
    \   |                                            expected `isize`, found reference\n\
    \   |                                            help: did you mean `x`: `&isize`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0608]: cannot index into a value of type `Map<Cloned<std::slice::Iter<'_,\
    \ isize>>, [closure@/tmp/tmp3jwkruhh.rs:22:43: 28:6]>`\n  --> /tmp/tmp3jwkruhh.rs:33:40\n\
    \   |\n33 |         while j < digits_iter.len() && digits_iter[j] == digits_iter[j\
    \ - 1] {\n   |                                        ^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Map<Cloned<std::slice::Iter<'_, isize>>,\
    \ [closure@/tmp/tmp3jwkruhh.rs:22:43: 28:6]>`\n  --> /tmp/tmp3jwkruhh.rs:33:58\n\
    \   |\n33 |         while j < digits_iter.len() && digits_iter[j] == digits_iter[j\
    \ - 1] {\n   |                                                          ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `iter` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmp3jwkruhh.rs:37:37\n   |\n37 |             result.push(digits_iter.iter().skip(i).take(j\
    \ - i).collect::<String>());\n   |                                     ^^^^ private\
    \ field, not a method\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        let mut j = i;\n        while j < arr.len() && arr[j]\
    \ < 10 {\n            j += 1\n        }\n        if j == i {\n            result.push(String::from(\"\
    One\"));\n            i += 1;\n        } else {\n            result.push(String::from(&arr[i\
    \ - j]));\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpa9_fi17l.rs:25:25\n   |\n25 |             result.push(String::from(&arr[i\
    \ - j]));\n   |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut digits_iter = reversed.iter().cloned();\n    let mut digits_iter =\
    \ digits_iter.map(|digit| {\n        if digit < 10 {\n            String::from(\"\
    One\")\n        } else if digit < 20 {\n            String::from(\"Two\")\n  \
    \      } else if digit < 30 {\n            String::from(\"Three\")\n        }\
    \ else if digit < 40 {\n            String::from(\"Four\")\n        } else if\
    \ digit < 50 {\n            String::from(\"Five\")\n        } else if digit <\
    \ 60 {\n            String::from(\"Six\")\n        } else if digit < 70 {\n  \
    \          String::from(\"Seven\")\n        } else if digit < 80 {\n         \
    \   String::from(\"Eight\")\n        } else if digit < 90 {\n            String::from(\"\
    Nine\")\n        } else {\n            String::from(\"Ten\")\n        }\n    });\n\
    \    let mut digits_iter = digits_iter.cloned();\n    let mut digits_iter = digits_iter.map(|digit|\
    \ {\n        if digit < 10 {\n            String::from(\"One\")\n        } else\
    \ if digit < 20 {\n            String::from(\"Two\")\n        } else if digit\
    \ < 30 {\n            String::from(\"Three\")\n        } else if digit < 40 {\n\
    \            String::from(\"Four\")\n        } else if digit < 50 {\n        \
    \    String::from(\"Five\")\n        } else if digit < 60 {\n            String::from(\"\
    Six\")\n        } else if digit < 70 {\n            String::from(\"Seven\")\n\
    \        } else if digit < 80 {\n            String::from(\"Eight\")\n       \
    \ } else if digit < 90 {\n            String::from(\"Nine\")\n        } else {\n\
    \            String::from(\"Ten\")\n        }\n    });\n    let mut digits_iter\
    \ = digits_iter.cloned();\n    let mut digits_iter = digits_iter.map(|digit| {\n\
    \        if digit < 10 {\n            String::from(\"One\")\n        } else if\
    \ digit < 20 {\n            String::from(\"Two\")\n        } else if digit < 30\
    \ {\n            String::from(\"Three\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmpquwkuk3p.rs:85:110\n\
    \   |\n85 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n   |  ______________________________________________________________________________________________________________^\n\
    86 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.clone();\n    let mut len = arr.len();\n    let mut i = 0;\n \
    \   while i < len {\n        if arr[i] > 9 {\n            len = i;\n        }\
    \ else {\n            i += 1;\n        }\n    }\n    let mut result = vec![];\n\
    \    while i < len {\n        result.push(by_length(arr.split_off(i)));\n    \
    \    i += 1;\n    }\n    let mut i = 0;\n    while i < len {\n        let mut\
    \ j = i;\n        while j < len {\n            if arr[j] > 9 {\n             \
    \   j += 1;\n            } else {\n                break;\n            }\n   \
    \     }\n        let mut k = i;\n        while k < j {\n            result.push(by_length(arr.split_off(k)));\n\
    \            k += 1;\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3095ko2o.rs:49:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    49 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.clone();\n    reversed.reverse();\n    for digit\
    \ in &reversed {\n        let index = digit as usize;\n        let name = match\
    \ index {\n            0 => \"One\",\n            1 => \"Two\",\n            2\
    \ => \"Three\",\n            3 => \"Four\",\n            4 => \"Five\",\n    \
    \        5 => \"Six\",\n            6 => \"Seven\",\n            7 => \"Eight\"\
    ,\n            8 => \"Nine\",\n            _ => panic!(\"Invalid digit {}\", digit),\n\
    \        };\n        result.push(name);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7b5xneo3.rs:34:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    34 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmp7b5xneo3.rs:19:21\n\
    \   |\n19 |         let index = digit as usize;\n   |                     -----^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `usize`\n   |                     help: dereference the expression: `*digit`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n            continue;\n        }\n\n        let mut j = i;\n    \
    \    while j < len {\n            if arr[j] > arr[i] {\n                break;\n\
    \            }\n            i += 1;\n        }\n\n        let mut tmp = arr[j];\n\
    \        arr[j] = arr[i];\n        arr[i] = tmp;\n        i += 1;\n    }\n\n \
    \   let mut result = vec![];\n    for i in arr {\n        result.push(String::from(&names[i]))\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpsktsv13a.rs:43:35\n\
    \   |\n43 |         result.push(String::from(&names[i]))\n   |               \
    \                    ^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n\n    while\
    \ i < arr.len() {\n        let mut current = arr[i];\n        while current >\
    \ 9 {\n            current /= 10;\n        }\n        if current > 1 {\n     \
    \       result.push(by_digit(current, &mut i, &mut j));\n        }\n        i\
    \ += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpl38guzaq.rs:28:25\n\
    \   |\n28 |             result.push(by_digit(current, &mut i, &mut j));\n   |\
    \                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        let len = arr[i] - 1;\n        if len < 1 || len > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        result.push(String::from(&arr[len\
    \ - i].to_string()));\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvk8xjn4c.rs:22:45\n   |\n\
    22 |         result.push(String::from(&arr[len - i].to_string()));\n   |     \
    \                                        ^ expected `isize`, found `usize`\n\n\
    error[E0277]: cannot subtract `usize` from `isize`\n  --> /tmp/tmpvk8xjn4c.rs:22:43\n\
    \   |\n22 |         result.push(String::from(&arr[len - i].to_string()));\n  \
    \ |                                           ^ no implementation for `isize -\
    \ usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpvk8xjn4c.rs:22:35\n\
    \   |\n22 |         result.push(String::from(&arr[len - i].to_string()));\n  \
    \ |                                   ^^^^^^^^^^^^ slice indices are of type `usize`\
    \ or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not\
    \ implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_len = digits_len.saturating_add((digits_len\
    \ % 10) as usize);\n    let mut digits_len = digits_len.saturating_add(1);\n \
    \   let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digits_len\
    \ = digits_len.saturating_add(1);\n    let mut digits_len = digits_len.saturating_add(1);\n\
    \    let mut digits_len = digits_len.saturating_add(1);\n    let mut digit\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpn5ybhczl.rs:50:18\n   |\n\
    50 |     let mut digit\n   |                  ^ help: add `;` here\n51 | }\n \
    \  | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn5ybhczl.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut reversed = vec![];\n    let mut\
    \ digits = vec![];\n    let mut counter = 0;\n\n    while arr.len() > 0 {\n  \
    \      let mut digit = arr.len() - 1;\n        while digit >= 0 && counter < 10\
    \ {\n            digit = digit - 1;\n            counter = counter + 1;\n    \
    \    }\n        reversed.push(String::from(&arr[digit].to_string()));\n      \
    \  digits.push(counter);\n        arr.pop();\n    }\n\n    for i in 0..(reversed.len()\
    \ - 1) {\n        let mut digit = reversed[i].to_string();\n        for j in 0..(digits.len()\
    \ - 1) {\n            if digits[j] < digits[j + 1] {\n                digit =\
    \ digits[j].to_string();\n            }\n        }\n        reversed[i] = digit;\n\
    \    }\n\n    reversed\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmp_glmwwia.rs:26:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.clone();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number in array: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpdx8c2mp1.rs:34:8\n     |\n34 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n            i += 1;\n        }\n    }\n\n    arr\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpq24401am.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpq24401am.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq24401am.rs:30:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n30 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n    \
    \            swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j\
    \ += 1;\n        }\n\n        i += 1;\n    }\n\n    arr.iter().map(|&x| String::from(&x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmptfoffq36.rs:30:17\n\
    \   |\n30 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmptfoffq36.rs:38:25\n   |\n38 |     arr.iter().map(|&x| String::from(&x)).collect()\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let mut j\
    \ = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n  \
    \      }\n        reversed.push(arr[j]);\n        i += j - 1;\n    }\n    for\
    \ i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j > 0\
    \ && reversed[j - 1] < reversed[j] {\n            j -= 1;\n        }\n       \
    \ reversed.swap(j, j + 1);\n    }\n    for i in 0..(reversed.len() - 1) {\n  \
    \      let mut j = i;\n        while j > 0 && reversed[j - 1] < reversed[j] {\n\
    \            j -= 1;\n        }\n        reversed.swap(j, j + 1);\n    }\n   \
    \ for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j\
    \ > 0 && reversed[j - 1] < reversed[j] {\n            j -= 1;\n        }\n   \
    \     reversed.swap(j, j + 1);\n    }\n    for i in 0..(reversed.len() - 1) {\n\
    \        let mut j = i;\n        while j > 0 && reversed[j - 1] < reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(j, j + 1);\n    }\n\
    \    for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while\
    \ j > 0 && reversed[j - 1] < reversed[j] {\n            j -= 1;\n        }\n \
    \       reversed.swap(j, j + 1);\n    }\n    for i in 0..(reversed.len() - 1)\
    \ {\n        let mut j = i;\n        while j > 0 && reversed[j - 1] < reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(j, j + 1);\n    }\n\
    \    for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while\
    \ j > 0 && reversed[j - 1] < reversed[j] {\n            j -= 1;\n        }\n \
    \       reversed.swap(j, j + 1);\n    }\n    for i in 0..(reversed.len() - 1)\
    \ {\n        let mut j = i;\n        while j > 0 && reversed[j - 1] < reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(j, j + 1);\n    }\n\
    \    for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while\
    \ j > 0 && reversed[j - 1] < reversed[j] {\n            j -= 1;\n        }\n \
    \       reversed.swap(j, j + 1);\n\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpro7ovq1u.rs:101:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n85  |     for\
    \ i in 0..(reversed.len() - 1) {\n    |                                      -\
    \ this delimiter might not be properly closed...\n...\n92  | }\n    | - ...as\
    \ it matches this but it has different indentation\n...\n101 | }\n    |   ^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpro7ovq1u.rs:13:34\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------             \
    \        ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n            i += 1;\n        }\n    }\n\n    arr\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmptp32suv1.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptp32suv1.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptp32suv1.rs:30:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n30 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = vec![];\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i;\n     \
    \   while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n        }\n   \
    \     reversed.push(arr[j]);\n        i += 1;\n    }\n    for i in 0..(reversed.len()\
    \ - 1) {\n        let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(i, j);\n    }\n   \
    \ for i in 0..(reversed.len() - 1) {\n        reversed.push(String::from(\"One\"\
    ));\n        reversed.push(String::from(\"Two\"));\n        reversed.push(String::from(\"\
    Three\"));\n        reversed.push(String::from(\"Four\"));\n        reversed.push(String::from(\"\
    Five\"));\n        reversed.push(String::from(\"Six\"));\n        reversed.push(String::from(\"\
    Seven\"));\n        reversed.push(String::from(\"Eight\"));\n        reversed.push(String::from(\"\
    Nine\"));\n    }\n    reversed\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:36:23\n   |\n\
    36 |         reversed.push(String::from(\"One\"));\n   |                     \
    \  ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcjchhjc2.rs:37:23\n   |\n37 |         reversed.push(String::from(\"\
    Two\"));\n   |                       ^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:38:23\n\
    \   |\n38 |         reversed.push(String::from(\"Three\"));\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:39:23\n   |\n39 |  \
    \       reversed.push(String::from(\"Four\"));\n   |                       ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcjchhjc2.rs:40:23\n   |\n40 |         reversed.push(String::from(\"\
    Five\"));\n   |                       ^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:41:23\n\
    \   |\n41 |         reversed.push(String::from(\"Six\"));\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcjchhjc2.rs:42:23\n   |\n42 |         reversed.push(String::from(\"\
    Seven\"));\n   |                       ^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:43:23\n\
    \   |\n43 |         reversed.push(String::from(\"Eight\"));\n   |            \
    \           ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpcjchhjc2.rs:44:23\n   |\n44 |  \
    \       reversed.push(String::from(\"Nine\"));\n   |                       ^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpcjchhjc2.rs:46:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<St"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut reversed = vec![];\n    let mut\
    \ digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n        let\
    \ digit = arr[i];\n        if digit < 10 {\n            digits.push(digit);\n\
    \        } else {\n            digits.push(digit % 10 as usize);\n           \
    \ digits.push(digit / 10 as usize);\n        }\n        i += 1;\n    }\n    for\
    \ i in 0..digits.len() {\n        let digit = digits[i];\n        let index =\
    \ digit as usize;\n        let digit = match index {\n            0 => String::from(\"\
    One\"),\n            1 => String::from(\"Two\"),\n            2 => String::from(\"\
    Three\"),\n            3 => String::from(\"Four\"),\n            4 => String::from(\"\
    Five\"),\n            5 => String::from(\"Six\"),\n            6 => String::from(\"\
    Seven\"),\n            7 => String::from(\"Eight\"),\n            8 => String::from(\"\
    Nine\"),\n            _ => panic!(\"Invalid digit index: {}\", index),\n     \
    \   };\n        reversed.push(digit);\n    }\n    reversed.reverse();\n    for\
    \ digit in reversed {\n        arr.push(digit as isize);\n    }\n    arr\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprzytmisw.rs:27:33\n   |\n\
    27 |             digits.push(digit % 10 as usize);\n   |                     \
    \            ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot\
    \ mod `isize` by `usize`\n  --> /tmp/tmprzytmisw.rs:27:31\n   |\n27 |        \
    \     digits.push(digit % 10 as usize);\n   |                               ^\
    \ no implementation for `isize % usize`\n   |\n   = help: the trait `Rem<usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprzytmisw.rs:28:33\n\
    \   |\n28 |             digits.push(digit / 10 as usize);\n   |              \
    \                   ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ cannot divide `isize` by `usize`\n  --> /tmp/tmprzytmisw.rs:28:31\n   |\n28\
    \ |             digits.push(digit / 10 as usize);\n   |                      \
    \         ^ no implementation for `isize / usize`\n   |\n   = help: the trait\
    \ `Div<usize>` is not implemented for `isize`\n   = help: the following other\
    \ types implement trait `Div<Rhs>`:\n             <&'a f32 as Div<f32>>\n    \
    \         <&'a f64 as Div<f64>>\n             <&'a i128 as Div<i128>>\n      \
    \       <&'a i16 as Div<i16>>\n             <&'a i32 as Div<i32>>\n          \
    \   <&'a i64 as Div<i64>>\n             <&'a i8 as Div<i8>>\n             <&'a\
    \ isize as Div<isize>>\n           and 54 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmprzytmisw.rs:53:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n53 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n        "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() && arr[j] < 1\
    \ {\n            i += 1;\n            j += 1\n        }\n        let mut k = j;\n\
    \        while k < arr.len() && arr[k] > 9 {\n            i += 1;\n          \
    \  k += 1\n        }\n        let mut reversed = vec![];\n        reversed.extend_from_slice(&arr[i..k]);\n\
    \        reversed.extend_from_slice(&arr[k..j]);\n        result.extend_from_slice(&reversed);\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpif3ebw_u.rs:40:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    40 |     result\n   |     ^^^^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = vec![];\n    let mut counter = 0;\n\
    \    let mut cur = arr[0];\n    let mut last = 0;\n    while cur > 0 {\n     \
    \   digits.push(cur % 10);\n        counter += 1;\n        cur /= 10;\n    }\n\
    \    digits.push(counter);\n    let mut i = 0;\n    while i < digits.size() {\n\
    \        let mut cur = digits[i];\n        let mut last = 0;\n        while cur\
    \ > 0 {\n            let mut index = last + 1;\n            if index > 9 {\n \
    \               index = 0;\n            }\n            result.push(String::from(&names[index]));\n\
    \            last += 1;\n            cur /= 10;\n        }\n        i += 1;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp9fg4tqaj.rs:37:39\n\
    \   |\n37 |             result.push(String::from(&names[index]));\n   |      \
    \                                 ^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `size` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmp9fg4tqaj.rs:29:22\n   |\n29 |     while i < digits.size() {\n \
    \  |                      ^^^^ help: there is an associated function with a similar\
    \ name: `resize`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut i = 0;\n    let mut digit = reversed.pop();\n    while digit != 0 {\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 100 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 1000 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n        digit = reversed.pop();\n    }\n    for digit\
    \ in digits {\n        if digit < 10 {\n            result.push(String::from(\"\
    One\"));\n        } else if digit < 100 {\n            result.push(String::from(\"\
    Two\"));\n        } else if digit < 1000 {\n            result.push(String::from(\"\
    Three\"));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp57dcnomn.rs:23:20\n   |\n\
    23 |     while digit != 0 {\n   |                    ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    23 |     while digit != Some(0) {\n   |                    +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp57dcnomn.rs:24:20\n   |\n24 |         if digit\
    \ < 10 {\n   |                    ^^ expected enum `Option`, found integer\n \
    \  |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n24 |         if digit < Some(10)\
    \ {\n   |                    +++++  +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp57dcnomn.rs:26:27\n   |\n26 |         } else if digit < 100 {\n   |\
    \                           ^^^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n26 |         } else if digit\
    \ < Some(100) {\n   |                           +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp57dcnomn.rs:28:27\n   |\n28 |         } else if digit <\
    \ 1000 {\n   |                           ^^^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<isize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n28 |         } else if digit\
    \ < Some(1000) {\n   |                           +++++    +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp57dcnomn.rs:30:27\n   |\n30 |         } else if digit <\
    \ 10000 {\n   |                           ^^^^^ expected enum `Option`, found\
    \ integer\n   |\n   = note: expected enum `Option<isize>`\n              found\
    \ type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n30 |  \
    \       } else if digit < Some(10000) {\n   |                           +++++\
    \     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp57dcnomn.rs:32:27\n \
    \  |\n32 |         } else if digit < 100000 {\n   |                 "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            arr[i] = \"One\".to_string();\n   \
    \         i += 1;\n            arr[i] = \"Two\".to_string();\n            i +=\
    \ 1;\n            arr[i] = \"Three\".to_string();\n            i += 1;\n     \
    \       arr[i] = \"Four\".to_string();\n            i += 1;\n            arr[i]\
    \ = \"Five\".to_string();\n            i += 1;\n            arr[i] = \"Six\".to_string();\n\
    \            i += 1;\n            arr[i] = \"Seven\".to_string();\n          \
    \  i += 1;\n            arr[i] = \"Eight\".to_string();\n            i += 1;\n\
    \            arr[i] = \"Nine\".to_string();\n            i += 1;\n        }\n\
    \    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbz3qpvtt.rs:25:22\n   |\n\
    25 |             arr[i] = \"One\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbz3qpvtt.rs:27:22\n   |\n27 |             arr[i] = \"Two\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbz3qpvtt.rs:29:22\n   |\n29 |\
    \             arr[i] = \"Three\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbz3qpvtt.rs:31:22\n   |\n31 |             arr[i] = \"Four\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbz3qpvtt.rs:33:22\n   |\n33 |\
    \             arr[i] = \"Five\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbz3qpvtt.rs:35:22\n   |\n35 |             arr[i] = \"Six\".to_string();\n\
    \   |             ------   ^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \   |             |\n   |             expected due to the type of this binding\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbz3qpvtt.rs:37:22\n   |\n37 |\
    \             arr[i] = \"Seven\".to_string();\n   |             ------   ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbz3qpvtt.rs:39:22\n   |\n39 |             arr[i] = \"Eight\".to_string"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut len = arr.len();\n\
    \    while len > 0 {\n        let mut cur = arr.len() - 1;\n        while cur\
    \ >= 0 {\n            if arr[cur] > 9 {\n                cur -= 1;\n         \
    \   } else {\n                break;\n            }\n        }\n        result.push(String::from(&arr[cur].to_string()));\n\
    \        len -= 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp22ztarqf.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.to_owned();\n    let mut result = vec![];\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i;\n     \
    \   while j < arr.len() && arr[j] < 10 {\n            j += 1\n        }\n    \
    \    let mut k = j;\n        while k < arr.len() && arr[k] > 9 {\n           \
    \ k += 1\n        }\n        if k == j {\n            result.push(String::from(&arr[i]));\n\
    \            i += 1;\n        } else {\n            result.push(String::from(&arr[k]));\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpieworl7o.rs:27:25\n   |\n27 |             result.push(String::from(&arr[i]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<&isize>` is not satisfied\n  -->\
    \ /tmp/tmpieworl7o.rs:30:25\n   |\n30 |             result.push(String::from(&arr[k]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut i = 0;\n    while i\
    \ < arr.len() {\n        let mut j = i;\n        while j < arr.len() && arr[j]\
    \ < 10 {\n            j += 1\n        }\n        if j - i > 1 {\n            result.push(by_length(arr.split_off(j).reverse()));\n\
    \        }\n        result.push(by_name(arr.split_off(i)));\n        i = j;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_name` in this scope\n  --> /tmp/tmpjdvzrkus.rs:24:21\n\
    \   |\n24 |         result.push(by_name(arr.split_off(i)));\n   |            \
    \         ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjdvzrkus.rs:22:35\n   |\n22 |             result.push(by_length(arr.split_off(j).reverse()));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n         \
    \  found unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjdvzrkus.rs:27:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n27 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.to_owned();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    arr.iter().map(|x| {\n        match x {\n           \
    \ 1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n    \
    \        4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpk8pjsm_5.rs:30:8\n     |\n30 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    let mut result = vec![];\n    for x in arr {\n      \
    \  let mut s = String::new();\n        if x < 10 {\n            s.push_str(&format!(\"\
    One\", x));\n        } else if x < 100 {\n            s.push_str(&format!(\"Two\"\
    , x - 10));\n        } else if x < 1000 {\n            s.push_str(&format!(\"\
    Three\", x - 100));\n        } else if x < 10000 {\n            s.push_str(&format!(\"\
    Four\", x - 1000));\n        } else if x < 100000 {\n            s.push_str(&format!(\"\
    Five\", x - 10000));\n        } else if x < 1000000 {\n            s.push_str(&format!(\"\
    Six\", x - 100000));\n        } else if x < 10000000 {\n            s.push_str(&format!(\"\
    Seven\", x - 1000000));\n        } else if x < 100000000 {\n            s.push_str(&format!(\"\
    Eight\", x - 10000000));\n        } else if x < 1000000000 {\n            s.push_str(&format!(\"\
    Nine\", x - 100000000));\n        } else {\n            s.push_str(&format!(\"\
    Ten\", x - 1000000000));\n        }\n        result.push(s);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpkxnrti87.rs:24:40\n   |\n24 |\
    \             s.push_str(&format!(\"One\", x));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpkxnrti87.rs:26:40\n   |\n26 |             s.push_str(&format!(\"\
    Two\", x - 10));\n   |                                 -----  ^^^^^^ argument\
    \ never used\n   |                                 |\n   |                   \
    \              formatting specifier missing\n\nerror: argument never used\n  -->\
    \ /tmp/tmpkxnrti87.rs:28:42\n   |\n28 |             s.push_str(&format!(\"Three\"\
    , x - 100));\n   |                                 -------  ^^^^^^^ argument never\
    \ used\n   |                                 |\n   |                         \
    \        formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpkxnrti87.rs:30:41\n\
    \   |\n30 |             s.push_str(&format!(\"Four\", x - 1000));\n   |      \
    \                           ------  ^^^^^^^^ argument never used\n   |       \
    \                          |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpkxnrti87.rs:32:41\n\
    \   |\n32 |             s.push_str(&format!(\"Five\", x - 10000));\n   |     \
    \                            ------  ^^^^^^^^^ argument never used\n   |     \
    \                            |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpkxnrti87.rs:34:40\n\
    \   |\n34 |             s.push_str(&format!(\"Six\", x - 100000));\n   |     \
    \                            -----  ^^^^^^^^^^ argument never used\n   |     \
    \                            |\n   |                                 formatting\
    \ specifier missing\n\nerror: argument never used\n  --> /tmp/tmpkxnrti87.rs:36:42\n\
    \   |\n36 |             s.push_str(&format!(\"Seven\", x - 1000000));\n   |  \
    \                               -------  ^^^^^^^^^^^ argument never used\n   |\
    \                                 |\n   |              "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    for num in arr {\n        if num < 1 || num\
    \ > 9 {\n            continue;\n        }\n\n        let mut reversed = num;\n\
    \        reversed.reverse();\n        let mut digit = reversed.to_string();\n\
    \        let mut name = String::from(\"One\");\n\n        while digit.len() >\
    \ 0 {\n            let index = digit.len() - 1;\n            let digit = digit.chars().nth(index).unwrap();\n\
    \            name = name.chars().nth(index).unwrap().to_ascii_lowercase().to_string();\n\
    \            digit = digit.chars().nth(index).unwrap();\n        }\n\n       \
    \ result.push(name);\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpuclmfrjk.rs:26:18\n   |\n26 |         reversed.reverse();\n\
    \   |                  ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reverse_bits`\n\nerror[E0599]: no method named `chars` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpuclmfrjk.rs:34:27\n   |\n34 |   \
    \          digit = digit.chars().nth(index).unwrap();\n   |                  \
    \         ^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    for num in arr {\n        if\
    \ num < 1 || num > 9 {\n            continue;\n        }\n        result.push(String::from(&format!(\"\
    {}\", num)));\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"3\", \"2\", \"8\", \"5\", \"4\", \"1\", \"1\", \"2\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpbk6lr27n.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        let mut k = i;\n        while k < j && arr[k] > 9 {\n\
    \            k += 1\n        }\n        if k > j {\n            result.push(by_length(arr.split_off(j)));\n\
    \            i = k;\n        } else {\n            result.push(by_length(arr.split_off(k)));\n\
    \            i = j;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphw4wdke6.rs:36:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    36 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.clone();\n    arr.sort_unstable();\n    arr.reverse();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number in array: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpdx8c2mp1.rs:34:8\n     |\n34 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            let mut j = i;\n     \
    \       while j < len {\n                if arr[j] < 1 || arr[j] > 9 {\n     \
    \               break;\n                }\n                j += 1;\n         \
    \   }\n            swap(&mut arr[i], &mut arr[j]);\n        }\n        i += 1;\n\
    \    }\n    let mut result = vec![];\n    for i in arr.iter().cloned().rev() {\n\
    \        result.push(String::from(&format!(\"{}\", i)));\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpy0v99j92.rs:32:13\n\
    \   |\n32 |             swap(&mut arr[i], &mut arr[j]);\n   |             ^^^^\
    \ not found in this scope\n   |\nhelp: consider importing one of these items\n\
    \   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect();\n    arr.sort_unstable();\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        if arr[i] < 10 {\n            result.push(String::from(\"One\"));\n \
    \       } else if arr[i] < 20 {\n            result.push(String::from(\"Two\"\
    ));\n        } else if arr[i] < 30 {\n            result.push(String::from(\"\
    Three\"));\n        } else if arr[i] < 40 {\n            result.push(String::from(\"\
    Four\"));\n        } else if arr[i] < 50 {\n            result.push(String::from(\"\
    Five\"));\n        } else if arr[i] < 60 {\n            result.push(String::from(\"\
    Six\"));\n        } else if arr[i] < 70 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if arr[i] < 80 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if arr[i] < 90 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(format!(\"{}\"\
    , arr[i])));\n        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp221fhecv.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    let mut i = 0;\n    let mut j = 0;\n    let\
    \ mut k = 0;\n\n    while i < arr.len() {\n        if arr[i] < 10 {\n        \
    \    result.append(&vec![String::from(\"One\")[arr[i] - 1]]);\n            i +=\
    \ 1;\n        } else {\n            result.append(&vec![String::from(\"Two\")[arr[i]\
    \ - 10]]);\n            i += 1;\n        }\n    }\n\n    while j < arr.len() {\n\
    \        if arr[j] < 10 {\n            result.append(&vec![String::from(\"Two\"\
    )[arr[j] - 1]]);\n            j += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Three\")[arr[j] - 10]]);\n            j += 1;\n        }\n    }\n\n    while k\
    \ < arr.len() {\n        if arr[k] < 10 {\n            result.append(&vec![String::from(\"\
    Three\")[arr[k] - 1]]);\n            k += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Four\")[arr[k] - 10]]);\n            k += 1;\n        }\n    }\n\n    while i\
    \ < arr.len() {\n        if arr[i] < 10 {\n            result.append(&vec![String::from(\"\
    Four\")[arr[i] - 1]]);\n            i += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Five\")[arr[i] - 10]]);\n            i += 1;\n        }\n    }\n\n    while j\
    \ < arr.len() {\n        if arr[j] < 10 {\n            result.append(&vec![String::from(\"\
    Five\")[arr[j] - 1]]);\n            j += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Six\")[arr[j] - 10]]);\n            j += 1;\n        }\n    }\n\n    while k <\
    \ arr.len() {\n        if arr[k] < 10 {\n            result.append(&vec![String::from(\"\
    Six\")[arr[k] - 1]]);\n            k += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Seven\")[arr[k] - 10]]);\n            k += 1;\n        }\n    }\n\n    while i\
    \ < arr.len() {\n        if arr[i] < 10 {\n            result.append(&vec![String::from(\"\
    Seven\")[arr[i] - 1]]);\n            i += 1;\n        } else {\n            result.append(&vec![String::from(\"\
    Eight\")[arr[i] - 10]]);\n            i += 1;\n        }\n    }\n\n    while j\
    \ < arr.len() {\n        if arr[j] < 10 {\n            result.append(\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpjsfy5fi0.rs:106:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n94  |     while\
    \ j < arr.len() {\n    |                         - unclosed delimiter\n95  | \
    \        if arr[j] < 10 {\n    |                        - this delimiter might\
    \ not be properly closed...\n96  |             result.append(\n97  | }\n    |\
    \ - ...as it matches this but it has different indentation\n...\n106 | }\n   \
    \ |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpjsfy5fi0.rs:96:26\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n96 |             result.append(\n   |                          ^ unclosed\
    \ delimiter\n97 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `isize`\n  --> /tmp/tmpjsfy5fi0.rs:26:33\n\
    \   |\n26 |             result.append(&vec![String::from(\"One\")[arr[i] - 1]]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `isize`\n   |\n   = help: the trait `Index<isize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjsfy5fi0.rs:26:27\n\
    \   |\n26 |             result.append(&vec![String::from(\"One\")[arr[i] - 1]]);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ\
    \ in mutability\n   |\n   = note: expected mutable reference `&mut Vec<_>`\n \
    \                     found reference `&Vec<_>`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `isize`\n  "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let len = arr[i] - 1;\n        if len < 1 || len > 9 {\n            i += 1;\n\
    \            continue;\n        }\n        result.push(by_length(arr.iter().skip(i).take(len).collect()));\n\
    \        i += len;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphyxana6e.rs:25:55\n   |\n\
    25 |         result.push(by_length(arr.iter().skip(i).take(len).collect()));\n\
    \   |                                                       ^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |         result.push(by_length(arr.iter().skip(i).take(len.try_into().unwrap()).collect()));\n\
    \   |                                                          ++++++++++++++++++++\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&isize`\n    --> /tmp/tmphyxana6e.rs:25:31\n     |\n\
    25   |         result.push(by_length(arr.iter().skip(i).take(len).collect()));\n\
    \     |                     --------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&isize>`\n\
    \     |                     |\n     |                     required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphyxana6e.rs:26:14\n   |\n26 |         i += len;\n\
    \   |              ^^^ expected `usize`, found `isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphyxana6e.rs:28:5\n   |\n13 | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n   |                                  ----------- expected\
    \ `Vec<String>` because of return type\n...\n28 |     result\n   |     ^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror[E0277]:\
    \ cannot add-assign `isize` to `usize`\n  --> /tmp/tmphyxana6e.rs:26:11\n   |\n\
    26 |         i += len;\n   |           ^^ no implementation for `usize += isize`\n\
    \   |\n   = help: the trait `AddAssign<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `AddAssign"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n \
    \       let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n       \
    \     j += 1\n        }\n        if j - i > 1 {\n            result.push(by_length(arr.iter().skip(i).take(j\
    \ - i).cloned()));\n        }\n        i = j;\n    }\n    result.push(by_length(arr.iter().skip(i).cloned()));\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn33xugob.rs:26:35\n   |\n\
    26 |             result.push(by_length(arr.iter().skip(i).take(j - i).cloned()));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Cloned<std::iter::Take<Skip<std::slice::Iter<'_,\
    \ isize>>>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn33xugob.rs:30:27\n\
    \   |\n30 |     result.push(by_length(arr.iter().skip(i).cloned()));\n   |   \
    \                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `Cloned`\n   |\n   = note: expected struct `Vec<isize>`\n           \
    \   found struct `Cloned<Skip<std::slice::Iter<'_, isize>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn33xugob.rs:31:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n31 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        let mut digit = digits[j];\n        let\
    \ mut digits_len = digits.len();\n        while digit > 9 {\n            digits_len\
    \ -= 1;\n            digit /= 10;\n        }\n        result.push(String::from(&digits[digits_len]));\n\
    \        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpwy5gvxdw.rs:32:21\n   |\n32 |         result.push(String::from(&digits[digits_len]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digit_pos = 0;\n    let mut\
    \ digit_len = 0;\n    while digit_pos < digits_len {\n        digit_len = 0;\n\
    \        for digit in &digits[digit_pos] {\n            if digit > 9 {\n     \
    \           break;\n            }\n            digit_len += 1;\n        }\n  \
    \      if digit_len > 0 {\n            let mut digit_str = String::new();\n  \
    \          for _ in 0..digit_len - 1 {\n                digit_str.push(\"One\"\
    );\n            }\n            for _ in 0..digit_len - 2 {\n                digit_str.push(\"\
    Two\");\n            }\n            for _ in 0..digit_len - 3 {\n            \
    \    digit_str.push(\"Three\");\n            }\n            for _ in 0..digit_len\
    \ - 4 {\n                digit_str.push(\"Four\");\n            }\n          \
    \  for _ in 0..digit_len - 5 {\n                digit_str.push(\"Five\");\n  \
    \          }\n            for _ in 0..digit_len - 6 {\n                digit_str.push(\"\
    Six\");\n            }\n            for _ in 0..digit_len - 7 {\n            \
    \    digit_str.push(\"Seven\");\n            }\n            for _ in 0..digit_len\
    \ - 8 {\n                digit_str.push(\"Eight\");\n            }\n         \
    \   for _ in 0..digit_len - 9 {\n                digit_str.push(\"Nine\");\n \
    \           }\n            result.push(digit_str);\n        }\n        digit_pos\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&isize` is not an iterator\n  --> /tmp/tmp0r_4w1j0.rs:24:22\n\
    \   |\n24 |         for digit in &digits[digit_pos] {\n   |                  \
    \    ^^^^^^^^^^^^^^^^^^ `&isize` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&isize`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&isize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0r_4w1j0.rs:33:32\n   |\n33 |                 digit_str.push(\"\
    One\");\n   |                                ^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0r_4w1j0.rs:36:32\n   |\n36 |\
    \                 digit_str.push(\"Two\");\n   |                             \
    \   ^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0r_4w1j0.rs:39:32\n   |\n39 |                 digit_str.push(\"Three\"\
    );\n   |                                ^^^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0r_4w1j0.rs:42:32\n   |\n42 |\
    \                 digit_str.push(\"Four\");\n   |                            \
    \    ^^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0r_4w1j0.rs:45:32\n   |\n45 |                 digit_str.push(\"\
    Five\");\n   |                                ^^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0r_4w1j0.rs:48:32\n   |\n48 |\
    \                 digit_str.push(\"Six\");\n   |                             \
    \   ^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0r_4w1j0.rs:51:32\n   |\n51 |                 digit_str.push(\"Seven\"\
    );\n   |                                ^^^^^^^ expected `char`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0r_4w1j0.rs:54:32\n   |\n54 |\
    \                 digit_str.push(\"Eight\");\n   |                           \
    \     ^^^^^^^ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0r_4w1j0.rs:57:32\n   |\n57 |                 digit_str.push(\"\
    Nine\");\n   |                                ^^^^^^ expected `char`, found `&str`\n\
    \nerror"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut reversed = arr\n        .iter()\n   \
    \     .cloned()\n        .enumerate()\n        .filter_map(|(i, x)| {\n      \
    \      if x < 10 {\n                Some(vec![String::from(\"One\"), String::from(\"\
    Two\"), String::from(\"Three\"), String::from(\"Four\"), String::from(\"Five\"\
    ), String::from(\"Six\"), String::from(\"Seven\"), String::from(\"Eight\"), String::from(\"\
    Nine\")][x])\n            } else {\n                Some(vec![String::from(\"\
    Ten\"), String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"Seven\"\
    ), String::from(\"Six\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"\
    Three\"), String::from(\"Two\"), String::from(\"One\")][x])\n            }\n \
    \       })\n        .collect::<Vec<_>>();\n    reversed.reverse();\n    for &i\
    \ in &reversed {\n        result.push(i);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmp9wcup0ni.rs:25:22\n\
    \   |\n25 | ...me(vec![String::from(\"One\"), String::from(\"Two\"), String::from(\"\
    Three\"), String::from(\"Four\"), String::from(\"Five\"), String::from(\"Six\"\
    ), String::from(\"Seven\"), String::from(\"Eight\"), String::from(\"Nine\")][...\n\
    \   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `isize`\n  --> /tmp/tmp9wcup0ni.rs:27:22\n\
    \   |\n27 | ...me(vec![String::from(\"Ten\"), String::from(\"Nine\"), String::from(\"\
    Eight\"), String::from(\"Seven\"), String::from(\"Six\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")][...\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `isize`\n   = help: the\
    \ trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because\
    \ of the requirements on the impl of `Index<isize>` for `Vec<String>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        if x < 1 || x > 9 {\n            0\n        } else {\n          \
    \  x\n        }\n    });\n    arr.reverse();\n    arr.iter().map(|x| {\n     \
    \   match x {\n            x if x < 10 => \"One\".to_string(),\n            x\
    \ if x < 20 => \"Two\".to_string(),\n            x if x < 30 => \"Three\".to_string(),\n\
    \            x if x < 40 => \"Four\".to_string(),\n            x if x < 50 =>\
    \ \"Five\".to_string(),\n            x if x < 60 => \"Six\".to_string(),\n   \
    \         x if x < 70 => \"Seven\".to_string(),\n            x if x < 80 => \"\
    Eight\".to_string(),\n            x if x < 90 => \"Nine\".to_string(),\n     \
    \       _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:19:16\n   |\n\
    19 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:19:25\n\
    \   |\n19 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpfvz5wp6e.rs:22:13\n\
    \   |\n19 | /         if x < 1 || x > 9 {\n20 | |             0\n   | |      \
    \       - expected because of this\n21 | |         } else {\n22 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n23 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n22 |             *x\n   |             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:28:22\n   |\n28 |  \
    \           x if x < 10 => \"One\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:29:22\n   |\n29 |  \
    \           x if x < 20 => \"Two\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:30:22\n   |\n30 |  \
    \           x if x < 30 => \"Three\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&30`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfvz5wp6e.rs:31:22\n   |\n31 |  \
    \           x if x < 40 => \"Four\".to_string(),\n   |                      ^"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n\
    \    let mut digits_reversed_len = digits_reversed.len();\n\n    let mut i = 0;\n\
    \    while i < digits_len {\n        if digits_len > 0 && digits_reversed_len\
    \ > 0 && digits_len == digits_reversed_len {\n            if digits_reversed[i]\
    \ == digits[i] {\n                digits_reversed.swap(i, digits_reversed.len());\n\
    \                digits_reversed_len -= 1;\n                digits_len -= 1;\n\
    \                i += 1;\n            } else {\n                i += 1;\n    \
    \        }\n        } else {\n            i += 1;\n        }\n    }\n\n    while\
    \ i < digits_len {\n        result.push(String::from(&digits[digits_len - i -\
    \ 1]));\n        i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp2luyu46u.rs:41:21\n   |\n41 |         result.push(String::from(&digits[digits_len\
    \ - i - 1]));\n   |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while len > 0 {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n  \
    \      }\n        swap(&mut arr[j], &mut arr[i]);\n        i += 1;\n        len\
    \ -= 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"{}\", x)).to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp9g0nms3d.rs:29:9\n\
    \   |\n29 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j < len {\n            if arr[j] < 1 || arr[j] > 9 {\n\
    \                j += 1;\n                continue;\n            }\n\n       \
    \     if arr[j] == arr[i] {\n                arr.swap(i, j);\n               \
    \ i += 1;\n                j += 1;\n                continue;\n            }\n\
    \n            if arr[j] > arr[i] {\n                j += 1;\n                continue;\n\
    \            }\n\n            arr.swap(i, j);\n            i += 1;\n        }\n\
    \    }\n\n    arr.iter().map(|x| String::from(&x[..])).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmp3x3dvnnl.rs:51:38\n\
    \   |\n51 |     arr.iter().map(|x| String::from(&x[..])).collect()\n   |     \
    \                                 ^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j > 0 && arr[j - 1] > arr[j]\
    \ {\n            j -= 1;\n        }\n        result.push(String::from(&arr[j as\
    \ usize]));\n        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp1mz1ceuh.rs:28:21\n   |\n28 |         result.push(String::from(&arr[j\
    \ as usize]));\n   |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let mut digit = digits[j];\n        digits[j] = digits_len\
    \ - j;\n        digits_len = j;\n        result.push(String::from(&digits[digit]));\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_fgprw92.rs:31:21\n   |\n\
    31 |         digits[j] = digits_len - j;\n   |         ---------   ^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |         |\n   |         expected due to\
    \ the type of this binding\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmp_fgprw92.rs:33:35\n   |\n33 |         result.push(String::from(&digits[digit]));\n\
    \   |                                   ^^^^^^^^^^^^^ slice indices are of type\
    \ `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    let mut cur = String::from(\"One\");\n    while i < len\
    \ {\n        if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < len {\n            if arr[j]\
    \ < 1 || arr[j] > 9 {\n                j += 1;\n                continue;\n  \
    \          }\n            if arr[j] == arr[i] {\n                arr.swap(i, j);\n\
    \                i += 1;\n                j += 1;\n                continue;\n\
    \            }\n            j += 1;\n        }\n        i += 1;\n        cur =\
    \ cur.into();\n        if i == len {\n            arr.swap(i, 0);\n        }\n\
    \    }\n    arr\n        .iter()\n        .map(|x| String::from(&format!(\"{}\"\
    , x)))\n        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp3qwropua.rs:55:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul(10).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_add(1).unwrap());\n    arr.iter().map(|x| {\n\
    \        match x {\n            x if x < 10 => String::from(\"One\"),\n      \
    \      x if x < 20 => String::from(\"Two\"),\n            x if x < 30 => String::from(\"\
    Three\"),\n            x if x < 40 => String::from(\"Four\"),\n            x if\
    \ x < 50 => String::from(\"Five\"),\n            x if x < 60 => String::from(\"\
    Six\"),\n            x if x < 70 => String::from(\"Seven\"),\n            x if\
    \ x < 80 => String::from(\"Eight\"),\n            x if x < 90 => String::from(\"\
    Nine\"),\n            _ => String::from(\"Zero\"),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:23:22\n   |\n\
    23 |             x if x < 10 => String::from(\"One\"),\n   |                 \
    \     ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&10`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:24:22\n   |\n24 |\
    \             x if x < 20 => String::from(\"Two\"),\n   |                    \
    \  ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&20`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:25:22\n   |\n25 |\
    \             x if x < 30 => String::from(\"Three\"),\n   |                  \
    \    ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&30`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:26:22\n   |\n26 |\
    \             x if x < 40 => String::from(\"Four\"),\n   |                   \
    \   ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&40`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:27:22\n   |\n27 |\
    \             x if x < 50 => String::from(\"Five\"),\n   |                   \
    \   ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&50`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:28:22\n   |\n28 |\
    \             x if x < 60 => String::from(\"Six\"),\n   |                    \
    \  ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer\n   |                      help: consider borrowing here: `&60`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwxxz_mkl.rs:29:22\n   |\n29 |\
    \             x if x < 70 => String::from(\"Seven\"),\n   |                  \
    \    ^^\n   |                      |\n   |                      expected `&isize`,\
    \ found integer"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut digits_len\
    \ = arr.len();\n    let mut i = 0;\n    while i < digits_len {\n        let digit\
    \ = arr[i] - 1;\n        if digit < 10 {\n            digits.push(digit);\n  \
    \      } else {\n            digits.push(digit % 10);\n            digits.push(digit\
    \ / 10);\n        }\n        i += 1;\n    }\n\n    let mut i = 0;\n    while i\
    \ < digits_len {\n        let digit = digits[i];\n        if digit < 10 {\n  \
    \          result.push(String::from(\"One\"));\n        } else if digit < 100\
    \ {\n            result.push(String::from(\"Two\"));\n        } else if digit\
    \ < 1000 {\n            result.push(String::from(\"Three\"));\n        } else\
    \ if digit < 10000 {\n            result.push(String::from(\"Four\"));\n     \
    \   } else if digit < 100000 {\n            result.push(String::from(\"Five\"\
    ));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmp22vwyt2d.rs:65:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() {\n          \
    \  if arr[j] < 1 || arr[j] > 9 {\n                j += 1;\n                continue;\n\
    \            }\n            if arr[j] == arr[i] {\n                i += 1;\n \
    \               j += 1;\n                continue;\n            }\n          \
    \  if arr[j] > arr[i] {\n                let mut tmp = arr[i];\n             \
    \   arr[i] = arr[j];\n                arr[j] = tmp;\n            }\n         \
    \   j += 1;\n        }\n        result.push(String::from(&arr[i]));\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpgg5w9ftf.rs:42:21\n   |\n42 |         result.push(String::from(&arr[i]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() {\n          \
    \  if arr[j] < 1 || arr[j] > 9 {\n                j += 1;\n                continue;\n\
    \            }\n            if arr[j] == arr[i] {\n                result.push(by_length(arr.iter().skip(i).take(j\
    \ - i)));\n                break;\n            }\n            j += 1;\n      \
    \  }\n        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppwiitad3.rs:31:39\n   |\n\
    31 |                 result.push(by_length(arr.iter().skip(i).take(j - i)));\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `std::iter::Take`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `std::iter::Take<Skip<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppwiitad3.rs:38:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n38 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        if x <= 9 {\n            1\n        } else if x >= 10 {\n       \
    \     9\n        } else {\n            x - 10\n        }\n    });\n    arr.reverse();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppnztfy2q.rs:20:17\n   |\n\
    20 |         if x <= 9 {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found integer\n   |                 help:\
    \ consider borrowing here: `&9`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppnztfy2q.rs:22:24\n\
    \   |\n22 |         } else if x >= 10 {\n   |                        ^^\n   |\
    \                        |\n   |                        expected `&isize`, found\
    \ integer\n   |                        help: consider borrowing here: `&10`\n\n\
    error[E0277]: a value of type `Vec<String>` cannot be built from an iterator over\
    \ elements of type `&str`\n    --> /tmp/tmppnztfy2q.rs:42:8\n     |\n42   |  \
    \   }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        if x < 1 || x > 9 {\n            0\n        } else {\n          \
    \  x\n        }\n    });\n    arr.iter().map(|x| {\n        if x < 1 || x > 9\
    \ {\n            String::from(\"One\")\n        } else {\n            String::from(&names[x\
    \ - 1])\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpy47etwvg.rs:29:27\n\
    \   |\n29 |             String::from(&names[x - 1])\n   |                    \
    \       ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy47etwvg.rs:19:16\n   |\n19 |         if x < 1 || x > 9 {\n   |    \
    \            ^\n   |                |\n   |                expected `&isize`,\
    \ found integer\n   |                help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy47etwvg.rs:19:25\n   |\n19 |         if x <\
    \ 1 || x > 9 {\n   |                         ^\n   |                         |\n\
    \   |                         expected `&isize`, found integer\n   |         \
    \                help: consider borrowing here: `&9`\n\nerror[E0308]: `if` and\
    \ `else` have incompatible types\n  --> /tmp/tmpy47etwvg.rs:22:13\n   |\n19 |\
    \ /         if x < 1 || x > 9 {\n20 | |             0\n   | |             - expected\
    \ because of this\n21 | |         } else {\n22 | |             x\n   | |     \
    \        ^ expected integer, found `&isize`\n23 | |         }\n   | |_________-\
    \ `if` and `else` have incompatible types\n   |\nhelp: consider dereferencing\
    \ the borrow\n   |\n22 |             *x\n   |             +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy47etwvg.rs:26:16\n   |\n26 |         if x < 1 || x > 9\
    \ {\n   |                ^\n   |                |\n   |                expected\
    \ `&isize`, found integer\n   |                help: consider borrowing here:\
    \ `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy47etwvg.rs:26:25\n  \
    \ |\n26 |         if x < 1 || x > 9 {\n   |                         ^\n   |  \
    \                       |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() {\n          \
    \  if arr[j] == i {\n                result.push(by_length(arr.iter().skip(j).rev()));\n\
    \                break;\n            }\n            j += 1\n        }\n      \
    \  i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn43qveod.rs:26:26\n   |\n\
    26 |             if arr[j] == i {\n   |                          ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n26 |             if arr[j] == i.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn43qveod.rs:27:39\n   |\n27 |                 result.push(by_length(arr.iter().skip(j).rev()));\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found struct `Rev`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Rev<Skip<std::slice::Iter<'_, isize>>>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpn43qveod.rs:34:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n34 |     result\n   |  \
    \   ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    for num in arr {\n        if\
    \ num < 1 || num > 9 {\n            continue;\n        }\n        let mut num\
    \ = num;\n        while num > 0 {\n            result.push(by_digit(num % 10));\n\
    \            num /= 10;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpo45eseyt.rs:21:25\n\
    \   |\n21 |             result.push(by_digit(num % 10));\n   |               \
    \          ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n      \
    \          swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    let mut res = vec![];\n    for i\
    \ in arr {\n        res.push(String::from(&names[i]))\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp_ycrezpv.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp_ycrezpv.rs:36:32\n\
    \   |\n36 |         res.push(String::from(&names[i]))\n   |                  \
    \              ^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = arr.len() - 1;\n\n    while i <= k {\n        if arr[i] < 9 {\n        \
    \    result.push(String::from(\"One\"));\n            i += 1;\n        } else\
    \ {\n            result.push(String::from(\"Nine\"));\n            i += 1;\n \
    \       }\n    }\n\n    while j <= k {\n        if arr[j] < 9 {\n            result.push(String::from(\"\
    Two\"));\n            j += 1;\n        } else {\n            result.push(String::from(\"\
    Nine\"));\n            j += 1;\n        }\n    }\n\n    while i <= k {\n     \
    \   if arr[i] < 9 {\n            result.push(String::from(\"Three\"));\n     \
    \       i += 1;\n        } else {\n            result.push(String::from(\"Nine\"\
    ));\n            i += 1;\n        }\n    }\n\n    while j <= k {\n        if arr[j]\
    \ < 9 {\n            result.push(String::from(\"Four\"));\n            j += 1;\n\
    \        } else {\n            result.push(String::from(\"Nine\"));\n        \
    \    j += 1;\n        }\n    }\n\n    while i <= k {\n        if arr[i] < 9 {\n\
    \            result.push(String::from(\"Five\"));\n            i += 1;\n     \
    \   } else {\n            result.push(String::from(\"Nine\"));\n            i\
    \ += 1;\n        }\n    }\n\n    while j <= k {\n        if arr[j] < 9 {\n   \
    \         result.push(String::from(\"Six\"));\n            j += 1;\n        }\
    \ else {\n            result.push(String::from(\"Nine\"));\n            j += 1;\n\
    \        }\n    }\n\n    while i <= k {\n        if arr[i] < 9 {\n           \
    \ result.push(String::from(\"Seven\"));\n            i += 1;\n        } else {\n\
    \            result.push(String::from(\"Nine\"));\n            i += 1;\n     \
    \   }\n    }\n\n    while j <= k {\n        if arr[j] < 9 {\n            result.push(String::from(\"\
    Eight\"));\n            j += 1;\n        } else {\n            result.push(String::from(\"\
    Nine\"));\n            j += 1;\n        }\n    }\n\n    while i <= k {\n     \
    \   if arr[i] < 9 {\n            result.push(String::from(\"Nine\"));\n      \
    \      i += 1;\n        } else {\n            result.push(String::from(\"One\"\
    ));\n            i += 1;\n        }\n    }\n\n    result\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"\
    Two\", \"Two\", \"Two\", \"Two\", \"Two\", \"Two\", \"Two\", \"Two\"]`,\n right:\
    \ `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"\
    ]`', /tmp/tmpm4obbnjg.rs:118:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n      \
    \      j += 1\n        }\n        result.push(String::from(&arr[i..j]));\n   \
    \     i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp9qx7dy39.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as usize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n\
    \        }\n\n        swap(&mut arr[j], &mut arr[i]);\n        i += 1;\n    }\n\
    \n    arr.iter().map(|x| String::from(x)).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppe7fbrt2.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmppe7fbrt2.rs:36:24\n\
    \   |\n36 |     arr.iter().map(|x| String::from(x)).collect()\n   |          \
    \              ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    arr.sort_unstable();\n    arr.reverse();\n  \
    \  let mut result = vec![];\n    for i in arr {\n        let mut s = String::new();\n\
    \        if i >= 1 && i <= 9 {\n            s.push_str(&format!(\"{}\", i));\n\
    \        } else {\n            s.push_str(&format!(\"{}\", i - 10));\n       \
    \ }\n        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpqxp2fizr.rs:35:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ x.checked_div(10).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div((10\
    \ as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div((10\
    \ as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div((10\
    \ as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div((10\
    \ as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_div((10\
    \ as isize)).unwrap());\n    arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \    arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n    \n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp63synnp8.rs:20:39\n\
    \   |\n20 |     arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n\
    \   |                                       ^           ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n20 -     arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n20 +     arr.sort_by_key(|x| x.checked_mul(10\
    \ as isize).unwrap());\n   | \n\nwarning: unnecessary parentheses around method\
    \ argument\n  --> /tmp/tmp63synnp8.rs:21:39\n   |\n21 |     arr.sort_by_key(|x|\
    \ x.checked_div((10 as isize)).unwrap());\n   |                              \
    \         ^           ^\n   |\nhelp: remove these parentheses\n   |\n21 -    \
    \ arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n21 +     arr.sort_by_key(|x|\
    \ x.checked_div(10 as isize).unwrap());\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmp63synnp8.rs:22:39\n   |\n22 |     arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n   |                              \
    \         ^           ^\n   |\nhelp: remove these parentheses\n   |\n22 -    \
    \ arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n22 +     arr.sort_by_key(|x|\
    \ x.checked_mul(10 as isize).unwrap());\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmp63synnp8.rs:23:39\n   |\n23 |     arr.sort_by_key(|x|\
    \ x.checked_div((10 as isize)).unwrap());\n   |                              \
    \         ^           ^\n   |\nhelp: remove these parentheses\n   |\n23 -    \
    \ arr.sort_by_key(|x| x.checked_div((10 as isize)).unwrap());\n23 +     arr.sort_by_key(|x|\
    \ x.checked_div(10 as isize).unwrap());\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmp63synnp8.rs:24:39\n   |\n24 |     arr.sort_by_key(|x|\
    \ x.checked_mul((10 as isize)).unwrap());\n   |                              \
    \         ^           ^\n   |\nhelp: remove these parentheses\n   |\n24 -    \
    \ arr.sort_by_key(|x| x.checked_mul((10 as isize)).unwrap());\n24 +     arr.sort_by_key(|x|\
    \ x.checked_mul(10 as isize).u"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        let mut digit = digits[j];\n        if\
    \ digit < 10 {\n            digit = digit as isize;\n            result.push(by_digit(digit));\n\
    \        } else {\n            digit = digit - 10 as isize;\n            result.push(by_digit(digit));\n\
    \            digit = digit as isize;\n            result.push(by_digit(digit));\n\
    \        }\n        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmp563tvnae.rs:30:25\n\
    \   |\n30 |             result.push(by_digit(digit));\n   |                  \
    \       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `by_digit` in this scope\n  --> /tmp/tmp563tvnae.rs:33:25\n   |\n33 |      \
    \       result.push(by_digit(digit));\n   |                         ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `by_digit` in this\
    \ scope\n  --> /tmp/tmp563tvnae.rs:35:25\n   |\n35 |             result.push(by_digit(digit));\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<isize>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            swap(&mut arr, i, len\
    \ - 1);\n            i += 1;\n        }\n    }\n    arr.iter().map(|&x| String::from(x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpq7nhus9t.rs:24:13\n\
    \   |\n24 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]:\
    \ the trait bound `String: From<isize>` is not satisfied\n  --> /tmp/tmpq7nhus9t.rs:28:25\n\
    \   |\n28 |     arr.iter().map(|&x| String::from(x)).collect()\n   |         \
    \                ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.clone();\n\
    \    let mut digits_reversed_len = digits_reversed.len();\n    let mut digits_reversed_reversed\
    \ = digits_reversed.clone();\n    let mut digits_reversed_reversed_len = digits_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed = digits_reversed_reversed.clone();\n\
    \    let mut digits_reversed_reversed_reversed_len = digits_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed.clone();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_len = digits_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed_reversed.clone();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_len = digits_reversed_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed = digits_reversed_reversed_reversed_reversed_reversed.clone();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed.len();\n    let\
    \ mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed =\
    \ digits_reversed_reversed_reversed_reversed_reversed_reversed.clone();\n    let\
    \ mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed.clone();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.len();\n\
    \    let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reverse\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp75jgvj03.rs:36:139\n   |\n\
    36 |     let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reverse\n   |                                            \
    \                                                                            \
    \                   ^ help: add `;` here\n37 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `digits_reversed_reverse` in this scope\n  -->\
    \ /tmp/tmp75jgvj03.rs:36:116\n   |\n36 |     let mut digits_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_len\
    \ = digits_reversed_reverse\n   |                                            \
    \                                                                        ^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `digits_reversed_reversed`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp75jgvj03.rs:13:34\n   |\n13 |\
    \ fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------          \
    \           ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |   \
    \ implicitly returns `()` as its body has no tail or `return` expression\n   |\n\
    \   = note: expected struct `Vec<String>`\n           found unit type `()`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n      \
    \          swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    arr.iter().cloned().map(|x| String::from(&format!(\"\
    {}\", x)).to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpp6wct5su.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = vec![];\n\
    \    let mut digits = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n\
    \        let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n      \
    \      j = j + 1;\n        }\n        reversed.push(&arr[j..i]);\n        digits.push(&arr[i..j]);\n\
    \        i = j;\n    }\n    let mut i = 0;\n    while i < digits.len() {\n   \
    \     let mut j = i;\n        while j < digits.len() && digits[j] < 10 {\n   \
    \         j = j + 1;\n        }\n        reversed.push(&digits[j..i]);\n     \
    \   i = j;\n    }\n    reversed.reverse();\n    for &s in reversed {\n       \
    \ arr.push(s.to_string());\n    }\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfhsqn2vu.rs:33:47\n   |\n\
    33 |         while j < digits.len() && digits[j] < 10 {\n   |                \
    \                               ^^ expected `&[isize]`, found integer\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfhsqn2vu.rs:36:23\n   |\n36 |         reversed.push(&digits[j..i]);\n\
    \   |                       ^^^^^^^^^^^^^ expected `isize`, found `&[isize]`\n\
    \   |\n   = note: expected reference `&[isize]`\n              found reference\
    \ `&[&[isize]]`\n\nerror[E0599]: `[isize]` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmpfhsqn2vu.rs:41:20\n   |\n41 |         arr.push(s.to_string());\n\
    \   |                    ^^^^^^^^^ `[isize]` cannot be formatted with the default\
    \ formatter\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[isize]: std::fmt::Display`\n           which is required by `[isize]:\
    \ ToString`\n\nerror[E0277]: the size for values of type `[isize]` cannot be known\
    \ at compilation time\n  --> /tmp/tmpfhsqn2vu.rs:40:10\n   |\n40 |     for &s\
    \ in reversed {\n   |          ^ doesn't have a size known at compile-time\n \
    \  |\n   = help: the trait `Sized` is not implemented for `[isize]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfhsqn2vu.rs:43:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n43 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[i] {\n          \
    \      swap(&mut arr[j], &mut arr[i]);\n            }\n            j += 1;\n \
    \       }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)).to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpmn23ciyl.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[i]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = vec![];\n    let mut counter = 0;\n    let mut digits = vec![];\n    let mut\
    \ digits_map = vec![];\n    let mut one = String::from(\"One\");\n    let mut\
    \ two = String::from(\"Two\");\n    let mut three = String::from(\"Three\");\n\
    \    let mut four = String::from(\"Four\");\n    let mut five = String::from(\"\
    Five\");\n    let mut six = String::from(\"Six\");\n    let mut seven = String::from(\"\
    Seven\");\n    let mut eight = String::from(\"Eight\");\n    let mut nine = String::from(\"\
    Nine\");\n\n    while counter < arr.len() {\n        digits.push(arr[counter]\
    \ % 10);\n        digits_map.push(digits[counter]);\n        reversed.push(digits[counter]);\n\
    \        counter += 1;\n    }\n\n    for digit in reversed.iter_mut() {\n    \
    \    if digits_map.contains(&digit) {\n            digits_map.remove(&digit);\n\
    \            digits_map.push(digit);\n        }\n    }\n\n    for digit in digits_map.iter_mut()\
    \ {\n        match digit {\n            0 => reversed.push(one),\n           \
    \ 1 => reversed.push(two),\n            2 => reversed.push(three),\n         \
    \   3 => reversed.push(four),\n            4 => reversed.push(five),\n       \
    \     5 => reversed.push(six),\n            6 => reversed.push(seven),\n     \
    \       7 => reversed.push(eight),\n            8 => reversed.push(nine),\n  \
    \          _ => unreachable!(),\n        }\n    }\n\n    reversed\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxv7g0lsv.rs:42:31\n   |\n\
    42 |             digits_map.remove(&digit);\n   |                            \
    \   ^^^^^^ expected `usize`, found `&&mut isize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv7g0lsv.rs:43:29\n   |\n43 |             digits_map.push(digit);\n\
    \   |                             ^^^^^ expected `isize`, found `&mut isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n43 |             digits_map.push(*digit);\n\
    \   |                             +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxv7g0lsv.rs:49:32\n\
    \   |\n49 |             0 => reversed.push(one),\n   |                       \
    \         ^^^ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxv7g0lsv.rs:50:32\n   |\n50 |             1 => reversed.push(two),\n\
    \   |                                ^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxv7g0lsv.rs:51:32\n   |\n51 |\
    \             2 => reversed.push(three),\n   |                               \
    \ ^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv7g0lsv.rs:52:32\n   |\n52 |             3 => reversed.push(four),\n\
    \   |                                ^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxv7g0lsv.rs:53:32\n   |\n53 |\
    \             4 => reversed.push(five),\n   |                                ^^^^\
    \ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv7g0lsv.rs:54:32\n   |\n54 |             5 => reversed.push(six),\n\
    \   |                                ^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxv7g0lsv.rs:55:32\n   |\n55 |\
    \             6 => reversed.push(seven),\n   |                               \
    \ ^^^^^ expected `isize`, found struct `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxv7g0lsv.rs:56:32\n   |\n56 |             7 => reversed.push(eight),\n\
    \   |                                ^^^^^ expected `isize`, found struct `String`"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let digit = digits[j];\n        let digit = digit as usize;\n\
    \        let digit = digit as usize;\n        let digit = digit as usize;\n  \
    \      let digit = digit as usize;\n        let digit = digit as usize;\n    \
    \    let digit = digit as usize;\n        let digit = digit as usize;\n      \
    \  let digit = digit as usize;\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit as usize;\n        let digit = digit\
    \ as usize;\n        let digit = digit as usize;\n        let digit = digit as\
    \ usize;\n        let digit = digit as usize;\n        let digit = digit as usize;\n\
    \        let digit = digit as usize;\n        let digit = digit as usize;\n  \
    \      let digit = digit as usize;\n        let digit = digit as usize;\n    \
    \    let digit = digit as usize;\n        let digit = digit as usize;\n      \
    \  let digit = digit as usize;\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit as usize;\n        let digit = digit\
    \ as usize;\n        let digit = digit as usize;\n        let digit = digit as\
    \ usize;\n        let digit = digit as usize;\n        let digit = digit as usize;\n\
    \        let digit = digit as usize;\n        let digit = digit as usize;\n  \
    \      let digit = digit as usize;\n        let digit = digit as usize;\n    \
    \    let digit = digit as usize;\n        let digit = digit as usize;\n      \
    \  let digit = digit as usize;\n        let digit = digit as usize;\n        let\
    \ digit = digit as usize;\n        let digit = digit as usize;\n        let digit\
    \ = digit as usize;\n        let digit = digit as usize;\n        let digit =\
    \ digit as usize;\n        let digit = digit \n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp0olb0vlf.rs:89:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n18 |     while i\
    \ < digits_len {\n   |                          - this delimiter might not be\
    \ properly closed...\n...\n80 | }\n   | - ...as it matches this but it has different\
    \ indentation\n...\n89 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  -->\
    \ /tmp/tmp0olb0vlf.rs:79:26\n   |\n79 |         let digit = digit \n   |     \
    \                     ^ help: add `;` here\n80 | }\n   | - unexpected token\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp0olb0vlf.rs:13:34\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------             \
    \        ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.clone();\n\
    \    let mut digits_reversed_len = digits_reversed.len();\n\n    while digits_len\
    \ > 0 {\n        let mut digit = digits_reversed.pop();\n        let mut digits_reversed_len\
    \ = digits_reversed_len - 1;\n        let mut digits_reversed_digit = digits_reversed[digits_reversed_len];\n\
    \n        while digit > 9 {\n            digits_reversed_len -= 1;\n         \
    \   digits_reversed_digit = digits_reversed[digits_reversed_len];\n        }\n\
    \n        result.push(String::from(&digits_reversed_digit));\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqx_bbzp0.rs:29:23\n   |\n\
    29 |         while digit > 9 {\n   |                       ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<isize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    29 |         while digit > Some(9) {\n   |                       +++++ +\n\nerror[E0277]:\
    \ the trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpqx_bbzp0.rs:34:21\n\
    \   |\n34 |         result.push(String::from(&digits_reversed_digit));\n   | \
    \                    ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i = 0;\n\
    \    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n            i +=\
    \ 1;\n            continue;\n        }\n        let mut j = i;\n        while\
    \ j < len {\n            if arr[j] == arr[j - 1] {\n                j += 1;\n\
    \                continue;\n            }\n            break;\n        }\n   \
    \     swap(&mut arr[i], &mut arr[j]);\n        i += 1;\n    }\n    let mut res\
    \ = vec![];\n    for i in 0..len {\n        let mut j = i;\n        while j <\
    \ len {\n            if arr[j] == arr[j - 1] {\n                j += 1;\n    \
    \            continue;\n            }\n            break;\n        }\n       \
    \ res.push(String::from(&arr[j as usize]));\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpgx2qmt8z.rs:33:9\n\
    \   |\n33 |         swap(&mut arr[i], &mut arr[j]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpgx2qmt8z.rs:46:18\n\
    \   |\n46 |         res.push(String::from(&arr[j as usize]));\n   |          \
    \        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_reversed = digits.clone();\n\
    \    digits_reversed.reverse();\n\n    while digits_len > 0 {\n        let mut\
    \ digit = digits_reversed.remove(0);\n        let mut digits_len = digits_len\
    \ - 1;\n        let mut digits_reversed = digits_reversed.clone();\n        digits_reversed.reverse();\n\
    \n        let mut index = digits_len as usize;\n        while index > 0 {\n  \
    \          if digit < 10 {\n                result.push(String::from(&digits[digits_len\
    \ - index - 1]));\n                break;\n            }\n            index -=\
    \ 1;\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp3ws1kudz.rs:33:29\n   |\n33 |                 result.push(String::from(&digits[digits_len\
    \ - index - 1]));\n   |                             ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = vec![];\n\
    \    let mut counter = 0;\n    while counter < arr.len() {\n        let mut i\
    \ = 0;\n        while i < arr.len() && arr[i] < 10 {\n            i += 1;\n  \
    \      }\n        if i == arr.len() {\n            reversed.push(String::from(\"\
    One\"));\n            i += 1;\n        }\n        if i == arr.len() {\n      \
    \      reversed.push(String::from(\"Two\"));\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            reversed.push(String::from(\"Three\"\
    ));\n            i += 1;\n        }\n        if i == arr.len() {\n           \
    \ reversed.push(String::from(\"Four\"));\n            i += 1;\n        }\n   \
    \     if i == arr.len() {\n            reversed.push(String::from(\"Five\"));\n\
    \            i += 1;\n        }\n        if i == arr.len() {\n            reversed.push(String::from(\"\
    Six\"));\n            i += 1;\n        }\n        if i == arr.len() {\n      \
    \      reversed.push(String::from(\"Seven\"));\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            reversed.push(String::from(\"Eight\"\
    ));\n            i += 1;\n        }\n        if i == arr.len() {\n           \
    \ reversed.push(String::from(\"Nine\"));\n            i += 1;\n        }\n   \
    \     if i == arr.len() {\n            reversed.push(String::from(\"Zero\"));\n\
    \            i += 1;\n        }\n        if i == arr.len() {\n            reversed.push(String::from(\"\
    One\"));\n            i += 1;\n        }\n        if i == arr.len() {\n      \
    \      reversed.push(String::from(\"Two\"));\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            reversed.push(String::from(\"Three\"\
    ));\n            i += 1;\n        }\n        if i == arr.len() {\n           \
    \ reversed.push(String::from(\"Four\"));\n            i += 1;\n        }\n   \
    \     if i == arr.len() {\n            reversed.push(String::from(\"Five\"));\n\
    \            i += 1;\n        }\n        if i == arr.len() {\n            reversed.push(String::from(\"\
    Six\"));\n            i += 1;\n        }\n        if i == arr.len() {\n      \
    \      reversed.push(String::from(\"Seven\"));\n            i += 1;\n        }\n\
    \        if i == arr.len() {\n            reversed.push(String::from(\"Eight\"\
    ));\n            i += 1;\n        }\n        if i == arr.len() {\n           \
    \ reversed.push(String::from(\"\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n   --> /tmp/tmpqxicjio5.rs:107:110\n\
    \    |\n107 |       assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n    |  ______________________________________________________________________________________________________________^\n\
    108 | | }\n    | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] < 1 || arr[j] > 9 {\n \
    \               j += 1;\n                continue;\n            }\n          \
    \  if arr[j] == arr[i] {\n                arr.swap(i, j);\n                i +=\
    \ 1;\n                j += 1;\n                continue;\n            }\n    \
    \        j += 1;\n        }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&x[..])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpho8llj9b.rs:42:38\n\
    \   |\n42 |     arr.iter().map(|x| String::from(&x[..])).collect()\n   |     \
    \                                 ^^^^^\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = arr.clone();\n\
    \    reversed.reverse();\n    for &i in &reversed {\n        arr.push(String::from(&format!(\"\
    {}\", i)));\n    }\n    arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoyxoi3pc.rs:21:18\n   |\n\
    21 |         arr.push(String::from(&format!(\"{}\", i)));\n   |              \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpoyxoi3pc.rs:23:5\n   |\n13 | fn\
    \ by_length(arr: Vec<isize>) -> Vec<String> {\n   |                          \
    \        ----------- expected `Vec<String>` because of return type\n...\n23 |\
    \     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    for num in arr {\n        if num < 1 || num\
    \ > 9 {\n            continue;\n        }\n\n        let mut reversed = num;\n\
    \        reversed.reverse();\n        let mut digits = vec![];\n        while\
    \ reversed > 0 {\n            digits.push(reversed % 10);\n            reversed\
    \ /= 10;\n        }\n\n        let mut digit = String::from(\"One\");\n      \
    \  for d in digits {\n            digit = digit.chars().nth(d - 1).unwrap().to_string();\n\
    \        }\n        result.push(digit);\n    }\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpx14k7am3.rs:26:18\n   |\n26 |         reversed.reverse();\n\
    \   |                  ^^^^^^^ help: there is an associated function with a similar\
    \ name: `reverse_bits`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx14k7am3.rs:35:39\n\
    \   |\n35 |             digit = digit.chars().nth(d - 1).unwrap().to_string();\n\
    \   |                                       ^^^^^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n35 |             digit = digit.chars().nth((d - 1).try_into().unwrap()).unwrap().to_string();\n\
    \   |                                       +     +++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let len = arr[i] - 1;\n        if len > 9 {\n            i += 1;\n        \
    \    continue;\n        }\n        result.push(String::from(&names[len]));\n \
    \       i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpjb0wffeq.rs:25:35\n\
    \   |\n25 |         result.push(String::from(&names[len]));\n   |            \
    \                       ^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n            continue;\n        }\n        let mut j = i;\n      \
    \  while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n        }\n    \
    \    swap(&mut arr[j], &mut arr[i]);\n        i += 1;\n    }\n    arr.iter().map(|x|\
    \ String::from(x)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpfyu6hrdk.rs:30:9\n\
    \   |\n30 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmpfyu6hrdk.rs:33:24\n\
    \   |\n33 |     arr.iter().map(|x| String::from(x)).collect()\n   |          \
    \              ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<isize>>();\n\
    \    let mut i = 0;\n    while i < reversed.len() {\n        let digit = reversed[i];\n\
    \        if digit < 10 {\n            result.push(String::from(\"One\"));\n  \
    \      } else if digit < 100 {\n            result.push(String::from(\"Two\"));\n\
    \        } else if digit < 1000 {\n            result.push(String::from(\"Three\"\
    ));\n        } else if digit < 10000 {\n            result.push(String::from(\"\
    Four\"));\n        } else if digit < 100000 {\n            result.push(String::from(\"\
    Five\"));\n        } else if digit < 1000000 {\n            result.push(String::from(\"\
    Six\"));\n        } else if digit < 10000000 {\n            result.push(String::from(\"\
    Seven\"));\n        } else if digit < 100000000 {\n            result.push(String::from(\"\
    Eight\"));\n        } else if digit < 1000000000 {\n            result.push(String::from(\"\
    Nine\"));\n        } else {\n            result.push(String::from(\"Ten\"));\n\
    \        }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\", \"One\"]`,\n\
    \ right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"]`', /tmp/tmpc8tbplry.rs:51:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() {\n          \
    \  if arr[j] == arr[i] {\n                j += 1;\n                continue;\n\
    \            }\n            if arr[j] > arr[i] {\n                break;\n   \
    \         }\n            result.push(String::from(&arr[i - j]));\n           \
    \ i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmp_48cwdgh.rs:33:25\n   |\n33 |             result.push(String::from(&arr[i\
    \ - j]));\n   |                         ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() && arr[j] == arr[j\
    \ - 1] {\n            i += 1;\n            j += 1\n        }\n        let mut\
    \ reversed = vec![];\n        while j < arr.len() {\n            reversed.push(arr[j]);\n\
    \            j += 1\n        }\n        reversed.reverse();\n        for r in\
    \ reversed {\n            result.push(String::from(&format!(\"{}\", r)));\n  \
    \      }\n        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpv959s6fg.rs:25:46

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut reversed = digits.iter().cloned().rev().collect::<Vec<_>>();\n  \
    \  let mut digits_iter = reversed.iter().cloned();\n    let mut digits_iter =\
    \ digits_iter.map(|x| x.to_string());\n    let mut digits_iter = digits_iter.map(|x|\
    \ x.chars().collect::<Vec<_>>());\n    let mut digits_iter = digits_iter.map(|x|\
    \ x.iter().cloned());\n    let mut digits_iter = digits_iter.map(|x| x.map(|x|\
    \ x.to_string()));\n    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.chars().collect::<Vec<_>>()));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.iter().cloned()));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.to_string())));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.chars().collect::<Vec<_>>())));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.iter().cloned())));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.map(|x| x.to_string()))));\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.map(|x| x.chars().collect::<Vec<_>>()))))\n\
    \        .collect::<Vec<_>>();\n    let mut digits_iter = digits_iter.map(|x|\
    \ x.map(|x| x.map(|x| x.map(|x| x.iter().cloned()))))\n        .collect::<Vec<_>>();\n\
    \    let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.map(|x| x.map(|x|\
    \ x.to_string()))))).collect::<Vec<_>>();\n    let mut digits_iter = digits_iter.map(|x|\
    \ x.map(|x| x.map(|x| x.map(|x| x.map(|x| \n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpnylr1kh7.rs:37:82\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n37 |     let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.map(|x|\
    \ x.map(|x| \n   |                                                           \
    \                       ^ unclosed delimiter\n38 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: expected expression, found `)`\n  --> /tmp/tmpnylr1kh7.rs:38:1\n\
    \   |\n38 | }\n   | ^ expected expression\n\nerror[E0599]: `Vec<Map<Map<Map<Map<Map<Map<Map<Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpnylr1kh7.rs:25:53: 25:70]>, [closure@/tmp/tmpnylr1kh7.rs:26:53:\
    \ 26:86]>, [closure@/tmp/tmpnylr1kh7.rs:27:53: 27:74]>, [closure@/tmp/tmpnylr1kh7.rs:28:53:\
    \ 28:81]>, [closure@/tmp/tmpnylr1kh7.rs:29:53: 29:97]>, [closure@/tmp/tmpnylr1kh7.rs:30:53:\
    \ 30:85]>, [closure@/tmp/tmpnylr1kh7.rs:31:53: 31:92]>, [closure@/tmp/tmpnylr1kh7.rs:32:53:\
    \ 32:108]>>` is not an iterator\n   --> /tmp/tmpnylr1kh7.rs:34:39\n    |\n34 \
    \ |       let mut digits_iter = digits_iter.map(|x| x.map(|x| x.map(|x| x.map(|x|\
    \ x.iter().cloned()))))\n    |                                         ^^^ `Vec<Map<Map<Map<Map<Map<Map<Map<Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpnylr1kh7.rs:25:53: 25:70]>, [closure@/tmp/tmpnylr1kh7.rs:26:53:\
    \ 26:86]>, [closure@/tmp/tmpnylr1kh7.rs:27:53: 27:74]>, [closure@/tmp/tmpnylr1kh7.rs:28:53:\
    \ 28:81]>, [closure@/tmp/tmpnylr1kh7.rs:29:53: 29:97]>, [closure@/tmp/tmpnylr1kh7.rs:30:53:\
    \ 30:85]>, [closure@/tmp/tmpnylr1kh7.rs:31:53: 31:92]>, [closure@/tmp/tmpnylr1kh7.rs:32:53:\
    \ 32:108]>>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<Map<Map<Map<Map<Map<Map<Map<Map<Cloned<std::slice::Iter<'_,\
    \ char>>, [closure@/tmp/tmpnylr1kh7.rs:25:53: 25:70]>, [closure@/tmp/tmpnylr1kh7.rs:26:53:\
    \ 26:86]>, [closure@/tmp/tmpnylr1kh7.rs:27:53: 27:74]>, [closure@/tmp/tmpnylr1kh7.rs:28:53:\
    \ 28:81]>, [closure@/tmp/tmpnylr"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = arr.clone();\n\n    let mut i = 0;\n    while i < reversed.len() {\n     \
    \   let mut j = reversed.len() - 1;\n        while j >= i {\n            if reversed[j]\
    \ > reversed[j + 1] {\n                reversed.swap(j, j + 1);\n            }\n\
    \            j -= 1;\n        }\n        i += 1;\n    }\n\n    let mut result\
    \ = vec![];\n    for i in 0..arr.len() {\n        let index = reversed.iter().position(|&x|\
    \ x == i).unwrap();\n        result.push(String::from(&arr[index]));\n    }\n\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3xv6ro2p.rs:35:56\n   |\n\
    35 |         let index = reversed.iter().position(|&x| x == i).unwrap();\n   |\
    \                                                        ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n35 |         let index = reversed.iter().position(|&x|\
    \ x == i.try_into().unwrap()).unwrap();\n   |                                \
    \                         ++++++++++++++++++++\n\nerror[E0277]: the trait bound\
    \ `String: From<&isize>` is not satisfied\n  --> /tmp/tmp3xv6ro2p.rs:36:21\n \
    \  |\n36 |         result.push(String::from(&arr[index]));\n   |             \
    \        ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i = 0;\n\
    \    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n            i +=\
    \ 1;\n        } else {\n            let mut j = i;\n            while j > 0 &&\
    \ arr[j - 1] > arr[j] {\n                j -= 1;\n            }\n            arr[i]\
    \ = String::from(&arr[j]);\n            i += 1;\n        }\n    }\n    arr\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpit4he2p8.rs:28:22\n   |\n28 |             arr[i] = String::from(&arr[j]);\n\
    \   |                      ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpit4he2p8.rs:28:22\n   |\n28 |\
    \             arr[i] = String::from(&arr[j]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpit4he2p8.rs:32:5\n   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String>\
    \ {\n   |                                  ----------- expected `Vec<String>`\
    \ because of return type\n...\n32 |     arr\n   |     ^^^ expected struct `String`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        match x {\n            1 => 1,\n            2 => 2,\n           \
    \ 3 => 3,\n            4 => 4,\n            5 => 5,\n            6 => 6,\n   \
    \         7 => 7,\n            8 => 8,\n            9 => 9,\n            _ =>\
    \ panic!(\"Invalid number: {}\", x),\n        }\n    });\n    arr.iter_mut().for_each(|x|\
    \ {\n        match x {\n            1 => \"One\",\n            2 => \"Two\",\n\
    \            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid\
    \ number: {}\", x),\n        }\n    });\n    arr\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpmprw9xgv.rs:44:18\n\
    \   |\n34 | /         match x {\n35 | |             1 => \"One\",\n36 | |    \
    \         2 => \"Two\",\n37 | |             3 => \"Three\",\n...  |\n43 | |  \
    \           9 => \"Nine\",\n   | |                  ------ this and all prior\
    \ arms are found to be of type `&str`\n44 | |             _ => panic!(\"Invalid\
    \ number: {}\", x),\n   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `()`\n45 | |         }\n   | |_________- `match` arms have incompatible\
    \ types\n   |\n   = note: this error originates in the macro `$crate::panic::panic_2015`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmprw9xgv.rs:47:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n47 |     arr\n   |     ^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    let mut result = vec![];\n    for x in arr {\n      \
    \  let mut s = String::new();\n        if x < 10 {\n            s.push_str(&format!(\"\
    One\", x));\n        } else if x < 20 {\n            s.push_str(&format!(\"Two\"\
    , x));\n        } else if x < 30 {\n            s.push_str(&format!(\"Three\"\
    , x));\n        } else if x < 40 {\n            s.push_str(&format!(\"Four\",\
    \ x));\n        } else if x < 50 {\n            s.push_str(&format!(\"Five\",\
    \ x));\n        } else if x < 60 {\n            s.push_str(&format!(\"Six\", x));\n\
    \        } else if x < 70 {\n            s.push_str(&format!(\"Seven\", x));\n\
    \        } else if x < 80 {\n            s.push_str(&format!(\"Eight\", x));\n\
    \        } else if x < 90 {\n            s.push_str(&format!(\"Nine\", x));\n\
    \        } else {\n            s.push_str(&format!(\"Ten\", x));\n        }\n\
    \        result.push(s);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: argument never used\n  --> /tmp/tmpji8ai4is.rs:24:40\n   |\n24 |\
    \             s.push_str(&format!(\"One\", x));\n   |                        \
    \         -----  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpji8ai4is.rs:26:40\n   |\n26 |             s.push_str(&format!(\"\
    Two\", x));\n   |                                 -----  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpji8ai4is.rs:28:42\n\
    \   |\n28 |             s.push_str(&format!(\"Three\", x));\n   |            \
    \                     -------  ^ argument never used\n   |                   \
    \              |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpji8ai4is.rs:30:41\n   |\n30 |    \
    \         s.push_str(&format!(\"Four\", x));\n   |                           \
    \      ------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmpji8ai4is.rs:32:41\n   |\n32 |             s.push_str(&format!(\"\
    Five\", x));\n   |                                 ------  ^ argument never used\n\
    \   |                                 |\n   |                                \
    \ formatting specifier missing\n\nerror: argument never used\n  --> /tmp/tmpji8ai4is.rs:34:40\n\
    \   |\n34 |             s.push_str(&format!(\"Six\", x));\n   |              \
    \                   -----  ^ argument never used\n   |                       \
    \          |\n   |                                 formatting specifier missing\n\
    \nerror: argument never used\n  --> /tmp/tmpji8ai4is.rs:36:42\n   |\n36 |    \
    \         s.push_str(&format!(\"Seven\", x));\n   |                          \
    \       -------  ^ argument never used\n   |                                 |\n\
    \   |                                 formatting specifier missing\n\nerror: argument\
    \ never used\n  --> /tmp/tmp"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] == arr[i] {\n         \
    \       arr.swap(i, j);\n                i += 1;\n                break;\n   \
    \         }\n            j += 1;\n        }\n        i += 1;\n    }\n    arr.iter().cloned().collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpokpxkwks.rs:37:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    37 |     arr.iter().cloned().collect::<Vec<_>>()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.to_owned();\n    arr.sort();\n    arr.iter().map(|x|\
    \ {\n        match x {\n            1 => \"One\".to_string(),\n            2 =>\
    \ \"Two\".to_string(),\n            3 => \"Three\".to_string(),\n            4\
    \ => \"Four\".to_string(),\n            5 => \"Five\".to_string(),\n         \
    \   6 => \"Six\".to_string(),\n            7 => \"Seven\".to_string(),\n     \
    \       8 => \"Eight\".to_string(),\n            9 => \"Nine\".to_string(),\n\
    \            _ => panic!(\"Invalid number: {}\", x),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\", \"Two\", \"Two\", \"Three\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpt3y02oeu.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660011869
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    for num in arr {\n        if\
    \ num < 1 || num > 9 {\n            continue;\n        }\n        result.push(String::from(&format!(\"\
    {}\", num)));\n    }\n    result.rev()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<String>` is not an iterator\n   --> /tmp/tmpv2_bhsie.rs:21:12\n\
    \    |\n21  |       result.rev()\n    |              ^^^ `Vec<String>` is not\
    \ an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<String>: Iterator`\n            which is required by `&mut Vec<String>:\
    \ Iterator`\n            `[String]: Iterator`\n            which is required by\
    \ `&mut [String]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed\
    \ = arr.clone();\n    reversed.reverse();\n    for &n in &reversed {\n       \
    \ arr.push(match n {\n            1 => \"One\",\n            2 => \"Two\",\n \
    \           3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid number\
    \ in array: {}\", n),\n        });\n    }\n    arr\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptnqxr5kv.rs:23:18\n   |\n\
    23 |             1 => \"One\",\n   |                  ^^^^^ expected `isize`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptnqxr5kv.rs:35:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n35 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n        } else {\n            swap(&mut arr, i, len\
    \ - 1);\n            i += 1;\n        }\n    }\n    arr.iter().map(|x| String::from(&format!(\"\
    {}\", x)))\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpj49l8n8a.rs:25:13\n\
    \   |\n25 |             swap(&mut arr, i, len - 1);\n   |             ^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing one of these items\n   |\n\
    1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj49l8n8a.rs:29:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n29 |     arr.iter().map(|x|\
    \ String::from(&format!(\"{}\", x)))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Map`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Map<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmpj49l8n8a.rs:29:20: 29:55]>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.clone();\n    let mut len = arr.len();\n    let mut i = 0;\n\
    \    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n            i +=\
    \ 1;\n        } else {\n            let mut j = i;\n            while j < len\
    \ && arr[j] < 1 || arr[j] > 9 {\n                j += 1;\n            }\n    \
    \        swap(&mut arr[i..j], &mut arr[i..j]);\n            i += j - i;\n    \
    \    }\n    }\n    arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmp_vxgp6a0.rs:29:13\n\
    \   |\n29 |             swap(&mut arr[i..j], &mut arr[i..j]);\n   |          \
    \   ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmp_vxgp6a0.rs:33:38\n\
    \   |\n33 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                      ^^^^^ not found in this scope\n\nerror[E0606]:\
    \ casting `&isize` as `usize` is invalid\n  --> /tmp/tmp_vxgp6a0.rs:33:44\n  \
    \ |\n33 |     arr.iter().map(|x| String::from(&names[x as usize])).collect()\n\
    \   |                                            -^^^^^^^^^\n   |            \
    \                                |\n   |                                     \
    \       cannot cast `&isize` as `usize`\n   |                                \
    \            help: dereference the expression: `*x`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0425, E0606.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n\
    \        }\n\n        swap(&mut arr[j], &mut arr[i]);\n        i += 1;\n    }\n\
    \n    arr.iter().map(|x| String::from(x)).collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmppe7fbrt2.rs:32:9\n\
    \   |\n32 |         swap(&mut arr[j], &mut arr[i]);\n   |         ^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing one of these items\n   |\n1  |\
    \ use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\nerror[E0277]: the\
    \ trait bound `String: From<&isize>` is not satisfied\n  --> /tmp/tmppe7fbrt2.rs:36:24\n\
    \   |\n36 |     arr.iter().map(|x| String::from(x)).collect()\n   |          \
    \              ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n\n    while i < arr.len() {\n        let digit = arr[i];\n\
    \        if digit < 10 {\n            digits.push(digit);\n            i += 1;\n\
    \        } else {\n            digits.push(digit % 10);\n            i += 1;\n\
    \            digits.push(digit / 10);\n        }\n    }\n\n    for digit in digits\
    \ {\n        if digit < 10 {\n            result.push(String::from(\"One\"));\n\
    \        } else {\n            result.push(String::from(&format!(\"{}\", digits[digit]));\n\
    \        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `;`\n\
    \  --> /tmp/tmpcgdwzush.rs:39:24\n   |\n39 |             result.push(String::from(&format!(\"\
    {}\", digits[digit]));\n   |                        ^ unclosed delimiter     \
    \                   ^ help: `)` may belong here\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpcgdwzush.rs:40:9\n   |\n40 |         }\n   |      \
    \   ^ expected expression\n\nerror[E0277]: the type `[isize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpcgdwzush.rs:39:53\n   |\n39 |             result.push(String::from(&format!(\"\
    {}\", digits[digit]));\n   |                                                 \
    \    ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut i = 0;\n\
    \    let mut j = 0;\n\n    while i < arr.len() {\n        let digit = arr[i];\n\
    \        if digit < 10 {\n            digits.push(String::from(&digit as isize));\n\
    \            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        } else {\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n            digits.push(String::from(&digit\
    \ as isize));\n            i += 1;\n        }\n    }\n\n    while i < arr.len()\
    \ {\n        let digit = arr[i];\n        if digit < 10 {\n            digits.push(\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpv7ygiap_.rs:114:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n101 |     while\
    \ i < arr.len() {\n    |                         - unclosed delimiter\n102 | \
    \        let digit = arr[i];\n103 |         if digit < 10 {\n    |           \
    \            - this delimiter might not be properly closed...\n104 |         \
    \    digits.push(\n105 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n114 | }\n    |   ^\n\nerror: mismatched closing delimiter:\
    \ `}`\n   --> /tmp/tmpv7ygiap_.rs:104:24\n    |\n13  | fn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    |                                              - closing\
    \ delimiter possibly meant for this\n...\n104 |             digits.push(\n   \
    \ |                        ^ unclosed delimiter\n105 | }\n    | ^ mismatched closing\
    \ delimiter\n\nerror[E0277]: the trait bound `String: From<isize>` is not satisfied\n\
    \  --> /tmp/tmpv7ygiap_.rs:26:25\n   |\n26 |             digits.push(String::from(&digit\
    \ as isize));\n   |                         ^^^^^^^^^^^^ the trait `From<isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror[E0277]: the trait bound `String:\
    \ From<isize>` is not satisfied\n  --> /tmp/tmpv7ygiap_.rs:29:25\n   |\n29 | \
    \            digits.push(String::from(&digit as isize));\n   |               \
    \          ^^^^^^^^^^^^ the trait `From<isize>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            i += 1;\n            continue;\n\
    \        }\n        let mut j = i;\n        while j < arr.len() && arr[j] == arr[j]\
    \ + 1 {\n            j += 1\n        }\n        let mut k = j;\n        while\
    \ k < arr.len() && arr[k] == arr[k] - 1 {\n            k += 1\n        }\n   \
    \     if j > i {\n            result.push(by_length(arr.split_off(i).rev()));\n\
    \            result.push(by_length(arr.split_off(k).rev()));\n            result.push(by_length(arr.split_off(j).rev()));\n\
    \        }\n        i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp8ha5d0r8.rs:33:52\n\
    \    |\n33  |               result.push(by_length(arr.split_off(i).rev()));\n\
    \    |                                                      ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmp8ha5d0r8.rs:34:52\n    |\n34  |               result.push(by_length(arr.split_off(k).rev()));\n\
    \    |                                                      ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmp8ha5d0r8.rs:35:52\n    |\n35  |               result.push(by_length(arr.split_off(j).rev()));\n\
    \    |                                                      ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ha5d0r8.rs:39:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n39 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut num_digits\
    \ = arr.len();\n    let mut i = 0;\n    let mut j = 0;\n\n    while num_digits\
    \ > 0 {\n        digits.push(arr[i..i + 1]);\n        num_digits -= 1;\n     \
    \   i += 1;\n    }\n\n    for i in 0..digits.len() {\n        let mut digit =\
    \ digits[i];\n        let mut digits_len = digit.len();\n\n        while digits_len\
    \ > 0 {\n            let digit = digit[..digits_len];\n            let index =\
    \ digit - 1;\n            let mut digits_len = digits_len - 1;\n\n           \
    \ if index >= 10 {\n                digits_len -= 1;\n                digit +=\
    \ '0';\n            } else {\n                digit += &\"One\"[index as usize];\n\
    \            }\n\n            result.push(digit);\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n   --> /tmp/tmp8_otv5g_.rs:25:21\n    |\n25  |         digits.push(arr[i..i\
    \ + 1]);\n    |                ---- ^^^^^^^^^^^^^ doesn't have a size known at\
    \ compile-time\n    |                |\n    |                required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `[isize]`\nnote: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]:\
    \ the size for values of type `[isize]` cannot be known at compilation time\n\
    \   --> /tmp/tmp8_otv5g_.rs:19:22\n    |\n19  |     let mut digits = vec![];\n\
    \    |                      ^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `[isize]`\nnote:\
    \ required by a bound in `Vec::<T>::new`\n    = note: this error originates in\
    \ the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n   --> /tmp/tmp8_otv5g_.rs:19:22\n    |\n19  |     let mut digits = vec![];\n\
    \    |                      ^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `[isize]`\nnote:\
    \ required by a bound in `Vec`\n    = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0599]:\
    \ the method `len` exists for struct `Vec<[isize]>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmp8_otv5g_.rs:30:24\n   |\n30 |     for i in 0..digits.len()\
    \ {\n   |                        ^^^ private field, not a method\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `[isize]: Sized`\n\
    \nerror[E0608]: cannot index into a value of type `Vec<[isize]>`\n  --> /tmp/tmp8_otv5g_.rs:31:25\n\
    \   |\n31 |         let mut digit = digits[i];\n   |                         ^^^^^^^^^\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp8_otv5g_.rs:43:27\n\
    \   |\n43 |                 digit += &\"One\"[index as usize];\n   "
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = vec![];\n    let mut digits_len\
    \ = arr.len();\n\n    while digits_len > 0 {\n        let digit = arr.pop().unwrap();\n\
    \        digits.push(digit);\n        digits_len -= 1;\n    }\n\n    let mut reversed_digits\
    \ = digits.clone();\n    reversed_digits.reverse();\n\n    for digit in reversed_digits\
    \ {\n        let index = digits.iter().position(|&x| x == digit).unwrap();\n \
    \       result.push(String::from(&digits[digits_len + index]));\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpu33o8bqi.rs:33:21\n   |\n33 |         result.push(String::from(&digits[digits_len\
    \ + index]));\n   |                     ^^^^^^^^^^^^ the trait `From<&isize>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut reversed = vec![];\n\
    \    let mut i = 0;\n    while i < arr.len() {\n        let mut j = i;\n     \
    \   while j > 0 && arr[j - 1] > arr[j] {\n            j -= 1;\n        }\n   \
    \     reversed.push(arr[j]);\n        i += 1;\n    }\n    for i in 0..(reversed.len()\
    \ - 1) {\n        let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(i, j);\n    }\n   \
    \ for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j\
    \ > 0 && reversed[j - 1] > reversed[j] {\n            j -= 1;\n        }\n   \
    \     reversed.swap(i, j);\n    }\n    for i in 0..(reversed.len() - 1) {\n  \
    \      let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j] {\n\
    \            j -= 1;\n        }\n        reversed.swap(i, j);\n    }\n    for\
    \ i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j > 0\
    \ && reversed[j - 1] > reversed[j] {\n            j -= 1;\n        }\n       \
    \ reversed.swap(i, j);\n    }\n    for i in 0..(reversed.len() - 1) {\n      \
    \  let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j] {\n  \
    \          j -= 1;\n        }\n        reversed.swap(i, j);\n    }\n    for i\
    \ in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j > 0 &&\
    \ reversed[j - 1] > reversed[j] {\n            j -= 1;\n        }\n        reversed.swap(i,\
    \ j);\n    }\n    for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n\
    \        while j > 0 && reversed[j - 1] > reversed[j] {\n            j -= 1;\n\
    \        }\n        reversed.swap(i, j);\n    }\n    for i in 0..(reversed.len()\
    \ - 1) {\n        let mut j = i;\n        while j > 0 && reversed[j - 1] > reversed[j]\
    \ {\n            j -= 1;\n        }\n        reversed.swap(i, j);\n    }\n   \
    \ for i in 0..(reversed.len() - 1) {\n        let mut j = i;\n        while j\
    \ > 0 && reversed[j - 1] > reversed[j] {\n            j -= 1;\n        }\n   \
    \     reversed.swap(i, j);\n    }\n    for i in 0..(reversed.len() - 1) {\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp9yddg6lg.rs:101:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n91  |     for\
    \ i in 0..(reversed.len() - 1) {\n    |                                      -\
    \ this delimiter might not be properly closed...\n92  | }\n    | - ...as it matches\
    \ this but it has different indentation\n...\n101 | }\n    |   ^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9yddg6lg.rs:13:34\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |    ---------                     ^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    for n in arr {\n        if\
    \ n > 0 && n < 10 {\n            result.push(String::from(&names[n]));\n     \
    \   }\n    }\n    result.reverse();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpinp3pxei.rs:17:39\n\
    \   |\n17 |             result.push(String::from(&names[n]));\n   |          \
    \                             ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        let mut k = j;\n        while k < arr.len() && arr[k]\
    \ > 9 {\n            k += 1\n        }\n        if k == j {\n            result.push(String::from(&arr[i]));\n\
    \            i += 1;\n        } else {\n            result.push(String::from(&arr[k]));\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpb42k28xi.rs:29:25\n   |\n29 |             result.push(String::from(&arr[i]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<&isize>` is not satisfied\n  -->\
    \ /tmp/tmpb42k28xi.rs:32:25\n   |\n32 |             result.push(String::from(&arr[k]));\n\
    \   |                         ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut i = 0;\n    while i < digits_len\
    \ {\n        let mut j = i;\n        while j < digits_len && digits[j] < 10 {\n\
    \            j += 1\n        }\n        if j == digits_len {\n            break;\n\
    \        }\n        let mut digit = digits[j];\n        let mut reversed_digit\
    \ = digit as usize;\n        reversed_digit *= 10;\n        reversed_digit -=\
    \ 1;\n        result.push(String::from(&names[reversed_digit]));\n        i +=\
    \ 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `names` in this scope\n  --> /tmp/tmpk6poev9z.rs:33:35\n\
    \   |\n33 |         result.push(String::from(&names[reversed_digit]));\n   | \
    \                                  ^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n        } else {\n            arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n            i += 1;\n        }\n    }\n    arr\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `name` in this scope\n  --> /tmp/tmpajdv5ead.rs:25:36\n\
    \   |\n25 |             arr[i] = String::from(&name[arr[i] - 1]);\n   |      \
    \                              ^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpajdv5ead.rs:25:22\n   |\n25 |             arr[i] = String::from(&name[arr[i]\
    \ - 1]);\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found struct `String`\n   |             |\n   |             expected due to\
    \ the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpajdv5ead.rs:29:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n29 |     arr\n   |     ^^^ expected struct `String`, found `isize`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n\n    while digits_len > 0 {\n      \
    \  let mut digit = digits[0];\n        let mut index = 0;\n\n        while index\
    \ < digits_len {\n            if digit < 10 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 100 {\n     \
    \           result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 1000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 10000 {\n   \
    \             result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 100000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 1000000 {\n \
    \               result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 10000000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 100000000 {\n\
    \                result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 1000000000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 10000000000 {\n\
    \                result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 100000000000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 1000000000000\
    \ {\n                result.push(String::from(&digits[index]));\n            \
    \    break;\n            }\n\n            if digit < 10000000000000 {\n      \
    \          result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 100000000000000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 1000000000000000\
    \ {\n                result.push(String::from(&digits[index]));\n            \
    \    break;\n            }\n\n            if digit < 10000000000000000 {\n   \
    \             result.push(String::from(&digits[index]));\n                break;\n\
    \            }\n\n            if digit < 100000000000000000 {\n              \
    \  result.push(String::from(&digits[index]));\n                break;\n      \
    \      }\n\n            if digit < 1000000000000000000 {\n                result.push(String::from(&digits[index]));\n\
    \                break;\n            }\n\n            if digit < 10000000000000000000\
    \ {\n                result.push(String::from(&digits[index]));\n            \
    \    break;\n            }\n\n            if digit < 100000000000000000000 {\n\
    \                result.push(String::from(&digits[index\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpcpkpqvdy.rs:133:3\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - unclosed delimiter\n...\n22  |     while\
    \ digits_len > 0 {\n    |                          - unclosed delimiter\n...\n\
    26  |         while index < digits_len {\n    |                              \
    \    - unclosed delimiter\n...\n122 |             if digit < 100000000000000000000\
    \ {\n    |                                              - this delimiter might\
    \ not be properly closed...\n123 |                 result.push(String::from(&digits[index\n\
    124 | }\n    | - ...as it matches this but it has different indentation\n...\n\
    133 | }\n    |   ^\n\nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmpcpkpqvdy.rs:123:49\n\
    \    |\n13  | fn by_length(arr: Vec<isize>) -> Vec<String> {\n    |          \
    \                                    - closing delimiter possibly meant for this\n\
    ...\n123 |                 result.push(String::from(&digits[index\n    |     \
    \                                            ^ unclosed delimiter\n124 | }\n \
    \   | ^ mismatched closing delimiter\n\nerror[E0277]: the trait bound `String:\
    \ From<&isize>` is not satisfied\n  --> /tmp/tmpcpkpqvdy.rs:28:29\n   |\n28 |\
    \                 result.push(String::from(&digits[index]));\n   |           \
    \                  ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0277]: the trait bound `String: From<&isize>` is not satisfied\n  -->\
    \ /tmp/tmpcpkpqvdy.rs:33:29\n   |\n33 |                 result.push(String::from(&digits[index]));\n\
    \   |                             ^^^^^^^^^^^^ the trait `From<&isize>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `Fro"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.iter_mut().for_each(|x| {\n        if x < 10 {\n            *x = String::from(\"\
    One\");\n        } else if x < 100 {\n            *x = String::from(\"Two\");\n\
    \        } else if x < 1000 {\n            *x = String::from(\"Three\");\n   \
    \     } else if x < 10000 {\n            *x = String::from(\"Four\");\n      \
    \  } else if x < 100000 {\n            *x = String::from(\"Five\");\n        }\
    \ else if x < 1000000 {\n            *x = String::from(\"Six\");\n        } else\
    \ if x < 10000000 {\n            *x = String::from(\"Seven\");\n        } else\
    \ if x < 100000000 {\n            *x = String::from(\"Eight\");\n        } else\
    \ if x < 1000000000 {\n            *x = String::from(\"Nine\");\n        } else\
    \ {\n            *x = String::from(\"Ten\");\n        }\n    });\n    arr\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz5vysj7j.rs:20:16\n   |\n\
    20 |         if x < 10 {\n   |                ^^\n   |                |\n   |\
    \                expected `&mut isize`, found integer\n   |                help:\
    \ consider mutably borrowing here: `&mut 10`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz5vysj7j.rs:21:18\n   |\n21 |             *x = String::from(\"\
    One\");\n   |             --   ^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct\
    \ `String`\n   |             |\n   |             expected due to the type of this\
    \ binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5vysj7j.rs:22:23\n\
    \   |\n22 |         } else if x < 100 {\n   |                       ^^^\n   |\
    \                       |\n   |                       expected `&mut isize`, found\
    \ integer\n   |                       help: consider mutably borrowing here: `&mut\
    \ 100`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5vysj7j.rs:23:18\n  \
    \ |\n23 |             *x = String::from(\"Two\");\n   |             --   ^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz5vysj7j.rs:24:23\n   |\n24 |         } else if x < 1000 {\n  \
    \ |                       ^^^^\n   |                       |\n   |           \
    \            expected `&mut isize`, found integer\n   |                      \
    \ help: consider mutably borrowing here: `&mut 1000`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpz5vysj7j.rs:25:18\n   |\n25 |             *x = String::from(\"\
    Three\");\n   |             --   ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n   |             |\n   |             expected due to the type\
    \ of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5vysj7j.rs:26:23\n\
    \   |\n26 |         } else if x < 10000 {\n   |                       ^^^^^\n\
    \   |                       |\n   |                       expected `&mut isize`,\
    \ found integer\n   |                       help: consider mutably borrowing here:\
    \ `&mut 10000`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5v"
  stdout: ''
  timestamp: 1660011869
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.to_owned();\n    arr.sort_unstable();\n    let mut result = vec![];\n\
    \    for i in arr.iter() {\n        let index = i as usize;\n        let name\
    \ = match index {\n            1 => \"One\",\n            2 => \"Two\",\n    \
    \        3 => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\"\
    ,\n            6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"\
    Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"Invalid number:\
    \ {}\", index),\n        };\n        result.push(name);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3k0p8w68.rs:36:5\n   |\n\
    13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    36 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror[E0606]: casting `&isize` as `usize` is invalid\n  --> /tmp/tmp3k0p8w68.rs:21:21\n\
    \   |\n21 |         let index = i as usize;\n   |                     -^^^^^^^^^\n\
    \   |                     |\n   |                     cannot cast `&isize` as\
    \ `usize`\n   |                     help: dereference the expression: `*i`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0606.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  let mut j = i;\n        while j < arr.len() && arr[j] < 10 {\n            j\
    \ += 1\n        }\n        let mut k = j;\n        while k < arr.len() && arr[k]\
    \ > 9 {\n            k += 1\n        }\n        if k > i {\n            result.push(by_length(arr.split_off(i).reverse()));\n\
    \        }\n        result.push(by_length(arr.split_off(k).reverse()));\n    \
    \    i = j;\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6d7pq8g7.rs:29:35\n   |\n\
    29 |             result.push(by_length(arr.split_off(i).reverse()));\n   |   \
    \                                ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6d7pq8g7.rs:31:31\n\
    \   |\n31 |         result.push(by_length(arr.split_off(k).reverse()));\n   |\
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found\
    \ unit type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6d7pq8g7.rs:34:5\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                     ----------- expected `Vec<String>` because of return type\n\
    ...\n34 |     result\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n\n    let mut digits = arr.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut digits_len = digits.len();\n    let mut digits_len = digits_len.saturating_add((digits_len\
    \ % 10) as usize);\n\n    while digits_len > 0 {\n        let mut digits_len =\
    \ digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % 10) as usize);\n        let mut digits_len\
    \ = digits_len.saturating_add((digits_len % \n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpds3z9kgk.rs:53:3\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - unclosed delimiter\n...\n24 |     while digits_len\
    \ > 0 {\n   |                          - this delimiter might not be properly\
    \ closed...\n...\n44 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n53 | }\n   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpds3z9kgk.rs:43:56\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n43 |         let mut digits_len = digits_len.saturating_add((digits_len %\
    \ \n   |                                                        ^ unclosed delimiter\n\
    44 | }\n   | ^ mismatched closing delimiter\n\nerror: expected expression, found\
    \ `)`\n  --> /tmp/tmpds3z9kgk.rs:44:1\n   |\n44 | }\n   | ^ expected expression\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n  -->\
    \ /tmp/tmpds3z9kgk.rs:44:1\n   |\n44 | }\n   | ^ expected one of `.`, `;`, `?`,\
    \ `else`, or an operator\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpds3z9kgk.rs:13:34\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |    ---------\
    \                     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut arr = arr.into_iter().collect::<Vec<_>>();\n    arr.sort_by_key(|x|\
    \ {\n        if x < 1 || x > 9 {\n            0\n        } else {\n          \
    \  x\n        }\n    });\n    arr.iter().map(|x| {\n        match x {\n      \
    \      x if x < 10 => \"One\".to_string(),\n            x if x < 20 => \"Two\"\
    .to_string(),\n            x if x < 30 => \"Three\".to_string(),\n           \
    \ x if x < 40 => \"Four\".to_string(),\n            x if x < 50 => \"Five\".to_string(),\n\
    \            x if x < 60 => \"Six\".to_string(),\n            x if x < 70 => \"\
    Seven\".to_string(),\n            x if x < 80 => \"Eight\".to_string(),\n    \
    \        x if x < 90 => \"Nine\".to_string(),\n            _ => panic!(\"Invalid\
    \ number {:?}\", x),\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:16:16\n   |\n\
    16 |         if x < 1 || x > 9 {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&1`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:16:25\n\
    \   |\n16 |         if x < 1 || x > 9 {\n   |                         ^\n   |\
    \                         |\n   |                         expected `&isize`, found\
    \ integer\n   |                         help: consider borrowing here: `&9`\n\n\
    error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp8xy7yqt0.rs:19:13\n\
    \   |\n16 | /         if x < 1 || x > 9 {\n17 | |             0\n   | |      \
    \       - expected because of this\n18 | |         } else {\n19 | |          \
    \   x\n   | |             ^ expected integer, found `&isize`\n20 | |         }\n\
    \   | |_________- `if` and `else` have incompatible types\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n19 |             *x\n   |             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:24:22\n   |\n24 |  \
    \           x if x < 10 => \"One\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&10`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:25:22\n   |\n25 |  \
    \           x if x < 20 => \"Two\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&20`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:26:22\n   |\n26 |  \
    \           x if x < 30 => \"Three\".to_string(),\n   |                      ^^\n\
    \   |                      |\n   |                      expected `&isize`, found\
    \ integer\n   |                      help: consider borrowing here: `&30`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8xy7yqt0.rs:27:22\n   |\n27 |  \
    \           x if x < 40 => \"Four\".to_string(),\n   |                      ^"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut result = vec![];\n    let mut i = 0;\n    while i < arr.len() {\n      \
    \  if arr[i] < 1 || arr[i] > 9 {\n            continue;\n        }\n        let\
    \ mut j = i;\n        while j < arr.len() && arr[j] < 1 {\n            j += 1;\n\
    \        }\n        let mut k = j;\n        while k < arr.len() && arr[k] > 9\
    \ {\n            k += 1;\n        }\n        let mut temp = arr[i];\n        arr[i]\
    \ = arr[j];\n        arr[j] = temp;\n        result.push(String::from(&arr[i]));\n\
    \        i += 1;\n        j -= 1;\n        k -= 1;\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpu5txv2no.rs:34:21\n   |\n34 |         result.push(String::from(&arr[i]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[i] {\n          \
    \      swap(&mut arr[j], &mut arr[i]);\n            }\n            j += 1;\n \
    \       }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&x[..])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpshx1aedr.rs:29:17\n\
    \   |\n29 |                 swap(&mut arr[j], &mut arr[i]);\n   |            \
    \     ^^^^ not found in this scope\n   |\nhelp: consider importing one of these\
    \ items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\n\
    \nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpshx1aedr.rs:35:38\n\
    \   |\n35 |     arr.iter().map(|x| String::from(&x[..])).collect()\n   |     \
    \                                 ^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 101
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut result = vec![];\n    let mut i = 0;\n    let mut j = 0;\n    let mut\
    \ k = arr.len() - 1;\n\n    while i <= k {\n        if arr[i] < 10 {\n       \
    \     result.push(String::from(\"One\"));\n            i += 1;\n        } else\
    \ {\n            result.push(String::from(\"Ten\"));\n            i += 10;\n \
    \       }\n\n        while j >= i && arr[j] > 9 {\n            result.push(String::from(\"\
    Nine\"));\n            j -= 10;\n        }\n\n        while j >= i && arr[j] <\
    \ 10 {\n            result.push(String::from(\"One\"));\n            j -= 1;\n\
    \        }\n\n        if j >= i {\n            result.push(String::from(format!(\"\
    {}\", arr[j])));\n        }\n\n        i += 1;\n        j -= 1;\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpbyktblk0.rs:47:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660011869
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n\n        let mut\
    \ j = i;\n        while j < len {\n            if arr[j] == arr[i] {\n       \
    \         arr.swap(i, j);\n                i += 1;\n                j += 1;\n\
    \                break;\n            }\n            j += 1;\n        }\n    }\n\
    \n    let mut result = vec![];\n    for i in 0..arr.len() {\n        result.push(String::from(&arr[i]));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpy43nvbwz.rs:41:21\n   |\n41 |         result.push(String::from(&arr[i]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    let mut result = vec![];\n    let mut len = arr.len();\n\
    \    while len > 0 {\n        let mut i = 0;\n        while i < len {\n      \
    \      if arr[i] < 1 || arr[i] > 9 {\n                i += 1;\n              \
    \  continue;\n            }\n            result.push(by_digit(arr[i]));\n    \
    \        i += 1;\n        }\n        len -= i;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `by_digit` in this scope\n  --> /tmp/tmpfc87orcu.rs:23:25\n\
    \   |\n23 |             result.push(by_digit(arr[i]));\n   |                 \
    \        ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.to_owned();\n    let mut len = arr.len();\n    let mut i\
    \ = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9 {\n         \
    \   i += 1;\n            continue;\n        }\n\n        let mut j = i;\n    \
    \    while j < len {\n            if arr[j] < 1 || arr[j] > 9 {\n            \
    \    j += 1;\n                continue;\n            }\n\n            if arr[j]\
    \ == arr[i] {\n                arr.swap(i, j);\n                i += 1;\n    \
    \            j += 1;\n                break;\n            }\n\n            j +=\
    \ 1;\n        }\n    }\n\n    let mut result = vec![];\n    for i in 0..len {\n\
    \        result.push(String::from(&arr[i]));\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<&isize>` is not satisfied\n\
    \  --> /tmp/tmpwgxr9ofr.rs:47:21\n   |\n47 |         result.push(String::from(&arr[i]));\n\
    \   |                     ^^^^^^^^^^^^ the trait `From<&isize>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n\n  \
    \  let mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    let mut cur = String::from(\"One\");\n    while i < len\
    \ {\n        if arr[i] < 10 {\n            arr[i] = String::from(&format!(\"{}\"\
    , arr[i]));\n        } else {\n            arr[i] = String::from(&format!(\"{}\"\
    , &arr[i / 10] + &arr[i % 10]));\n        }\n        i += 1;\n    }\n    arr.reverse();\n\
    \    arr.iter_mut().for_each(|&x| {\n        if x < 10 {\n            *x = String::from(&format!(\"\
    {}\", x));\n        } else {\n            *x = String::from(&format!(\"{}\", &x\
    \ - 10 + &arr[x / 10] + &arr[x % 10]));\n        }\n    });\n    arr\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj3g_fybv.rs:24:22\n   |\n\
    24 |             arr[i] = String::from(&format!(\"{}\", arr[i]));\n   |      \
    \       ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ struct `String`\n   |             |\n   |             expected due to the type\
    \ of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj3g_fybv.rs:26:22\n\
    \   |\n26 |             arr[i] = String::from(&format!(\"{}\", &arr[i / 10] +\
    \ &arr[i % 10]));\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found struct `String`\n   |             |\n   |          \
    \   expected due to the type of this binding\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpj3g_fybv.rs:31:30\n   |\n31 |     arr.iter_mut().for_each(|&x|\
    \ {\n   |                              ^--\n   |                             \
    \ ||\n   |                              |expected due to this\n   |          \
    \                    types differ in mutability\n   |                        \
    \      help: did you mean `x`: `&&mut isize`\n   |\n   = note: expected mutable\
    \ reference `&mut isize`\n                      found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpj3g_fybv.rs:38:5\n   |\n13 | fn by_length(arr:\
    \ Vec<isize>) -> Vec<String> {\n   |                                  -----------\
    \ expected `Vec<String>` because of return type\n...\n38 |     arr\n   |     ^^^\
    \ expected struct `String`, found `isize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<isize>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| x as usize).collect();\n    arr.sort_unstable();\n\
    \    let mut arr = arr.into_iter().map(|x| \n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpfj0t4_zl.rs:53:38\n\
    \   |\n13 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    ...\n53 |     let mut arr = arr.into_iter().map(|x| \n   |                   \
    \                   ^ unclosed delimiter\n54 | }\n   | ^ mismatched closing delimiter\n\
    \nerror: expected expression, found `)`\n  --> /tmp/tmpfj0t4_zl.rs:54:1\n   |\n\
    54 | }\n   | ^ expected expression\n\nerror[E0282]: type annotations needed\n\
    \  --> /tmp/tmpfj0t4_zl.rs:18:5\n   |\n17 |     let mut arr = arr.into_iter().map(|x|\
    \ x as usize).collect();\n   |         ------- consider giving `arr` a type\n\
    18 |     arr.sort_unstable();\n   |     ^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    let mut len = arr.len();\n\
    \    let mut i = 0;\n    while i < len {\n        if arr[i] < 1 || arr[i] > 9\
    \ {\n            i += 1;\n            continue;\n        }\n        let mut j\
    \ = i;\n        while j < len {\n            if arr[j] > arr[j + 1] {\n      \
    \          swap(&mut arr[j], &mut arr[j + 1]);\n            }\n            j +=\
    \ 1;\n        }\n        i += 1;\n    }\n    arr.iter().map(|x| String::from(&x[..])).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `swap` in this scope\n  --> /tmp/tmpl8o2gqyu.rs:28:17\n\
    \   |\n28 |                 swap(&mut arr[j], &mut arr[j + 1]);\n   |        \
    \         ^^^^ not found in this scope\n   |\nhelp: consider importing one of\
    \ these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n\
    \   |\n\nerror[E0608]: cannot index into a value of type `&isize`\n  --> /tmp/tmpl8o2gqyu.rs:34:38\n\
    \   |\n34 |     arr.iter().map(|x| String::from(&x[..])).collect()\n   |     \
    \                                 ^^^^^\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.iter().cloned().collect::<Vec<_>>();\n    arr.sort_unstable();\n\
    \    arr.reverse();\n    arr.iter().map(|x| {\n        match x {\n           \
    \ 1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n    \
    \        4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\"\
    ,\n            7 => \"Seven\",\n            8 => \"Eight\",\n            9 =>\
    \ \"Nine\",\n            _ => panic!(\"Invalid number: {}\", x),\n        }\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpin1yyrm4.rs:33:8\n     |\n33 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660011868
- exit_code: 1
  program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// >>> by_length(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3])\n/// vec![String::from(\"Eight\"), String::from(\"Five\"\
    ), String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]\n/// If the array is empty,\
    \ return an empty array:\n/// >>> by_length(vec![])\n/// Vec::<String>::new()\n\
    /// If the array has any strange number ignore it:\n/// >>> by_length(vec![1,\
    \ -1, 55])\n/// vec![String::from(\"One\")]\nfn by_length(arr: Vec<isize>) ->\
    \ Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n    let\
    \ mut arr = arr.into_iter().map(|x| x as isize).collect();\n    arr.sort_unstable();\n\
    \    arr.iter().map(|x| {\n        match x {\n            1 => \"One\",\n    \
    \        2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => panic!(\"Invalid number {:?}\", x),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp5j43o2k5.rs:18:5\n\
    \   |\n17 |     let mut arr = arr.into_iter().map(|x| x as isize).collect();\n\
    \   |         ------- consider giving `arr` a type\n18 |     arr.sort_unstable();\n\
    \   |     ^^^ cannot infer type\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1660011868
