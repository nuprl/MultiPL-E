language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&alphabet[vowel_counter]);\n            vowel_counter\
    \ += 2;\n        } else {\n            result.push_str(&alphabet[letter_counter]);\n\
    \            letter_counter += 2;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbjgakzke.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbjgakzke.rs:18:16\n   |\n18 |         if let Some(vowel)\
    \ = vowels.binary_search(&letter) {\n   |                ^^^^^^^^^^^   -----------------------------\
    \ this expre"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut\
    \ index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8\
    \ = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11\
    \ = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14\
    \ = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17\
    \ = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20\
    \ = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23\
    \ = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26\
    \ = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29\
    \ = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32\
    \ = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35\
    \ = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38\
    \ = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41\
    \ = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44\
    \ = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47\
    \ = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50\
    \ = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53\
    \ = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56\
    \ = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59\
    \ = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62\
    \ = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n    let mut index65\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjg0och5j.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpjg0och5j.rs:84:17\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:84:25\n \
    \  |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjg0och5j.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjg0och5j.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjg0och5j.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjg0och5j.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjg0och5j.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_positions\
    \ = Vec::new();\n    let mut letter_positions = Vec::new();\n    let mut letter_counts\
    \ = Vec::new();\n    let mut letter_index = 0;\n    let mut vowel_index = 0;\n\
    \    let mut letter_count = 1;\n    let mut vowel_count = 1;\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len = message.len();\n\
    \    let mut vowel_len = vowels.len();\n    let mut letter_count = message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut vowel_count = vowels.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut letter_len = message.len();\n    let mut vowel_len = vowels.len();\n\
    \    let mut letter_count = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut vowel_count = vowels.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len\
    \ = message.len();\n    let mut vowel_len = vowels.len();\n    let mut letter_count\
    \ = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n    let mut vowel_count\
    \ = vowels.chars().filter(|c| c >= 'a' && c <= 'z').count();\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len = message.len();\n\
    \    let mut vowel_len = vowels.len();\n    let mut letter_count = message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut vowel_count = vowels.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut letter_len = message.len();\n    let mut vowel_len = vowels.len();\n\
    \    let mut letter_count = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut vowel_count = \n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9y79tjd9.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp9y79tjd9.rs:56:17\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:56:25\n \
    \  |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9y79tjd9.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9y79tjd9.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9y79tjd9.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9y79tjd9.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9y79tjd9.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:60:25\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9y79tjd9.rs:26:60\n\
    \   |\n26 |     let mut letter_count ="
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut letter_\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xdqd0t5.rs:75:20\n   |\n\
    75 |     let mut letter_\n   |                    ^ help: add `;` here\n76 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:80:25\n   |\n80 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:81:25\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:82:17\n  \
    \ |\n82 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:82:25\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:17\n   |\n83 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:25\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:84:25\n   |\n84 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters_counter = 0;\n    for letter in message {\n        if\
    \ letter == letters[letters_counter] {\n            letters_counter += 1;\n  \
    \      } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter += 1;\n        } else\
    \ {\n            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter += 1;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter += 1;\n        } else {\n            vowels_counter = 0;\n  \
    \      }\n        if letter == letters[letters_counter] {\n            letters_counter\
    \ += 1;\n        } else {\n            letters_counter = 0;\n        }\n     \
    \   if letter == vowels[vowels_counter] {\n            vowels_counter += 1;\n\
    \        } else {\n            vowels_counter = 0;\n        }\n        if letter\
    \ == letters[letters_counter] {\n            letters_counter += 1;\n        }\
    \ else {\n            letters_counter = 0;\n        }\n        if letter == vowels[vowels_counter]\
    \ {\n            vowels_counter += 1;\n        } else {\n            vowels_counter\
    \ = 0;\n        }\n        if letter == letters[letters_counter] {\n         \
    \   letters_counter += 1;\n        } else {\n            letters_counter = 0;\n\
    \        }\n        if letter == vowels[vowels_counter] {\n            vowels_counter\
    \ += 1;\n        } else {\n            vowels_counter = 0;\n        }\n      \
    \  if letter == letters[letters_counter] {\n            letters_counter += 1;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter += 1;\n        } else\
    \ {\n            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter += 1;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter += 1;\n        } else {\n            vowels_counter = 0;\n  \
    \      }\n        if letter\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprt_6unr9.rs:98:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     for letter in message {\n\
    \   |                           - this delimiter might not be properly closed...\n\
    ...\n89 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    98 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmprt_6unr9.rs:89:1\n\
    \   |\n88 |         if letter\n   |         -- this `if` expression has a condition,\
    \ but no block\n89 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmprt_6unr9.rs:93:17\n   |\n93 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:93:25\n \
    \  |\n93 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprt_6unr9.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:94:25\n   |\n94 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprt_6unr9.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:95:25\n   |\n95 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprt_6unr9.rs:96:17\n  \
    \ |\n96 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprt_6unr9.rs:96:25\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in t"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.binary_search(&letter) {\n          \
    \  encoded.push_str(&letters[(index + 1) % 26]);\n        } else {\n         \
    \   encoded.push_str(&letters[letter.to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_f2xzrt5.rs:29:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n18 |  \
    \       } else {\n   |                - this delimiter might not be properly closed...\n\
    19 |             encoded.push_str(&lette...\n20 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n29 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp_f2xzrt5.rs:19:38\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n19 |             encoded.push_str(&letters[letter.to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to...\n\
    \   |                                      ^ unclosed delimiter\n20 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left` in\
    \ this scope\n  --> /tmp/tmp_f2xzrt5.rs:24:17\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:24:25\n \
    \  |\n24 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_f2xzrt5.rs:25:17\n   |\n25 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:25:25\n   |\n25 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_f2xzrt5.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:26:25\n   |\n26 |     assert_eq!({left},\
    \ {right});\n   |          "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphg79ldgh.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphg79ldgh.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:85:25\n   |\n85 |     asser"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'o' || letter\
    \ == 'O' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'e' || letter == 'E' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'i' || letter\
    \ == 'I' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'u' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'A' || letter\
    \ == 'a' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'E' || letter == 'e' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'I' || letter\
    \ == 'i' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'O' || letter == 'o' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'U' || letter\
    \ == 'u' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'a' || letter == 'A' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'e' || letter\
    \ == 'E' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'i' || letter == 'I' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'o' || letter\
    \ == 'O' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'u' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'O' || letter\
    \ == 'o' {\n            vowels.\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoda3k7no.rs:92:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n81 |  \
    \       if letter == 'O' || letter == 'o' {\n   |                            \
    \               - this delimiter might not be properly closed...\n82 |       \
    \      vowels.\n83 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n92 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpoda3k7no.rs:83:1\n\
    \   |\n83 | }\n   | ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpoda3k7no.rs:13:22\n   |\n13 |     let mut vowels =\
    \ HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpoda3k7no.rs:87:17\n\
    \   |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoda3k7no.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoda3k7no.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoda3k7no.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoda3k7no.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoda3k7no.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]"
  stdout: ''
  timestamp: 1659747235
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut index = 0;\n    let mut vowel_index = 0;\n    let mut letter_count\
    \ = 1;\n    let mut letter_count_index = 0;\n    let mut letter_count_index2 =\
    \ 0;\n    let mut letter_count_index3 = 0;\n    let mut letter_count_index4 =\
    \ 0;\n    let mut letter_count_index5 = 0;\n    let mut letter_count_index6 =\
    \ 0;\n    let mut letter_count_index7 = 0;\n    let mut letter_count_index8 =\
    \ 0;\n    let mut letter_count_index9 = 0;\n    let mut letter_count_index10 =\
    \ 0;\n    let mut letter_count_index11 = 0;\n    let mut letter_count_index12\
    \ = 0;\n    let mut letter_count_index13 = 0;\n    let mut letter_count_index14\
    \ = 0;\n    let mut letter_count_index15 = 0;\n    let mut letter_count_index16\
    \ = 0;\n    let mut letter_count_index17 = 0;\n    let mut letter_count_index18\
    \ = 0;\n    let mut letter_count_index19 = 0;\n    let mut letter_count_index20\
    \ = 0;\n    let mut letter_count_index21 = 0;\n    let mut letter_count_index22\
    \ = 0;\n    let mut letter_count_index23 = 0;\n    let mut letter_count_index24\
    \ = 0;\n    let mut letter_count_index25 = 0;\n    let mut letter_count_index26\
    \ = 0;\n    let mut letter_count_index27 = 0;\n    let mut letter_count_index28\
    \ = 0;\n    let mut letter_count_index29 = 0;\n    let mut letter_count_index30\
    \ = 0;\n    let mut letter_count_index31 = 0;\n    let mut letter_count_index32\
    \ = 0;\n    let mut letter_count_index33 = 0;\n    let mut letter_count_index34\
    \ = 0;\n    let mut letter_count_index35 = 0;\n    let mut letter_count_index36\
    \ = 0;\n    let mut letter_count_index37 = 0;\n    let mut letter_count_index38\
    \ = 0;\n    let mut letter_count_index39 = 0;\n    let mut letter_count_index40\
    \ = 0;\n    let mut letter_count_index41 = 0;\n    let mut letter_count_index42\
    \ = 0;\n    let mut letter_count_index43 = 0;\n    let mut letter_count_index44\
    \ = 0;\n    let mut letter_count_index45 = 0;\n    let mut letter_count_index46\
    \ = 0;\n    let mut letter_count_index47 = 0;\n    let mut letter_count_index48\
    \ = 0;\n    let mut letter_count_index49 = 0;\n    let mut letter_count_index50\
    \ = 0;\n    let mut letter_count_index51 = 0;\n    let mut letter_count_index52\
    \ = 0;\n    let mut letter_count_index53 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:75:17\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:76:25\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7u_g_e0c.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:77:25\n   |\n77 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:78:25\n   |\n78 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:79:17\n  \
    \ |\n79 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:79:25\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7u_g_e0c.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_letters\
    \ = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowel_letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_letters = vec![\"B\", \"C\", \"D\", \"\
    F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowel_letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,\
    \ 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,\
    \ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 7\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp8whq3bzr.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp8whq3bzr.rs:19:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut vowel_letters_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n20\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmp8whq3bzr.rs:24:17\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:24:25\n \
    \  |\n24 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8whq3bzr.rs:25:17\n   |\n25 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:25:25\n   |\n25 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8whq3bzr.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:26:25\n   |\n26 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8whq3bzr.rs:27:17\n  \
    \ |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8whq3bzr.rs:27:25\n   |\n27 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_counts = HashMap::new();\n    for letter in message.chars()\
    \ {\n        if let Some(count) = letter_counts.entry(letter).or_insert(0) {\n\
    \            *count += 1;\n        } else {\n            letter_counts.insert(letter,\
    \ 1);\n        }\n    }\n    for letter in message.chars() {\n        if let Some(count)\
    \ = letter_counts.entry(letter).or_insert(0) {\n            if *count > 2 {\n\
    \                let mut new_letter = letter;\n                while let Some(count)\
    \ = letter_counts.entry(new_letter).or_insert(0) {\n                    if *count\
    \ > 2 {\n                        new_letter = alphabet.entry(alphabet.index(new_letter)\
    \ + 1).or_insert(0);\n                    } else {\n                        new_letter\
    \ = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n               \
    \     }\n                }\n                result.push_str(&new_letter);\n  \
    \          } else {\n                result.push_str(&letter);\n            }\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5bbad967.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp5bbad967.rs:14:29\n\
    \   |\n14 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:28:38\n\
    \   |\n28 |                         new_letter = alphabet.entry(alphabet.index(new_letter)\
    \ + 1).or_insert(0);\n   |                                      ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmp5bbad967.rs:28:53\n   |\n28 |                         new_letter\
    \ = alphabet.entry(alphabet.index(new_letter) + 1).or_insert(0);\n   |       \
    \                                              ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:30:38\n\
    \   |\n30 |                         new_letter = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n\
    \   |                                      ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:30:53\n\
    \   |\n30 |                         new_letter = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n\
    \   |                                                     ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5bbad967.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5bbad967.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                        "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi_sq4ffm.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:73:17\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi_sq4ffm.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi_sq4ffm.rs"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7mvyv8a.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb7mvyv8a.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb7mvyv8a.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb7mvyv8a.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb7mvyv8a.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut count = 1;\n    let mut\
    \ prev = 0;\n    let mut next = -1;\n    let mut prev2 = -1;\n    let mut next2\
    \ = -1;\n    let mut prev3 = -1;\n    let mut next3 = -1;\n    let mut prev4 =\
    \ -1;\n    let mut next4 = -1;\n    let mut prev5 = -1;\n    let mut next5 = -1;\n\
    \    let mut prev6 = -1;\n    let mut next6 = -1;\n    let mut prev7 = -1;\n \
    \   let mut next7 = -1;\n    let mut prev8 = -1;\n    let mut next8 = -1;\n  \
    \  let mut prev9 = -1;\n    let mut next9 = -1;\n    let mut prev10 = -1;\n  \
    \  let mut next10 = -1;\n    let mut prev11 = -1;\n    let mut next11 = -1;\n\
    \    let mut prev12 = -1;\n    let mut next12 = -1;\n    let mut prev13 = -1;\n\
    \    let mut next13 = -1;\n    let mut prev14 = -1;\n    let mut next14 = -1;\n\
    \    let mut prev15 = -1;\n    let mut next15 = -1;\n    let mut prev16 = -1;\n\
    \    let mut next16 = -1;\n    let mut prev17 = -1;\n    let mut next17 = -1;\n\
    \    let mut prev18 = -1;\n    let mut next18 = -1;\n    let mut prev19 = -1;\n\
    \    let mut next19 = -1;\n    let mut prev20 = -1;\n    let mut next20 = -1;\n\
    \    let mut prev21 = -1;\n    let mut next21 = -1;\n    let mut prev22 = -1;\n\
    \    let mut next22 = -1;\n    let mut prev23 = -1;\n    let mut next23 = -1;\n\
    \    let mut prev24 = -1;\n    let mut next24 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpwu29291v.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpwu29291v.rs:69:17\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:69:25\n \
    \  |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwu29291v.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwu29291v.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwu29291v.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwu29291v.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwu29291v.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwu29291v.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[(index as usize) % letters.len()]);\n\
    \            result.push_str(&vowels[(index as usize) % vowels.len()]);\n    \
    \    }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptrpe4w32.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptrpe4w32.rs:20:29\n   |\n20 |             result.push_str(&letters[(index\
    \ as usize) % letters.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOU\"\
    .to_string();\n    let mut index = 0;\n    for c in message.chars() {\n      \
    \  if c.is_uppercase() {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            result.push_str(&vowels[(index - 1) % vowels.len()]);\n\
    \        }\n        result.push_str(&c.to_string());\n        index += 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:29:17\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfxy2xm95.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpfxy2xm95.rs:17:30\n   |\n\
    17 |             result.push_str(&vowels[(index + 1) % vowels.len()]);\n   | \
    \                             ^^^^^"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_2 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_3 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_4 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_5 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_6 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_7 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_8 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_9 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_10 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_11 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_j7blrh7.rs:26:1\n   |\n26 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_j7blrh7.rs:25:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n25 |     let mut vowels_index_12 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n26 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:17\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:25\n \
    \  |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_j7blrh7.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_j7blrh7.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:33:25\n   |\n33 |     assert_eq!({left}, {right}"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n\
    \    let mut vowels_idx3 = 0;\n    let mut letters_idx3 = 0;\n    let mut vowels_idx4\
    \ = 0;\n    let mut letters_idx4 = 0;\n    let mut vowels_idx5 = 0;\n    let mut\
    \ letters_idx5 = 0;\n    let mut vowels_idx6 = 0;\n    let mut letters_idx6 =\
    \ 0;\n    let mut vowels_idx7 = 0;\n    let mut letters_idx7 = 0;\n    let mut\
    \ vowels_idx8 = 0;\n    let mut letters_idx8 = 0;\n    let mut vowels_idx9 = 0;\n\
    \    let mut letters_idx9 = 0;\n    let mut vowels_idx10 = 0;\n    let mut letters_idx10\
    \ = 0;\n    let mut vowels_idx11 = 0;\n    let mut letters_idx11 = 0;\n    let\
    \ mut vowels_idx12 = 0;\n    let mut letters_idx12 = 0;\n    let mut vowels_idx13\
    \ = 0;\n    let mut letters_idx13 = 0;\n    let mut vowels_idx14 = 0;\n    let\
    \ mut letters_idx14 = 0;\n    let mut vowels_idx15 = 0;\n    let mut letters_idx15\
    \ = 0;\n    let mut vowels_idx16 = 0;\n    let mut letters_idx16 = 0;\n    let\
    \ mut vowels_idx17 = 0;\n    let mut letters_idx17 = 0;\n    let mut vowels_idx18\
    \ = 0;\n    let mut letters_idx18 = 0;\n    let mut vowels_idx19 = 0;\n    let\
    \ mut letters_idx19 = 0;\n    let mut vowels_idx20 = 0;\n    let mut letters_idx20\
    \ = 0;\n    let mut vowels_idx21 = 0;\n    let mut letters_idx21 = 0;\n    let\
    \ mut vowels_idx22 = 0;\n    let mut letters_idx22 = 0;\n    let mut vowels_idx23\
    \ = 0;\n    let mut letters_idx23 = 0;\n    let mut vowels_idx24 = 0;\n    let\
    \ mut letters_idx24 = 0;\n    let mut vowels_idx25 = 0;\n    let mut letters_idx25\
    \ = 0;\n    let mut vowels_idx26 = 0;\n    let mut letters_idx26 = 0;\n    let\
    \ mut vowels_idx27 = 0;\n    let mut letters_idx27 = 0;\n    let mut vowels_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpka6aonru.rs:69:20\n   |\n\
    69 |     let mut vowels_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpka6aonru.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpka6aonru.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpka6aonru.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E04"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = alphabet.len();\n    let mut m = vowels.len();\n\
    \    let mut n = message.len();\n    while i < n {\n        if message[i] == '\
    \ ' {\n            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message[i] == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message[i] == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4u70i4_5.rs:126:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n21  |     while i < n {\n    |\
    \                 - this delimiter might not be properly closed...\n...\n117 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n126\
    \ | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp4u70i4_5.rs:117:1\n\
    \    |\n116 |         if message\n    |         -- this `if` expression has a\
    \ condition, but no block\n117 | }\n    | ^ expected `{`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp4u70i4_5.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp4u70i4_5.rs:14:24\n   |\n14\
    \ |     let mut alphabet = HashSet::new();\n   |                        ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmp4u70i4_5.rs:121:17\n    |\n121 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp4u70i4_5.rs:121:25\n\
    \    |\n121 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp4u70i4_5.rs:122:17\n    |\n122 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp4u70i4_5.rs:122:25\n\
    \    |\n122 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp4u70i4_5.rs:123:17\n    |\n123 |     assert_eq!({lef"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \        if !vowels.contains(&c) {\n            vowels.insert(c);\n        }\n\
    \    }\n    for c in vowels.iter() {\n        result.push_str(&c.to_lowercase());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7z1yaxnr.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:36:25\n   |\n36 |     asser"
  stdout: ''
  timestamp: 1659747234
