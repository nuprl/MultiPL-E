language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            result.push_str(&alphabet[vowel_counter]);\n            vowel_counter\
    \ += 2;\n        } else {\n            result.push_str(&alphabet[letter_counter]);\n\
    \            letter_counter += 2;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbjgakzke.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbjgakzke.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbjgakzke.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbjgakzke.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbjgakzke.rs:18:16\n   |\n18 |         if let Some(vowel)\
    \ = vowels.binary_search(&letter) {\n   |                ^^^^^^^^^^^   -----------------------------\
    \ this expre"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut\
    \ index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8\
    \ = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11\
    \ = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14\
    \ = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17\
    \ = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20\
    \ = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23\
    \ = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26\
    \ = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29\
    \ = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32\
    \ = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35\
    \ = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38\
    \ = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41\
    \ = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44\
    \ = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47\
    \ = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50\
    \ = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53\
    \ = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56\
    \ = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59\
    \ = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62\
    \ = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n    let mut index65\
    \ = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpjg0och5j.rs:80:1\n  \
    \ |\n80 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpjg0och5j.rs:84:17\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:84:25\n \
    \  |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjg0och5j.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjg0och5j.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjg0och5j.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjg0och5j.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjg0och5j.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjg0och5j.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_positions\
    \ = Vec::new();\n    let mut letter_positions = Vec::new();\n    let mut letter_counts\
    \ = Vec::new();\n    let mut letter_index = 0;\n    let mut vowel_index = 0;\n\
    \    let mut letter_count = 1;\n    let mut vowel_count = 1;\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len = message.len();\n\
    \    let mut vowel_len = vowels.len();\n    let mut letter_count = message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut vowel_count = vowels.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut letter_len = message.len();\n    let mut vowel_len = vowels.len();\n\
    \    let mut letter_count = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut vowel_count = vowels.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut letter_pos = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len\
    \ = message.len();\n    let mut vowel_len = vowels.len();\n    let mut letter_count\
    \ = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n    let mut vowel_count\
    \ = vowels.chars().filter(|c| c >= 'a' && c <= 'z').count();\n    let mut letter_pos\
    \ = 0;\n    let mut vowel_pos = 0;\n    let mut letter_len = message.len();\n\
    \    let mut vowel_len = vowels.len();\n    let mut letter_count = message.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut vowel_count = vowels.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').count();\n    let mut letter_pos = 0;\n    let mut vowel_pos\
    \ = 0;\n    let mut letter_len = message.len();\n    let mut vowel_len = vowels.len();\n\
    \    let mut letter_count = message.chars().filter(|c| c >= 'a' && c <= 'z').count();\n\
    \    let mut vowel_count = \n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmp9y79tjd9.rs:52:1\n\
    \   |\n52 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp9y79tjd9.rs:56:17\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:56:25\n \
    \  |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9y79tjd9.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9y79tjd9.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9y79tjd9.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9y79tjd9.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9y79tjd9.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9y79tjd9.rs:60:25\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9y79tjd9.rs:26:60\n\
    \   |\n26 |     let mut letter_count ="
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut letter_\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xdqd0t5.rs:75:20\n   |\n\
    75 |     let mut letter_\n   |                    ^ help: add `;` here\n76 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:80:25\n   |\n80 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:81:25\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:82:17\n  \
    \ |\n82 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:82:25\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:17\n   |\n83 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:25\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:84:25\n   |\n84 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters_counter = 0;\n    for letter in message {\n        if\
    \ letter == letters[letters_counter] {\n            letters_counter += 1;\n  \
    \      } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter += 1;\n        } else\
    \ {\n            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter += 1;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter += 1;\n        } else {\n            vowels_counter = 0;\n  \
    \      }\n        if letter == letters[letters_counter] {\n            letters_counter\
    \ += 1;\n        } else {\n            letters_counter = 0;\n        }\n     \
    \   if letter == vowels[vowels_counter] {\n            vowels_counter += 1;\n\
    \        } else {\n            vowels_counter = 0;\n        }\n        if letter\
    \ == letters[letters_counter] {\n            letters_counter += 1;\n        }\
    \ else {\n            letters_counter = 0;\n        }\n        if letter == vowels[vowels_counter]\
    \ {\n            vowels_counter += 1;\n        } else {\n            vowels_counter\
    \ = 0;\n        }\n        if letter == letters[letters_counter] {\n         \
    \   letters_counter += 1;\n        } else {\n            letters_counter = 0;\n\
    \        }\n        if letter == vowels[vowels_counter] {\n            vowels_counter\
    \ += 1;\n        } else {\n            vowels_counter = 0;\n        }\n      \
    \  if letter == letters[letters_counter] {\n            letters_counter += 1;\n\
    \        } else {\n            letters_counter = 0;\n        }\n        if letter\
    \ == vowels[vowels_counter] {\n            vowels_counter += 1;\n        } else\
    \ {\n            vowels_counter = 0;\n        }\n        if letter == letters[letters_counter]\
    \ {\n            letters_counter += 1;\n        } else {\n            letters_counter\
    \ = 0;\n        }\n        if letter == vowels[vowels_counter] {\n           \
    \ vowels_counter += 1;\n        } else {\n            vowels_counter = 0;\n  \
    \      }\n        if letter\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmprt_6unr9.rs:98:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     for letter in message {\n\
    \   |                           - this delimiter might not be properly closed...\n\
    ...\n89 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    98 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmprt_6unr9.rs:89:1\n\
    \   |\n88 |         if letter\n   |         -- this `if` expression has a condition,\
    \ but no block\n89 | }\n   | ^ expected `{`\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmprt_6unr9.rs:93:17\n   |\n93 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:93:25\n \
    \  |\n93 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprt_6unr9.rs:94:17\n   |\n94 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:94:25\n   |\n94 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprt_6unr9.rs:95:17\n   |\n95 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprt_6unr9.rs:95:25\n   |\n95 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprt_6unr9.rs:96:17\n  \
    \ |\n96 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprt_6unr9.rs:96:25\n   |\n96 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in t"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels.binary_search(&letter) {\n          \
    \  encoded.push_str(&letters[(index + 1) % 26]);\n        } else {\n         \
    \   encoded.push_str(&letters[letter.to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp_f2xzrt5.rs:29:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n18 |  \
    \       } else {\n   |                - this delimiter might not be properly closed...\n\
    19 |             encoded.push_str(&lette...\n20 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n29 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmp_f2xzrt5.rs:19:38\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n19 |             encoded.push_str(&letters[letter.to_ascii_lowercase().unwrap().to_ascii_uppercase().unwrap().to_ascii_lowercase().unwrap().to...\n\
    \   |                                      ^ unclosed delimiter\n20 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left` in\
    \ this scope\n  --> /tmp/tmp_f2xzrt5.rs:24:17\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:24:25\n \
    \  |\n24 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_f2xzrt5.rs:25:17\n   |\n25 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:25:25\n   |\n25 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_f2xzrt5.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_f2xzrt5.rs:26:25\n   |\n26 |     assert_eq!({left},\
    \ {right});\n   |          "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashMap::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphg79ldgh.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphg79ldgh.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphg79ldgh.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphg79ldgh.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphg79ldgh.rs:85:25\n   |\n85 |     asser"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'A' || letter\
    \ == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'o' || letter\
    \ == 'O' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'e' || letter == 'E' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'i' || letter\
    \ == 'I' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'u' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'A' || letter\
    \ == 'a' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'E' || letter == 'e' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'I' || letter\
    \ == 'i' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'O' || letter == 'o' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'U' || letter\
    \ == 'u' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'a' || letter == 'A' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'e' || letter\
    \ == 'E' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'i' || letter == 'I' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'o' || letter\
    \ == 'O' {\n            vowels.insert(letter);\n            vowels_index = letter;\n\
    \        }\n        if letter == 'u' || letter == 'U' {\n            vowels.insert(letter);\n\
    \            vowels_index = letter;\n        }\n        if letter == 'O' || letter\
    \ == 'o' {\n            vowels.\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpoda3k7no.rs:92:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n81 |  \
    \       if letter == 'O' || letter == 'o' {\n   |                            \
    \               - this delimiter might not be properly closed...\n82 |       \
    \      vowels.\n83 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n92 | }\n   |   ^\n\nerror: unexpected token: `}`\n  --> /tmp/tmpoda3k7no.rs:83:1\n\
    \   |\n83 | }\n   | ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpoda3k7no.rs:13:22\n   |\n13 |     let mut vowels =\
    \ HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpoda3k7no.rs:87:17\n\
    \   |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoda3k7no.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoda3k7no.rs:88:17\n   |\n88 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoda3k7no.rs:88:25\n\
    \   |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoda3k7no.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoda3k7no.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]"
  stdout: ''
  timestamp: 1659747235
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut index = 0;\n    let mut vowel_index = 0;\n    let mut letter_count\
    \ = 1;\n    let mut letter_count_index = 0;\n    let mut letter_count_index2 =\
    \ 0;\n    let mut letter_count_index3 = 0;\n    let mut letter_count_index4 =\
    \ 0;\n    let mut letter_count_index5 = 0;\n    let mut letter_count_index6 =\
    \ 0;\n    let mut letter_count_index7 = 0;\n    let mut letter_count_index8 =\
    \ 0;\n    let mut letter_count_index9 = 0;\n    let mut letter_count_index10 =\
    \ 0;\n    let mut letter_count_index11 = 0;\n    let mut letter_count_index12\
    \ = 0;\n    let mut letter_count_index13 = 0;\n    let mut letter_count_index14\
    \ = 0;\n    let mut letter_count_index15 = 0;\n    let mut letter_count_index16\
    \ = 0;\n    let mut letter_count_index17 = 0;\n    let mut letter_count_index18\
    \ = 0;\n    let mut letter_count_index19 = 0;\n    let mut letter_count_index20\
    \ = 0;\n    let mut letter_count_index21 = 0;\n    let mut letter_count_index22\
    \ = 0;\n    let mut letter_count_index23 = 0;\n    let mut letter_count_index24\
    \ = 0;\n    let mut letter_count_index25 = 0;\n    let mut letter_count_index26\
    \ = 0;\n    let mut letter_count_index27 = 0;\n    let mut letter_count_index28\
    \ = 0;\n    let mut letter_count_index29 = 0;\n    let mut letter_count_index30\
    \ = 0;\n    let mut letter_count_index31 = 0;\n    let mut letter_count_index32\
    \ = 0;\n    let mut letter_count_index33 = 0;\n    let mut letter_count_index34\
    \ = 0;\n    let mut letter_count_index35 = 0;\n    let mut letter_count_index36\
    \ = 0;\n    let mut letter_count_index37 = 0;\n    let mut letter_count_index38\
    \ = 0;\n    let mut letter_count_index39 = 0;\n    let mut letter_count_index40\
    \ = 0;\n    let mut letter_count_index41 = 0;\n    let mut letter_count_index42\
    \ = 0;\n    let mut letter_count_index43 = 0;\n    let mut letter_count_index44\
    \ = 0;\n    let mut letter_count_index45 = 0;\n    let mut letter_count_index46\
    \ = 0;\n    let mut letter_count_index47 = 0;\n    let mut letter_count_index48\
    \ = 0;\n    let mut letter_count_index49 = 0;\n    let mut letter_count_index50\
    \ = 0;\n    let mut letter_count_index51 = 0;\n    let mut letter_count_index52\
    \ = 0;\n    let mut letter_count_index53 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:75:17\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:76:25\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7u_g_e0c.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:77:25\n   |\n77 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:78:25\n   |\n78 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7u_g_e0c.rs:79:17\n  \
    \ |\n79 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7u_g_e0c.rs:79:25\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7u_g_e0c.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_letters\
    \ = vec![\"A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowel_letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_letters = vec![\"B\", \"C\", \"D\", \"\
    F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut vowel_letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,\
    \ 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,\
    \ 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 7\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp8whq3bzr.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp8whq3bzr.rs:19:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut vowel_letters_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n20\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmp8whq3bzr.rs:24:17\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:24:25\n \
    \  |\n24 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8whq3bzr.rs:25:17\n   |\n25 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:25:25\n   |\n25 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8whq3bzr.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8whq3bzr.rs:26:25\n   |\n26 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8whq3bzr.rs:27:17\n  \
    \ |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8whq3bzr.rs:27:25\n   |\n27 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_counts = HashMap::new();\n    for letter in message.chars()\
    \ {\n        if let Some(count) = letter_counts.entry(letter).or_insert(0) {\n\
    \            *count += 1;\n        } else {\n            letter_counts.insert(letter,\
    \ 1);\n        }\n    }\n    for letter in message.chars() {\n        if let Some(count)\
    \ = letter_counts.entry(letter).or_insert(0) {\n            if *count > 2 {\n\
    \                let mut new_letter = letter;\n                while let Some(count)\
    \ = letter_counts.entry(new_letter).or_insert(0) {\n                    if *count\
    \ > 2 {\n                        new_letter = alphabet.entry(alphabet.index(new_letter)\
    \ + 1).or_insert(0);\n                    } else {\n                        new_letter\
    \ = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n               \
    \     }\n                }\n                result.push_str(&new_letter);\n  \
    \          } else {\n                result.push_str(&letter);\n            }\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5bbad967.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp5bbad967.rs:14:29\n\
    \   |\n14 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:28:38\n\
    \   |\n28 |                         new_letter = alphabet.entry(alphabet.index(new_letter)\
    \ + 1).or_insert(0);\n   |                                      ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmp5bbad967.rs:28:53\n   |\n28 |                         new_letter\
    \ = alphabet.entry(alphabet.index(new_letter) + 1).or_insert(0);\n   |       \
    \                                              ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:30:38\n\
    \   |\n30 |                         new_letter = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n\
    \   |                                      ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp5bbad967.rs:30:53\n\
    \   |\n30 |                         new_letter = alphabet.entry(alphabet.index(new_letter)).or_insert(0);\n\
    \   |                                                     ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp5bbad967.rs:46:17\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5bbad967.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                        "
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut alphabet = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut\
    \ index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6\
    \ = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 =\
    \ 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mu\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpi_sq4ffm.rs:68:11\n   |\n\
    68 |     let mu\n   |           ^ help: add `;` here\n69 | }\n   | - unexpected\
    \ token\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:73:17\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi_sq4ffm.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi_sq4ffm.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi_sq4ffm.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi_sq4ffm.rs"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n  \
    \  let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpb7mvyv8a.rs:51:20\n   |\n\
    51 |     let mut vowels_\n   |                    ^ help: add `;` here\n52 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb7mvyv8a.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb7mvyv8a.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:57:25\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:58:17\n  \
    \ |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb7mvyv8a.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb7mvyv8a.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb7mvyv8a.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut count = 1;\n    let mut\
    \ prev = 0;\n    let mut next = -1;\n    let mut prev2 = -1;\n    let mut next2\
    \ = -1;\n    let mut prev3 = -1;\n    let mut next3 = -1;\n    let mut prev4 =\
    \ -1;\n    let mut next4 = -1;\n    let mut prev5 = -1;\n    let mut next5 = -1;\n\
    \    let mut prev6 = -1;\n    let mut next6 = -1;\n    let mut prev7 = -1;\n \
    \   let mut next7 = -1;\n    let mut prev8 = -1;\n    let mut next8 = -1;\n  \
    \  let mut prev9 = -1;\n    let mut next9 = -1;\n    let mut prev10 = -1;\n  \
    \  let mut next10 = -1;\n    let mut prev11 = -1;\n    let mut next11 = -1;\n\
    \    let mut prev12 = -1;\n    let mut next12 = -1;\n    let mut prev13 = -1;\n\
    \    let mut next13 = -1;\n    let mut prev14 = -1;\n    let mut next14 = -1;\n\
    \    let mut prev15 = -1;\n    let mut next15 = -1;\n    let mut prev16 = -1;\n\
    \    let mut next16 = -1;\n    let mut prev17 = -1;\n    let mut next17 = -1;\n\
    \    let mut prev18 = -1;\n    let mut next18 = -1;\n    let mut prev19 = -1;\n\
    \    let mut next19 = -1;\n    let mut prev20 = -1;\n    let mut next20 = -1;\n\
    \    let mut prev21 = -1;\n    let mut next21 = -1;\n    let mut prev22 = -1;\n\
    \    let mut next22 = -1;\n    let mut prev23 = -1;\n    let mut next23 = -1;\n\
    \    let mut prev24 = -1;\n    let mut next24 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpwu29291v.rs:65:1\n\
    \   |\n65 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpwu29291v.rs:69:17\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:69:25\n \
    \  |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwu29291v.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwu29291v.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwu29291v.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwu29291v.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwu29291v.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwu29291v.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwu29291v.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[(index as usize) % letters.len()]);\n\
    \            result.push_str(&vowels[(index as usize) % vowels.len()]);\n    \
    \    }\n        index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptrpe4w32.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptrpe4w32.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptrpe4w32.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptrpe4w32.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptrpe4w32.rs:20:29\n   |\n20 |             result.push_str(&letters[(index\
    \ as usize) % letters.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOU\"\
    .to_string();\n    let mut index = 0;\n    for c in message.chars() {\n      \
    \  if c.is_uppercase() {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            result.push_str(&vowels[(index - 1) % vowels.len()]);\n\
    \        }\n        result.push_str(&c.to_string());\n        index += 1;\n  \
    \  }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:29:17\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfxy2xm95.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfxy2xm95.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfxy2xm95.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfxy2xm95.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpfxy2xm95.rs:17:30\n   |\n\
    17 |             result.push_str(&vowels[(index + 1) % vowels.len()]);\n   | \
    \                             ^^^^^"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_2 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_3 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_4 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_5 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_6 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_7 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_8 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_9 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_10 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_11 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_j7blrh7.rs:26:1\n   |\n26 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_j7blrh7.rs:25:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n25 |     let mut vowels_index_12 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n26 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:17\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:25\n \
    \  |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_j7blrh7.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_j7blrh7.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:33:25\n   |\n33 |     assert_eq!({left}, {right}"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n\
    \    let mut vowels_idx3 = 0;\n    let mut letters_idx3 = 0;\n    let mut vowels_idx4\
    \ = 0;\n    let mut letters_idx4 = 0;\n    let mut vowels_idx5 = 0;\n    let mut\
    \ letters_idx5 = 0;\n    let mut vowels_idx6 = 0;\n    let mut letters_idx6 =\
    \ 0;\n    let mut vowels_idx7 = 0;\n    let mut letters_idx7 = 0;\n    let mut\
    \ vowels_idx8 = 0;\n    let mut letters_idx8 = 0;\n    let mut vowels_idx9 = 0;\n\
    \    let mut letters_idx9 = 0;\n    let mut vowels_idx10 = 0;\n    let mut letters_idx10\
    \ = 0;\n    let mut vowels_idx11 = 0;\n    let mut letters_idx11 = 0;\n    let\
    \ mut vowels_idx12 = 0;\n    let mut letters_idx12 = 0;\n    let mut vowels_idx13\
    \ = 0;\n    let mut letters_idx13 = 0;\n    let mut vowels_idx14 = 0;\n    let\
    \ mut letters_idx14 = 0;\n    let mut vowels_idx15 = 0;\n    let mut letters_idx15\
    \ = 0;\n    let mut vowels_idx16 = 0;\n    let mut letters_idx16 = 0;\n    let\
    \ mut vowels_idx17 = 0;\n    let mut letters_idx17 = 0;\n    let mut vowels_idx18\
    \ = 0;\n    let mut letters_idx18 = 0;\n    let mut vowels_idx19 = 0;\n    let\
    \ mut letters_idx19 = 0;\n    let mut vowels_idx20 = 0;\n    let mut letters_idx20\
    \ = 0;\n    let mut vowels_idx21 = 0;\n    let mut letters_idx21 = 0;\n    let\
    \ mut vowels_idx22 = 0;\n    let mut letters_idx22 = 0;\n    let mut vowels_idx23\
    \ = 0;\n    let mut letters_idx23 = 0;\n    let mut vowels_idx24 = 0;\n    let\
    \ mut letters_idx24 = 0;\n    let mut vowels_idx25 = 0;\n    let mut letters_idx25\
    \ = 0;\n    let mut vowels_idx26 = 0;\n    let mut letters_idx26 = 0;\n    let\
    \ mut vowels_idx27 = 0;\n    let mut letters_idx27 = 0;\n    let mut vowels_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpka6aonru.rs:69:20\n   |\n\
    69 |     let mut vowels_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpka6aonru.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpka6aonru.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpka6aonru.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E04"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = alphabet.len();\n    let mut m = vowels.len();\n\
    \    let mut n = message.len();\n    while i < n {\n        if message[i] == '\
    \ ' {\n            i += 1;\n            continue;\n        }\n        if message[i]\
    \ == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message[i] == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message[i] == alphabet[j] {\n            i += 1;\n            alphabet.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == vowels[k] {\n    \
    \        i += 1;\n            vowels.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == alphabet[j] {\n            i += 1;\n    \
    \        alphabet.insert(message[i]);\n            continue;\n        }\n    \
    \    if message[i] == vowels[k] {\n            i += 1;\n            vowels.insert(message[i]);\n\
    \            continue;\n        }\n        if message[i] == alphabet[j] {\n  \
    \          i += 1;\n            alphabet.insert(message[i]);\n            continue;\n\
    \        }\n        if message[i] == vowels[k] {\n            i += 1;\n      \
    \      vowels.insert(message[i]);\n            continue;\n        }\n        if\
    \ message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp4u70i4_5.rs:126:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n21  |     while i < n {\n    |\
    \                 - this delimiter might not be properly closed...\n...\n117 |\
    \ }\n    | - ...as it matches this but it has different indentation\n...\n126\
    \ | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp4u70i4_5.rs:117:1\n\
    \    |\n116 |         if message\n    |         -- this `if` expression has a\
    \ condition, but no block\n117 | }\n    | ^ expected `{`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp4u70i4_5.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmp4u70i4_5.rs:14:24\n   |\n14\
    \ |     let mut alphabet = HashSet::new();\n   |                        ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmp4u70i4_5.rs:121:17\n    |\n121 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp4u70i4_5.rs:121:25\n\
    \    |\n121 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp4u70i4_5.rs:122:17\n    |\n122 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmp4u70i4_5.rs:122:25\n\
    \    |\n122 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmp4u70i4_5.rs:123:17\n    |\n123 |     assert_eq!({lef"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \        if !vowels.contains(&c) {\n            vowels.insert(c);\n        }\n\
    \    }\n    for c in vowels.iter() {\n        result.push_str(&c.to_lowercase());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7z1yaxnr.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7z1yaxnr.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7z1yaxnr.rs:36:25\n   |\n36 |     asser"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    for c in message.chars() {\n    \
    \    if c.is_uppercase() {\n            alphabet.insert(c.to_lowercase());\n \
    \       } else {\n            alphabet.insert(c.to_uppercase());\n        }\n\
    \    }\n    for c in message.chars() {\n        if !alphabet.contains(&c.to_lowercase())\
    \ {\n            continue;\n        }\n        if !vowels.contains(&c.to_lowercase())\
    \ {\n            vowels.insert(c.to_lowercase());\n        }\n        let mut\
    \ index = alphabet.iter().position(|x| x == c.to_lowercase()).unwrap();\n    \
    \    result.push_str(&alphabet[index + (*vowels.iter().position(|x| x == c.to_lowercase()).unwrap())]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpoguf2aeg.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpoguf2aeg.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpoguf2aeg.rs:37:17\n   |\n37 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoguf2aeg.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoguf2aeg.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoguf2aeg.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoguf2aeg.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpoguf2aeg.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoguf2aeg.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoguf2aeg.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxdxg8z_l.rs:47:20\n   |\n\
    47 |     let mut vowels_\n   |                    ^ help: add `;` here\n48 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxdxg8z_l.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxdxg8z_l.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxdxg8z_l.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxdxg8z_l.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxdxg8z_l.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), letter_count));\n            letter_count\
    \ += 1;\n        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            letter_count += 1;\n        }\n        if letter.is_lowercase()\
    \ {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            letter_count += 1;\n        } else {\n        \
    \    result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(), letter_count));\n\
    \            letter_count += 1;\n        }\n        if letter.is_digit() {\n \
    \           result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(), letter_count));\n\
    \            letter_count += 1;\n        } else {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), letter_count));\n            letter_count\
    \ += 1;\n        }\n        if letter.is_punctuation() {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), letter_count));\n            letter_count\
    \ += 1;\n        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            letter_count += 1;\n        }\n        if letter.is_whitespace()\
    \ {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            letter_count += 1;\n        } else {\n        \
    \    result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(), letter_count));\n\
    \            letter_count += 1;\n        }\n        if letter.is_symbol() {\n\
    \            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(), letter_count));\n\
    \            letter_count += 1;\n        } else {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), letter_count));\n            letter_count\
    \ += 1;\n        }\n        if letter.is_control() {\n            result.push_str(&format!(\"\
    {}{}\", letter.to_ascii_lowercase(), letter_count));\n            letter_count\
    \ += 1;\n        } else {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            letter_count += 1;\n        }\n        if letter.is_ascii()\
    \ {\n            result.push_str(&format!(\"{}{}\", letter.to_ascii_lowercase(),\
    \ letter_count));\n            \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpu990mcgy.rs:78:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n66 |  \
    \       if letter.is_ascii() {\n   |                              - this delimiter\
    \ might not be properly closed...\n...\n69 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpu990mcgy.rs:13:22\n\
    \   |\n13 |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpu990mcgy.rs:73:17\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpu990mcgy.rs:73:25\n \
    \  |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpu990mcgy.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpu990mcgy.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpu990mcgy.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpu990mcgy.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpu990mcgy.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |       "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut i = 0;\n \
    \   while i < message.len() {\n        let mut j = i;\n        while j < message.len()\
    \ {\n            if message[j] == vowels[i] {\n                result.push(*letters[i\
    \ as usize]);\n                i += 1;\n                j += 1;\n            }\
    \ else {\n                result.push(*message[j]);\n                j += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpn9vts8h0.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn9vts8h0.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpn9vts8h0.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpn9vts8h0.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpn9vts8h0.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpn9vts8h0.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpn9vts8h0.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpn9vts8h0.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpn9vts8h0.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpn9vts8h0.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpn9vts8h0.rs:19:16\n   |\n\
    19 |             if message[j] == vowels[i] {\n   |                ^^^^^^^^^^\
    \ `String` cannot be indexed by `us"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter_counter\
    \ < 2 {\n                result.push_str(&letters[letter_counter]);\n        \
    \        letter_counter += 1;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n                letter_counter = 1;\n  \
    \          }\n        }\n    }\n    if vowel_counter > 0 {\n        result.push_str(&vowels[vowel_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8klt2tgh.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8klt2tgh.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8klt2tgh.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8klt2tgh.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8klt2tgh.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8klt2tgh.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8klt2tgh.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8klt2tgh.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8klt2tgh.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8klt2tgh.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8klt2tgh.rs:22:33\n   |\n22 |                 result.push_str(&letters[letter_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut index = 0;\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&c) {\n            vowels.insert(c);\n   \
    \     }\n    }\n    let mut index2 = 0;\n    for c in message.chars() {\n    \
    \    if !letters.contains(&c) {\n            letters.insert(c);\n        }\n \
    \       if !vowels.contains(&c) {\n            vowels.insert(c);\n        }\n\
    \    }\n    for c in message.chars() {\n        if !letters.contains(&c) {\n \
    \           letters.insert(c);\n        }\n        if !vowels.contains(&c) {\n\
    \            vowels.insert(c);\n        }\n    }\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&c) {\n            vowels.insert(c);\n   \
    \     }\n    }\n    for c in message.chars() {\n        if !letters.contains(&c)\
    \ {\n            letters.insert(c);\n        }\n        if !vowels.contains(&c)\
    \ {\n            vowels.insert(c);\n        }\n    }\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&c) {\n            vowels.insert(c);\n   \
    \     }\n    }\n    for c in message.chars() {\n        if !letters.contains(&c)\
    \ {\n            letters.insert(c);\n        }\n        if !vowels.contains(&c)\
    \ {\n            vowels.insert(c);\n        }\n    }\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&c) {\n            vowels.insert(c);\n   \
    \     }\n    }\n    for c in message.chars() {\n        if !letters.contains(&c)\
    \ {\n            letters.insert(c);\n        }\n        if !vowels.contains(&c)\
    \ {\n            vowels.insert(c);\n        }\n    }\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&c) {\n            vowels.insert(c);\n   \
    \     }\n    }\n    for c in message.chars() {\n        if !letters.contains(&c)\
    \ {\n            letters.insert(c);\n        }\n        if !vowels.contains(&c)\
    \ {\n            vowels.insert(c);\n        }\n    }\n    for c in message.chars()\
    \ {\n        if !letters.contains(&c) {\n            letters.insert(c);\n    \
    \    }\n        if !vowels.contains(&\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpqifmf2jl.rs:119:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n105 |     for c in message.chars()\
    \ {\n    |                              - this delimiter might not be properly\
    \ closed...\n...\n110 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n119 | }\n    |   ^\n\nerror: expected expression, found `)`\n\
    \   --> /tmp/tmpqifmf2jl.rs:110:1\n    |\n110 | }\n    | ^ expected expression\n\
    \nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmpqifmf2jl.rs:109:28\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - closing delimiter possibly meant for this\n...\n109 | \
    \        if !vowels.contains(&\n    |                            ^ unclosed delimiter\n\
    110 | }\n    | ^ mismatched closing delimiter\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpqifmf2jl.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpqifmf2jl.rs:14:23\n   |\n14 |  \
    \   let mut letters = HashSet::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n   --> /tmp/tmpqifmf2jl.rs:114:17\n    |\n114 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n   --> /tmp/tmpqifmf2jl.rs:114:25\n\
    \    |\n114 |     assert_eq!({left}, {right});\n    |                        \
    \ ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n   --> /tmp/tmpqifmf2jl.rs:115:17\n    |\n115 |     assert_eq!({left},\
    \ {right});\n    |                 ^^^^ not found in this scope\n\nerror[E0425]: "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      if let Some(letter) = message.chars().nth(i) {\n            if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == letter) {\n                result.push((letters[vowel]\
    \ + letters[vowel + 1]).to_string());\n                i += 2;\n            }\
    \ else {\n                result.push(letter);\n                i += 1;\n    \
    \        }\n        } else {\n            i += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptk6zh37j.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptk6zh37j.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptk6zh37j.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptk6zh37j.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptk6zh37j.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptk6zh37j.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptk6zh37j.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptk6zh37j.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptk6zh37j.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptk6zh37j.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmptk6zh37j.rs:19:45\n   |\n19 |          \
    \       result.push((letters[vowel] + letters[vowel + 1]).to_string());\n   |\
    \                              ----------"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.find(letter) {\n \
    \           result.push_str(&vowels[vowel]);\n            vowels_counter += 1;\n\
    \        } else {\n            result.push_str(&letter);\n            letter_counter\
    \ += 1;\n        }\n    }\n    if vowels_counter > 2 {\n        result.push_str(&vowels[vowels.iter().skip(vowels_counter\
    \ - 2).next()]);\n    }\n    if letter_counter > 2 {\n        result.push_str(&letters[letter_counter\
    \ - 2]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpsbgzkz6x.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `letters` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:29:26\n\
    \   |\n29 |         result.push_str(&letters[letter_counter - 2]);\n   |     \
    \                     ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsbgzkz6x.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsbgzkz6x.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsbgzkz6x.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsbgzkz6x.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmps"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter_index = 0;\n    let mut\
    \ letter_counter_index2 = 0;\n    let mut letter_counter_index3 = 0;\n    let\
    \ mut letter_counter_index4 = 0;\n    let mut letter_counter_index5 = 0;\n   \
    \ let mut letter_counter_index6 = 0;\n    let mut letter_counter_index7 = 0;\n\
    \    let mut letter_counter_index8 = 0;\n    let mut letter_counter_index9 = 0;\n\
    \    let mut letter_counter_index10 = 0;\n    let mut letter_counter_index11 =\
    \ 0;\n    let mut letter_counter_index12 = 0;\n    let mut letter_counter_index13\
    \ = 0;\n    let mut letter_counter_index14 = 0;\n    let mut letter_counter_index15\
    \ = 0;\n    let mut letter_counter_index16 = 0;\n    let mut letter_counter_index17\
    \ = 0;\n    let mut letter_counter_index18 = 0;\n    let mut letter_counter_index19\
    \ = 0;\n    let mut letter_counter_index20 = 0;\n    let mut letter_counter_index21\
    \ = 0;\n    let mut letter_counter_index22 = 0;\n    let mut letter_counter_index23\
    \ = 0;\n    let mut letter_counter_index24 = 0;\n    let mut letter_counter_index25\
    \ = 0;\n    let mut letter_counter_index26 = 0;\n    let mut letter_counter_index27\
    \ = 0;\n    let mut letter_counter_index28 = 0;\n    let mut letter_counter_index29\
    \ = 0;\n    let mut letter_counter_index30 = 0;\n    let mut letter_counter_index31\
    \ = 0;\n    let mut letter_counter_index32 = 0;\n    let mut letter_counter_index33\
    \ = 0;\n    let mut letter_counter_index34 = 0;\n    let mut letter_counter_index35\
    \ = 0;\n    let mut letter_counter_index36 = 0;\n    let mut letter_counter_index37\
    \ = 0;\n    let mut letter_counter_index38 = 0;\n    let mut letter_counter_index39\
    \ = 0;\n    let mut letter_counter_index40 = 0;\n    let mut letter_counter_index41\
    \ = 0;\n    let mut letter_counter_index42 = 0;\n    let mut letter_counter_index43\
    \ = 0;\n    let mut letter_counter_index44 = 0;\n    let mut letter_counter_index45\
    \ = 0;\n    let mut letter_counter_index46 = 0;\n    let mut letter_counter_index47\
    \ = 0;\n    let mut letter_counter_index48 = 0;\n    let mut letter_counter_index49\
    \ = 0;\n    let mut letter_counter_index50 = 0;\n    let mut letter_counter_index51\
    \ = 0;\n    let mut letter_counter_index52 = 0;\n    let mut letter_\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_mxg17g9.rs:68:20\n   |\n\
    68 |     let mut letter_\n   |                    ^ help: add `;` here\n69 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_mxg17g9.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_mxg17g9.rs:73:25\n   |\n73 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_mxg17g9.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_mxg17g9.rs:74:25\n   |\n74 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_mxg17g9.rs:75:17\n  \
    \ |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_mxg17g9.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_mxg17g9.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_mxg17g9.rs:76:25\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_mxg17g9.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_mxg17g9.rs:77:25\n   |\n77 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n            result.push_str(&message[vowels_idx..vowels_idx+vowel]);\n\
    \            result.push_str(&message[vowels_idx+vowel+1..]);\n            vowels_idx\
    \ += vowel + 1;\n        } else {\n            result.push_str(&message[letter_counter..]);\n\
    \            result.push_str(&message[letter_counter+1..]);\n            letter_counter\
    \ += 1;\n        }\n        vowels.insert(letter);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp5qmv765n.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5qmv765n.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5qmv765n.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5qmv765n.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5qmv765n.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5qmv765n.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5qmv765n.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5qmv765n.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5qmv765n.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5qmv765n.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5qmv765n.rs:37:25\n   |\n37 |     asser"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   \
    \         result.push_str(&vowels[vowel_counter]);\n            vowel_counter\
    \ += 1;\n        } else {\n            result.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptaljphlw.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptaljphlw.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptaljphlw.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptaljphlw.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptaljphlw.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptaljphlw.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptaljphlw.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptaljphlw.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptaljphlw.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptaljphlw.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: can't\
    \ compare `&str` with `char`\n  --> /tmp/tmptaljphlw.rs:18:60\n   |\n18 |    \
    \     if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   |  \
    \                                         "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = vowels.len();\n    let mut letter_counter = 0;\n\
    \    for letter in message {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            result.push_str(&vowels[vowels_index]);\n\
    \            vowels_index += 2;\n            letter_counter += 1;\n        }\n\
    \    }\n    if letter_counter > 0 {\n        result.push_str(&vowels[vowels_index..]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpihbn3vhs.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpihbn3vhs.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpihbn3vhs.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpihbn3vhs.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpihbn3vhs.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpihbn3vhs.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpihbn3vhs.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpihbn3vhs.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpihbn3vhs.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpihbn3vhs.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpihbn3vhs.rs:16:19\n    |\n16  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_map = HashMap::new();\n    let mut\
    \ vowel_map = HashMap::new();\n    for letter in message.chars() {\n        if\
    \ let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n            vowel_map.insert(vowel,\
    \ letter);\n        }\n        letter_map.insert(letter, letter);\n    }\n   \
    \ for vowel in vowels.iter() {\n        let mut count = 0;\n        for letter\
    \ in message.chars() {\n            if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n                if count == 2 {\n                    result\
    \ += vowel_map.get(vowel);\n                } else {\n                    result\
    \ += letter_map.get(letter);\n                }\n                count += 1;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpauj6g8w0.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpauj6g8w0.rs:15:25\n\
    \   |\n15 |     let mut vowel_map = HashMap::new();\n   |                    \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpauj6g8w0.rs:40:17\n   |\n40 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpauj6g8w0.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpauj6g8w0.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpauj6g8w0.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpauj6g8w0.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpauj6g8w0.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpauj6g8w0.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpauj6g8w0.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7jelmwiu.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7jelmwiu.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    \n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowels.find(letter) {\n \
    \           encoded.push_str(&letters[(index + 1) % letters.len()]);\n       \
    \ } else {\n            encoded.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_qdqodg5.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_qdqodg5.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_qdqodg5.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_qdqodg5.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_qdqodg5.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_qdqodg5.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_qdqodg5.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_qdqodg5.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_qdqodg5.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_qdqodg5.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `usize`\n  --> /tmp/tmp_qdqodg5.rs:18:31\n   |\n\
    18 |             encoded.push_str(&letters[(index + 1) % letters.len()]);\n  \
    \ |                               ^^^^"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index2 = String::new();\n\
    \    let mut vowels_index3 = String::new();\n    let mut vowels_index4 = String::new();\n\
    \    let mut vowels_index5 = String::new();\n    let mut vowels_index6 = String::new();\n\
    \    let mut vowels_index7 = String::new();\n    let mut vowels_index8 = String::new();\n\
    \    let mut vowels_index9 = String::new();\n    let mut vowels_index10 = String::new();\n\
    \    let mut vowels_index11 = String::new();\n    let mut vowels_index12 = String::new();\n\
    \    let mut vowels_index13 = String::new();\n    let mut vowels_index14 = String::new();\n\
    \    let mut vowels_index15 = String::new();\n    let mut vowels_index16 = String::new();\n\
    \    let mut vowels_index17 = String::new();\n    let mut vowels_index18 = String::new();\n\
    \    let mut vowels_index19 = String::new();\n    let mut vowels_index20 = String::new();\n\
    \    let mut vowels_index21 = String::new();\n    let mut vowels_index22 = String::new();\n\
    \    let mut vowels_index23 = String::new();\n    let mut vowels_index24 = String::new();\n\
    \    let mut vowels_index25 = String::new();\n    let mut vowels_index26 = String::new();\n\
    \    let mut vowels_index27 = String::new();\n    let mut vowels_index28 = String::new();\n\
    \    let mut vowels_index29 = String::new();\n    let mut vowels_index30 = String::new();\n\
    \    let mut vowels_index31 = String::new();\n    let mut vowels_index32 = String::new();\n\
    \    let mut vowels_index33 = String::new();\n    let mut vowels_index34 = String::new();\n\
    \    let mut vowels_index35 = String::new();\n    let mut vowels_index36 = String::new();\n\
    \    let mut vowels_index37 = String::new();\n    let mut vowels_index38 = String::new();\n\
    \    let mut vowels_index39 = String::\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmp168ygkoq.rs:53:1\n\
    \   |\n53 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp168ygkoq.rs:57:17\n   |\n57 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp168ygkoq.rs:57:25\n \
    \  |\n57 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp168ygkoq.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp168ygkoq.rs:58:25\n   |\n58 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp168ygkoq.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp168ygkoq.rs:59:25\n   |\n59 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp168ygkoq.rs:60:17\n  \
    \ |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp168ygkoq.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp168ygkoq.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp168ygkoq.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    let mut current_letter = String::from(\"\
    \");\n    let mut current_vowel = String::from(\"\");\n    let mut current_letter_index\
    \ = -1;\n    let mut current_vowel_index = -1;\n    let mut current_letter_index2\
    \ = -1;\n    let mut current_vowel_index2 = -1;\n    let mut current_letter_index3\
    \ = -1;\n    let mut current_vowel_index3 = -1;\n    let mut current_letter_index4\
    \ = -1;\n    let mut current_vowel_index4 = -1;\n    let mut current_letter_index5\
    \ = -1;\n    let mut current_vowel_index5 = -1;\n    let mut current_letter_index6\
    \ = -1;\n    let mut current_vowel_index6 = -1;\n    let mut current_letter_index7\
    \ = -1;\n    let mut current_vowel_index7 = -1;\n    let mut current_letter_index8\
    \ = -1;\n    let mut current_vowel_index8 = -1;\n    let mut current_letter_index9\
    \ = -1;\n    let mut current_vowel_index9 = -1;\n    let mut current_letter_index10\
    \ = -1;\n    let mut current_vowel_index10 = -1;\n    let mut current_letter_index11\
    \ = -1;\n    let mut current_vowel_index11 = -1;\n    let mut current_letter_index12\
    \ = -1;\n    let mut current_vowel_index12 = -1;\n    let mut current_letter_index13\
    \ = -1;\n    let mut current_vowel_index13 = -1;\n    let mut current_letter_index14\
    \ = -1;\n    let mut current_vowel_index14 = -1;\n    let mut current_letter_index15\
    \ = -1;\n    let mut current_vowel_index15 = -1;\n    let mut current_letter_index16\
    \ = -1;\n    let mut current_vowel_index16 = -1;\n    let mut current_letter_index17\
    \ = -1;\n    let mut current_vowel_index17 = -1;\n    let mut current_letter_index18\
    \ = -1;\n    let mut current_vowel_index18 = -1;\n    let mut current_letter_index19\
    \ = -1;\n    let mut current_vowel_index19 = -1;\n    let mut current_letter_index20\
    \ = -1;\n    let mut current_vowel_index20 = -1;\n    let mut current_letter_index21\
    \ = -1;\n    let mut current_vowel_index21 = -1;\n    let mut current_letter_index22\
    \ = -1;\n    let mut current_vowel_index22 = -1;\n    let mut current_letter_index23\
    \ = -1;\n    let mut current_vowel_index23 = -1;\n    let mut current_letter\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmph3vnxw1l.rs:64:27\n   |\n\
    64 |     let mut current_letter\n   |                           ^ help: add `;`\
    \ here\n65 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmph3vnxw1l.rs:69:17\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmph3vnxw1l.rs:69:25\n \
    \  |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmph3vnxw1l.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmph3vnxw1l.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmph3vnxw1l.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmph3vnxw1l.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmph3vnxw1l.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmph3vnxw1l.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmph3vnxw1l.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmph3vnxw1l.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    let mut last_vowel = String::new();\n    let mut\
    \ last_vowel_pos = 0;\n    let mut last_vowel_pos_index = 0;\n    let mut last_vowel_pos_index2\
    \ = 0;\n    let mut last_vowel_pos_index3 = 0;\n    let mut last_vowel_pos_index4\
    \ = 0;\n    let mut last_vowel_pos_index5 = 0;\n    let mut last_vowel_pos_index6\
    \ = 0;\n    let mut last_vowel_pos_index7 = 0;\n    let mut last_vowel_pos_index8\
    \ = 0;\n    let mut last_vowel_pos_index9 = 0;\n    let mut last_vowel_pos_index10\
    \ = 0;\n    let mut last_vowel_pos_index11 = 0;\n    let mut last_vowel_pos_index12\
    \ = 0;\n    let mut last_vowel_pos_index13 = 0;\n    let mut last_vowel_pos_index14\
    \ = 0;\n    let mut last_vowel_pos_index15 = 0;\n    let mut last_vowel_pos_index16\
    \ = 0;\n    let mut last_vowel_pos_index17 = 0;\n    let mut last_vowel_pos_index18\
    \ = 0;\n    let mut last_vowel_pos_index19 = 0;\n    let mut last_vowel_pos_index20\
    \ = 0;\n    let mut last_vowel_pos_index21 = 0;\n    let mut last_vowel_pos_index22\
    \ = 0;\n    let mut last_vowel_pos_index23 = 0;\n    let mut last_vowel_pos_index24\
    \ = 0;\n    let mut last_vowel_pos_index25 = 0;\n    let mut last_vowel_pos_index26\
    \ = 0;\n    let mut last_vowel_pos_index27 = 0;\n    let mut last_vowel_pos_index28\
    \ = 0;\n    let mut last_vowel_pos_index29 = 0;\n    let mut last_vowel_pos_index30\
    \ = 0;\n    let mut last_vowel_pos_index31 = 0;\n    let mut last_vowel_pos_index32\
    \ = 0;\n    let mut last_vowel_pos_index33 = 0;\n    let mut last_vowel_pos_index34\
    \ = 0;\n    let mut last_vowel_pos_index35 = 0;\n    let mut last_vowel_pos_index36\
    \ = 0;\n    let mut last_vowel_pos_index37 = 0;\n    let mut last_vowel_pos_index38\
    \ = 0;\n    let mut last_vowel_pos_index39 = 0;\n    let mut last_vowel_pos_index40\
    \ = 0;\n    let mut last_vowel_pos_index41 = 0;\n    let mut last_vowel_pos_index42\
    \ = 0;\n    let mut last_vowel_pos_index\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxf0b_yot.rs:59:33\n   |\n\
    59 |     let mut last_vowel_pos_index\n   |                                 ^\
    \ help: add `;` here\n60 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxf0b_yot.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxf0b_yot.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxf0b_yot.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxf0b_yot.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxf0b_yot.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxf0b_yot.rs:66:25\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxf0b_yot.rs:67:17\n  \
    \ |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxf0b_yot.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxf0b_yot.rs:68:17\n   |\n68 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxf0b_yot.rs:68:25\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            letters.insert(c.to_lowercase());\n        } else {\n       \
    \     letters.insert(c.to_uppercase());\n        }\n    }\n    for c in message.chars()\
    \ {\n        if c.is_uppercase() {\n            if letters.contains(c.to_lowercase())\
    \ {\n                let mut new_letter = c.to_lowercase();\n                if\
    \ vowels.contains(new_letter) {\n                    let mut new_vowel = c.to_lowercase();\n\
    \                    let mut new_vowel_counter = 0;\n                    while\
    \ vowel_counter < 2 {\n                        new_vowel = new_vowel.chars().next().unwrap();\n\
    \                        if new_vowel == c.to_lowercase() {\n                \
    \            new_vowel_counter++;\n                        }\n               \
    \     }\n                    new_vowel = new_vowel.chars().next().unwrap();\n\
    \                    encoded.push_str(new_vowel.to_string());\n              \
    \      vowel_counter = new_vowel_counter;\n                } else {\n        \
    \            encoded.push_str(new_letter.to_string());\n                    vowel_counter++;\n\
    \                }\n            } else {\n                encoded.push_str(c.to_string());\n\
    \            }\n        } else {\n            if letters.contains(c.to_uppercase())\
    \ {\n                let mut new_letter = c.to_uppercase();\n                if\
    \ vowels.contains(new_letter) {\n                    let mut new_vowel = c.to_uppercase();\n\
    \                    let mut new_vowel_counter = 0;\n                    while\
    \ vowel_counter < 2 {\n                        new_vowel = new_vowel.chars().next().unwrap();\n\
    \                        if new_vowel == c.to_uppercase() {\n                \
    \            new_vowel_counter++;\n                        }\n               \
    \     }\n                    new_vowel = new_vowel.chars().next().unwrap();\n\
    \                    encoded.push_str(new_vowel.to_string());\n              \
    \      vowel_counter = new_vowel_counter;\n                } else {\n        \
    \            encoded.push_str(new_letter.to_string());\n                    vowel_counter++;\n\
    \                }\n            } else {\n                encoded.push_str(c.to_string());\n\
    \            }\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpqs2nqce5.rs:34:47\n\
    \   |\n34 | ...                   new_vowel_counter++;\n   |                 \
    \                        ^ expected expression\n\nerror: expected expression,\
    \ found `+`\n  --> /tmp/tmpqs2nqce5.rs:42:35\n   |\n42 |                     vowel_counter++;\n\
    \   |                                   ^ expected expression\n\nerror: expected\
    \ expression, found `+`\n  --> /tmp/tmpqs2nqce5.rs:56:47\n   |\n56 | ...     \
    \              new_vowel_counter++;\n   |                                    \
    \     ^ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpqs2nqce5.rs:64:35\n\
    \   |\n64 |                     vowel_counter++;\n   |                       \
    \            ^ expected expression\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpqs2nqce5.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpqs2nqce5.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqs2nqce5.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqs2nqce5.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqs2nqce5.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqs2nqce5.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found i"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',\
    \ 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n   \
    \ let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\
    \ 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\
    \ 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,\
    \ 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,\
    \ 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,\
    \ 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_count = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmphp79n1cw.rs:20:1\n   |\n20 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmphp79n1cw.rs:19:38\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n19 |     let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, \n   |                                      ^ unclosed delimiter\n20 |\
    \ }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmphp79n1cw.rs:24:17\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmphp79n1cw.rs:24:25\n \
    \  |\n24 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmphp79n1cw.rs:25:17\n   |\n25 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmphp79n1cw.rs:25:25\n   |\n25 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmphp79n1cw.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmphp79n1cw.rs:26:25\n   |\n26 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmphp79n1cw.rs:27:17\n  \
    \ |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmphp79n1cw.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\
    \    let mut vowels_index = 0;\n    let mut letters_index = 0;\n    let mut letters_index2\
    \ = 0;\n    let mut letters_index3 = 0;\n    let mut letters_index4 = 0;\n   \
    \ let mut letters_index5 = 0;\n    let mut letters_index6 = 0;\n    let mut letters_index7\
    \ = 0;\n    let mut letters_index8 = 0;\n    let mut letters_index9 = 0;\n   \
    \ let mut letters_index10 = 0;\n    let mut letters_index11 = 0;\n    let mut\
    \ letters_index12 = 0;\n    let mut letters_index13 = 0;\n    let mut letters_index14\
    \ = 0;\n    let mut letters_index15 = 0;\n    let mut letters_index16 = 0;\n \
    \   let mut letters_index17 = 0;\n    let mut letters_index18 = 0;\n    let mut\
    \ letters_index19 = 0;\n    let mut letters_index20 = 0;\n    let mut letters_index21\
    \ = 0;\n    let mut letters_index22 = 0;\n    let mut letters_index23 = 0;\n \
    \   let mut letters_index24 = 0;\n    let mut letters_index25 = 0;\n    let mut\
    \ letters_index26 = 0;\n    let mut letters_index27 = 0;\n    let mut letters_index28\
    \ = 0;\n    let mut letters_index29 = 0;\n    let mut letters_index30 = 0;\n \
    \   let mut letters_index31 = 0;\n    let mut letters_index32 = 0;\n    let mut\
    \ letters_index33 = 0;\n    let mut letters_index34 = 0;\n    let mut letters_index35\
    \ = 0;\n    let mut letters_index36 = 0;\n    let mut letters_index37 = 0;\n \
    \   let mut letters_index38 = 0;\n    let mut letters_index39 = 0;\n    let mut\
    \ letters_index40 = 0;\n    let mut letters_index41 = 0;\n    let mut letters_index42\
    \ = 0;\n    let mut letters_index43 = 0;\n    let mut letters_index44 = 0;\n \
    \   let mut letters_index45 = 0;\n    let mut letters_index46 = 0;\n    let mut\
    \ letters_index47 = 0;\n    let mut letters_index48 = 0;\n    let mut letters_index49\
    \ = 0;\n    let mut letters_index50 = 0;\n    let mut letters_index51 = 0;\n \
    \   let mut letters_index52\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkc9_jhqa.rs:67:28\n   |\n\
    67 |     let mut letters_index52\n   |                            ^ help: add\
    \ `;` here\n68 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:72:17\n   |\n72 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:72:25\n \
    \  |\n72 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkc9_jhqa.rs:73:17\n   |\n73 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:73:25\n   |\n73 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkc9_jhqa.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:74:25\n   |\n74 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:75:17\n  \
    \ |\n75 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkc9_jhqa.rs:75:25\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:76:17\n   |\n76 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkc9_jhqa.rs:76:25\n\
    \   |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatch"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut index = 0;\n    let mut vowel_index = 0;\n\
    \    let mut letter_position = 0;\n    let mut letter_count = 0;\n    let mut\
    \ letter_positions = vec![];\n    let mut letter_positions_index = 0;\n    let\
    \ mut letter_positions_index2 = 0;\n    let mut letter_positions_index3 = 0;\n\
    \    let mut letter_positions_index4 = 0;\n    let mut letter_positions_index5\
    \ = 0;\n    let mut letter_positions_index6 = 0;\n    let mut letter_positions_index7\
    \ = 0;\n    let mut letter_positions_index8 = 0;\n    let mut letter_positions_index9\
    \ = 0;\n    let mut letter_positions_index10 = 0;\n    let mut letter_positions_index11\
    \ = 0;\n    let mut letter_positions_index12 = 0;\n    let mut letter_positions_index13\
    \ = 0;\n    let mut letter_positions_index14 = 0;\n    let mut letter_positions_index15\
    \ = 0;\n    let mut letter_positions_index16 = 0;\n    let mut letter_positions_index17\
    \ = 0;\n    let mut letter_positions_index18 = 0;\n    let mut letter_positions_index19\
    \ = 0;\n    let mut letter_positions_index20 = 0;\n    let mut letter_positions_index21\
    \ = 0;\n    let mut letter_positions_index22 = 0;\n    let mut letter_positions_index23\
    \ = 0;\n    let mut letter_positions_index24 = 0;\n    let mut letter_positions_index25\
    \ = 0;\n    let mut letter_positions_index26 = 0;\n    let mut letter_positions_index27\
    \ = 0;\n    let mut letter_positions_index28 = 0;\n    let mut letter_positions_index29\
    \ = 0;\n    let mut letter_positions_index30 = 0;\n    let mut letter_positions_index31\
    \ = 0;\n    let mut letter_positions_index32 = 0;\n    let mut letter_positions_index33\
    \ = 0;\n    let mut letter_positions_index34 = 0;\n    let mut letter_positions_index35\
    \ = 0;\n    let mut letter_positions_index36 = 0;\n    let mut letter_positions_index37\
    \ = 0;\n    let mut letter_positions_index38 = 0;\n    let mut letter_positions_index39\
    \ = 0;\n    let mut letter_positions_index40 = 0;\n    let mut letter_positions_index41\
    \ = 0;\n    let mut letter_\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpbrbe1sem.rs:61:20\n   |\n\
    61 |     let mut letter_\n   |                    ^ help: add `;` here\n62 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbrbe1sem.rs:66:17\n   |\n66 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbrbe1sem.rs:66:25\n   |\n66 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbrbe1sem.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbrbe1sem.rs:67:25\n   |\n67 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbrbe1sem.rs:68:17\n  \
    \ |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbrbe1sem.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbrbe1sem.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbrbe1sem.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbrbe1sem.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbrbe1sem.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      if let Some(letter) = message.chars().nth(i + 1) {\n            if let\
    \ Some(vowel) = vowels.iter().position(|&x| x == letter) {\n                let\
    \ mut j = i + 1;\n                while j < message.len() {\n                \
    \    if let Some(letter) = message.chars().nth(j + 1) {\n                    \
    \    if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n       \
    \                     let mut k = j + 1;\n                            while k\
    \ < message.len() {\n                                if let Some(letter) = message.chars().nth(k\
    \ + 1) {\n                                    if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n                                        let mut l = k + 1;\n\
    \                                        while l < message.len() {\n         \
    \                                   if let Some(letter) = message.chars().nth(l\
    \ + 1) {\n                                                if let Some(vowel) =\
    \ vowels.iter().position(|&x| x == letter) {\n                               \
    \                     let mut m = l + 1;\n                                   \
    \                 while m < message.len() {\n                                \
    \                        if let Some(letter) = message.chars().nth(m + 1) {\n\
    \                                                            let mut n = m + 1;\n\
    \                                                            while n < message.len()\
    \ {\n                                                                if let Some(letter)\
    \ = message.chars().nth(n + 1) {\n                                           \
    \                         if let Some(vowel) = vowels.iter().position(|&x| x ==\
    \ letter) {\n                                                                \
    \        let mut o = n + 1;\n                                                \
    \                        while o < message.len() {\n                         \
    \                                                   if let Some(letter) = message.chars().nth(o\
    \ + 1) {\n                                                                   \
    \             if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n\
    \                                                                            \
    \        let mut p = o + 1;\n                                                \
    \                                    while p < message.len() {\n             \
    \                                                                           if\
    \ let Some(letter) = message.chars().nth(p + 1) {\n                          \
    \                                                                  if let Some(vowel)\
    \ = vowels.iter().position(|&x| x == letter) {\n                             \
    \                                                                   let mut q\
    \ = p + 1;\n                                                                 \
    \                               while q < message.len() {\n                  \
    \                                                                            \
    \      if let Some(letter) = message.chars().nth(q + 1) {\n                  \
    \                                                                            \
    \          if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n \
    \                                                                            \
    \                               \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa53o7l62.rs:60:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n16 |     while i < message.len()\
    \ {\n   |                             - unclosed delimiter\n17 |         if let\
    \ Some(letter) = message.chars().nth(i + 1) {\n   |                          \
    \                                - unclosed delimiter\n18 |             if let\
    \ Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   |             \
    \                                                              - unclosed delimiter\n\
    19 |                 let mut j = i + 1;\n20 |                 while j < message.len()\
    \ {\n   |                                         - unclosed delimiter\n21 | \
    \                    if let Some(letter) = message.chars().nth(j + 1) {\n   |\
    \                                                                      - unclosed\
    \ delimiter\n22 |                         if let Some(vowel) = vowels.iter().position(|&x|\
    \ x == letter) {\n   |                                                       \
    \                                - unclosed delimiter\n23 |                  \
    \           let mut k = j + 1;\n24 |                             while k < message.len()\
    \ {\n   |                                                     - unclosed delimiter\n\
    25 |                                 if let Some(letter) = message.chars().nth(k\
    \ + 1) {\n   |                                                               \
    \                   - unclosed delimiter\n26 |                               \
    \      if let Some(vowel) = vowels.iter().position(|&x| x == letter) {\n   | \
    \                                                                            \
    \                      - unclosed delimiter\n27 |                            \
    \             let mut l = k + 1;\n28 |                                       \
    \  while l < message.len() {\n   |                                           \
    \                      - unclosed delimiter\n29 |                            \
    \                 if let Some(letter) "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_pairs = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair_count = 0;\n    let mut letter_pair_count2 = 0;\n   \
    \ let mut letter_pair_count3 = 0;\n    let mut letter_pair_count4 = 0;\n    let\
    \ mut letter_pair_count5 = 0;\n    let mut letter_pair_count6 = 0;\n    let mut\
    \ letter_pair_count7 = 0;\n    let mut letter_pair_count8 = 0;\n    let mut letter_pair_count9\
    \ = 0;\n    let mut letter_pair_count10 = 0;\n    let mut letter_pair_count11\
    \ = 0;\n    let mut letter_pair_count12 = 0;\n    let mut letter_pair_count13\
    \ = 0;\n    let mut letter_pair_count14 = 0;\n    let mut letter_pair_count15\
    \ = 0;\n    let mut letter_pair_count16 = 0;\n    let mut letter_pair_count17\
    \ = 0;\n    let mut letter_pair_count18 = 0;\n    let mut letter_pair_count19\
    \ = 0;\n    let mut letter_pair_count20 = 0;\n    let mut letter_pair_count21\
    \ = 0;\n    let mut letter_pair_count22 = 0;\n    let mut letter_pair_count23\
    \ = 0;\n    let mut letter_pair_count24 = 0;\n    let mut letter_pair_count25\
    \ = 0;\n    let mut letter_pair_count26 = 0;\n    let mut letter_pair_count27\
    \ = 0;\n    let mut letter_pair_count28 = 0;\n    let mut letter_pair_count29\
    \ = 0;\n    let mut letter_pair_count30 = 0;\n    let mut letter_pair_count31\
    \ = 0;\n    let mut letter_pair_count32 = 0;\n    let mut letter_pair_count33\
    \ = 0;\n    let mut letter_pair_count34 = 0;\n    let mut letter_pair_count35\
    \ = 0;\n    let mut letter_pair_count36 = 0;\n    let mut letter_pair_count37\
    \ = 0;\n    let mut letter_pair_count38 = 0;\n    let mut letter_pair_count39\
    \ = 0;\n    let mut letter_pair_count40 = 0;\n    let mut letter_pair_count41\
    \ = 0;\n    let mut letter_pair_count42 = 0;\n    let mut letter_pair_count43\
    \ = 0;\n    let mut letter_pair_count44 = 0;\n    let mut letter_pair_count45\
    \ = 0;\n    let mut letter_pair_count46 = 0;\n    let mut letter_pair_count47\
    \ = 0;\n    let mut letter_pair_count48 = 0;\n    let mut letter_pair_count49\
    \ = 0;\n    let mut letter_pair_count50 = 0;\n    let mut letter_pair_count51\
    \ = 0;\n    let mut letter_pair_count52 = 0;\n    let mut letter_pair\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp4k22opo.rs:68:24\n   |\n\
    68 |     let mut letter_pair\n   |                        ^ help: add `;` here\n\
    69 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpp4k22opo.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpp4k22opo.rs:14:28\n   |\n14 |     let mut letter_pairs = HashSet::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpp4k22opo.rs:15:27\n   |\n15 |     let mut letter_pair = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpp4k22opo.rs:73:17\n  \
    \ |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp4k22opo.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpp4k22opo.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpp4k22opo.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp4k22opo.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  -"
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowels_index\
    \ = letters.len() - vowels.len();\n    let mut letters_index = letters.len() -\
    \ vowels.len() - 1;\n    let mut vowels_index2 = letters.len() - vowels.len()\
    \ - 2;\n    let mut letters_index2 = letters.len() - vowels.len() - 3;\n    let\
    \ mut vowels_index3 = letters.len() - vowels.len() - 4;\n    let mut letters_index3\
    \ = letters.len() - vowels.len() - 5;\n    let mut vowels_index4 = letters.len()\
    \ - vowels.len() - 6;\n    let mut letters_index4 = letters.len() - vowels.len()\
    \ - 7;\n    let mut vowels_index5 = letters.len() - vowels.len() - 8;\n    let\
    \ mut letters_index5 = letters.len() - vowels.len() - 9;\n    let mut vowels_index6\
    \ = letters.len() - vowels.len() - 10;\n    let mut letters_index6 = letters.len()\
    \ - vowels.len() - 11;\n    let mut vowels_index7 = letters.len() - vowels.len()\
    \ - 12;\n    let mut letters_index7 = letters.len() - vowels.len() - 13;\n   \
    \ let mut vowels_index8 = letters.len() - vowels.len() - 14;\n    let mut letters_index8\
    \ = letters.len() - vowels.len() - 15;\n    let mut vowels_index9 = letters.len()\
    \ - vowels.len() - 16;\n    let mut letters_index9 = letters.len() - vowels.len()\
    \ - 17;\n    let mut vowels_index10 = letters.len() - vowels.len() - 18;\n   \
    \ let mut letters_index10 = letters.len() - vowels.len() - 19;\n    let mut vowels_index11\
    \ = letters.len() - vowels.len() - 20;\n    let mut letters_index11 = letters.len()\
    \ - vowels.len() - 21;\n    let mut vowels_index12 = letters.len() - vowels.len()\
    \ - 22;\n    let mut letters_index12 = letters.len() - vowels.len() - 23;\n  \
    \  let mut vowels_index13 = letters.len() - vowels.len() - 24;\n    let mut letters_index13\
    \ = letters.len() - vowels.len() - 25;\n    let mut vowels_index14 = letters.len()\
    \ - vowels.len() - 26;\n    let mut letters_index14 = \n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpuvgu1eaq.rs:43:1\n\
    \   |\n43 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpuvgu1eaq.rs:47:17\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:47:25\n \
    \  |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpuvgu1eaq.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpuvgu1eaq.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpuvgu1eaq.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpuvgu1eaq.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .chars();\n    let mut vowels_index = 0;\n    let mut index = 0;\n    while index\
    \ < message.len() {\n        let mut new_letter = message[index];\n        if\
    \ new_letter == ' ' {\n            result.push_str(&new_letter);\n           \
    \ index += 1; // skip space\n            continue;\n        }\n        if new_letter\
    \ == 'a' {\n            new_letter = vowels[vowels_index].to_string();\n     \
    \       vowels_index += 1;\n        }\n        if new_letter == 'e' {\n      \
    \      new_letter = vowels[vowels_index].to_string();\n            vowels_index\
    \ += 1;\n        }\n        if new_letter == 'i' {\n            new_letter = vowels[vowels_index].to_string();\n\
    \            vowels_index += 1;\n        }\n        if new_letter == 'o' {\n \
    \           new_letter = vowels[vowels_index].to_string();\n            vowels_index\
    \ += 1;\n        }\n        if new_letter == 'u' {\n            new_letter = vowels[vowels_index].to_string();\n\
    \            vowels_index += 1;\n        }\n        result.push_str(&new_letter);\n\
    \        index += 1; // skip letter\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7fqrcjpm.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7fqrcjpm.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7fqrcjpm.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7fqrcjpm.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7fqrcjpm.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp7fqrcjpm.rs:17:30\n   |\n\
    17 |         let mut new_letter = message[index];\n   |                      \
    \        ^^^^^^^^^^^^^^ `String` ca"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_2\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_2\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_3\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_4\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_4\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_5\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_5\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letters_index_6\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowel\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpp4rb7su9.rs:27:18\n   |\n\
    27 |     let mut vowel\n   |                  ^ help: add `;` here\n28 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp4rb7su9.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpp4rb7su9.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpp4rb7su9.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpp4rb7su9.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpp4rb7su9.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpp4rb7su9.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpp4rb7su9.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpp4rb7su9.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpp4rb7su9.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpp4rb7su9.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut vowels_counter2 = 0;\n    let mut\
    \ vowels_counter3 = 0;\n    let mut vowels_counter4 = 0;\n    let mut vowels_counter5\
    \ = 0;\n    let mut vowels_counter6 = 0;\n    let mut vowels_counter7 = 0;\n \
    \   let mut vowels_counter8 = 0;\n    let mut vowels_counter9 = 0;\n    let mut\
    \ vowels_counter10 = 0;\n    let mut vowels_counter11 = 0;\n    let mut vowels_counter12\
    \ = 0;\n    let mut vowels_counter13 = 0;\n    let mut vowels_counter14 = 0;\n\
    \    let mut vowels_counter15 = 0;\n    let mut vowels_counter16 = 0;\n    let\
    \ mut vowels_counter17 = 0;\n    let mut vowels_counter18 = 0;\n    let mut vowels_counter19\
    \ = 0;\n    let mut vowels_counter20 = 0;\n    let mut vowels_counter21 = 0;\n\
    \    let mut vowels_counter22 = 0;\n    let mut vowels_counter23 = 0;\n    let\
    \ mut vowels_counter24 = 0;\n    let mut vowels_counter25 = 0;\n    let mut vowels_counter26\
    \ = 0;\n    let mut vowels_counter27 = 0;\n    let mut vowels_counter28 = 0;\n\
    \    let mut vowels_counter29 = 0;\n    let mut vowels_counter30 = 0;\n    let\
    \ mut vowels_counter31 = 0;\n    let mut vowels_counter32 = 0;\n    let mut vowels_counter33\
    \ = 0;\n    let mut vowels_counter34 = 0;\n    let mut vowels_counter35 = 0;\n\
    \    let mut vowels_counter36 = 0;\n    let mut vowels_counter37 = 0;\n    let\
    \ mut vowels_counter38 = 0;\n    let mut vowels_counter39 = 0;\n    let mut vowels_counter40\
    \ = 0;\n    let mut vowels_counter41 = 0;\n    let mut vowels_counter42 = 0;\n\
    \    let mut vowels_counter43 = 0;\n    let mut vowels_counter44 = 0;\n    let\
    \ mut vowels_counter45 = 0;\n    let mut vowels_counter46 = 0;\n    let mut vowels_counter47\
    \ = 0;\n    let mut vowels_counter48 = 0;\n    let mut vowels_counter49 = 0;\n\
    \    let mut vowels_counter50 = 0;\n    let mut vowels_counter51 = 0;\n    let\
    \ mut vowels_counter52 = 0;\n    let mut vowels_counter53 = 0;\n    let mut vowels_counter54\
    \ = 0;\n    let mut vowels_counter55 = 0;\n    let mu\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx5b27lpz.rs:69:11\n   |\n\
    69 |     let mu\n   |           ^ help: add `;` here\n70 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpx5b27lpz.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx5b27lpz.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx5b27lpz.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx5b27lpz.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx5b27lpz.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx5b27lpz.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx5b27lpz.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx5b27lpz.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx5b27lpz.rs:77:25\n   |\n77 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx5b27lpz.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut vowel_index\
    \ = 0;\n    let mut letter_count = 0;\n    let mut vowel_count = 0;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            letter_count +=\
    \ 1;\n        }\n        if letter == 'a' || letter == 'e' || letter == 'i' ||\
    \ letter == 'o' || letter == 'u' {\n            vowels += letter;\n          \
    \  vowel_index += 1;\n        }\n        if letter == 'A' || letter == 'E' ||\
    \ letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels += letter;\n\
    \            vowel_index += 1;\n        }\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            vowels\
    \ += letter;\n            vowel_index += 1;\n        }\n        if letter == 'A'\
    \ || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U' {\n    \
    \        vowels += letter;\n            vowel_index += 1;\n        }\n       \
    \ if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter\
    \ == 'u' {\n            vowels += letter;\n            vowel_index += 1;\n   \
    \     }\n        if letter == 'A' || letter == 'E' || letter == 'I' || letter\
    \ == 'O' || letter == 'U' {\n            vowels += letter;\n            vowel_index\
    \ += 1;\n        }\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u' {\n            vowels += letter;\n       \
    \     vowel_index += 1;\n        }\n        if letter == 'A' || letter == 'E'\
    \ || letter == 'I' || letter == 'O' || letter == 'U' {\n            vowels +=\
    \ letter;\n            vowel_index += 1;\n        }\n        if letter == 'a'\
    \ || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n    \
    \        vowels += letter;\n            vowel_index += 1;\n        }\n       \
    \ if letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter\
    \ == 'U' {\n            vowels += letter;\n            vowel_index += 1;\n   \
    \     }\n        if letter == 'a' || letter == 'e' || letter == 'i' || letter\
    \ == 'o' || letter == 'u' {\n            vowels += letter;\n            vowel_index\
    \ += 1;\n        }\n        if letter == 'A' || letter == 'E' || letter == 'I'\
    \ || letter == 'O' || letter == 'U' {\n            vowels += letter\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp1j_yflji.rs:78:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     for letter in message.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n67 |  \
    \       if letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' ||\
    \ letter == 'U' {\n   |                                                      \
    \                                        - this delimiter might not be properly\
    \ closed...\n68 |             vowels += letter\n69 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n78 | }\n   |   ^\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1j_yflji.rs:73:17\n  \
    \ |\n73 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1j_yflji.rs:73:25\n   |\n73 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1j_yflji.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1j_yflji.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1j_yflji.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1j_yflji.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1j_yflji.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1j_yflji.rs:76:25\n   |\n76 "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut i = 0;\n    for letter in message {\n       \
    \ if letter == letters.last() {\n            result.push_str(&vowels[i as usize]);\n\
    \            i += 1;\n        } else {\n            result.push_str(&letters[i\
    \ as usize]);\n            i += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptmi4fd9v.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptmi4fd9v.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptmi4fd9v.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptmi4fd9v.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptmi4fd9v.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptmi4fd9v.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptmi4fd9v.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptmi4fd9v.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptmi4fd9v.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptmi4fd9v.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmptmi4fd9v.rs:16:19\n    |\n16  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let\
    \ mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59\
    \ = 0;\n    let mut letter_counter60\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyqi_76ze.rs:75:29\n   |\n\
    75 |     let mut letter_counter60\n   |                             ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpyqi_76ze.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpyqi_76ze.rs:14:23\n   |\n14 |  \
    \   let mut letters = HashSet::new();\n   |                       ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpyqi_76ze.rs:80:17\n   |\n80 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpyqi_76ze.rs:80:25\n \
    \  |\n80 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyqi_76ze.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyqi_76ze.rs:81:25\n   |\n81 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyqi_76ze.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyqi_76ze.rs:82:25\n   |\n82 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyqi_76ze.rs:83:17\n  \
    \ |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in thi"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowel_alphabet = HashSet::new();\n\
    \    let mut vowel_alphabet2 = HashSet::new();\n    let mut vowel_alphabet3 =\
    \ HashSet::new();\n    let mut vowel_alphabet4 = HashSet::new();\n    let mut\
    \ vowel_alphabet5 = HashSet::new();\n    let mut vowel_alphabet6 = HashSet::new();\n\
    \    let mut vowel_alphabet7 = HashSet::new();\n    let mut vowel_alphabet8 =\
    \ HashSet::new();\n    let mut vowel_alphabet9 = HashSet::new();\n    let mut\
    \ vowel_alphabet10 = HashSet::new();\n    let mut vowel_alphabet11 = HashSet::new();\n\
    \    let mut vowel_alphabet12 = HashSet::new();\n    let mut vowel_alphabet13\
    \ = HashSet::new();\n    let mut vowel_alphabet14 = HashSet::new();\n    let mut\
    \ vowel_alphabet15 = HashSet::new();\n    let mut vowel_alphabet16 = HashSet::new();\n\
    \    let mut vowel_alphabet17 = HashSet::new();\n    let mut vowel_alphabet18\
    \ = HashSet::new();\n    let mut vowel_alphabet19 = HashSet::new();\n    let mut\
    \ vowel_alphabet20 = HashSet::new();\n    let mut vowel_alphabet21 = HashSet::new();\n\
    \    let mut vowel_alphabet22 = HashSet::new();\n    let mut vowel_alphabet23\
    \ = HashSet::new();\n    let mut vowel_alphabet24 = HashSet::new();\n    let mut\
    \ vowel_alphabet25 = HashSet::new();\n    let mut vowel_alphabet26 = HashSet::new();\n\
    \    let mut vowel_alphabet27 = HashSet::new();\n    let mut vowel_alphabet28\
    \ = HashSet::new();\n    let mut vowel_alphabet29 = HashSet::new();\n    let mut\
    \ vowel_alphabet30 = HashSet::new();\n    let mut vowel_alphabet31 = HashSet::new();\n\
    \    let mut vowel_alphabet32 = HashSet::new();\n    let mut vowel_alphabet33\
    \ = HashSet::new();\n    let mut vowel_alphabet34 = HashSet::new();\n    let mut\
    \ vowel_alphabet35 = HashSet::new();\n    let mut \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpmj1uwtb6.rs:51:1\n\
    \   |\n51 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:14:24\n   |\n14 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:15:30\n   |\n15 |  \
    \   let mut vowel_alphabet = HashSet::new();\n   |                           \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:16:31\n   |\n16\
    \ |     let mut vowel_alphabet2 = HashSet::new();\n   |                      \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:17:31\n\
    \   |\n17 |     let mut vowel_alphabet3 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:18:31\n\
    \   |\n18 |     let mut vowel_alphabet4 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpmj1uwtb6.rs:19:31\n\
    \   |\n19 |     l"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel, vowel);\n    }\n    for letter\
    \ in message.chars() {\n        let mut new_letter = letter;\n        let mut\
    \ new_vowel = vowels_map.get(&new_letter);\n        if new_vowel == Some(&new_letter)\
    \ {\n            new_vowel = vowels_map.get(&new_letter).unwrap();\n        }\n\
    \        result.push_str(new_vowel.to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpr_wgteyd.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpr_wgteyd.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr_wgteyd.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpr_wgteyd.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpr_wgteyd.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpr_wgteyd.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpr_wgteyd.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpr_wgteyd.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpr_wgteyd.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpr_wgteyd.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpr_wgteyd.rs:35:25\n   |\n35 |  "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from('a'), String::from('e'));\n    vowels.insert(String::from('e'),\
    \ String::from('i'));\n    vowels.insert(String::from('i'), String::from('o'));\n\
    \    vowels.insert(String::from('o'), String::from('u'));\n    vowels.insert(String::from('u'),\
    \ String::from('y'));\n    vowels.insert(String::from('y'), String::from('a'));\n\
    \    vowels.insert(String::from('o'), String::from('u'));\n    vowels.insert(String::from('u'),\
    \ String::from('y'));\n    vowels.insert(String::from('y'), String::from('a'));\n\
    \    vowels.insert(String::from('e'), String::from('i'));\n    vowels.insert(String::from('i'),\
    \ String::from('o'));\n    vowels.insert(String::from('o'), String::from('u'));\n\
    \    vowels.insert(String::from('u'), String::from('y'));\n    vowels.insert(String::from('y'),\
    \ String::from('a'));\n    vowels.insert(String::from('e'), String::from('i'));\n\
    \    vowels.insert(String::from('i'), String::from('o'));\n    vowels.insert(String::from('o'),\
    \ String::from('u'));\n    vowels.insert(String::from('u'), String::from('y'));\n\
    \    vowels.insert(String::from('y'), String::from('a'));\n    vowels.insert(String::from('e'),\
    \ String::from('i'));\n    vowels.insert(String::from('i'), String::from('o'));\n\
    \    vowels.insert(String::from('o'), String::from('u'));\n    vowels.insert(String::from('u'),\
    \ String::from('y'));\n    vowels.insert(String::from('y'), String::from('a'));\n\
    \    vowels.insert(String::from('e'), String::from('i'));\n    vowels.insert(String::from('i'),\
    \ String::from('o'));\n    vowels.insert(String::from('o'), String::from('u'));\n\
    \    vowels.insert(String::from('u'), String::from('y'));\n    vowels.insert(String::from('y'),\
    \ String::from('a'));\n    vowels.insert(String::from('e'), String::from('i\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `while`, `for`, `loop` or `{` after a label\n  --> /tmp/tmpboc1003f.rs:44:1\n\
    \   |\n44 | }\n   | ^ expected `while`, `for`, `loop` or `{` after a label\n\n\
    error: expected expression, found `)`\n  --> /tmp/tmpboc1003f.rs:44:1\n   |\n\
    44 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter: `}`\n\
    \  --> /tmp/tmpboc1003f.rs:43:50\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |                                      - closing delimiter possibly meant\
    \ for this\n...\n43 |     vowels.insert(String::from('e'), String::from('i\n \
    \  |                                                  ^ unclosed delimiter\n44\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpboc1003f.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashMap::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpboc1003f.rs:48:17\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpboc1003f.rs:48:25\n \
    \  |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpboc1003f.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpboc1003f.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpboc1003f.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpboc1003f.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    let mut i = 0;\n    while i < message.len() {\n        if message[i] == vowels.chars().nth(i\
    \ + 1).unwrap() {\n            result.push_str(&letters.chars().nth(i + 1).unwrap());\n\
    \            i += 2;\n        } else {\n            result.push_str(&message[i]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmppq9joe2v.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppq9joe2v.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppq9joe2v.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmppq9joe2v.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmppq9joe2v.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmppq9joe2v.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmppq9joe2v.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmppq9joe2v.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmppq9joe2v.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppq9joe2v.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmppq9joe2v.rs:17:12\n   |\n\
    17 |         if message[i] == vowels.chars().nth(i + 1).unwrap() {\n   |     \
    \       ^^^^^^^^^^ `String` cannot "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = alphabet.len();\n    while i < message.len()\
    \ {\n        if message.chars().nth(i).unwrap() == 'a' {\n            alphabet.insert(message.chars().nth(i\
    \ + 1).unwrap());\n            i += 1;\n        }\n        if message.chars().nth(i).unwrap()\
    \ == 'e' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n\
    \            i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'i' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'o' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'u' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'y' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'A' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'E' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'I' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'O' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'U' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'Y' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'a' {\n            alphabet.insert(message.chars().nth(i + 1).unwrap());\n \
    \           i += 1;\n        }\n        if message.chars().nth(i).unwrap() ==\
    \ 'e' {\n            alphabet.insert(message.char\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpg3rn8z0p.rs:83:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     while i < message.len()\
    \ {\n   |                             - unclosed delimiter\n...\n72 |        \
    \ if message.chars().nth(i).unwrap() == 'e' {\n   |                          \
    \                         - this delimiter might not be properly closed...\n73\
    \ |             alphabet.insert(message.char\n74 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n83 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpg3rn8z0p.rs:73:28\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n73 |             alphabet.insert(message.char\n\
    \   |                            ^ unclosed delimiter\n74 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpg3rn8z0p.rs:13:22\n   |\n13 |     let mut vowels =\
    \ HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpg3rn8z0p.rs:14:24\n   |\n14 |     let mut alphabet = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpg3rn8z0p.rs:78:17\n  \
    \ |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpg3rn8z0p.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpg3rn8z0p.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter in vowels {\n            if letter_counter < 2 {\n               \
    \ result.push(*letters[letter_counter]);\n                letter_counter += 1;\n\
    \            } else {\n                result.push(*vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            }\n        } else {\n      \
    \      result.push(*letters[letter_counter]);\n            letter_counter += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpiryr0s4e.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpiryr0s4e.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpiryr0s4e.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpiryr0s4e.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpiryr0s4e.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpiryr0s4e.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpiryr0s4e.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpiryr0s4e.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpiryr0s4e.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpiryr0s4e.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpiryr0s4e.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if vowels.contains(&letter) {\n        \
    \        vowel_counter++;\n                if vowel_counter == 2 && letters.contains(&letters[letter_counter])\
    \ {\n                    result.push_str(&letters[letter_counter]);\n        \
    \        } else {\n                    result.push_str(&letter);\n           \
    \     }\n            } else {\n                letter_counter++;\n           \
    \     if letter_counter == 2 && letters.contains(&letters[letter_counter]) {\n\
    \                    result.push_str(&letters[letter_counter]);\n            \
    \    } else {\n                    result.push_str(&letter);\n               \
    \ }\n            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `+`\n  --> /tmp/tmpg_o0qxkp.rs:22:31\n\
    \   |\n22 |                 vowel_counter++;\n   |                           \
    \    ^ expected expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmpg_o0qxkp.rs:29:32\n\
    \   |\n29 |                 letter_counter++;\n   |                          \
    \      ^ expected expression\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpg_o0qxkp.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpg_o0qxkp.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpg_o0qxkp.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpg_o0qxkp.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpg_o0qxkp.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpg_o0qxkp.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpg_o0qxkp.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpg_o0qxkp.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpg_o0qxkp.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter_counter\
    \ < vowel_counter {\n                result.push_str(vowels[vowel_counter]);\n\
    \            } else {\n                result.push_str(vowels[vowel_counter -\
    \ 1]);\n            }\n            result.push_str(letter);\n            letter_counter\
    \ += 1;\n        }\n        vowel_counter += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp317vvh6i.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp317vvh6i.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp317vvh6i.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp317vvh6i.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp317vvh6i.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp317vvh6i.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp317vvh6i.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp317vvh6i.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp317vvh6i.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp317vvh6i.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp317vvh6i.rs:21:33\n   |\n21 |                 result.push_str(vowels[vowel_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, fou"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyoy0nvah.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyoy0nvah.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    let mut count = 1;\n    let mut\
    \ index2 = 0;\n    let mut count2 = 0;\n    let mut index3 = 0;\n    let mut count3\
    \ = 0;\n    let mut index4 = 0;\n    let mut count4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut count5 = 0;\n    let mut index6 = 0;\n    let mut count6 = 0;\n\
    \    let mut index7 = 0;\n    let mut count7 = 0;\n    let mut index8 = 0;\n \
    \   let mut count8 = 0;\n    let mut index9 = 0;\n    let mut count9 = 0;\n  \
    \  let mut index10 = 0;\n    let mut count10 = 0;\n    let mut index11 = 0;\n\
    \    let mut count11 = 0;\n    let mut index12 = 0;\n    let mut count12 = 0;\n\
    \    let mut index13 = 0;\n    let mut count13 = 0;\n    let mut index14 = 0;\n\
    \    let mut count14 = 0;\n    let mut index15 = 0;\n    let mut count15 = 0;\n\
    \    let mut index16 = 0;\n    let mut count16 = 0;\n    let mut index17 = 0;\n\
    \    let mut count17 = 0;\n    let mut index18 = 0;\n    let mut count18 = 0;\n\
    \    let mut index19 = 0;\n    let mut count19 = 0;\n    let mut index20 = 0;\n\
    \    let mut count20 = 0;\n    let mut index21 = 0;\n    let mut count21 = 0;\n\
    \    let mut index22 = 0;\n    let mut count22 = 0;\n    let mut index23 = 0;\n\
    \    let mut count23 = 0;\n    let mut index24 = 0;\n    let mut count24 = 0;\n\
    \    let mut index25 = 0;\n    let mut count25 = 0;\n    let mut index26 = 0;\n\
    \    let mut count26 = 0;\n    let mut index27 = 0;\n    let mut count27 = 0;\n\
    \    let mut index28 = 0;\n    let mut count28 = 0;\n    let mut index29 = 0;\n\
    \    let mut count29 = 0;\n    let mut index30 = 0;\n    let mut count30 = 0;\n\
    \    let mut index31 = 0;\n    let mut count31 = 0;\n    let mut index32 = 0;\n\
    \    let mut count32 = 0;\n    let mut index33 = 0;\n    let mut count33 = 0;\n\
    \    let mut index34 = 0;\n    let mut count34 = 0;\n    let \n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpa90nbwyu.rs:84:1\n  \
    \ |\n84 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpa90nbwyu.rs:88:17\n   |\n88 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpa90nbwyu.rs:88:25\n \
    \  |\n88 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpa90nbwyu.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpa90nbwyu.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpa90nbwyu.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpa90nbwyu.rs:90:25\n   |\n90 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpa90nbwyu.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpa90nbwyu.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpa90nbwyu.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpa90nbwyu.rs:92:25\n\
    \   |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter in vowels {\n            vowel_counter += 1;\n            result.push((letters[letter_counter]\
    \ + letters[letter_counter + 1]).to_string());\n            letter_counter +=\
    \ 2;\n        } else {\n            result.push((letters[letter_counter] + letters[letter_counter\
    \ + 1]).to_string());\n            letter_counter += 1;\n        }\n    }\n  \
    \  if vowel_counter > 0 {\n        result.push((letters[letter_counter] + letters[letter_counter\
    \ + 1]).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpkdrqetot.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkdrqetot.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkdrqetot.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkdrqetot.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkdrqetot.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkdrqetot.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkdrqetot.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkdrqetot.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkdrqetot.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkdrqetot.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkdrqetot.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut index = 0;\n    let mut i = 0;\n    while i <\
    \ message.len() {\n        if message[i] == ' ' {\n            result.push_str(&message[..i]);\n\
    \            i += 1;\n        } else {\n            let mut found = false;\n \
    \           for j in 0..vowels.len() {\n                if message[i] == vowels[j]\
    \ {\n                    found = true;\n                    result.push_str(&letters[vowels.len()\
    \ - j - 1]);\n                    i += 1;\n                    break;\n      \
    \          }\n            }\n            if !found {\n                result.push_str(&message[i]);\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp27mb9iru.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp27mb9iru.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp27mb9iru.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp27mb9iru.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp27mb9iru.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp27mb9iru.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp27mb9iru.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp27mb9iru.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp27mb9iru.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp27mb9iru.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp27mb9iru.rs:18:12\n   |\n\
    18 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   ="
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    let mut vowel_counter2 = 0;\n   \
    \ let mut letter_counter2 = 0;\n    let mut vowel_counter3 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut vowel_counter4 = 0;\n    let mut letter_counter4 = 0;\n  \
    \  let mut vowel_counter5 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ vowel_counter6 = 0;\n    let mut letter_counter6 = 0;\n    let mut vowel_counter7\
    \ = 0;\n    let mut letter_counter7 = 0;\n    let mut vowel_counter8 = 0;\n  \
    \  let mut letter_counter8 = 0;\n    let mut vowel_counter9 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut vowel_counter10 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut vowel_counter11 = 0;\n    let mut letter_counter11 = 0;\n\
    \    let mut vowel_counter12 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut vowel_counter13 = 0;\n    let mut letter_counter13 = 0;\n    let mut vowel_counter14\
    \ = 0;\n    let mut letter_counter14 = 0;\n    let mut vowel_counter15 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut vowel_counter16 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut vowel_counter17 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut vowel_counter18 = 0;\n    let mut letter_counter18 = 0;\n\
    \    let mut vowel_counter19 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut vowel_counter20 = 0;\n    let mut letter_counter20 = 0;\n    let mut vowel_counter21\
    \ = 0;\n    let mut letter_counter21 = 0;\n    let mut vowel_counter22 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut vowel_counter23 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut vowel_counter24 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut vowel_counter25 = 0;\n    let mut letter_counter25 = 0;\n\
    \    let mut vowel_counter26 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut vowel_counter27 = 0;\n    let \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpeqkho468.rs:69:1\n  \
    \ |\n69 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpeqkho468.rs:73:17\n   |\n73 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpeqkho468.rs:73:25\n \
    \  |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpeqkho468.rs:74:17\n   |\n74 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpeqkho468.rs:74:25\n   |\n74 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpeqkho468.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpeqkho468.rs:75:25\n   |\n75 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpeqkho468.rs:76:17\n  \
    \ |\n76 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeqkho468.rs:76:25\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeqkho468.rs:77:17\n   |\n77 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpeqkho468.rs:77:25\n\
    \   |\n77 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut index = 0;\n    let mut currentLetter = String::new();\n\
    \    let mut currentVowel = String::new();\n    let mut currentVowelIndex = -1;\n\
    \    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n  \
    \  let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let\
    \ mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut\
    \ currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex\
    \ = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex =\
    \ -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n\
    \    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n  \
    \  let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let\
    \ mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut\
    \ currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex\
    \ = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex =\
    \ -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n\
    \    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n  \
    \  let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let\
    \ mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut\
    \ currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex\
    \ = -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex =\
    \ -1;\n    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n\
    \    let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n  \
    \  let mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n    let\
    \ mut currentVowelIndex = -1;\n    let mut currentVowelIndex = -1;\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpe_o96juf.rs:67:17\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpe_o96juf.rs:67:25\n   |\n67 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpe_o96juf.rs:68:17\n   |\n68 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpe_o96juf.rs:68:25\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpe_o96juf.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpe_o96juf.rs:69:25\n   |\n69 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpe_o96juf.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpe_o96juf.rs:70:25\n   |\n70 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpe_o96juf.rs:71:17\n  \
    \ |\n71 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpe_o96juf.rs:71:25\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpe_o96juf.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyoy0nvah.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyoy0nvah.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyoy0nvah.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyoy0nvah.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyoy0nvah.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33\
    \ = vec![0, 1, 2, 3, 4];\n    let mut \n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmposd6_og7.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected identifier\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmposd6_og7.rs:52:17\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmposd6_og7.rs:52:25\n \
    \  |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmposd6_og7.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmposd6_og7.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmposd6_og7.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmposd6_og7.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmposd6_og7.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmposd6_og7.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmposd6_og7.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmposd6_og7.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    let mut current_letter = String::new();\n    let\
    \ mut next_letter = String::new();\n    let mut current_vowel = String::new();\n\
    \    let mut next_vowel = String::new();\n    \n    for letter in message {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&vowels[index % vowels.len()]);\n           \
    \ result.push_str(&letter);\n        }\n        index += 1;\n    }\n    \n   \
    \ for letter in result {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n        } else {\n            if letter == &vowels[index % vowels.len()]\
    \ {\n                current_vowel = &vowels[index % vowels.len()];\n        \
    \        next_vowel = &vowels[(index + 1) % vowels.len()];\n            } else\
    \ {\n                current_vowel = &letter;\n                next_vowel = &letter;\n\
    \            }\n            \n            result.push_str(&current_vowel);\n \
    \           result.push_str(&next_vowel);\n        }\n        index += 1;\n  \
    \  }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpi7o69345.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi7o69345.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpi7o69345.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpi7o69345.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpi7o69345.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpi7o69345.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpi7o69345.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpi7o69345.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpi7o69345.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpi7o69345.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpi7o69345.rs:20:19\n    |\n20  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::from(\"\
    aeiouAEIOU\");\n    let mut letters = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    let mut i = 0;\n    \n    for letter in message.chars() {\n        if\
    \ let Some(vowel) = vowels.chars().position(|c| c == letter) {\n            encoded.push_str(&letters[vowel\
    \ + 2]);\n        } else {\n            encoded.push_str(&letters[letter]);\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8343_jfn.rs:29:17\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8343_jfn.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8343_jfn.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8343_jfn.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8343_jfn.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8343_jfn.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8343_jfn.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8343_jfn.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8343_jfn.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8343_jfn.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp8343_jfn.rs:19:31\n   |\n\
    19 |             encoded.push_str(&letters[vowel + 2]);\n   |                \
    \               ^^^^^^^^^^^^^^^^^^ "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n     \
    \   } else {\n            result.push_str(&vowels[(index + 1) % vowels.len()].to_lowercase());\n\
    \        }\n        result.push_str(&c);\n        index += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgbl6oydk.rs:29:17\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgbl6oydk.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgbl6oydk.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgbl6oydk.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgbl6oydk.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgbl6oydk.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgbl6oydk.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgbl6oydk.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgbl6oydk.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgbl6oydk.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `usize`\n  --> /tmp/tmpgbl6oydk.rs:17:30\n   |\n\
    17 |             result.push_str(&vowels[(index + 1) % vowels.len()]);\n   | \
    \                             ^^^^^^^^"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = 0;\n    let mut letters_index\
    \ = 0;\n    let mut vowels_index2 = 0;\n    let mut letters_index2 = 0;\n    let\
    \ mut vowels_index3 = 0;\n    let mut letters_index3 = 0;\n    let mut vowels_index4\
    \ = 0;\n    let mut letters_index4 = 0;\n    let mut vowels_index5 = 0;\n    let\
    \ mut letters_index5 = 0;\n    let mut vowels_index6 = 0;\n    let mut letters_index6\
    \ = 0;\n    let mut vowels_index7 = 0;\n    let mut letters_index7 = 0;\n    let\
    \ mut vowels_index8 = 0;\n    let mut letters_index8 = 0;\n    let mut vowels_index9\
    \ = 0;\n    let mut letters_index9 = 0;\n    let mut vowels_index10 = 0;\n   \
    \ let mut letters_index10 = 0;\n    let mut vowels_index11 = 0;\n    let mut letters_index11\
    \ = 0;\n    let mut vowels_index12 = 0;\n    let mut letters_index12 = 0;\n  \
    \  let mut vowels_index13 = 0;\n    let mut letters_index13 = 0;\n    let mut\
    \ vowels_index14 = 0;\n    let mut letters_index14 = 0;\n    let mut vowels_index15\
    \ = 0;\n    let mut letters_index15 = 0;\n    let mut vowels_index16 = 0;\n  \
    \  let mut letters_index16 = 0;\n    let mut vowels_index17 = 0;\n    let mut\
    \ letters_index17 = 0;\n    let mut vowels_index18 = 0;\n    let mut letters_index18\
    \ = 0;\n    let mut vowels_index19 = 0;\n    let mut letters_index19 = 0;\n  \
    \  let mut vowels_index20 = 0;\n    let mut letters_index20 = 0;\n    let mut\
    \ vowels_index21 = 0;\n    let mut letters_index21 = 0;\n    let mut vowels_index22\
    \ = 0;\n    let mut letters_index22 = 0;\n    let mut vowels_index23 = 0;\n  \
    \  let mut letters_index23 = 0;\n    let mut vowels_index24 = 0;\n    let mut\
    \ letters_index24 = 0;\n    let mut vowels_index25 = 0;\n    let mut letters_index\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp1bilprqc.rs:64:26\n   |\n\
    64 |     let mut letters_index\n   |                          ^ help: add `;`\
    \ here\n65 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp1bilprqc.rs:69:17\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp1bilprqc.rs:69:25\n \
    \  |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1bilprqc.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1bilprqc.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1bilprqc.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1bilprqc.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1bilprqc.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1bilprqc.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1bilprqc.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1bilprqc.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched t"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    let mut letter = String::new();\n    let mut vowel\
    \ = String::new();\n    let mut vowel_next = String::new();\n    \n    for letter\
    \ in message {\n        if letter == ' ' {\n            encoded.push(letter);\n\
    \            continue;\n        }\n        \n        if vowels.contains(&letter)\
    \ {\n            encoded.push(vowel);\n            vowel = String::new();\n  \
    \          vowel_next = String::new();\n            vowel = vowel.clone();\n \
    \           vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = vowel_next.clone();\n            vowel = vowel.clone();\n\
    \            vowel_next = \n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgplms3l0.rs:88:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n19 |     for letter in message {\n\
    \   |                           - unclosed delimiter\n...\n25 |         if vowels.contains(&letter)\
    \ {\n   |                                     - this delimiter might not be properly\
    \ closed...\n...\n79 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n88 | }\n   |   ^\n\nerror: expected expression, found `}`\n  --> /tmp/tmpgplms3l0.rs:79:1\n\
    \   |\n79 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpgplms3l0.rs:83:17\n   |\n83 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpgplms3l0.rs:83:25\n \
    \  |\n83 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgplms3l0.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgplms3l0.rs:84:25\n   |\n84 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgplms3l0.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgplms3l0.rs:85:25\n   |\n85 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgplms3l0.rs:86:17\n  \
    \ |\n86 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgplms3l0.rs:86:25\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \            "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut index = 0;\n    let mut current = 0;\n    let mut prev = 0;\n   \
    \ let mut next = message.chars().nth(1).unwrap();\n    while current != next {\n\
    \        if current == 'a' || current == 'e' || current == 'i' || current == 'o'\
    \ || current == 'u' {\n            vowels.insert(current as usize);\n        }\n\
    \        encoded.push_str(&message.chars().nth(index).unwrap());\n        prev\
    \ = current;\n        current = next;\n        next = message.chars().nth(index\
    \ + 1).unwrap();\n        index += 1;\n    }\n    let mut i = 0;\n    while vowels.len()\
    \ > 0 {\n        let mut next = vowels.iter().next().unwrap();\n        let mut\
    \ j = 0;\n        while j != next {\n            encoded.push_str(&message.chars().nth(i).unwrap());\n\
    \            i += 1;\n            j = next;\n            next = vowels.iter().next().unwrap();\n\
    \        }\n        i += 1;\n    }\n    encoded\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_9l5ofzv.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_9l5ofzv.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:46:17\n   |\n46 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:46:25\n\
    \   |\n46 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_9l5ofzv.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:47:25\n   |\n47 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_9l5ofzv.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:48:25\n   |\n48 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_9l5ofzv.rs:49:17\n  \
    \ |\n49 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_9l5ofzv.rs:49:25\n   |\n49 |     asser"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_count\
    \ = 1;\n    let mut vowels_encoded_count_prev = 0;\n    let mut vowels_encoded_count_prev2\
    \ = 0;\n    let mut vowels_encoded_count_prev3 = 0;\n    let mut vowels_encoded_count_prev4\
    \ = 0;\n    let mut vowels_encoded_count_prev5 = 0;\n    let mut vowels_encoded_count_prev6\
    \ = 0;\n    let mut vowels_encoded_count_prev7 = 0;\n    let mut vowels_encoded_count_prev8\
    \ = 0;\n    let mut vowels_encoded_count_prev9 = 0;\n    let mut vowels_encoded_count_prev10\
    \ = 0;\n    let mut vowels_encoded_count_prev11 = 0;\n    let mut vowels_encoded_count_prev12\
    \ = 0;\n    let mut vowels_encoded_count_prev13 = 0;\n    let mut vowels_encoded_count_prev14\
    \ = 0;\n    let mut vowels_encoded_count_prev15 = 0;\n    let mut vowels_encoded_count_prev16\
    \ = 0;\n    let mut vowels_encoded_count_prev17 = 0;\n    let mut vowels_encoded_count_prev18\
    \ = 0;\n    let mut vowels_encoded_count_prev19 = 0;\n    let mut vowels_encoded_count_prev20\
    \ = 0;\n    let mut vowels_encoded_count_prev21 = 0;\n    let mut vowels_encoded_count_prev22\
    \ = 0;\n    let mut vowels_encoded_count_prev23 = 0;\n    let mut vowels_encoded_count_prev24\
    \ = 0;\n    let mut vowels_encoded_count_prev25 = 0;\n    let mut vowels_encoded_count_prev26\
    \ = 0;\n    let mut vowels_encoded_count_prev27 = 0;\n    let mut vowels_encoded_count_prev28\
    \ = 0;\n    let mut vowels_encoded_count_prev29 = 0;\n    let mut vowels_encoded_count_prev30\
    \ = 0;\n    let mut vowels_encoded_count_prev31 = 0;\n    let mut vowels_encoded_count_prev32\
    \ = 0;\n    let mut vowels_encoded_count_prev33 = 0;\n    let mut vowels_encoded_count_prev34\
    \ = 0;\n    let mut vowels_encoded_count_prev35 = 0;\n    let mut vowels_encoded_count_prev36\
    \ = 0;\n    let mut vowels_encoded_count_prev37 = 0;\n    let mut vowels_encoded_count_prev38\
    \ = 0;\n    let mut vowels_encoded_count_prev39 = 0;\n    let mut vowels_\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7wcnug_4.rs:55:20\n   |\n\
    55 |     let mut vowels_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp7wcnug_4.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp7wcnug_4.rs:14:30\n   |\n14 |     let mut vowels_encoded = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7wcnug_4.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7wcnug_4.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7wcnug_4.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7wcnug_4.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7wcnug_4.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7wcnug_4.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7wcnug_4.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this sc"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    for letter in message.chars() {\n        if vowels.contains(&letter) {\n\
    \            result.push(*letter);\n        } else {\n            result.push(*letter);\n\
    \            result.push(*vowels.entry(letter - 'a').or_insert(String::from('a')));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9vstaqo9.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9vstaqo9.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9vstaqo9.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9vstaqo9.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9vstaqo9.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9vstaqo9.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9vstaqo9.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9vstaqo9.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9vstaqo9.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9vstaqo9.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9vstaqo9.rs:37:25\n   |\n37 |     asser"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_lowercase() {\n            letters.insert(c);\n        } else {\n\
    \            vowels.insert(c);\n        }\n    }\n    for c in letters.iter()\
    \ {\n        result.push((c + &vowels[c - &letters.first()]).to_string());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmptpqrii84.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmptpqrii84.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmptpqrii84.rs:30:17\n   |\n30 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptpqrii84.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptpqrii84.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptpqrii84.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptpqrii84.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptpqrii84.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptpqrii84.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptpqrii84.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_pairs = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter = String::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mut letter_pair = HashSet::new();\n\
    \    let mut letter_pair = HashSet::new();\n    let mu\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpxx657mdv.rs:55:11\n   |\n\
    55 |     let mu\n   |           ^ help: add `;` here\n56 | }\n   | - unexpected\
    \ token\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n\
    \  --> /tmp/tmpxx657mdv.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:14:28\n\
    \   |\n14 |     let mut letter_pairs = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:15:27\n\
    \   |\n15 |     let mut letter_pair = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:17:27\n\
    \   |\n17 |     let mut letter_pair = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:18:27\n\
    \   |\n18 |     let mut letter_pair = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:19:27\n\
    \   |\n19 |     let mut letter_pair = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpxx657mdv.rs:"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[index % letters.len()]);\n  \
    \          result.push_str(&vowels[index % vowels.len()]);\n            index\
    \ += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpbls68e1v.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbls68e1v.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpbls68e1v.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpbls68e1v.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpbls68e1v.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpbls68e1v.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpbls68e1v.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpbls68e1v.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpbls68e1v.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpbls68e1v.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbls68e1v.rs:20:29\n   |\n20 |             result.push_str(&letters[index\
    \ % letters.len()]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\"\
    ;\n    let mut letters_index = -1;\n    let mut vowel_letters = String::new();\n\
    \    let mut vowel_letters_index = -1;\n    let mut vowel_letters_index2 = -1;\n\
    \    let mut vowel_letters_index3 = -1;\n    let mut vowel_letters_index4 = -1;\n\
    \    let mut vowel_letters_index5 = -1;\n    let mut vowel_letters_index6 = -1;\n\
    \    let mut vowel_letters_index7 = -1;\n    let mut vowel_letters_index8 = -1;\n\
    \    let mut vowel_letters_index9 = -1;\n    let mut vowel_letters_index10 = -1;\n\
    \    let mut vowel_letters_index11 = -1;\n    let mut vowel_letters_index12 =\
    \ -1;\n    let mut vowel_letters_index13 = -1;\n    let mut vowel_letters_index14\
    \ = -1;\n    let mut vowel_letters_index15 = -1;\n    let mut vowel_letters_index16\
    \ = -1;\n    let mut vowel_letters_index17 = -1;\n    let mut vowel_letters_index18\
    \ = -1;\n    let mut vowel_letters_index19 = -1;\n    let mut vowel_letters_index20\
    \ = -1;\n    let mut vowel_letters_index21 = -1;\n    let mut vowel_letters_index22\
    \ = -1;\n    let mut vowel_letters_index23 = -1;\n    let mut vowel_letters_index24\
    \ = -1;\n    let mut vowel_letters_index25 = -1;\n    let mut vowel_letters_index26\
    \ = -1;\n    let mut vowel_letters_index27 = -1;\n    let mut vowel_letters_index28\
    \ = -1;\n    let mut vowel_letters_index29 = -1;\n    let mut vowel_letters_index30\
    \ = -1;\n    let mut vowel_letters_index31 = -1;\n    let mut vowel_letters_index32\
    \ = -1;\n    let mut vowel_letters_index33 = -1;\n    let mut vowel_letters_index34\
    \ = -1;\n    let mut vowel_letters_index35 = -1;\n    let mut vowel_letters_index36\
    \ = -1;\n    let mut vowel_letters_index37 = -1;\n    let mut vowel_letters_index38\
    \ = -1;\n    let mut vowel_\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpwc0k831z.rs:56:19\n   |\n\
    56 |     let mut vowel_\n   |                   ^ help: add `;` here\n57 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwc0k831z.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwc0k831z.rs:61:25\n   |\n61 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwc0k831z.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwc0k831z.rs:62:25\n   |\n62 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwc0k831z.rs:63:17\n  \
    \ |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwc0k831z.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpwc0k831z.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwc0k831z.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwc0k831z.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwc0k831z.rs:65:25\n   |\n65 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tm"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx2 = 0;\n    let mut letters_idx2 = 0;\n\
    \    let mut vowels_idx3 = 0;\n    let mut letters_idx3 = 0;\n    let mut vowels_idx4\
    \ = 0;\n    let mut letters_idx4 = 0;\n    let mut vowels_idx5 = 0;\n    let mut\
    \ letters_idx5 = 0;\n    let mut vowels_idx6 = 0;\n    let mut letters_idx6 =\
    \ 0;\n    let mut vowels_idx7 = 0;\n    let mut letters_idx7 = 0;\n    let mut\
    \ vowels_idx8 = 0;\n    let mut letters_idx8 = 0;\n    let mut vowels_idx9 = 0;\n\
    \    let mut letters_idx9 = 0;\n    let mut vowels_idx10 = 0;\n    let mut letters_idx10\
    \ = 0;\n    let mut vowels_idx11 = 0;\n    let mut letters_idx11 = 0;\n    let\
    \ mut vowels_idx12 = 0;\n    let mut letters_idx12 = 0;\n    let mut vowels_idx13\
    \ = 0;\n    let mut letters_idx13 = 0;\n    let mut vowels_idx14 = 0;\n    let\
    \ mut letters_idx14 = 0;\n    let mut vowels_idx15 = 0;\n    let mut letters_idx15\
    \ = 0;\n    let mut vowels_idx16 = 0;\n    let mut letters_idx16 = 0;\n    let\
    \ mut vowels_idx17 = 0;\n    let mut letters_idx17 = 0;\n    let mut vowels_idx18\
    \ = 0;\n    let mut letters_idx18 = 0;\n    let mut vowels_idx19 = 0;\n    let\
    \ mut letters_idx19 = 0;\n    let mut vowels_idx20 = 0;\n    let mut letters_idx20\
    \ = 0;\n    let mut vowels_idx21 = 0;\n    let mut letters_idx21 = 0;\n    let\
    \ mut vowels_idx22 = 0;\n    let mut letters_idx22 = 0;\n    let mut vowels_idx23\
    \ = 0;\n    let mut letters_idx23 = 0;\n    let mut vowels_idx24 = 0;\n    let\
    \ mut letters_idx24 = 0;\n    let mut vowels_idx25 = 0;\n    let mut letters_idx25\
    \ = 0;\n    let mut vowels_idx26 = 0;\n    let mut letters_idx26 = 0;\n    let\
    \ mut vowels_idx27 = 0;\n    let mut letters_idx27 = 0;\n    let mut vowels_\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpka6aonru.rs:69:20\n   |\n\
    69 |     let mut vowels_\n   |                    ^ help: add `;` here\n70 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpka6aonru.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpka6aonru.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:74:17\n  \
    \ |\n74 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:74:25\n   |\n74 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpka6aonru.rs:75:17\n   |\n75 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:75:25\n\
    \   |\n75 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpka6aonru.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpka6aonru.rs:76:25\n   |\n76 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpka6aonru.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E04"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut i = 0;\n    while i < message.len() {\n        if message[i] == '\
    \ ' {\n            result.push_str(&message[..i]);\n            i += 1;\n    \
    \        continue;\n        }\n        if message[i] in vowels {\n           \
    \ result.push_str(&message[..i]);\n            result.push_str(&letters[index\
    \ % letters.len()]);\n            i += 1;\n            index %= letters.len();\n\
    \            continue;\n        }\n        result.push_str(&message[..i]);\n \
    \       result.push_str(&letters[index % letters.len()]);\n        i += 1;\n \
    \       index %= letters.len();\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp2fr3eklc.rs:23:23\n\
    \   |\n23 |         if message[i] in vowels {\n   |         --            ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2fr3eklc.rs:40:17\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2fr3eklc.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2fr3eklc.rs:41:17\n   |\n41 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2fr3eklc.rs:41:25\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2fr3eklc.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2fr3eklc.rs:42:25\n   |\n42 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2fr3eklc.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp2fr3eklc.rs:43:25\n   |\n43 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp2fr3eklc.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2fr3eklc.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut next_letter = String::new();\n    let mut next_letter_2 = String::new();\n\
    \    \n    for letter in message.chars() {\n        if letter == ' ' {\n     \
    \       result.push_str(\" \");\n        } else {\n            if index == 0 {\n\
    \                result.push_str(&vowels[vowels.len() - 1]);\n            } else\
    \ {\n                result.push_str(&vowels[vowels.len() - 2]);\n           \
    \ }\n            result.push_str(&letter);\n        }\n        index += 1;\n \
    \   }\n    \n    for letter in result.chars() {\n        if letter == ' ' {\n\
    \            result.push_str(\" \");\n        } else {\n            if letter\
    \ == vowels[vowels.len() - 1] {\n                next_letter = String::new();\n\
    \                next_letter_2 = String::new();\n                let mut index\
    \ = 0;\n                for letter in message.chars() {\n                    if\
    \ letter == ' ' {\n                        result.push_str(\" \");\n         \
    \           } else {\n                        if index == 0 {\n              \
    \              next_letter.push_str(&vowels[vowels.len() - 1]);\n            \
    \            } else {\n                            next_letter.push_str(&vowels[vowels.len()\
    \ - 2]);\n                        }\n                        next_letter.push_str(&letter);\n\
    \                        index += 1;\n                    }\n                }\n\
    \                \n                for letter in next_letter.chars() {\n     \
    \               if letter == ' ' {\n                        result.push_str(\"\
    \ \");\n                    } else {\n                        if letter == vowels[vowels.len()\
    \ - 1] {\n                            next_letter_2.push_str(&vowels[vowels.len()\
    \ - 2]);\n                        } else {\n                            next_letter_2.push_str(&letter);\n\
    \                        }\n                        result.push_str(&next_letter_2);\n\
    \                    }\n                }\n            } else {\n            \
    \    result.push_str(&letter);\n            }\n        }\n    }\n    \n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4_xkbu12.rs:78:17\n\
    \   |\n78 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4_xkbu12.rs:78:25\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4_xkbu12.rs:79:17\n   |\n79 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4_xkbu12.rs:79:25\n\
    \   |\n79 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4_xkbu12.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4_xkbu12.rs:80:25\n   |\n80 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4_xkbu12.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4_xkbu12.rs:81:25\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4_xkbu12.rs:82:17\n  \
    \ |\n82 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4_xkbu12.rs:82:25\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp4_xkbu12.rs:24:34\n   |\n\
    24 |                 result.push_str(&vowels[vowels.len() - 1]);\n   |       \
    \                           ^^^^^^^"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowel_map = HashMap::new();\n    for letter in vowels.chars()\
    \ {\n        vowel_map.insert(letter, vowels.chars().next().unwrap());\n    }\n\
    \    for letter in message.chars() {\n        if let Some(vowel) = vowel_map.get(&letter)\
    \ {\n            result.push(*vowel);\n            result.push(*vowel);\n    \
    \    } else {\n            result.push(*letter);\n            result.push(*letter);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp7yli_xy5.rs:14:25\n   |\n14 |     let mut vowel_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7yli_xy5.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7yli_xy5.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7yli_xy5.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7yli_xy5.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7yli_xy5.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7yli_xy5.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7yli_xy5.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7yli_xy5.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7yli_xy5.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7yli_xy5.rs:36:25\n   |\n36 |    "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_2 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_4 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_5 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_6 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_7 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_8 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_9 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_10 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_11 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_13 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_14 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_15 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_16 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_17 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_18 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_19 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_20 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_21 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_22 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_23 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_24 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_25 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_26 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_27 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_28 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_29 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_30 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowels_index_31 = vec![0, 1, 2, 3, 4];\n    let mut\
    \ vowels_index_32 = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_33 = vec![0,\
    \ 1, 2, 3, 4];\n    let mut vowel\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpc6qbgv4j.rs:47:18\n   |\n\
    47 |     let mut vowel\n   |                  ^ help: add `;` here\n48 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpc6qbgv4j.rs:52:17\n   |\n52 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:52:25\n   |\n52 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpc6qbgv4j.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:53:25\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:54:17\n  \
    \ |\n54 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpc6qbgv4j.rs:54:25\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:55:17\n   |\n55 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:55:25\n\
    \   |\n55 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpc6qbgv4j.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpc6qbgv4j.rs:56:25\n   |\n56 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_2places = HashSet::new();\n    let mut vowels_3places = HashSet::new();\n\
    \    let mut vowels_4places = HashSet::new();\n    let mut vowels_5places = HashSet::new();\n\
    \    let mut vowels_6places = HashSet::new();\n    let mut vowels_7places = HashSet::new();\n\
    \    let mut vowels_8places = HashSet::new();\n    let mut vowels_9places = HashSet::new();\n\
    \    let mut vowels_10places = HashSet::new();\n    let mut vowels_11places =\
    \ HashSet::new();\n    let mut vowels_12places = HashSet::new();\n    let mut\
    \ vowels_13places = HashSet::new();\n    let mut vowels_14places = HashSet::new();\n\
    \    let mut vowels_15places = HashSet::new();\n    let mut vowels_16places =\
    \ HashSet::new();\n    let mut vowels_17places = HashSet::new();\n    let mut\
    \ vowels_18places = HashSet::new();\n    let mut vowels_19places = HashSet::new();\n\
    \    let mut vowels_20places = HashSet::new();\n    let mut vowels_21places =\
    \ HashSet::new();\n    let mut vowels_22places = HashSet::new();\n    let mut\
    \ vowels_23places = HashSet::new();\n    let mut vowels_24places = HashSet::new();\n\
    \    let mut vowels_25places = HashSet::new();\n    let mut vowels_26places =\
    \ HashSet::new();\n    let mut vowels_27places = HashSet::new();\n    let mut\
    \ vowels_28places = HashSet::new();\n    let mut vowels_29places = HashSet::new();\n\
    \    let mut vowels_30places = HashSet::new();\n    let mut vowels_31places =\
    \ HashSet::new();\n    let mut vowels_32places = HashSet::new();\n    let mut\
    \ vowels_33places = HashSet::new();\n    let mut vowels_34places = HashSet::new();\n\
    \    let mut vowels_35places = HashSet::new();\n    let mut vowels_36places =\
    \ HashSet::new();\n    let \n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp0fxjb8im.rs:50:1\n  \
    \ |\n50 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmp0fxjb8im.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:14:30\n   |\n14 |     let mut vowels_2places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:15:30\n   |\n15 |     let mut vowels_3places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:16:30\n   |\n16 |     let mut vowels_4places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:17:30\n   |\n17 |     let mut vowels_5places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:18:30\n   |\n18 |     let mut vowels_6places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp0fxjb8im.rs:19:30\n   |\n19 |     l"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_2 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_3 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_4 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_5 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_6 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_7 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_8 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_9 = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_10 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_11 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut vowels_index_12 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp_j7blrh7.rs:26:1\n   |\n26 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp_j7blrh7.rs:25:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n25 |     let mut vowels_index_12 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n26 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:17\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:30:25\n \
    \  |\n30 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_j7blrh7.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:31:25\n   |\n31 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_j7blrh7.rs:32:25\n   |\n32 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_j7blrh7.rs:33:17\n  \
    \ |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_j7blrh7.rs:33:25\n   |\n33 |     assert_eq!({left}, {right}"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut count = 1;\n    let mut current_letter = String::new();\n    let\
    \ mut current_vowel = String::new();\n    let mut current_letter_index = -1;\n\
    \    let mut current_vowel_index = -1;\n    \n    for letter in message {\n  \
    \      if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == letters.len() - 1 {\n                result.push_str(letter);\n\
    \            } else {\n                if letter == letters.len() - 2 {\n    \
    \                result.push_str(letters[letters.len() - 2]);\n              \
    \  } else {\n                    if letter == letters.len() - 3 {\n          \
    \              result.push_str(letters[letters.len() - 3]);\n                \
    \    } else {\n                        if letter == letters.len() - 4 {\n    \
    \                        result.push_str(letters[letters.len() - 4]);\n      \
    \                  } else {\n                            if letter == letters.len()\
    \ - 5 {\n                                result.push_str(letters[letters.len()\
    \ - 5]);\n                            } else {\n                             \
    \   if letter == letters.len() - 6 {\n                                    result.push_str(letters[letters.len()\
    \ - 6]);\n                                } else {\n                         \
    \           if letter == letters.len() - 7 {\n                               \
    \         result.push_str(letters[letters.len() - 7]);\n                     \
    \               } else {\n                                        if letter ==\
    \ letters.len() - 8 {\n                                            result.push_str(letters[letters.len()\
    \ - 8]);\n                                        } else {\n                 \
    \                           if letter == letters.len() - 9 {\n               \
    \                                 result.push_str(letters[letters.len() - 9]);\n\
    \                                            } else {\n                      \
    \                          if letter == letters.len() - 10 {\n               \
    \                                     result.push_str(letters[letters.len() -\
    \ 10]);\n                                                } else {\n          \
    \                                          if letter == letters.len() - 11 {\n\
    \                                                        result.push_str(letters[letters.len()\
    \ - 11]);\n                                                    } else {\n    \
    \                                                    if letter == letters.len()\
    \ - 12 {\n                                                            result.push_str(letters[letters.len()\
    \ - 12]);\n                                                        } else {\n\
    \                                                            if letter == letters.len()\
    \ - 13 {\n                                                                result.push_str(letters[letters.len()\
    \ - 13]);\n                                                            } else\
    \ {\n                                                                if letter\
    \ == letters.len() - 14 {\n                                                  \
    \                  result.push_str(letters[letters.len() - 14]);\n           \
    \                                                     } else {\n             \
    \                                                       if letter == letters.len(\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpzrwni69i.rs:78:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n22 |     for letter in message {\n\
    \   |                           - unclosed delimiter\n...\n25 |         } else\
    \ {\n   |                - unclosed delimiter\n...\n28 |             } else {\n\
    \   |                    - unclosed delimiter\n...\n31 |                 } else\
    \ {\n   |                        - unclosed delimiter\n...\n34 |             \
    \        } else {\n   |                            - unclosed delimiter\n...\n\
    37 |                         } else {\n   |                                - unclosed\
    \ delimiter\n...\n40 |                             } else {\n   |            \
    \                        - unclosed delimiter\n...\n43 |                     \
    \            } else {\n   |                                        - unclosed\
    \ delimiter\n...\n46 |                                     } else {\n   |    \
    \                                        - unclosed delimiter\n...\n49 |     \
    \                                    } else {\n   |                          \
    \                      - unclosed delimiter\n...\n52 |                       \
    \                      } else {\n   |                                        \
    \            - unclosed delimiter\n...\n55 |                                 \
    \                } else {\n   |                                              \
    \          - unclosed delimiter\n...\n58 |                                   \
    \                  } else {\n   |                                            \
    \                - unclosed delimiter\n...\n61 |                             \
    \                            } else {\n   |                                  \
    \                              - unclosed delimiter\n...\n64 |               \
    \                                              } else {\n   |                \
    \                                                    - unclosed delimiter\n...\n\
    67 |                                                                 } else {\n\
    \   |                "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\
    \ 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\
    \ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,\
    \ 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,\
    \ 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87,\
    \ 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut letter_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\
    \ 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\
    \ 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,\
    \ 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,\
    \ 96, 97, 98, 99];\n    let mut letter_count_index2 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpul6i6nif.rs:18:1\n   |\n18 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpul6i6nif.rs:17:39\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n17 |     let mut letter_count_index2 = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26, ...\n   |                                       ^ unclosed delimiter\n18\
    \ | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value\
    \ `left` in this scope\n  --> /tmp/tmpul6i6nif.rs:22:17\n   |\n22 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpul6i6nif.rs:22:25\n \
    \  |\n22 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpul6i6nif.rs:23:17\n   |\n23 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpul6i6nif.rs:23:25\n   |\n23 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpul6i6nif.rs:24:17\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpul6i6nif.rs:24:25\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpul6i6nif.rs:25:17\n  \
    \ |\n25 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpul6i6nif.rs:25:25\n   |\n25 |     assert_eq!({left}, {ri"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashMap::new();\n\
    \    vowels.insert(String::from(\"a\"), String::from(\"A\"));\n    vowels.insert(String::from(\"\
    e\"), String::from(\"E\"));\n    vowels.insert(String::from(\"i\"), String::from(\"\
    I\"));\n    vowels.insert(String::from(\"o\"), String::from(\"O\"));\n    vowels.insert(String::from(\"\
    u\"), String::from(\"U\"));\n    vowels.insert(String::from(\"y\"), String::from(\"\
    Y\"));\n    vowels.insert(String::from(\"A\"), String::from(\"a\"));\n    vowels.insert(String::from(\"\
    E\"), String::from(\"e\"));\n    vowels.insert(String::from(\"I\"), String::from(\"\
    i\"));\n    vowels.insert(String::from(\"O\"), String::from(\"o\"));\n    vowels.insert(String::from(\"\
    U\"), String::from(\"u\"));\n    vowels.insert(String::from(\"Y\"), String::from(\"\
    y\"));\n    for letter in message.chars() {\n        let mut new_letter = letter;\n\
    \        let mut new_vowel = String::new();\n        if let Some(vowel) = vowels.get(&letter)\
    \ {\n            new_vowel = vowel;\n            new_letter = vowels.get(&new_letter).unwrap();\n\
    \        }\n        result.push_str(&new_letter);\n        result.push_str(&new_vowel);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqvevpz_1.rs:13:22\n   |\n13 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqvevpz_1.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqvevpz_1.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqvevpz_1.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqvevpz_1.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqvevpz_1.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqvevpz_1.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqvevpz_1.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqvevpz_1.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqvevpz_1.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqvevpz_1.rs:45:25\n   |\n45 |     asser"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    for ch in message {\n        if !vowels.contains(&ch)\
    \ {\n            result.push((&message[index..index+2]).to_ascii_lowercase());\n\
    \            result.push(ch);\n            index += 2;\n        } else {\n   \
    \         result.push(ch);\n            index += 1;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmmmvxu_2.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmmmvxu_2.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmmmvxu_2.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmmmvxu_2.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmmmvxu_2.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpmmmvxu_2.rs:15:15\n    |\n15  |     for ch\
    \ in message {\n    |               ^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded1 = HashSet::new();\n\
    \    let mut vowels_encoded2 = HashSet::new();\n    let mut vowels_encoded3 =\
    \ HashSet::new();\n    let mut vowels_encoded4 = HashSet::new();\n    let mut\
    \ vowels_encoded5 = HashSet::new();\n    let mut vowels_encoded6 = HashSet::new();\n\
    \    let mut vowels_encoded7 = HashSet::new();\n    let mut vowels_encoded8 =\
    \ HashSet::new();\n    let mut vowels_encoded9 = HashSet::new();\n    let mut\
    \ vowels_encoded10 = HashSet::new();\n    let mut vowels_encoded11 = HashSet::new();\n\
    \    let mut vowels_encoded12 = HashSet::new();\n    let mut vowels_encoded13\
    \ = HashSet::new();\n    let mut vowels_encoded14 = HashSet::new();\n    let mut\
    \ vowels_encoded15 = HashSet::new();\n    let mut vowels_encoded16 = HashSet::new();\n\
    \    let mut vowels_encoded17 = HashSet::new();\n    let mut vowels_encoded18\
    \ = HashSet::new();\n    let mut vowels_encoded19 = HashSet::new();\n    let mut\
    \ vowels_encoded20 = HashSet::new();\n    let mut vowels_encoded21 = HashSet::new();\n\
    \    let mut vowels_encoded22 = HashSet::new();\n    let mut vowels_encoded23\
    \ = HashSet::new();\n    let mut vowels_encoded24 = HashSet::new();\n    let mut\
    \ vowels_encoded25 = HashSet::new();\n    let mut vowels_encoded26 = HashSet::new();\n\
    \    let mut vowels_encoded27 = HashSet::new();\n    let mut vowels_encoded28\
    \ = HashSet::new();\n    let mut vowels_encoded29 = HashSet::new();\n    let mut\
    \ vowels_encoded30 = HashSet::new();\n    let mut vowels_encoded31 = HashSet::new();\n\
    \    let mut vowels_encoded32 = HashSet::new();\n    let mut vowels_encoded33\
    \ = HashSet::new();\n    let mut vowels_encoded34 = HashSet::new();\n    let mut\
    \ vowels_encoded35 = HashSet::new();\n\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpn36ub8ns.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:14:30\n\
    \   |\n14 |     let mut vowels_encoded = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:15:31\n\
    \   |\n15 |     let mut vowels_encoded1 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:16:31\n\
    \   |\n16 |     let mut vowels_encoded2 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:17:31\n\
    \   |\n17 |     let mut vowels_encoded3 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:18:31\n\
    \   |\n18 |     let mut vowels_encoded4 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpn36ub8ns.rs:19:31\n\
    \   |\n19 |     let mut vowels_encoded5 = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found i"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut index2\
    \ = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 =\
    \ 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n\
    \    let mut index9 = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n\
    \    let mut index12 = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n\
    \    let mut index15 = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n\
    \    let mut index18 = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n\
    \    let mut index21 = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n\
    \    let mut index24 = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n\
    \    let mut index27 = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n\
    \    let mut index30 = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n\
    \    let mut index33 = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n\
    \    let mut index36 = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n\
    \    let mut index39 = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n\
    \    let mut index42 = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n\
    \    let mut index45 = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n\
    \    let mut index48 = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n\
    \    let mut index51 = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n\
    \    let mut index54 = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n\
    \    let mut index57 = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n\
    \    let mut index60 = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n\
    \    let mut index63 = 0;\n    let mut index64 = 0;\n    let mut index65 = 0;\n\
    \    let mut index66 = 0;\n    let mut index67 = 0;\n    let mut index68 = 0;\n\
    \    let mut index69 = 0;\n    let mut index\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpou3q6837.rs:84:18\n   |\n\
    84 |     let mut index\n   |                  ^ help: add `;` here\n85 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpou3q6837.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpou3q6837.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpou3q6837.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpou3q6837.rs:90:25\n   |\n90 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpou3q6837.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpou3q6837.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpou3q6837.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpou3q6837.rs:92:25\n\
    \   |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpou3q6837.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpou3q6837.rs:93:25\n   |\n93 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if letter\
    \ in vowels {\n            result.push(*letters.iter().position(|x| x == letter).unwrap());\n\
    \        } else {\n            result.push(*letters.iter().position(|x| x == letter\
    \ + 1).unwrap());\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpcotr1zm5.rs:16:19\n\
    \   |\n16 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpcotr1zm5.rs:27:17\n\
    \   |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcotr1zm5.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcotr1zm5.rs:28:17\n   |\n28 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpcotr1zm5.rs:28:25\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcotr1zm5.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcotr1zm5.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcotr1zm5.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcotr1zm5.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcotr1zm5.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcotr1zm5.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter_counter\
    \ < 2 {\n                result.push_str(&letters[letter_counter]);\n        \
    \        letter_counter += 1;\n            } else {\n                result.push_str(&letters[letter_counter\
    \ - 2]);\n                letter_counter += 1;\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmqticb78.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmqticb78.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmqticb78.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmqticb78.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmqticb78.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmqticb78.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmqticb78.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmqticb78.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmqticb78.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmqticb78.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmqticb78.rs:22:33\n   |\n22 |                 result.push_str(&letters[letter_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for letter in message.chars() {\n\
    \        if letter.is_lowercase() {\n            letters.insert(letter);\n   \
    \     }\n    }\n    for vowel in vowels.keys() {\n        let mut vowel_letters\
    \ = HashSet::new();\n        for letter in vowels.keys() {\n            if letter\
    \ == vowel {\n                vowel_letters.insert(letter);\n            }\n \
    \       }\n        let mut letter_letters = HashSet::new();\n        for letter\
    \ in letters.keys() {\n            if letter == vowel {\n                letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letters = HashSet::new();\n\
    \        for letter in letter_letters.keys() {\n            if letter == vowel\
    \ {\n                letter_letter_letters.insert(letter);\n            }\n  \
    \      }\n        let mut letter_letter_letter_letters = HashSet::new();\n   \
    \     for letter in letter_letter_letters.keys() {\n            if letter == vowel\
    \ {\n                letter_letter_letter_letters.insert(letter);\n          \
    \  }\n        }\n        let mut letter_letter_letter_letter_letters = HashSet::new();\n\
    \        for letter in letter_letter_letter_letter_letters.keys() {\n        \
    \    if letter == vowel {\n                letter_letter_letter_letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letter_letter_letter_letters\
    \ = HashSet::new();\n        for letter in letter_letter_letter_letter_letter_letters.keys()\
    \ {\n            if letter == vowel {\n                letter_letter_letter_letter_letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letter_letter_letter_letter_letters\
    \ = HashSet::new();\n        for letter in letter_letter_letter_letter_letter_letter_letters.keys()\
    \ {\n            if letter == vowel {\n                letter_letter_letter_letter_letter_letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letter_letter_letter_letter_letters\
    \ = HashSet::new();\n        for letter in letter_letter_letter_letter_letter_letter_letters.keys()\
    \ {\n            if letter == vowel {\n                letter_letter_letter_letter_letter_letter_letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letter_letter_letter_letter_letter_letters\
    \ = HashSet::new();\n        for letter in letter_letter_letter_letter_letter_letter_letter_letters.keys()\
    \ {\n            if letter == vowel {\n                letter_letter_letter_letter_letter_letter_letter_letter_letters.insert(letter);\n\
    \            }\n        }\n        let mut letter_letter_letter_letter_letter_letter_letter_letter_letters\
    \ = HashSet::new();\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx12mgr96.rs:86:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n20 |     for vowel in vowels.keys()\
    \ {\n   |                                - this delimiter might not be properly\
    \ closed...\n...\n77 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n86 | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmpx12mgr96.rs:13:22\n   |\n13 |     let mut vowels =\
    \ HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpx12mgr96.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpx12mgr96.rs:21:33\n\
    \   |\n21 |         let mut vowel_letters = HashSet::new();\n   |            \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpx12mgr96.rs:27:34\n\
    \   |\n27 |         let mut letter_letters = HashSet::new();\n   |           \
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpx12mgr96.rs:33:41\n\
    \   |\n33 |         let mut letter_letter_letters = HashSet::new();\n   |    \
    \                                     ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpx12mgr96.r"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letter_counter = vec!['Z', 'Y', 'X', 'W',\
    \ 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q',\
    \ 'P', 'O', 'I', 'T', 'N', 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V',\
    \ 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P',\
    \ 'O', 'I', 'T', 'N', 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U',\
    \ 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O',\
    \ 'I', 'T', 'N', 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T',\
    \ 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I',\
    \ 'T', 'N', 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T', 'S',\
    \ 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I', 'T',\
    \ 'N', 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R',\
    \ 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I', 'T', 'N',\
    \ 'K', 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D',\
    \ 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I', 'T', 'N', 'K',\
    \ 'J', 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F',\
    \ 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I', 'T', 'N', 'K', 'J',\
    \ 'I', 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U', 'T', 'S', 'R', 'D', 'F', 'G',\
    \ 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P', 'O', 'I', 'T', 'N', 'K', 'J', 'I',\
    \ 'S', 'Q', 'R', 'U', 'Y', 'W', 'X', 'V', 'U\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp91ejiacj.rs:15:1\n   |\n15 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp91ejiacj.rs:14:34\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n14 |     let mut letter_counter = vec!['Z', 'Y', 'X', 'W', 'V',\
    \ 'U', 'T', 'S', 'R', 'D', 'F', 'G', 'H', 'J', 'K', 'M', 'B', 'N', 'L', 'Q', 'P'...\n\
    \   |                                  ^ unclosed delimiter\n15 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp91ejiacj.rs:19:17\n   |\n19 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp91ejiacj.rs:19:25\n   |\n19 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp91ejiacj.rs:20:17\n   |\n20 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp91ejiacj.rs:20:25\n   |\n20 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp91ejiacj.rs:21:17\n  \
    \ |\n21 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp91ejiacj.rs:21:25\n   |\n21 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp91ejiacj.rs:22:17\n   |\n22 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp91ejiacj.rs:22:25\n\
    \   |\n22 |     assert_eq!({left}, {right})"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let\
    \ mut letter_counter3 = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5\
    \ = 0;\n    let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n \
    \   let mut letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut\
    \ letter_counter10 = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12\
    \ = 0;\n    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n\
    \    let mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let\
    \ mut letter_counter17 = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19\
    \ = 0;\n    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n\
    \    let mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let\
    \ mut letter_counter24 = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26\
    \ = 0;\n    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n\
    \    let mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let\
    \ mut letter_counter31 = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33\
    \ = 0;\n    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n\
    \    let mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let\
    \ mut letter_counter38 = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40\
    \ = 0;\n    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n\
    \    let mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let\
    \ mut letter_counter45 = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47\
    \ = 0;\n    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n\
    \    let mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let\
    \ mut letter_counter52 = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54\
    \ = 0;\n    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n\
    \    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpngmfu4d6.rs:72:1\n  \
    \ |\n72 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpngmfu4d6.rs:76:17\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpngmfu4d6.rs:76:25\n \
    \  |\n76 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpngmfu4d6.rs:77:17\n   |\n77 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpngmfu4d6.rs:77:25\n   |\n77 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpngmfu4d6.rs:78:17\n   |\n78 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpngmfu4d6.rs:78:25\n   |\n78 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpngmfu4d6.rs:79:17\n  \
    \ |\n79 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpngmfu4d6.rs:79:25\n   |\n79 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpngmfu4d6.rs:80:17\n   |\n80 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpngmfu4d6.rs:80:25\n\
    \   |\n80 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut current_letter = String::new();\n    let mut current_vowel = String::new();\n\
    \    for letter in message {\n        if letter == ' ' {\n            result.push_str(current_letter);\n\
    \            current_letter = String::new();\n        } else {\n            current_letter.push_str(letter);\n\
    \        }\n        if vowels.contains(&letter) {\n            for vowel in vowels\
    \ {\n                if vowels_index[vowel] == vowels_index.len() - 1 {\n    \
    \                current_vowel.push_str(vowel);\n                    vowels_index[vowel]\
    \ = vowels_index.len() - 2;\n                } else {\n                    current_vowel.push_str(vowel);\n\
    \                    vowels_index[vowel] = vowels_index[vowel] + 1;\n        \
    \        }\n            }\n            result.push_str(current_vowel);\n     \
    \       current_vowel = String::new();\n        }\n    }\n    result.push_str(current_vowel);\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxok_eil7.rs:44:17\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxok_eil7.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxok_eil7.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxok_eil7.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxok_eil7.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxok_eil7.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxok_eil7.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxok_eil7.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxok_eil7.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxok_eil7.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpxok_eil7.rs:17:19\n    |\n17  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpqdmtrywr.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0433]: failed to resolve: use of\
    \ undeclared type `HashSet`\n  --> /tmp/tmpqdmtrywr.rs:13:22\n   |\n13 |     let\
    \ mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpqdmtrywr.rs:81:17\n\
    \   |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpqdmtrywr.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpqdmtrywr.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpqdmtrywr.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpqdmtrywr.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpqdmtrywr.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpqdmtrywr.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpqdmtrywr.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpqdmtrywr.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\ner"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(letter)\
    \ {\n            result.push_str(&vowels[vowel_counter]);\n            vowel_counter\
    \ += 1;\n        } else {\n            result.push_str(&consonants[consonant_counter]);\n\
    \            consonant_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_mmz1wpp.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_mmz1wpp.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_mmz1wpp.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_mmz1wpp.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_mmz1wpp.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_mmz1wpp.rs:18:28\n   |\n18 |         if vowels.contains(letter)\
    \ {\n   |                            ^^^^^^\n   |                            |\n\
    \   |                     "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_map = HashMap::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_map.insert(vowel, vowel);\n\
    \    }\n    let mut vowels_map2 = HashMap::new();\n    for vowel in vowels.iter()\
    \ {\n        vowels_map2.insert(vowel, vowel);\n    }\n    let mut vowels_map3\
    \ = HashMap::new();\n    for vowel in vowels.iter() {\n        vowels_map3.insert(vowel,\
    \ vowel);\n    }\n    let mut vowels_map4 = HashMap::new();\n    for vowel in\
    \ vowels.iter() {\n        vowels_map4.insert(vowel, vowel);\n    }\n    let mut\
    \ vowels_map5 = HashMap::new();\n    for vowel in vowels.iter() {\n        vowels_map5.insert(vowel,\
    \ vowel);\n    }\n    let mut vowels_map6 = HashMap::new();\n    for vowel in\
    \ vowels.iter() {\n        vowels_map6.insert(vowel, vowel);\n    }\n    let mut\
    \ vowels_map7 = HashMap::new();\n    for vowel in vowels.iter() {\n        vowels_map7.insert(vowel,\
    \ vowel);\n    }\n    let mut vowels_map8 = HashMap::new();\n    for vowel in\
    \ vowels.iter() {\n        vowels_map8.insert(vowel, vowel);\n    }\n    let mut\
    \ vowels_map9 = HashMap::new();\n    for vowel in vowels.iter() {\n        vowels_map9.insert(vowel,\
    \ vowel);\n    }\n    let mut vowels_map10 = HashMap::new();\n    for vowel in\
    \ vowels.iter() {\n        vowels_map10.insert(vowel, vowel);\n    }\n    let\
    \ mut vowels_map11 = HashMap::new();\n    for vowel in vowels.iter() {\n     \
    \   vowels_map11.insert(vowel, vowel);\n    }\n    let mut vowels_map12 = HashMap::new();\n\
    \    for vowel in vowels.iter() {\n        vowels_map12.insert(vowel, vowel);\n\
    \    }\n    let mut vowels_map13 = HashMap::new();\n    for vowel in vowels.iter()\
    \ {\n        vowels_map13.insert(vowel, vowel);\n    }\n    let mut vowels_map14\
    \ = HashMap::\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found `}`\n  --> /tmp/tmpsmrtngqu.rs:67:1\n\
    \   |\n67 | }\n   | ^ expected identifier\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:14:26\n   |\n14\
    \ |     let mut vowels_map = HashMap::new();\n   |                          ^^^^^^^\
    \ not found in this scope\n   |\nhelp: consider importing this struct\n   |\n\
    1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:18:27\n   |\n18\
    \ |     let mut vowels_map2 = HashMap::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:22:27\n   |\n22\
    \ |     let mut vowels_map3 = HashMap::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:26:27\n   |\n26\
    \ |     let mut vowels_map4 = HashMap::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:30:27\n   |\n30\
    \ |     let mut vowels_map5 = HashMap::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:34:27\n   |\n34\
    \ |     let mut vowels_map6 = HashMap::new();\n   |                          \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashMap`\n  --> /tmp/tmpsmrtngqu.rs:38:27\n   |\n38\
    \ |     let mut vowels_ma"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter = 0;\n    let mut letters_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter in vowels\
    \ {\n                result.push_str(&vowels[vowels_counter]);\n             \
    \   vowels_counter += 1;\n            } else {\n                let mut letters_counter\
    \ = 0;\n                while letters_counter < letters.len() {\n            \
    \        if letter == letters[letters_counter] {\n                        result.push_str(&letters[letters_counter]);\n\
    \                        letters_counter += 1;\n                    } else {\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp5cpfali9.rs:21:23\n\
    \   |\n21 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5cpfali9.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5cpfali9.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5cpfali9.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5cpfali9.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5cpfali9.rs:44:17\n   |\n44 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5cpfali9.rs:44:25\n\
    \   |\n44 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5cpfali9.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5cpfali9.rs:45:25\n   |\n45 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5cpfali9.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5cpfali9.rs:46:25\n   |\n46 |     assert_eq!({left},\
    \ {right});\n   |                 "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    let mut\
    \ j = 0;\n    let mut k = 0;\n    let mut l = message.len();\n    while i < l\
    \ {\n        if message[i] == ' ' {\n            result.push_str(\" \");\n   \
    \         i += 1;\n        } else {\n            if letters[k] == message[i] {\n\
    \                result.push_str(&vowels[(j + k) % vowels.len()]);\n         \
    \       i += 1;\n                j += 1;\n                k += 1;\n          \
    \  } else {\n                result.push_str(&letters[k]);\n                i\
    \ += 1;\n                j += 1;\n                k += 1;\n            }\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpecyqyoip.rs:42:17\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpecyqyoip.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpecyqyoip.rs:43:17\n   |\n43 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpecyqyoip.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpecyqyoip.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpecyqyoip.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpecyqyoip.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpecyqyoip.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpecyqyoip.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpecyqyoip.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpecyqyoip.rs:20:12\n   |\n\
    20 |         if message[i] == ' ' {\n   |            ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   ="
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            if letter_counter == 2 {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            } else {\n                result.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n                letter_counter += 1;\n \
    \           }\n        } else {\n            result.push_str(&letter);\n     \
    \       letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp76ct6qpy.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp76ct6qpy.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp76ct6qpy.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp76ct6qpy.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp76ct6qpy.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp76ct6qpy.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp76ct6qpy.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp76ct6qpy.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp76ct6qpy.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp76ct6qpy.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp76ct6qpy.rs:19:33\n   |\n19 |                 result.push_str(&vowels[vowel_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, fo"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel.to_string(), vowel);\n    }\n \
    \   for letter in message.chars() {\n        let mut new_letter = letter;\n  \
    \      if let Some(vowel) = vowels_map.get(&new_letter) {\n            new_letter\
    \ = vowel;\n        }\n        result.push(new_letter);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmprk5lndbv.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprk5lndbv.rs:30:17\n  \
    \ |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprk5lndbv.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmprk5lndbv.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmprk5lndbv.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprk5lndbv.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprk5lndbv.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprk5lndbv.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprk5lndbv.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprk5lndbv.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprk5lndbv.rs:34:25\n   |\n34 |  "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if vowels.contains(&letter) {\n \
    \           result.push((letters[vowel_counter] + letters[letter_counter]).to_string());\n\
    \            vowel_counter += 2;\n            letter_counter += 2;\n        }\
    \ else {\n            result.push(letter);\n            vowel_counter += 1;\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpx6bbwazs.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx6bbwazs.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx6bbwazs.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx6bbwazs.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx6bbwazs.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx6bbwazs.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx6bbwazs.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx6bbwazs.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx6bbwazs.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx6bbwazs.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpx6bbwazs.rs:17:19\n    |\n17  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letter_counts = HashMap::new();\n    for letter in message.chars()\
    \ {\n        if let Some(count) = letter_counts.entry(letter).or_insert(0) {\n\
    \            letter_counts.entry(letter).and_modify(|count| count + 1);\n    \
    \    } else {\n            letter_counts.insert(letter, 1);\n        }\n    }\n\
    \    for letter in message.chars() {\n        if let Some(count) = letter_counts.entry(letter).or_insert(0)\
    \ {\n            if count == 2 {\n                vowels.insert(letter);\n   \
    \         }\n        }\n    }\n    for letter in vowels.iter() {\n        let\
    \ mut pos = 0;\n        for letter in message.chars() {\n            if let Some(count)\
    \ = letter_counts.entry(letter).or_insert(0) {\n                if count == 2\
    \ {\n                    result.push_str(&message[pos..]);\n                 \
    \   result.push_str(&letter);\n                    pos = message.len() - 1;\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpeqisea3a.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpeqisea3a.rs:14:29\n\
    \   |\n14 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpeqisea3a.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpeqisea3a.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpeqisea3a.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpeqisea3a.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpeqisea3a.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpeqisea3a.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpeqisea3a.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpeqisea3a.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    while i < message.len() {\n        if let Some(letter) = message.chars().nth(i)\
    \ {\n            if let Some(vowel) = vowels.chars().nth(i) {\n              \
    \  result.push_str(&letters[letters.find(&vowel).unwrap() + 2]);\n           \
    \ } else {\n                result.push_str(&letters[letters.find(&letter).unwrap()]);\n\
    \            }\n            i += 1;\n        } else {\n            i += 1;\n \
    \       }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpl7709uc9.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpl7709uc9.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpl7709uc9.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpl7709uc9.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpl7709uc9.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpl7709uc9.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpl7709uc9.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpl7709uc9.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpl7709uc9.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpl7709uc9.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmpl7709uc9.rs:19:55\n   |\n\
    19 |                 result.push_str(&letters[letters.find(&vowel).unwrap() +\
    \ 2]);\n   |                       "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_seen = HashSet::new();\n    let mut vowels_seen2 = HashSet::new();\n\
    \    let mut vowels_seen3 = HashSet::new();\n    let mut vowels_seen4 = HashSet::new();\n\
    \    let mut vowels_seen5 = HashSet::new();\n    let mut vowels_seen6 = HashSet::new();\n\
    \    let mut vowels_seen7 = HashSet::new();\n    let mut vowels_seen8 = HashSet::new();\n\
    \    let mut vowels_seen9 = HashSet::new();\n    let mut vowels_seen10 = HashSet::new();\n\
    \    let mut vowels_seen11 = HashSet::new();\n    let mut vowels_seen12 = HashSet::new();\n\
    \    let mut vowels_seen13 = HashSet::new();\n    let mut vowels_seen14 = HashSet::new();\n\
    \    let mut vowels_seen15 = HashSet::new();\n    let mut vowels_seen16 = HashSet::new();\n\
    \    let mut vowels_seen17 = HashSet::new();\n    let mut vowels_seen18 = HashSet::new();\n\
    \    let mut vowels_seen19 = HashSet::new();\n    let mut vowels_seen20 = HashSet::new();\n\
    \    let mut vowels_seen21 = HashSet::new();\n    let mut vowels_seen22 = HashSet::new();\n\
    \    let mut vowels_seen23 = HashSet::new();\n    let mut vowels_seen24 = HashSet::new();\n\
    \    let mut vowels_seen25 = HashSet::new();\n    let mut vowels_seen26 = HashSet::new();\n\
    \    let mut vowels_seen27 = HashSet::new();\n    let mut vowels_seen28 = HashSet::new();\n\
    \    let mut vowels_seen29 = HashSet::new();\n    let mut vowels_seen30 = HashSet::new();\n\
    \    let mut vowels_seen31 = HashSet::new();\n    let mut vowels_seen32 = HashSet::new();\n\
    \    let mut vowels_seen33 = HashSet::new();\n    let mut vowels_seen34 = HashSet::new();\n\
    \    let mut vowels_seen35 = HashSet::new();\n    let mut vowels_seen36 = HashSet::new();\n\
    \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpjnb2r34n.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:14:27\n\
    \   |\n14 |     let mut vowels_seen = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:15:28\n\
    \   |\n15 |     let mut vowels_seen2 = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:16:28\n\
    \   |\n16 |     let mut vowels_seen3 = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:17:28\n\
    \   |\n17 |     let mut vowels_seen4 = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:18:28\n\
    \   |\n18 |     let mut vowels_seen5 = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpjnb2r34n.rs:19:28\n\
    \   |\n19 |     let mut vowels_seen6 = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider imp"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message {\n        if letter in vowels {\n            vowel_counter += 1;\n\
    \            result.push((letters[letter_counter].to_string()).to_lowercase());\n\
    \        } else {\n            letter_counter += 1;\n            result.push((letters[letter_counter].to_string()).to_lowercase());\n\
    \        }\n    }\n    if vowel_counter > 1 {\n        result.push((letters[letter_counter].to_string()).to_lowercase());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpy7yyz2ec.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy7yyz2ec.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpy7yyz2ec.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpy7yyz2ec.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpy7yyz2ec.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy7yyz2ec.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_idx = 0;\n    let mut letter_offset\
    \ = 0;\n    let mut letter_length = 0;\n    let mut letter_offset2 = 0;\n    let\
    \ mut letter_length2 = 0;\n    let mut letter_offset3 = 0;\n    let mut letter_length3\
    \ = 0;\n    let mut letter_offset4 = 0;\n    let mut letter_length4 = 0;\n   \
    \ let mut letter_offset5 = 0;\n    let mut letter_length5 = 0;\n    let mut letter_offset6\
    \ = 0;\n    let mut letter_length6 = 0;\n    let mut letter_offset7 = 0;\n   \
    \ let mut letter_length7 = 0;\n    let mut letter_offset8 = 0;\n    let mut letter_length8\
    \ = 0;\n    let mut letter_offset9 = 0;\n    let mut letter_length9 = 0;\n   \
    \ let mut letter_offset10 = 0;\n    let mut letter_length10 = 0;\n    let mut\
    \ letter_offset11 = 0;\n    let mut letter_length11 = 0;\n    let mut letter_offset12\
    \ = 0;\n    let mut letter_length12 = 0;\n    let mut letter_offset13 = 0;\n \
    \   let mut letter_length13 = 0;\n    let mut letter_offset14 = 0;\n    let mut\
    \ letter_length14 = 0;\n    let mut letter_offset15 = 0;\n    let mut letter_length15\
    \ = 0;\n    let mut letter_offset16 = 0;\n    let mut letter_length16 = 0;\n \
    \   let mut letter_offset17 = 0;\n    let mut letter_length17 = 0;\n    let mut\
    \ letter_offset18 = 0;\n    let mut letter_length18 = 0;\n    let mut letter_offset19\
    \ = 0;\n    let mut letter_length19 = 0;\n    let mut letter_offset20 = 0;\n \
    \   let mut letter_length20 = 0;\n    let mut letter_offset21 = 0;\n    let mut\
    \ letter_length21 = 0;\n    let mut letter_offset22 = 0;\n    let mut letter_length22\
    \ = 0;\n    let mut letter_offset23 = 0;\n    let mut letter_length23 = 0;\n \
    \   let mut letter_offset24 = 0;\n    let mut letter_length24 = 0;\n    let mut\
    \ letter_offset25 = 0;\n    let mut letter_length25 = 0;\n    let mut letter_offset26\
    \ = 0;\n    let mut letter_length26 = 0;\n    let mut letter_offset27 = 0;\n \
    \   let mut letter_length27 = 0;\n    let mut letter_offset28 = 0;\n    let mut\
    \ letter_length28 = 0;\n    let mut letter_offset29 = 0;\n    let mut letter_length29\
    \ = 0;\n    let mut letter_offset30 = 0;\n    let mut letter_length30 = 0;\n \
    \   let mut letter_offset31 = 0;\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpoc1un4r8.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoc1un4r8.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoc1un4r8.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoc1un4r8.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoc1un4r8.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoc1un4r8.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoc1un4r8.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoc1un4r8.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpoc1un4r8.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoc1un4r8.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoc1un4r8.rs:85:25\n   |\n85 |     asser"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"bcdfghjklmnpqrstvwxyz\".to_string();\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.find(letter)\
    \ {\n            result.push_str(&letters[(index + 1) % letters.len()]);\n   \
    \     } else {\n            result.push_str(&letters[letters.find(letter).unwrap()\
    \ + 1]);\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpoxp77660.rs:27:17\n\
    \   |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoxp77660.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpoxp77660.rs:28:17\n   |\n28 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpoxp77660.rs:28:25\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpoxp77660.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpoxp77660.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpoxp77660.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpoxp77660.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpoxp77660.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpoxp77660.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpoxp77660.rs:17:30\n   |\n\
    17 |             result.push_str(&letters[(index + 1) % letters.len()]);\n   |\
    \                              ^^^"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpnknx0ljg.rs:61:27\n   |\n\
    61 |     let mut letter_counter\n   |                           ^ help: add `;`\
    \ here\n62 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpnknx0ljg.rs:66:17\n   |\n66 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpnknx0ljg.rs:66:25\n \
    \  |\n66 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpnknx0ljg.rs:67:17\n   |\n67 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpnknx0ljg.rs:67:25\n   |\n67 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpnknx0ljg.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpnknx0ljg.rs:68:25\n   |\n68 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpnknx0ljg.rs:69:17\n  \
    \ |\n69 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpnknx0ljg.rs:69:25\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpnknx0ljg.rs:70:17\n   |\n70 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpnknx0ljg.rs:70:25\n\
    \   |\n70 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut letter_count = vec![0];\n    let mut letter_count_index =\
    \ vec![0];\n    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3\
    \ = vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp3s7tkgaa.rs:42:33\n   |\n\
    42 |     let mut letter_count_index27\n   |                                 ^\
    \ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3s7tkgaa.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3s7tkgaa.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:50:17\n  \
    \ |\n50 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3s7tkgaa.rs:50:25\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:51:17\n   |\n51 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3s7tkgaa.rs:51:25\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    alphabet.insert(String::from(\"a\"\
    ));\n    alphabet.insert(String::from(\"b\"));\n    alphabet.insert(String::from(\"\
    c\"));\n    alphabet.insert(String::from(\"d\"));\n    alphabet.insert(String::from(\"\
    e\"));\n    alphabet.insert(String::from(\"f\"));\n    alphabet.insert(String::from(\"\
    g\"));\n    alphabet.insert(String::from(\"h\"));\n    alphabet.insert(String::from(\"\
    i\"));\n    alphabet.insert(String::from(\"j\"));\n    alphabet.insert(String::from(\"\
    k\"));\n    alphabet.insert(String::from(\"l\"));\n    alphabet.insert(String::from(\"\
    m\"));\n    alphabet.insert(String::from(\"n\"));\n    alphabet.insert(String::from(\"\
    o\"));\n    alphabet.insert(String::from(\"p\"));\n    alphabet.insert(String::from(\"\
    q\"));\n    alphabet.insert(String::from(\"r\"));\n    alphabet.insert(String::from(\"\
    s\"));\n    alphabet.insert(String::from(\"t\"));\n    alphabet.insert(String::from(\"\
    u\"));\n    alphabet.insert(String::from(\"v\"));\n    alphabet.insert(String::from(\"\
    w\"));\n    alphabet.insert(String::from(\"x\"));\n    alphabet.insert(String::from(\"\
    y\"));\n    alphabet.insert(String::from(\"z\"));\n    vowels.insert(String::from(\"\
    a\"));\n    vowels.insert(String::from(\"e\"));\n    vowels.insert(String::from(\"\
    i\"));\n    vowels.insert(String::from(\"o\"));\n    vowels.insert(String::from(\"\
    u\"));\n    vowels.insert(String::from(\"y\"));\n    vowels.insert(String::from(\"\
    A\"));\n    vowels.insert(String::from(\"E\"));\n    vowels.insert(String::from(\"\
    I\"));\n    vowels.insert(String::from(\"O\"));\n    vowels.insert(String::from(\"\
    U\"));\n    vowels.insert(String::from(\"Y\"));\n    for letter in message.chars()\
    \ {\n        if let Some(vowel) = vowels.find(letter) {\n            let mut newletter\
    \ = String::from(\"a\");\n            for _ in 0..2 {\n                newletter\
    \ += vowel;\n            }\n            result += newletter;\n        } else {\n\
    \            result += letter;\n        }\n    }\n\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpwah943ed.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpwah943ed.rs:14:24\n\
    \   |\n14 |     let mut alphabet = HashSet::new();\n   |                     \
    \   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpwah943ed.rs:69:17\n   |\n69 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpwah943ed.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpwah943ed.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpwah943ed.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpwah943ed.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpwah943ed.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpwah943ed.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpwah943ed.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_seen = HashSet::new();\n    let mut letter_seen = HashSet::new();\n\
    \    let mut letter_seen_2 = HashSet::new();\n    let mut letters_seen = HashSet::new();\n\
    \    let mut letters_seen_2 = HashSet::new();\n    let mut letters_seen_3 = HashSet::new();\n\
    \    let mut letters_seen_4 = HashSet::new();\n    let mut letters_seen_5 = HashSet::new();\n\
    \    let mut letters_seen_6 = HashSet::new();\n    let mut letters_seen_7 = HashSet::new();\n\
    \    let mut letters_seen_8 = HashSet::new();\n    let mut letters_seen_9 = HashSet::new();\n\
    \    let mut letters_seen_10 = HashSet::new();\n    let mut letters_seen_11 =\
    \ HashSet::new();\n    let mut letters_seen_12 = HashSet::new();\n    let mut\
    \ letters_seen_13 = HashSet::new();\n    let mut letters_seen_14 = HashSet::new();\n\
    \    let mut letters_seen_15 = HashSet::new();\n    let mut letters_seen_16 =\
    \ HashSet::new();\n    let mut letters_seen_17 = HashSet::new();\n    let mut\
    \ letters_seen_18 = HashSet::new();\n    let mut letters_seen_19 = HashSet::new();\n\
    \    let mut letters_seen_20 = HashSet::new();\n    let mut letters_seen_21 =\
    \ HashSet::new();\n    let mut letters_seen_22 = HashSet::new();\n    let mut\
    \ letters_seen_23 = HashSet::new();\n    let mut letters_seen_24 = HashSet::new();\n\
    \    let mut letters_seen_25 = HashSet::new();\n    let mut letters_seen_26 =\
    \ HashSet::new();\n    let mut letters_seen_27 = HashSet::new();\n    let mut\
    \ letters_seen_28 = HashSet::new();\n    let mut letters_seen_29 = HashSet::new();\n\
    \    let mut letters_seen_30 = HashSet::new();\n    let mut letters_seen_31 =\
    \ HashSet::new();\n    let mut letters_seen_32 = HashSet::new();\n    let mut\
    \ letters_seen_33 = HashSet::new();\n    let mut letters_\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_4o41hvi.rs:50:21\n   |\n\
    50 |     let mut letters_\n   |                     ^ help: add `;` here\n51 |\
    \ }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp_4o41hvi.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp_4o41hvi.rs:14:27\n   |\n14 |     let mut vowels_seen = HashSet::new();\n\
    \   |                           ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_4o41hvi.rs:15:27\n\
    \   |\n15 |     let mut letter_seen = HashSet::new();\n   |                  \
    \         ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_4o41hvi.rs:16:29\n\
    \   |\n16 |     let mut letter_seen_2 = HashSet::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_4o41hvi.rs:17:28\n\
    \   |\n17 |     let mut letters_seen = HashSet::new();\n   |                 \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_4o41hvi.rs:18:30\n\
    \   |\n18 |     let mut letters_seen_2 = HashSet::new();\n   |               \
    \               ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashS"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"\
    j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"\
    w\", \"x\", \"y\", \"z\"];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\
    \ 26];\n    let mut current_letter = 0;\n    let mut current_vowel = 0;\n    let\
    \ mut current_letter_index = 0;\n    let mut current_vowel_index = 0;\n    let\
    \ mut current_letter_count = 1;\n    let mut current_vowel_count = 1;\n    let\
    \ mut current_letter_indexes = [0, 0];\n    let mut current_vowel_indexes = [0,\
    \ 0];\n    let mut current_letter_counts = [0, 0];\n    let mut current_vowel_counts\
    \ = [0, 0];\n    let mut current_letter_indexes_2 = [0, 0];\n    let mut current_vowel_indexes_2\
    \ = [0, 0];\n    let mut current_letter_counts_2 = [0, 0];\n    let mut current_vowel_counts_2\
    \ = [0, 0];\n    let mut current_letter_indexes_3 = [0, 0];\n    let mut current_vowel_indexes_3\
    \ = [0, 0];\n    let mut current_letter_counts_3 = [0, 0];\n    let mut current_vowel_counts_3\
    \ = [0, 0];\n    let mut current_letter_indexes_4 = [0, 0];\n    let mut current_vowel_indexes_4\
    \ = [0, 0];\n    let mut current_letter_counts_4 = [0, 0];\n    let mut current_vowel_counts_4\
    \ = [0, 0];\n    let mut current_letter_indexes_5 = [0, 0];\n    let mut current_vowel_indexes_5\
    \ = [0, 0];\n    let mut current_letter_counts_5 = [0, 0];\n    let mut current_vowel_counts_5\
    \ = [0, 0];\n    let mut current_letter_indexes_6 = [0, 0];\n    let mut current_vowel_indexes_6\
    \ = [0, 0];\n    let mut current_letter_counts_6 = [0, 0];\n    let mut current_vowel_counts_6\
    \ = [0, 0];\n    let mut current_letter_indexes_7 = [0, 0];\n    let mut current_vowel_indexes_7\
    \ = [0, 0];\n    let mut current_letter_counts_7 = [0, 0];\n    let mut current_vowel_counts_7\
    \ = [0, 0];\n    let mut current_letter_indexes_8 = [0, 0];\n    let mut current_vowel_indexes_8\
    \ = [0, 0];\n    let \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpgqb1x_cd.rs:54:1\n  \
    \ |\n54 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpgqb1x_cd.rs:58:17\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:58:25\n \
    \  |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgqb1x_cd.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgqb1x_cd.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:60:25\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:61:17\n  \
    \ |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgqb1x_cd.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:62:17\n   |\n62 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgqb1x_cd.rs:62:25\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7jelmwiu.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7jelmwiu.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    for letter in message.chars() {\n        if let Some(index)\
    \ = vowels.iter().position(|&x| x == letter) {\n            result.push(*letters[(index\
    \ + 1) % vowels.len()]);\n        } else {\n            result.push(*letters[letters.iter().position(|&x|\
    \ x == letter).unwrap() + 1]);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmptjlj7is7.rs:27:17\n\
    \   |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptjlj7is7.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmptjlj7is7.rs:28:17\n   |\n28 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmptjlj7is7.rs:28:25\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmptjlj7is7.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmptjlj7is7.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmptjlj7is7.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmptjlj7is7.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmptjlj7is7.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmptjlj7is7.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmptjlj7is7.rs:17:25\n   |\n17 | \
    \            result.push(*letters[(index + 1) % vowels.len()]);\n   |        \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count = vec![0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9];\n    let mut letters_count = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4,\
    \ 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9];\n    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8,\
    \ 9];\n    let mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n\
    \    let mut vowels_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let\
    \ mut letters_count_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowels_count_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_count_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut vowel\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp5ut0vmai.rs:41:18\n   |\n\
    41 |     let mut vowel\n   |                  ^ help: add `;` here\n42 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5ut0vmai.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5ut0vmai.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5ut0vmai.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5ut0vmai.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5ut0vmai.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5ut0vmai.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5ut0vmai.rs:49:17\n   |\n49 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5ut0vmai.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5ut0vmai.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5ut0vmai.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_uppercase());\n        }\n\
    \        if !vowels.contains(&c) {\n            result.push_str(&c.to_lowercase());\n\
    \        }\n        vowels.insert(c);\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpfkvcw2lh.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:30:17\n  \
    \ |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfkvcw2lh.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpfkvcw2lh.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpfkvcw2lh.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpfkvcw2lh.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpfkvcw2lh.rs:34:25\n   |\n34 |     asser"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut current_letter = String::new();\n\
    \    let mut current_vowel = String::new();\n    let mut current_vowel_pos = 0;\n\
    \    let mut current_letter_pos = 0;\n    let mut current_letter_len = message.chars().count();\n\
    \    \n    while index < message.chars().count() {\n        current_letter = message.chars().nth(index).unwrap();\n\
    \        current_vowel = vowels.iter().position(|&x| x == current_letter).unwrap();\n\
    \        current_letter_pos = letters.iter().position(|&x| x == current_letter).unwrap();\n\
    \        \n        if current_letter_pos == 0 {\n            result.push((letters[current_letter_pos]\
    \ + current_letter).to_string());\n        } else {\n            result.push((letters[current_letter_pos]\
    \ + current_letter + letters[current_letter_pos - 1]).to_string());\n        }\n\
    \        \n        if current_vowel_pos == 0 {\n            result.push((vowels[current_vowel_pos]\
    \ + current_vowel).to_string());\n        } else {\n            result.push((vowels[current_vowel_pos]\
    \ + current_vowel + vowels[current_vowel_pos - 1]).to_string());\n        }\n\
    \        \n        index += 1;\n    }\n    \n    result\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7l4a9zxa.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7l4a9zxa.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7l4a9zxa.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7l4a9zxa.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7l4a9zxa.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7l4a9zxa.rs:23:26\n   |\n23 |         current_letter =\
    \ message.chars().nth(index).unwrap();\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter in vowels {\n            vowel_counter++;\n        }\n        if letter\
    \ in letters {\n            letter_counter++;\n        }\n    }\n    for letter\
    \ in message {\n        if letter in vowels {\n            if letter_counter ==\
    \ 2 {\n                result.push((letters[vowel_counter - 1] + letters[vowel_counter])\
    \ as char);\n                vowel_counter = 0;\n                letter_counter\
    \ = 0;\n            } else {\n                result.push((letters[vowel_counter\
    \ - 1] + letter) as char);\n                vowel_counter = 0;\n            }\n\
    \        }\n        if letter in letters {\n            if letter_counter == 2\
    \ {\n                result.push((letters[letter_counter - 1] + letters[letter_counter])\
    \ as char);\n                letter_counter = 0;\n            } else {\n     \
    \           result.push((letters[letter_counter - 1] + letter) as char);\n   \
    \             letter_counter = 0;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpmtriegz_.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror: expected `{`, found keyword `in`\n  --> /tmp/tmpmtriegz_.rs:26:19\n\
    \   |\n26 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpmtriegz_.rs:51:17\n\
    \   |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmtriegz_.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmtriegz_.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmtriegz_.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmtriegz_.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmtriegz_.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmtriegz_.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmtriegz_.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmtriegz_.rs:55:17\n  \
    \ |\n55 |     assert_eq!({lef"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n\
    \    for letter in message.chars() {\n        if letter == vowels[vowel_counter].to_ascii_lowercase()\
    \ {\n            vowel_counter = vowel_counter + 1;\n        } else {\n      \
    \      if letter_counter < vowel_counter {\n                result.push((vowels[letter_counter].to_ascii_lowercase()\
    \ + letter).to_ascii_lowercase());\n            } else {\n                result.push((letter\
    \ + vowels[letter_counter].to_ascii_lowercase()).to_ascii_lowercase());\n    \
    \        }\n            letter_counter = letter_counter + 1;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpkjqctb0l.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkjqctb0l.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkjqctb0l.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkjqctb0l.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkjqctb0l.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkjqctb0l.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkjqctb0l.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkjqctb0l.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkjqctb0l.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkjqctb0l.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpkjqctb0l.rs:17:22\n\
    \   |\n17 |         if letter == vowels[vowel_counter].to_ascii_lowercase() {\n\
    \   |                      ^^^^^^^^^"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n\
    \    let mut letter_counter = 0;\n    for letter in message.chars() {\n      \
    \  if letter == ' ' {\n            result.push_str(\" \");\n        } else {\n\
    \            if letter in vowels {\n                vowel_counter += 1;\n    \
    \            let vowel_index = vowels.iter().position(|&x| x == letter).unwrap();\n\
    \                let vowel_letter = vowels[vowel_index];\n                result.push_str(&vowel_letter);\n\
    \            } else {\n                letter_counter += 1;\n                let\
    \ letter_index = letters.iter().position(|&x| x == letter).unwrap();\n       \
    \         let letter_letter = letters[letter_index];\n                result.push_str(&letter_letter);\n\
    \            }\n        }\n    }\n    if vowel_counter > 0 {\n        result.push_str(&vowels[vowel_counter\
    \ - 1]);\n    }\n    if letter_counter > 0 {\n        result.push_str(&letters[letter_counter\
    \ - 1]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpa8g3m7c6.rs:21:23\n\
    \   |\n21 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpa8g3m7c6.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpa8g3m7c6.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:47:17\n   |\n47 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:47:25\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpa8g3m7c6.rs:48:17\n   |\n48 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:48:25\n   |\n48 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpa8g3m7c6.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpa8g3m7c6.rs:49:25\n   |\n49 |     assert_eq!({left},\
    \ {right});\n   |                 "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_count\
    \ = 1;\n    let mut vowels_encoded_count_prev = 0;\n    let mut vowels_encoded_count_prev2\
    \ = 0;\n    let mut vowels_encoded_count_prev3 = 0;\n    let mut vowels_encoded_count_prev4\
    \ = 0;\n    let mut vowels_encoded_count_prev5 = 0;\n    let mut vowels_encoded_count_prev6\
    \ = 0;\n    let mut vowels_encoded_count_prev7 = 0;\n    let mut vowels_encoded_count_prev8\
    \ = 0;\n    let mut vowels_encoded_count_prev9 = 0;\n    let mut vowels_encoded_count_prev10\
    \ = 0;\n    let mut vowels_encoded_count_prev11 = 0;\n    let mut vowels_encoded_count_prev12\
    \ = 0;\n    let mut vowels_encoded_count_prev13 = 0;\n    let mut vowels_encoded_count_prev14\
    \ = 0;\n    let mut vowels_encoded_count_prev15 = 0;\n    let mut vowels_encoded_count_prev16\
    \ = 0;\n    let mut vowels_encoded_count_prev17 = 0;\n    let mut vowels_encoded_count_prev18\
    \ = 0;\n    let mut vowels_encoded_count_prev19 = 0;\n    let mut vowels_encoded_count_prev20\
    \ = 0;\n    let mut vowels_encoded_count_prev21 = 0;\n    let mut vowels_encoded_count_prev22\
    \ = 0;\n    let mut vowels_encoded_count_prev23 = 0;\n    let mut vowels_encoded_count_prev24\
    \ = 0;\n    let mut vowels_encoded_count_prev25 = 0;\n    let mut vowels_encoded_count_prev26\
    \ = 0;\n    let mut vowels_encoded_count_prev27 = 0;\n    let mut vowels_encoded_count_prev28\
    \ = 0;\n    let mut vowels_encoded_count_prev29 = 0;\n    let mut vowels_encoded_count_prev30\
    \ = 0;\n    let mut vowels_encoded_count_prev31 = 0;\n    let mut vowels_encoded_count_prev32\
    \ = 0;\n    let mut vowels_encoded_count_prev33 = 0;\n    let mut vowels_encoded_count_prev34\
    \ = 0;\n    let mut vowels_encoded_count_prev35 = 0;\n    let mut vowels_encoded_count_prev36\
    \ = 0;\n    let mut vowels_encoded_count_prev37 = 0;\n    let mut vowels_encoded_count_prev38\
    \ = 0;\n    let mut vowels_encoded_count_prev39 = 0;\n    let mut vowels_\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7wcnug_4.rs:55:20\n   |\n\
    55 |     let mut vowels_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp7wcnug_4.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp7wcnug_4.rs:14:30\n   |\n14 |     let mut vowels_encoded = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7wcnug_4.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7wcnug_4.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7wcnug_4.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7wcnug_4.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7wcnug_4.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7wcnug_4.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7wcnug_4.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this sc"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut current_vowel = 0;\n    let mut current_index = 0;\n    let\
    \ mut current_letter = 0;\n    for letter in message {\n        if letter == '\
    \ ' {\n            result.push_str(&\"\");\n        } else {\n            if current_vowel\
    \ == 0 {\n                if current_index == 0 {\n                    result.push_str(&letter);\n\
    \                } else {\n                    result.push_str(&vowels[current_index]);\n\
    \                }\n            } else {\n                if current_index ==\
    \ 0 {\n                    result.push_str(&vowels[current_vowel]);\n        \
    \        } else {\n                    result.push_str(&vowels[current_vowel]);\n\
    \                }\n            }\n            result.push_str(&vowels[current_vowel]);\n\
    \            result.push_str(&letter);\n        }\n        current_vowel = vowels_index[current_vowel];\n\
    \        current_index += 1;\n        current_letter += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:47:17\n\
    \   |\n47 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpe6g4s_oq.rs:47:25\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:48:17\n   |\n48 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:48:25\n\
    \   |\n48 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpe6g4s_oq.rs:49:17\n   |\n49 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:49:25\n   |\n49 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpe6g4s_oq.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:50:25\n   |\n50 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpe6g4s_oq.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpe6g4s_oq.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpe6g4s_oq.rs:18:19\n    |\n18  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_counter = vec![0];\n   \
    \ let mut letter_counter = vec![0];\n    let mut letter = String::new();\n   \
    \ let mut vowel = String::new();\n    let mut vowel_counter = vec![0];\n    let\
    \ mut letter_index = String::new();\n    let mut letter_index_counter = vec![0];\n\
    \    let mut letter_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n   \
    \ let mut vowel_counter = vec![0];\n    let mut letter_index = String::new();\n\
    \    let mut letter_index_counter = vec![0];\n    let mut letter_counter = vec![0];\n\
    \    let mut letter = String::new();\n    let mut vowel = String::new();\n\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxz3ambhv.rs:66:17\n\
    \   |\n66 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxz3ambhv.rs:66:25\n   |\n66 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxz3ambhv.rs:67:17\n   |\n67 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxz3ambhv.rs:67:25\n\
    \   |\n67 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxz3ambhv.rs:68:17\n   |\n68 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxz3ambhv.rs:68:25\n   |\n68 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxz3ambhv.rs:69:17\n   |\n69 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxz3ambhv.rs:69:25\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxz3ambhv.rs:70:17\n  \
    \ |\n70 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxz3ambhv.rs:70:25\n   |\n70 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxz3ambhv.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    for letter in message.chars() {\n        if letter.is_uppercase()\
    \ {\n            letters.insert(letter);\n        } else {\n            vowels.insert(letter);\n\
    \        }\n    }\n    for letter in letters {\n        for vowel in vowels {\n\
    \            if vowel == letter {\n                encoded.push_str(&vowels[vowel_counter]);\n\
    \                vowel_counter += 1;\n            }\n        }\n    }\n    for\
    \ vowel in vowels {\n        for letter in letters {\n            if vowel ==\
    \ letter {\n                encoded.push_str(&vowels[vowel_counter]);\n      \
    \          vowel_counter += 1;\n            }\n        }\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp9iag9cyg.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp9iag9cyg.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp9iag9cyg.rs:45:17\n   |\n45 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9iag9cyg.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9iag9cyg.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9iag9cyg.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9iag9cyg.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9iag9cyg.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9iag9cyg.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9iag9cyg.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmpx1dp0nfi.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpx1dp0nfi.rs:81:17\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:81:25\n \
    \  |\n81 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx1dp0nfi.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:82:25\n   |\n82 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx1dp0nfi.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:83:25\n   |\n83 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:84:17\n  \
    \ |\n84 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx1dp0nfi.rs:84:25\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:85:17\n   |\n85 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx1dp0nfi.rs:85:25\n\
    \   |\n85 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    for c in message.chars() {\n        if letters.contains(&c)\
    \ {\n            letters_idx += 1;\n        }\n        if vowels.contains(&c)\
    \ {\n            vowels_idx += 1;\n        }\n        if letters_idx > 2 {\n \
    \           letters_idx -= 2;\n        }\n        if vowels_idx > 2 {\n      \
    \      vowels_idx -= 2;\n        }\n        if letters_idx < 2 {\n           \
    \ letters.insert(c);\n        }\n        if vowels_idx < 2 {\n            vowels.insert(c);\n\
    \        }\n        result.push(c);\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp_frphlg6.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp_frphlg6.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp_frphlg6.rs:43:17\n   |\n43 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_frphlg6.rs:43:25\n\
    \   |\n43 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_frphlg6.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_frphlg6.rs:44:25\n   |\n44 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_frphlg6.rs:45:17\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_frphlg6.rs:45:25\n   |\n45 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp_frphlg6.rs:46:17\n  \
    \ |\n46 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_frphlg6.rs:46:25\n   |\n46 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_counter\
    \ = 0;\n    let mut letters_counter = 0;\n    for c in message.chars() {\n   \
    \     if letters_counter < letters.len() {\n            result.push(*letters[letters_counter]);\n\
    \            letters_counter += 1;\n        } else {\n            result.push(*vowels[vowels_counter]);\n\
    \            vowels_counter += 1;\n        }\n        if letters_counter == letters.len()\
    \ {\n            result.push(*letters[letters_counter]);\n            letters_counter\
    \ += 1;\n        }\n        if vowels_counter == vowels.len() {\n            result.push(*vowels[vowels_counter]);\n\
    \            vowels_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3isemswj.rs:39:17\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3isemswj.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3isemswj.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3isemswj.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3isemswj.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3isemswj.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3isemswj.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3isemswj.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3isemswj.rs:43:17\n  \
    \ |\n43 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3isemswj.rs:43:25\n   |\n43 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3isemswj.rs:19:25\n   |\n19 |             result.push(*letters[letters_counter]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ `str`"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = 0;\n    let mut letter_counter\
    \ = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n \
    \   let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n    let mut\
    \ letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut letter_counter8\
    \ = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n\
    \    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n    let\
    \ mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let mut letter_counter15\
    \ = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n\
    \    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n    let\
    \ mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let mut letter_counter22\
    \ = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n\
    \    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n    let\
    \ mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let mut letter_counter29\
    \ = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n\
    \    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n    let\
    \ mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let mut letter_counter36\
    \ = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n\
    \    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n    let\
    \ mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let mut letter_counter43\
    \ = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n\
    \    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n    let\
    \ mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let mut letter_counter50\
    \ = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n\
    \    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n    let\
    \ mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let mut letter_counter57\
    \ = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n\
    \    let mut letter_counter60 = 0;\n    let mut letter_\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp8xdqd0t5.rs:75:20\n   |\n\
    75 |     let mut letter_\n   |                    ^ help: add `;` here\n76 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:80:17\n   |\n80 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:80:25\n   |\n80 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:81:25\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:82:17\n  \
    \ |\n82 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8xdqd0t5.rs:82:25\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:17\n   |\n83 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:83:25\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xdqd0t5.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xdqd0t5.rs:84:25\n   |\n84 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659747234
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    for letter in message.chars()\
    \ {\n        if letter == ' ' {\n            result.push_str(\" \");\n       \
    \ } else {\n            result.push_str(&letters[letter - 'A']);\n        }\n\
    \        if letter == vowels[i as usize] {\n            result.push_str(&vowels[i\
    \ as usize + 1]);\n            i += 2;\n        } else {\n            i += 1;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb33wjga2.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb33wjga2.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb33wjga2.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb33wjga2.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb33wjga2.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb33wjga2.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb33wjga2.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb33wjga2.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb33wjga2.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb33wjga2.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ subtract `char` from `char`\n  --> /tmp/tmpb33wjga2.rs:20:45\n   |\n20 |   \
    \          result.push_str(&letters[letter - 'A']);\n   |                    \
    \                  ------ ^ --- char\n   |"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n   \
    \ let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 = vec![0];\n\
    \    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5 =\
    \ vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = vec\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp_sr64duz.rs:55:39\n   |\n\
    55 |     let mut letter_count_index40 = vec\n   |                            \
    \           ^ help: add `;` here\n56 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found macro `vec`\n  --> /tmp/tmp_sr64duz.rs:55:36\n   |\n55\
    \ |     let mut letter_count_index40 = vec\n   |                             \
    \       ^^^ not a value\n   |\nhelp: use `!` to invoke the macro\n   |\n55 | \
    \    let mut letter_count_index40 = vec!\n   |                               \
    \        +\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp_sr64duz.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp_sr64duz.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp_sr64duz.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp_sr64duz.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp_sr64duz.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp_sr64duz.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp_sr64duz.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp_sr64duz.rs:63:25\n   |\n63 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this s"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = String::new();\n    let mut vowels_index_2 = String::new();\n\
    \    let mut vowels_index_3 = String::new();\n    let mut vowels_index_4 = String::new();\n\
    \    let mut vowels_index_5 = String::new();\n    let mut vowels_index_6 = String::new();\n\
    \    let mut vowels_index_7 = String::new();\n    let mut vowels_index_8 = String::new();\n\
    \    let mut vowels_index_9 = String::new();\n    let mut vowels_index_10 = String::new();\n\
    \    let mut vowels_index_11 = String::new();\n    let mut vowels_index_12 = String::new();\n\
    \    let mut vowels_index_13 = String::new();\n    let mut vowels_index_14 = String::new();\n\
    \    let mut vowels_index_15 = String::new();\n    let mut vowels_index_16 = String::new();\n\
    \    let mut vowels_index_17 = String::new();\n    let mut vowels_index_18 = String::new();\n\
    \    let mut vowels_index_19 = String::new();\n    let mut vowels_index_20 = String::new();\n\
    \    let mut vowels_index_21 = String::new();\n    let mut vowels_index_22 = String::new();\n\
    \    let mut vowels_index_23 = String::new();\n    let mut vowels_index_24 = String::new();\n\
    \    let mut vowels_index_25 = String::new();\n    let mut vowels_index_26 = String::new();\n\
    \    let mut vowels_index_27 = String::new();\n    let mut vowels_index_28 = String::new();\n\
    \    let mut vowels_index_29 = String::new();\n    let mut vowels_index_30 = String::new();\n\
    \    let mut vowels_index_31 = String::new();\n    let mut vowels_index_32 = String::new();\n\
    \    let mut vowels_index_33 = String::new();\n    let mut vowels_index_34 = String::new();\n\
    \    let mut vowels_index_35 = String::new();\n    let mut vowels_index_36 = String::new();\n\
    \    let mut vowels_index_37 = String::new();\n    let mut vowels_index_38 = String::new();\n\
    \    let mut vowels_index_39 = String::new();\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6yeck7jt.rs:58:17\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6yeck7jt.rs:58:25\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6yeck7jt.rs:59:17\n   |\n59 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6yeck7jt.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6yeck7jt.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6yeck7jt.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6yeck7jt.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6yeck7jt.rs:61:25\n   |\n61 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6yeck7jt.rs:62:17\n  \
    \ |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6yeck7jt.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6yeck7jt.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_letters = vec!['b', 'c', 'd', 'f', 'g',\
    \ 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut letter_letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut vowel_letter_letters = vec!['B', 'C', 'D', 'F', 'G', 'H',\
    \ 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n\
    \    let mut letter_letter_letters = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\
    \ 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'];\n    let mut vowel_letter_letter_letters = vec!['B', 'C', 'D', 'F',\
    \ 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'];\n    let mut letter_letter_letter_letters = vec!['A', 'B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_letter_letter_letter_letters\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letter_letter_letter_letter_letters\
    \ = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\
    \ 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowel_letter_letter_letter_letter_letters\
    \ = vec!['B', 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R',\
    \ '\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n  --> /tmp/tmpta5c3s7e.rs:23:132\n\
    \   |\n23 |     let mut vowel_letter_letter_letter_letter_letters = vec!['B',\
    \ 'C', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', '\n   |   \
    \                                                                            \
    \                                                     ^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0762`.\n"
  stdout: ''
  timestamp: 1659821833
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            vowel_counter += 1;\n            result.push((letters[letter_counter]\
    \ + letters[letter_counter + 1]).to_string());\n            letter_counter +=\
    \ 2;\n        } else {\n            result.push((letters[letter_counter]).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    if vowel_counter > 0\
    \ {\n        result.push((letters[letter_counter]).to_string());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpaofxy84r.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaofxy84r.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaofxy84r.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaofxy84r.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaofxy84r.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaofxy84r.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaofxy84r.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaofxy84r.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaofxy84r.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaofxy84r.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmpaofxy84r.rs:20:50\n   |\n20 |          \
    \   result.push((letters[letter_counter] + letters[letter_counter + 1]).to_string());\n\
    \   |                          "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for c in message.chars() {\n     \
    \   if c.is_uppercase() {\n            letters.insert(c.to_lowercase());\n   \
    \     } else {\n            letters.insert(c.to_uppercase());\n        }\n   \
    \ }\n    for c in letters.iter() {\n        if vowels.contains(&c) {\n       \
    \     result.push(c);\n        } else {\n            result.push(c.to_ascii_lowercase().to_string());\n\
    \        }\n    }\n    for c in vowels.iter() {\n        result.push(c);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpx59wbeeo.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpx59wbeeo.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpx59wbeeo.rs:37:17\n   |\n37 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx59wbeeo.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx59wbeeo.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx59wbeeo.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx59wbeeo.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx59wbeeo.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx59wbeeo.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx59wbeeo.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec!\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmps08f1chw.rs:49:1\n\
    \   |\n48 |     let mut vowels_index_prev = vec!\n   |                       \
    \              - expected one of `(`, `[`, or `{`\n49 | }\n   | ^ unexpected token\n\
    \nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmps08f1chw.rs:53:17\n\
    \   |\n53 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmps08f1chw.rs:53:25\n   |\n53 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmps08f1chw.rs:54:17\n   |\n54 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmps08f1chw.rs:54:25\n\
    \   |\n54 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmps08f1chw.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmps08f1chw.rs:55:25\n   |\n55 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmps08f1chw.rs:56:17\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmps08f1chw.rs:56:25\n   |\n56 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmps08f1chw.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmps08f1chw.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut i = 0;\n    while\
    \ i < message.len() {\n        if message[i] == ' ' {\n            result.push_str(&message[..i]);\n\
    \            i += 1;\n            continue;\n        }\n        if message[i]\
    \ in vowels {\n            result.push_str(&letters[index % letters.len()]);\n\
    \            i += 1;\n            index /= letters.len();\n            continue;\n\
    \        }\n        result.push_str(&message[i]);\n        i += 1;\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpgb36p0hz.rs:23:23\n\
    \   |\n23 |         if message[i] in vowels {\n   |         --            ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpgb36p0hz.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgb36p0hz.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpgb36p0hz.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpgb36p0hz.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpgb36p0hz.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpgb36p0hz.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpgb36p0hz.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpgb36p0hz.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpgb36p0hz.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpgb36p0hz.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if let Some(vowel) = vowels.binary_search(&letter)\
    \ {\n            vowel_counter += 1;\n            result.push((vowel - vowel_counter)\
    \ % 26 + alphabet[vowel]);\n        } else {\n            letter_counter += 1;\n\
    \            result.push((letter_counter - vowel_counter) % 26 + letter);\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp66sui1cd.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp66sui1cd.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp66sui1cd.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp66sui1cd.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp66sui1cd.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp66sui1cd.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp66sui1cd.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp66sui1cd.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp66sui1cd.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp66sui1cd.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp66sui1cd.rs:18:16\n   |\n18 |         if let Some(vowel)\
    \ = vowels.binary_search(&letter) {\n   |                ^^^^^^^^^^^   -----------------------------\
    \ this expre"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n    let \n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `}`\n  --> /tmp/tmp8cr9djq0.rs:77:1\n  \
    \ |\n77 | }\n   | ^ expected pattern\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp8cr9djq0.rs:81:17\n   |\n81 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp8cr9djq0.rs:81:25\n \
    \  |\n81 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8cr9djq0.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8cr9djq0.rs:82:25\n   |\n82 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8cr9djq0.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8cr9djq0.rs:83:25\n   |\n83 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8cr9djq0.rs:84:17\n  \
    \ |\n84 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8cr9djq0.rs:84:25\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8cr9djq0.rs:85:17\n   |\n85 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8cr9djq0.rs:85:25\n\
    \   |\n85 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter_counter\
    \ < vowel_counter {\n                result.push_str(vowels[vowel_counter]);\n\
    \            } else {\n                result.push_str(vowels[vowel_counter -\
    \ letter_counter]);\n            }\n            result.push_str(letter);\n   \
    \         letter_counter += 1;\n        }\n        vowel_counter += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpdzlza26z.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdzlza26z.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdzlza26z.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdzlza26z.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdzlza26z.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdzlza26z.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdzlza26z.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdzlza26z.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdzlza26z.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdzlza26z.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdzlza26z.rs:21:33\n   |\n21 |                 result.push_str(vowels[vowel_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, fou"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letters = vec![\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"\
    g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut i = 0;\n    while\
    \ i < message.len() {\n        let mut letter = message[i];\n        if letter\
    \ == ' ' {\n            result.push('_');\n            i += 1;\n            continue;\n\
    \        }\n        if letter in vowels {\n            vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] += 1;\n            letter = letters[vowels_index[vowels.iter().position(|x|\
    \ x == letter).unwrap()] - 1];\n        }\n        result.push(letter);\n    \
    \    i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp8inqs6ng.rs:25:19\n\
    \   |\n25 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8inqs6ng.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8inqs6ng.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8inqs6ng.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8inqs6ng.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8inqs6ng.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8inqs6ng.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8inqs6ng.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8inqs6ng.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8inqs6ng.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8inqs6ng.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_counts = HashMap::new();\n  \
    \  let mut letter_counts_idx = 0;\n    let mut letter_counts_idx2 = 0;\n    let\
    \ mut letter_counts_idx3 = 0;\n    let mut letter_counts_idx4 = 0;\n    let mut\
    \ letter_counts_idx5 = 0;\n    let mut letter_counts_idx6 = 0;\n    let mut letter_counts_idx7\
    \ = 0;\n    let mut letter_counts_idx8 = 0;\n    let mut letter_counts_idx9 =\
    \ 0;\n    let mut letter_counts_idx10 = 0;\n    let mut letter_counts_idx11 =\
    \ 0;\n    let mut letter_counts_idx12 = 0;\n    let mut letter_counts_idx13 =\
    \ 0;\n    let mut letter_counts_idx14 = 0;\n    let mut letter_counts_idx15 =\
    \ 0;\n    let mut letter_counts_idx16 = 0;\n    let mut letter_counts_idx17 =\
    \ 0;\n    let mut letter_counts_idx18 = 0;\n    let mut letter_counts_idx19 =\
    \ 0;\n    let mut letter_counts_idx20 = 0;\n    let mut letter_counts_idx21 =\
    \ 0;\n    let mut letter_counts_idx22 = 0;\n    let mut letter_counts_idx23 =\
    \ 0;\n    let mut letter_counts_idx24 = 0;\n    let mut letter_counts_idx25 =\
    \ 0;\n    let mut letter_counts_idx26 = 0;\n    let mut letter_counts_idx27 =\
    \ 0;\n    let mut letter_counts_idx28 = 0;\n    let mut letter_counts_idx29 =\
    \ 0;\n    let mut letter_counts_idx30 = 0;\n    let mut letter_counts_idx31 =\
    \ 0;\n    let mut letter_counts_idx32 = 0;\n    let mut letter_counts_idx33 =\
    \ 0;\n    let mut letter_counts_idx34 = 0;\n    let mut letter_counts_idx35 =\
    \ 0;\n    let mut letter_counts_idx36 = 0;\n    let mut letter_counts_idx37 =\
    \ 0;\n    let mut letter_counts_idx38 = 0;\n    let mut letter_counts_idx39 =\
    \ 0;\n    let mut letter_counts_idx40 = 0;\n    let mut letter_counts_idx41 =\
    \ 0;\n    let mut letter_counts_idx42 = 0;\n    let mut letter_counts_idx43 =\
    \ 0;\n    let mut letter_counts_idx44 = 0;\n    let mut letter_counts_idx45 =\
    \ 0;\n    let mut letter_counts_idx46 = 0;\n    let mut letter_counts_idx47 =\
    \ 0;\n    let mut letter_counts_\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp2cuwz7h8.rs:63:27\n   |\n\
    63 |     let mut letter_counts_\n   |                           ^ help: add `;`\
    \ here\n64 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp2cuwz7h8.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmp2cuwz7h8.rs:15:29\n   |\n15 |     let mut letter_counts = HashMap::new();\n\
    \   |                             ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp2cuwz7h8.rs:68:17\n\
    \   |\n68 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp2cuwz7h8.rs:68:25\n   |\n68 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp2cuwz7h8.rs:69:17\n   |\n69 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp2cuwz7h8.rs:69:25\n\
    \   |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp2cuwz7h8.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp2cuwz7h8.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp2cuwz7h8.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not foun"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_index = 0;\n    for letter in message.chars() {\n        if\
    \ letter.is_uppercase() {\n            result.push_str(&encode(letter).to_uppercase());\n\
    \        } else {\n            result.push_str(&encode(letter).to_lowercase());\n\
    \        }\n        if vowels.contains(&letter) {\n            result.push_str(&encode(vowels[vowels_index]).to_lowercase());\n\
    \            vowels_index += 1;\n        } else {\n            vowels.insert(letter);\n\
    \            vowels_index = 0;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpd_1cy17g.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpd_1cy17g.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd_1cy17g.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpd_1cy17g.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpd_1cy17g.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpd_1cy17g.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpd_1cy17g.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpd_1cy17g.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpd_1cy17g.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpd_1cy17g.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd_1cy17g.rs:38:25\n   |\n38 |     asser"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_encoded = HashSet::new();\n    let mut vowels_encoded_count\
    \ = 1;\n    let mut vowels_encoded_count_index = 0;\n    let mut vowels_encoded_count_index2\
    \ = 0;\n    let mut vowels_encoded_count_index3 = 0;\n    let mut vowels_encoded_count_index4\
    \ = 0;\n    let mut vowels_encoded_count_index5 = 0;\n    let mut vowels_encoded_count_index6\
    \ = 0;\n    let mut vowels_encoded_count_index7 = 0;\n    let mut vowels_encoded_count_index8\
    \ = 0;\n    let mut vowels_encoded_count_index9 = 0;\n    let mut vowels_encoded_count_index10\
    \ = 0;\n    let mut vowels_encoded_count_index11 = 0;\n    let mut vowels_encoded_count_index12\
    \ = 0;\n    let mut vowels_encoded_count_index13 = 0;\n    let mut vowels_encoded_count_index14\
    \ = 0;\n    let mut vowels_encoded_count_index15 = 0;\n    let mut vowels_encoded_count_index16\
    \ = 0;\n    let mut vowels_encoded_count_index17 = 0;\n    let mut vowels_encoded_count_index18\
    \ = 0;\n    let mut vowels_encoded_count_index19 = 0;\n    let mut vowels_encoded_count_index20\
    \ = 0;\n    let mut vowels_encoded_count_index21 = 0;\n    let mut vowels_encoded_count_index22\
    \ = 0;\n    let mut vowels_encoded_count_index23 = 0;\n    let mut vowels_encoded_count_index24\
    \ = 0;\n    let mut vowels_encoded_count_index25 = 0;\n    let mut vowels_encoded_count_index26\
    \ = 0;\n    let mut vowels_encoded_count_index27 = 0;\n    let mut vowels_encoded_count_index28\
    \ = 0;\n    let mut vowels_encoded_count_index29 = 0;\n    let mut vowels_encoded_count_index30\
    \ = 0;\n    let mut vowels_encoded_count_index31 = 0;\n    let mut vowels_encoded_count_index32\
    \ = 0;\n    let mut vowels_encoded_count_index33 = 0;\n    let mut vowels_encoded_count_index34\
    \ = 0;\n    let mut vowels_encoded_count_index35 = 0;\n    let mut vowels_encoded_count_index36\
    \ = 0;\n    let mut vowels_encoded_count_index37 = 0;\n    let mut vowels_encoded_count_index38\
    \ = 0;\n    let mut vowels_encoded_count_index39 = 0;\n    let mut vowels_\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp6mi_gmvh.rs:55:20\n   |\n\
    55 |     let mut vowels_\n   |                    ^ help: add `;` here\n56 | }\n\
    \   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmp6mi_gmvh.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp6mi_gmvh.rs:14:30\n   |\n14 |     let mut vowels_encoded = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6mi_gmvh.rs:60:17\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6mi_gmvh.rs:60:25\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6mi_gmvh.rs:61:17\n   |\n61 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6mi_gmvh.rs:61:25\n\
    \   |\n61 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6mi_gmvh.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6mi_gmvh.rs:62:25\n   |\n62 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6mi_gmvh.rs:63:17\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this sc"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\
    \    for c in message.chars() {\n        if c.is_uppercase() {\n            encoded.push_str(&vowels[letters.find(&c.to_lowercase()).unwrap()\
    \ + 2]);\n        } else {\n            encoded.push_str(&letters[vowels.find(&c).unwrap()\
    \ + 2]);\n        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpzti_vddo.rs:27:17\n\
    \   |\n27 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzti_vddo.rs:27:25\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpzti_vddo.rs:28:17\n   |\n28 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpzti_vddo.rs:28:25\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpzti_vddo.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpzti_vddo.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpzti_vddo.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpzti_vddo.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpzti_vddo.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpzti_vddo.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `ToLowercase`\n  --> /tmp/tmpzti_vddo.rs:17:51\n\
    \   |\n17 |             encoded.push_str(&vowels[letters.find(&c.to_lowercase()).unwrap()\
    \ + 2]);\n   |         "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut letters = String::new();\n    let mut index = 0;\n    let mut i =\
    \ 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut\
    \ m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let\
    \ mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n   \
    \ let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n\
    \    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n\
    \    let mut g = 0;\n    let mut h = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n\
    \    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n\
    \    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n\
    \    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n\
    \    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n\
    \    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n\
    \    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n\
    \    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n\
    \    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n\
    \    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n\
    \    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n\
    \    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n\
    \    let mut g = 0;\n    let mut h = 0;\n    let mut i = 0;\n    let mut j = 0;\n\
    \    let mut k = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n   --> /tmp/tmp5vk5ewqv.rs:102:17\n\
    \    |\n102 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5vk5ewqv.rs:102:25\n    |\n102 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5vk5ewqv.rs:103:17\n\
    \    |\n103 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5vk5ewqv.rs:103:25\n    |\n103 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5vk5ewqv.rs:104:17\n\
    \    |\n104 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5vk5ewqv.rs:104:25\n    |\n104 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5vk5ewqv.rs:105:17\n\
    \    |\n105 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5vk5ewqv.rs:105:25\n    |\n105 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n   --> /tmp/tmp5vk5ewqv.rs:106:17\n\
    \    |\n106 |     assert_eq!({left}, {right});\n    |                 ^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n\
    \   --> /tmp/tmp5vk5ewqv.rs:106:25\n    |\n106 |     assert_eq!({left}, {right});\n\
    \    |                         ^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5vk5ewqv.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expe"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut alphabet = HashSet::new();\n    let mut vowel_counter = 0;\n    let\
    \ mut letter_counter = 0;\n    let mut letter_counter2 = 0;\n    let mut letter_counter3\
    \ = 0;\n    let mut letter_counter4 = 0;\n    let mut letter_counter5 = 0;\n \
    \   let mut letter_counter6 = 0;\n    let mut letter_counter7 = 0;\n    let mut\
    \ letter_counter8 = 0;\n    let mut letter_counter9 = 0;\n    let mut letter_counter10\
    \ = 0;\n    let mut letter_counter11 = 0;\n    let mut letter_counter12 = 0;\n\
    \    let mut letter_counter13 = 0;\n    let mut letter_counter14 = 0;\n    let\
    \ mut letter_counter15 = 0;\n    let mut letter_counter16 = 0;\n    let mut letter_counter17\
    \ = 0;\n    let mut letter_counter18 = 0;\n    let mut letter_counter19 = 0;\n\
    \    let mut letter_counter20 = 0;\n    let mut letter_counter21 = 0;\n    let\
    \ mut letter_counter22 = 0;\n    let mut letter_counter23 = 0;\n    let mut letter_counter24\
    \ = 0;\n    let mut letter_counter25 = 0;\n    let mut letter_counter26 = 0;\n\
    \    let mut letter_counter27 = 0;\n    let mut letter_counter28 = 0;\n    let\
    \ mut letter_counter29 = 0;\n    let mut letter_counter30 = 0;\n    let mut letter_counter31\
    \ = 0;\n    let mut letter_counter32 = 0;\n    let mut letter_counter33 = 0;\n\
    \    let mut letter_counter34 = 0;\n    let mut letter_counter35 = 0;\n    let\
    \ mut letter_counter36 = 0;\n    let mut letter_counter37 = 0;\n    let mut letter_counter38\
    \ = 0;\n    let mut letter_counter39 = 0;\n    let mut letter_counter40 = 0;\n\
    \    let mut letter_counter41 = 0;\n    let mut letter_counter42 = 0;\n    let\
    \ mut letter_counter43 = 0;\n    let mut letter_counter44 = 0;\n    let mut letter_counter45\
    \ = 0;\n    let mut letter_counter46 = 0;\n    let mut letter_counter47 = 0;\n\
    \    let mut letter_counter48 = 0;\n    let mut letter_counter49 = 0;\n    let\
    \ mut letter_counter50 = 0;\n    let mut letter_counter51 = 0;\n    let mut letter_counter52\
    \ = 0;\n    let mut letter_counter53 = 0;\n    let mut letter_counter54 = 0;\n\
    \    let mut letter_counter55 = 0;\n    let mut letter_counter56 = 0;\n    let\
    \ mut letter_counter57 = 0;\n    let mut letter_counter58 = 0;\n    let mut letter_counter59\
    \ = 0;\n    let mut letter_counter60\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpda3rk0i5.rs:75:29\n   |\n\
    75 |     let mut letter_counter60\n   |                             ^ help: add\
    \ `;` here\n76 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmpda3rk0i5.rs:13:22\n   |\n13\
    \ |     let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmpda3rk0i5.rs:14:24\n   |\n14 |  \
    \   let mut alphabet = HashSet::new();\n   |                        ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpda3rk0i5.rs:80:17\n   |\n80 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpda3rk0i5.rs:80:25\n \
    \  |\n80 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpda3rk0i5.rs:81:17\n   |\n81 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpda3rk0i5.rs:81:25\n   |\n81 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpda3rk0i5.rs:82:17\n   |\n82 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpda3rk0i5.rs:82:25\n   |\n82 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpda3rk0i5.rs:83:17\n  \
    \ |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in t"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if vowels.contains(&letter)\
    \ {\n            encoded.push_str(&vowels[vowel_counter]);\n            vowel_counter\
    \ += 1;\n        } else {\n            encoded.push_str(&letter);\n          \
    \  letter_counter += 1;\n        }\n    }\n    encoded\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpo8n1bnm6.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpo8n1bnm6.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpo8n1bnm6.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpo8n1bnm6.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpo8n1bnm6.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo8n1bnm6.rs:18:30\n   |\n18 |             encoded.push_str(&vowels[vowel_counter]);\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `c"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index = vec![0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\
    \ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41,\
    \ 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,\
    \ 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\
    \ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\
    \ 99];\n    let mut vowels_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n   \
    \ let mut letters_index_2 = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\
    \ 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\
    \ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\
    \ 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\
    \ 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\
    \ 90, 91, 92, 93, 94, 95, 96, 97, 98, 99];\n    let mut vowels_index_3 = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    let mut letters_index_3 = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\
    \ 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,\
    \ 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,\
    \ 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,\
    \ 82, 83, 84, 85, 86, 87, 88, \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmp4qmao2ql.rs:21:1\n   |\n21 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmp4qmao2ql.rs:20:35\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n20 |     let mut letters_index_3 = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\
    \ 27, ...\n   |                                   ^ unclosed delimiter\n21 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmp4qmao2ql.rs:25:17\n   |\n25 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmp4qmao2ql.rs:25:25\n \
    \  |\n25 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4qmao2ql.rs:26:17\n   |\n26 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4qmao2ql.rs:26:25\n   |\n26 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4qmao2ql.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4qmao2ql.rs:27:25\n   |\n27 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4qmao2ql.rs:28:17\n  \
    \ |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4qmao2ql.rs:28:25\n   |\n28 |     assert_eq!({left}, {right}"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_2places = HashSet::new();\n    let mut letters = HashSet::new();\n\
    \    let mut letters_2places = HashSet::new();\n    let mut letters_3places =\
    \ HashSet::new();\n    let mut letters_4places = HashSet::new();\n    let mut\
    \ letters_5places = HashSet::new();\n    let mut letters_6places = HashSet::new();\n\
    \    let mut letters_7places = HashSet::new();\n    let mut letters_8places =\
    \ HashSet::new();\n    let mut letters_9places = HashSet::new();\n    let mut\
    \ letters_10places = HashSet::new();\n    let mut letters_11places = HashSet::new();\n\
    \    let mut letters_12places = HashSet::new();\n    let mut letters_13places\
    \ = HashSet::new();\n    let mut letters_14places = HashSet::new();\n    let mut\
    \ letters_15places = HashSet::new();\n    let mut letters_16places = HashSet::new();\n\
    \    let mut letters_17places = HashSet::new();\n    let mut letters_18places\
    \ = HashSet::new();\n    let mut letters_19places = HashSet::new();\n    let mut\
    \ letters_20places = HashSet::new();\n    let mut letters_21places = HashSet::new();\n\
    \    let mut letters_22places = HashSet::new();\n    let mut letters_23places\
    \ = HashSet::new();\n    let mut letters_24places = HashSet::new();\n    let mut\
    \ letters_25places = HashSet::new();\n    let mut letters_26places = HashSet::new();\n\
    \    let mut letters_27places = HashSet::new();\n    let mut letters_28places\
    \ = HashSet::new();\n    let mut letters_29places = HashSet::new();\n    let mut\
    \ letters_30places = HashSet::new();\n    let mut letters_31places = HashSet::new();\n\
    \    let mut letters_32places = HashSet::new();\n    let mut letters_33places\
    \ = HashSet::new();\n    let mut letters_34places = HashSet::new();\n    let mut\
    \ letters_\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkt_xwg65.rs:49:21\n   |\n\
    49 |     let mut letters_\n   |                     ^ help: add `;` here\n50 |\
    \ }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashSet`\n  --> /tmp/tmpkt_xwg65.rs:13:22\n   |\n13 |     let mut vowels\
    \ = HashSet::new();\n   |                      ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpkt_xwg65.rs:14:30\n   |\n14 |     let mut vowels_2places = HashSet::new();\n\
    \   |                              ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpkt_xwg65.rs:15:23\n   |\n15 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpkt_xwg65.rs:16:31\n\
    \   |\n16 |     let mut letters_2places = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpkt_xwg65.rs:17:31\n\
    \   |\n17 |     let mut letters_3places = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpkt_xwg65.rs:18:31\n\
    \   |\n18 |     let mut letters_4places = HashSet::new();\n   |              \
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared t"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['b', 'c', 'd', 'f', 'g', 'h',\
    \ 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z'];\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    for letter\
    \ in message.chars() {\n        if letter == ' ' {\n            result.push_str(\"\
    \ \");\n            continue;\n        }\n        if letter == 'a' || letter ==\
    \ 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n            result.push_str(&vowels[vowel_counter]);\n\
    \            vowel_counter += 1;\n            continue;\n        }\n        if\
    \ letter == 'b' || letter == 'c' || letter == 'd' || letter == 'f' || letter ==\
    \ 'g' || letter == 'h' || letter == 'j' || letter == 'k' || letter == 'l' || letter\
    \ == 'm' || letter == 'n' || letter == 'p' || letter == 'q' || letter == 'r' ||\
    \ letter == 's' || letter == 't' || letter == 'v' || letter == 'w' || letter ==\
    \ 'x' || letter == 'y' || letter == 'z' {\n            result.push_str(&letters[letter_counter]);\n\
    \            letter_counter += 1;\n            continue;\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxumrqqu6.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxumrqqu6.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxumrqqu6.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxumrqqu6.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxumrqqu6.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxumrqqu6.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxumrqqu6.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxumrqqu6.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxumrqqu6.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxumrqqu6.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxumrqqu6.rs:23:29\n   |\n23 |             result.push_str(&vowels[vowel_counter]);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found\
    \ `cha"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_2 = vec!['B',\
    \ 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',\
    \ 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_3 = vec!['B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_4 = vec!['B', 'C', 'D',\
    \ 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',\
    \ 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_5 = vec!['B', 'C', 'D', 'E',\
    \ 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\
    \ 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_6 = vec!['B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowels_7 = vec!['B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',\
    \ 'X', 'Y', 'Z'];\n    let mut vowels_8 = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H',\
    \ 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\
    \ 'Y', 'Z'];\n    let mut vowels_9 = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'];\n    let mut vowels_10 = vec!['B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\
    \ 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n  \
    \  assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmplm4fr_oh.rs:23:1\n   |\n23 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmplm4fr_oh.rs:22:29\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n22 |     let mut vowels_10 = vec!['B', 'C', 'D', 'E', 'F', 'G',\
    \ 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W\n\
    \   |                             ^ unclosed delimiter\n23 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmplm4fr_oh.rs:27:17\n   |\n27 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmplm4fr_oh.rs:27:25\n   |\n27 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmplm4fr_oh.rs:28:17\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmplm4fr_oh.rs:28:25\n   |\n28 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmplm4fr_oh.rs:29:17\n  \
    \ |\n29 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmplm4fr_oh.rs:29:25\n   |\n29 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmplm4fr_oh.rs:30:17\n   |\n30 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmplm4fr_oh.rs:30:25\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |   "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"AEIOUaeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut i = 0;\n\
    \    for letter in message.chars() {\n        if letter == ' ' {\n           \
    \ result.push_str(\" \");\n        } else {\n            result.push_str(&vowels[i\
    \ as usize]);\n            result.push_str(&letters[letter as usize]);\n     \
    \       i += 2;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpb04a4pzu.rs:30:17\n\
    \   |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb04a4pzu.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpb04a4pzu.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpb04a4pzu.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpb04a4pzu.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpb04a4pzu.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpb04a4pzu.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpb04a4pzu.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpb04a4pzu.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpb04a4pzu.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `usize`\n  --> /tmp/tmpb04a4pzu.rs:20:30\n   |\n\
    20 |             result.push_str(&vowels[i as usize]);\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^ strin"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64 = 0;\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7jelmwiu.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7jelmwiu.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7jelmwiu.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7jelmwiu.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7jelmwiu.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821832
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\
    \ 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w',\
    \ 'x', 'y', 'z'];\n    for letter in message.chars() {\n        if letter == '\
    \ ' {\n            result.push_str(\" \");\n        } else {\n            if letter\
    \ in vowels {\n                result.push_str(&letters[vowels.index(letter)].to_string());\n\
    \            } else {\n                result.push_str(&letters[letters.iter().position(|x|\
    \ x == letter).unwrap() + 1].to_string());\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpdgjzyj3a.rs:19:23\n\
    \   |\n19 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdgjzyj3a.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpdgjzyj3a.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpdgjzyj3a.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpdgjzyj3a.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpdgjzyj3a.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                 "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = String::new();\n\
    \    let mut vowels_encoded = String::new();\n    let mut vowels_encoded1 = String::new();\n\
    \    let mut vowels_encoded2 = String::new();\n    let mut vowels_encoded3 = String::new();\n\
    \    let mut vowels_encoded4 = String::new();\n    let mut vowels_encoded5 = String::new();\n\
    \    let mut vowels_encoded6 = String::new();\n    let mut vowels_encoded7 = String::new();\n\
    \    let mut vowels_encoded8 = String::new();\n    let mut vowels_encoded9 = String::new();\n\
    \    let mut vowels_encoded10 = String::new();\n    let mut vowels_encoded11 =\
    \ String::new();\n    let mut vowels_encoded12 = String::new();\n    let mut vowels_encoded13\
    \ = String::new();\n    let mut vowels_encoded14 = String::new();\n    let mut\
    \ vowels_encoded15 = String::new();\n    let mut vowels_encoded16 = String::new();\n\
    \    let mut vowels_encoded17 = String::new();\n    let mut vowels_encoded18 =\
    \ String::new();\n    let mut vowels_encoded19 = String::new();\n    let mut vowels_encoded20\
    \ = String::new();\n    let mut vowels_encoded21 = String::new();\n    let mut\
    \ vowels_encoded22 = String::new();\n    let mut vowels_encoded23 = String::new();\n\
    \    let mut vowels_encoded24 = String::new();\n    let mut vowels_encoded25 =\
    \ String::new();\n    let mut vowels_encoded26 = String::new();\n    let mut vowels_encoded27\
    \ = String::new();\n    let mut vowels_encoded28 = String::new();\n    let mut\
    \ vowels_encoded29 = String::new();\n    let mut vowels_encoded31 = String::new();\n\
    \    let mut vowels_encoded32 = String::new();\n    let mut vowels_encoded33 =\
    \ String::new();\n    let mut vowels_encoded34 = String::new();\n    let mut vowels_encoded35\
    \ = String::new();\n    let mut vowels_encoded36 = String::new();\n    let mut\
    \ vowels_encoded37 = String::new();\n    let mut vowels_encoded38 = String::new();\n\
    \    let mut vowels_encoded39 = String::new\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpt78q5j2n.rs:52:43\n   |\n\
    52 |     let mut vowels_encoded39 = String::new\n   |                        \
    \                   ^ help: add `;` here\n53 | }\n   | - unexpected token\n\n\
    error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpt78q5j2n.rs:57:17\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt78q5j2n.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt78q5j2n.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt78q5j2n.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt78q5j2n.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt78q5j2n.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt78q5j2n.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt78q5j2n.rs:60:25\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt78q5j2n.rs:61:17\n  \
    \ |\n61 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt78q5j2n.rs:61:25\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_count = vec![0];\n    let mut letters = vec!['t', 'h', 'k', 's',\
    \ 'c', 'g', 'g', 'g'];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6,\
    \ 7, 8];\n    let mut letters_count = vec![0];\n    let mut letters_index = vec![0,\
    \ 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n    let mut\
    \ letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count\
    \ = vec![0];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n \
    \   let mut letters_count = vec![0];\n    let mut letters_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n \
    \   let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count\
    \ = vec![0];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n \
    \   let mut letters_count = vec![0];\n    let mut letters_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n \
    \   let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count\
    \ = vec![0];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n \
    \   let mut letters_count = vec![0];\n    let mut letters_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n \
    \   let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_count\
    \ = vec![0];\n    let mut letters_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n \
    \   let mut letters_count = vec![0];\n    let mut letters_index = vec![0, 1, 2,\
    \ 3, 4, 5, 6, 7, 8];\n    let mut letters_count = vec![0];\n    let mut letters_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8];\n    let mut letters_\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpvkej2asd.rs:52:21\n   |\n\
    52 |     let mut letters_\n   |                     ^ help: add `;` here\n53 |\
    \ }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this\
    \ scope\n  --> /tmp/tmpvkej2asd.rs:57:17\n   |\n57 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvkej2asd.rs:57:25\n   |\n57 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpvkej2asd.rs:58:17\n   |\n58 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpvkej2asd.rs:58:25\n   |\n58 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpvkej2asd.rs:59:17\n  \
    \ |\n59 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpvkej2asd.rs:59:25\n   |\n59 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpvkej2asd.rs:60:17\n   |\n60 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpvkej2asd.rs:60:25\n\
    \   |\n60 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpvkej2asd.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpvkej2asd.rs:61:25\n   |\n61 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for c in message.chars() {\n    \
    \    if let Some(vowel) = vowels.find(c) {\n            vowel_counter += 1;\n\
    \            if vowel_counter == 2 && letter_counter < vowels.len() {\n      \
    \          result.push((letters[vowels.len() - letter_counter - 1] + letters[vowels.len()\
    \ - letter_counter]));\n                letter_counter += 1;\n            }\n\
    \            result.push(c);\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmprean0v2t.rs:34:17\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprean0v2t.rs:34:25\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmprean0v2t.rs:35:17\n   |\n35 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmprean0v2t.rs:35:25\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprean0v2t.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprean0v2t.rs:36:25\n   |\n36 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprean0v2t.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprean0v2t.rs:37:25\n   |\n37 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprean0v2t.rs:38:17\n  \
    \ |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprean0v2t.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmprean0v2t.rs:21:29\n   |\n\
    21 |                 result.push((letters[vowels.len() - letter_counter - 1] +\
    \ letters[vowels.len() - letter_counte"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_idx = 0;\n    let mut\
    \ letters_idx = 0;\n    let mut vowels_idx_prev = 0;\n    let mut letters_idx_prev\
    \ = 0;\n    let mut vowels_idx_next = 0;\n    let mut letters_idx_next = 0;\n\
    \    let mut vowels_idx_next_prev = 0;\n    let mut letters_idx_next_prev = 0;\n\
    \    let mut vowels_idx_next_next = 0;\n    let mut letters_idx_next_next = 0;\n\
    \    let mut vowels_idx_next_next_prev = 0;\n    let mut letters_idx_next_next_prev\
    \ = 0;\n    let mut vowels_idx_next_next_next = 0;\n    let mut letters_idx_next_next_next\
    \ = 0;\n    let mut vowels_idx_next_next_next_prev = 0;\n    let mut letters_idx_next_next_next_prev\
    \ = 0;\n    let mut vowels_idx_next_next_next_next = 0;\n    let mut letters_idx_next_next_next_next\
    \ = 0;\n    let mut vowels_idx_next_next_next_next_prev = 0;\n    let mut letters_idx_next_next_next_next_prev\
    \ = 0;\n    let mut vowels_idx_next_next_next_next_next = 0;\n    let mut letters_idx_next_next_next_next_next\
    \ = 0;\n    let mut vowels_idx_next_next_next_next_next_prev = 0;\n    let mut\
    \ letters_idx_next_next_next_next_next_prev = 0;\n    let mut vowels_idx_next_next_next_next_next_next\
    \ = 0;\n    let mut letters_idx_next_next_next_next_next_next = 0;\n    let mut\
    \ vowels_idx_next_next_next_next_next_next_prev = 0;\n    let mut letters_idx_next_next_next_next_next_next_prev\
    \ = 0;\n    let mut vowels_idx_next_next_next_next_next_next_next = 0;\n    let\
    \ mut letters_idx_next_next_next_next_next_next_next = 0;\n    let mut vowels_idx_next_next_next_next_next_next_next_prev\
    \ = 0;\n    let mut letters_idx_next_next_next_next_next_next_next_prev = 0;\n\
    \    let mut vowels_idx_next_next_next_next_next_next_next_next = 0;\n    let\
    \ mut letters_idx_next_next_next_next_next_next_next_next = 0;\n    let mut vowels_idx_next_next_next_next_next_next_next_next_prev\
    \ = 0;\n    let mut letters_idx_next_next_next_next_next_next_next_next_prev =\
    \ 0;\n    let mut vowels_idx_next_next_next_next_next_next_next_next_next = 0;\n\
    \    let mut letters_idx_next_next_next_next_next_next_next_next_\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp7lsn6o9f.rs:52:65\n   |\n\
    52 |     let mut letters_idx_next_next_next_next_next_next_next_next_\n   |  \
    \                                                               ^ help: add `;`\
    \ here\n53 | }\n   | - unexpected token\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared type `HashSet`\n  --> /tmp/tmp7lsn6o9f.rs:13:22\n   |\n13 |  \
    \   let mut vowels = HashSet::new();\n   |                      ^^^^^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmp7lsn6o9f.rs:14:23\n   |\n14 |     let mut letters = HashSet::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7lsn6o9f.rs:57:17\n  \
    \ |\n57 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7lsn6o9f.rs:57:25\n   |\n57 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7lsn6o9f.rs:58:17\n   |\n58 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7lsn6o9f.rs:58:25\n\
    \   |\n58 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7lsn6o9f.rs:59:17\n   |\n59 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7lsn6o9f.rs:59:25\n   |\n59 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7lsn6o9f.rs:60:17\n   |\n60 |    "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from('a'));\n    vowels.insert(String::from('e'));\n\
    \    vowels.insert(String::from('i'));\n    vowels.insert(String::from('o'));\n\
    \    vowels.insert(String::from('u'));\n    vowels.insert(String::from('y'));\n\
    \    vowels.insert(String::from('A'));\n    vowels.insert(String::from('E'));\n\
    \    vowels.insert(String::from('I'));\n    vowels.insert(String::from('O'));\n\
    \    vowels.insert(String::from('U'));\n    vowels.insert(String::from('Y'));\n\
    \    let mut i = 0;\n    let mut j = 0;\n    for c in message.chars() {\n    \
    \    if vowels.contains(&c) {\n            result.push_str(&message[j..j+2]);\n\
    \            result.push_str(&message[i..i+1]);\n            i += 2;\n       \
    \     j += 1;\n        } else {\n            result.push_str(&message[i..i+1]);\n\
    \            i += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpjnufjoyh.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjnufjoyh.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjnufjoyh.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpjnufjoyh.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpjnufjoyh.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpjnufjoyh.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpjnufjoyh.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpjnufjoyh.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpjnufjoyh.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpjnufjoyh.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpjnufjoyh.rs:48:25\n   |\n48 |     asser"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut i = 0;\n    \n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            letters.insert(letter);\n\
    \        }\n        if letter.is_lowercase() {\n            letters.insert(letter);\n\
    \        }\n    }\n    \n    for letter in letters {\n        for vowel in vowels\
    \ {\n            if letter == vowel {\n                result.push((vowel + letters[vowel\
    \ + 2]).to_string());\n                break;\n            }\n        }\n    }\n\
    \    \n    for letter in letters {\n        for vowel in vowels {\n          \
    \  if letter == vowel {\n                result.push((letter + vowels[vowel +\
    \ 2]).to_string());\n                break;\n            }\n        }\n    }\n\
    \    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp6bzj3hjd.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp6bzj3hjd.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp6bzj3hjd.rs:49:17\n   |\n49 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6bzj3hjd.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6bzj3hjd.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6bzj3hjd.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6bzj3hjd.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6bzj3hjd.rs:51:25\n   |\n51 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6bzj3hjd.rs:52:17\n  \
    \ |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6bzj3hjd.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowels_index = 0;\n    let\
    \ mut letters_index = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            letters.insert(c.to_lowercase());\n        } else {\n       \
    \     letters.insert(c.to_uppercase());\n        }\n        if letters.contains(&c.to_lowercase())\
    \ {\n            letters_index += 1;\n        }\n        if letters.contains(&c.to_uppercase())\
    \ {\n            letters_index += 1;\n        }\n        if letters_index == 2\
    \ {\n            letters_index = 0;\n            vowels_index += 1;\n        }\n\
    \        if vowels.contains(&c.to_lowercase()) {\n            vowels_index +=\
    \ 1;\n        }\n        if vowels.contains(&c.to_uppercase()) {\n           \
    \ vowels_index += 1;\n        }\n        if vowels_index == 2 {\n            vowels_index\
    \ = 0;\n            result.push(c);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp3pi3at7w.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp3pi3at7w.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp3pi3at7w.rs:49:17\n   |\n49 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3pi3at7w.rs:49:25\n\
    \   |\n49 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3pi3at7w.rs:50:17\n   |\n50 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3pi3at7w.rs:50:25\n   |\n50 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3pi3at7w.rs:51:17\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3pi3at7w.rs:51:25\n   |\n51 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3pi3at7w.rs:52:17\n  \
    \ |\n52 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3pi3at7w.rs:52:25\n   |\n52 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut vowels_index2 = -1;\n    let mut\
    \ vowels_index3 = -1;\n    let mut vowels_index4 = -1;\n    let mut vowels_index5\
    \ = -1;\n    let mut vowels_index6 = -1;\n    let mut vowels_index7 = -1;\n  \
    \  let mut vowels_index8 = -1;\n    let mut vowels_index9 = -1;\n    let mut vowels_index10\
    \ = -1;\n    let mut vowels_index11 = -1;\n    let mut vowels_index12 = -1;\n\
    \    let mut vowels_index13 = -1;\n    let mut vowels_index14 = -1;\n    let mut\
    \ vowels_index15 = -1;\n    let mut vowels_index16 = -1;\n    let mut vowels_index17\
    \ = -1;\n    let mut vowels_index18 = -1;\n    let mut vowels_index19 = -1;\n\
    \    let mut vowels_index20 = -1;\n    let mut vowels_index21 = -1;\n    let mut\
    \ vowels_index22 = -1;\n    let mut vowels_index23 = -1;\n    let mut vowels_index24\
    \ = -1;\n    let mut vowels_index25 = -1;\n    let mut vowels_index26 = -1;\n\
    \    let mut vowels_index27 = -1;\n    let mut vowels_index28 = -1;\n    let mut\
    \ vowels_index29 = -1;\n    let mut vowels_index30 = -1;\n    let mut vowels_index31\
    \ = -1;\n    let mut vowels_index32 = -1;\n    let mut vowels_index33 = -1;\n\
    \    let mut vowels_index34 = -1;\n    let mut vowels_index35 = -1;\n    let mut\
    \ vowels_index36 = -1;\n    let mut vowels_index37 = -1;\n    let mut vowels_index38\
    \ = -1;\n    let mut vowels_index39 = -1;\n    let mut vowels_index40 = -1;\n\
    \    let mut vowels_index41 = -1;\n    let mut vowels_index42 = -1;\n    let mut\
    \ vowels_index43 = -1;\n    let mut vowels_index44 = -1;\n    let mut vowels_index45\
    \ = -1;\n    let mut vowels_index46 = -1;\n    let mut vowels_index47 = -1;\n\
    \    let mut vowels_index48 = -1;\n    let mut vowels_index49 = -1;\n    let mut\
    \ vowels_index50 = -1;\n    let mut vowels_index5\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpuxzjbidn.rs:64:26\n   |\n\
    64 |     let mut vowels_index5\n   |                          ^ help: add `;`\
    \ here\n65 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpuxzjbidn.rs:69:17\n   |\n69 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpuxzjbidn.rs:69:25\n \
    \  |\n69 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpuxzjbidn.rs:70:17\n   |\n70 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpuxzjbidn.rs:70:25\n   |\n70 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpuxzjbidn.rs:71:17\n   |\n71 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpuxzjbidn.rs:71:25\n   |\n71 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpuxzjbidn.rs:72:17\n  \
    \ |\n72 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpuxzjbidn.rs:72:25\n   |\n72 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpuxzjbidn.rs:73:17\n   |\n73 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpuxzjbidn.rs:73:25\n\
    \   |\n73 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched t"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let\
    \ mut vowel_index = 0;\n    let mut letter_index = 0;\n    for c in message.chars()\
    \ {\n        if letter_index == 0 {\n            letter_index = 1;\n         \
    \   vowel_index = 0;\n        }\n        if letter_index == 2 {\n            letter_index\
    \ = 0;\n            vowel_index++;\n        }\n        if letter_index == 3 {\n\
    \            letter_index = 0;\n            vowel_index++;\n        }\n      \
    \  if letter_index == 4 {\n            letter_index = 0;\n            vowel_index++;\n\
    \        }\n        if letter_index == 5 {\n            letter_index = 0;\n  \
    \          vowel_index++;\n        }\n        if letter_index == 6 {\n       \
    \     letter_index = 0;\n            vowel_index++;\n        }\n        if letter_index\
    \ == 7 {\n            letter_index = 0;\n            vowel_index++;\n        }\n\
    \        if letter_index == 8 {\n            letter_index = 0;\n            vowel_index++;\n\
    \        }\n        if letter_index == 9 {\n            letter_index = 0;\n  \
    \          vowel_index++;\n        }\n        if letter_index == 10 {\n      \
    \      letter_index = 0;\n            vowel_index++;\n        }\n        if letter_index\
    \ == 11 {\n            letter_index = 0;\n            vowel_index++;\n       \
    \ }\n        if letter_index == 12 {\n            letter_index = 0;\n        \
    \    vowel_index++;\n        }\n        if letter_index == 13 {\n            letter_index\
    \ = 0;\n            vowel_index++;\n        }\n        if letter_index == 14 {\n\
    \            letter_index = 0;\n            vowel_index++;\n        }\n      \
    \  if letter_index == 15 {\n            letter_index = 0;\n            vowel_index++;\n\
    \        }\n        if letter_index == 16 {\n            letter_index = 0;\n \
    \           vowel_index++;\n        }\n        if letter_index == 17 {\n     \
    \       letter_index = 0;\n            vowel_index++;\n        }\n        if letter_index\
    \ == 18 {\n            letter_index = 0;\n            vowel_index++;\n       \
    \ }\n        if letter_index == 19 {\n            letter_index = 0;\n        \
    \    vowel_index++;\n        }\n        if letter_index == 20 {\n            letter_index\
    \ = 0;\n            vowel_index++;\n        }\n        if letter_index == 21 {\n\
    \            letter\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmp8uks3989.rs:110:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n18  |     for c in message.chars()\
    \ {\n    |                              - unclosed delimiter\n...\n99  |     \
    \    if letter_index == 21 {\n    |                               - this delimiter\
    \ might not be properly closed...\n100 |             letter\n101 | }\n    | -\
    \ ...as it matches this but it has different indentation\n...\n110 | }\n    |\
    \   ^\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:25:25\n\
    \   |\n25 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:29:25\n\
    \   |\n29 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:33:25\n\
    \   |\n33 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:37:25\n\
    \   |\n37 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:41:25\n\
    \   |\n41 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:45:25\n\
    \   |\n45 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:49:25\n\
    \   |\n49 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:53:25\n\
    \   |\n53 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:57:25\n\
    \   |\n57 |             vowel_index++;\n   |                         ^ expected\
    \ expression\n\nerror: expected expression, found `+`\n  --> /tmp/tmp8uks3989.rs:61:25\n\
    \   |\n61 "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    vowels.insert(String::from(\"a\"), 1);\n    vowels.insert(String::from(\"\
    e\"), 1);\n    vowels.insert(String::from(\"i\"), 1);\n    vowels.insert(String::from(\"\
    o\"), 1);\n    vowels.insert(String::from(\"u\"), 1);\n    vowels.insert(String::from(\"\
    y\"), 1);\n    vowels.insert(String::from(\"A\"), 1);\n    vowels.insert(String::from(\"\
    E\"), 1);\n    vowels.insert(String::from(\"I\"), 1);\n    vowels.insert(String::from(\"\
    O\"), 1);\n    vowels.insert(String::from(\"U\"), 1);\n    vowels.insert(String::from(\"\
    Y\"), 1);\n    vowels.insert(String::from(\"a\"), 2);\n    vowels.insert(String::from(\"\
    e\"), 2);\n    vowels.insert(String::from(\"i\"), 2);\n    vowels.insert(String::from(\"\
    o\"), 2);\n    vowels.insert(String::from(\"u\"), 2);\n    vowels.insert(String::from(\"\
    y\"), 2);\n    vowels.insert(String::from(\"A\"), 2);\n    vowels.insert(String::from(\"\
    E\"), 2);\n    vowels.insert(String::from(\"I\"), 2);\n    vowels.insert(String::from(\"\
    O\"), 2);\n    vowels.insert(String::from(\"U\"), 2);\n    vowels.insert(String::from(\"\
    Y\"), 2);\n    for c in message.chars() {\n        if let Some(index) = vowels.iter().position(|&x|\
    \ x == c) {\n            result.push(c);\n            result.push(String::from(\"\
    a\").chars().nth(index).unwrap());\n        } else {\n            result.push(c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp1zs92l5z.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1zs92l5z.rs:51:17\n  \
    \ |\n51 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1zs92l5z.rs:51:25\n   |\n51 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp1zs92l5z.rs:52:17\n   |\n52 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp1zs92l5z.rs:52:25\n\
    \   |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp1zs92l5z.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp1zs92l5z.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp1zs92l5z.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp1zs92l5z.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp1zs92l5z.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp1zs92l5z.rs:55:25\n   |\n55 |     asser"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = 0;\n    let mut letter_count = 1;\n    let mut letter_count_index\
    \ = 0;\n    let mut letter_count_index2 = 0;\n    let mut letter_count_index3\
    \ = 0;\n    let mut letter_count_index4 = 0;\n    let mut letter_count_index5\
    \ = 0;\n    let mut letter_count_index6 = 0;\n    let mut letter_count_index7\
    \ = 0;\n    let mut letter_count_index8 = 0;\n    let mut letter_count_index9\
    \ = 0;\n    let mut letter_count_index10 = 0;\n    let mut letter_count_index11\
    \ = 0;\n    let mut letter_count_index12 = 0;\n    let mut letter_count_index13\
    \ = 0;\n    let mut letter_count_index14 = 0;\n    let mut letter_count_index15\
    \ = 0;\n    let mut letter_count_index16 = 0;\n    let mut letter_count_index17\
    \ = 0;\n    let mut letter_count_index18 = 0;\n    let mut letter_count_index19\
    \ = 0;\n    let mut letter_count_index20 = 0;\n    let mut letter_count_index21\
    \ = 0;\n    let mut letter_count_index22 = 0;\n    let mut letter_count_index23\
    \ = 0;\n    let mut letter_count_index24 = 0;\n    let mut letter_count_index25\
    \ = 0;\n    let mut letter_count_index26 = 0;\n    let mut letter_count_index27\
    \ = 0;\n    let mut letter_count_index28 = 0;\n    let mut letter_count_index29\
    \ = 0;\n    let mut letter_count_index30 = 0;\n    let mut letter_count_index31\
    \ = 0;\n    let mut letter_count_index32 = 0;\n    let mut letter_count_index33\
    \ = 0;\n    let mut letter_count_index34 = 0;\n    let mut letter_count_index35\
    \ = 0;\n    let mut letter_count_index36 = 0;\n    let mut letter_count_index37\
    \ = 0;\n    let mut letter_count_index38 = 0;\n    let mut letter_count_index39\
    \ = 0;\n    let mut letter_count_index40 = 0;\n    let mut letter_count_index41\
    \ = 0;\n    let mut letter_count_index42 = 0;\n    let mut letter_count_index43\
    \ = 0;\n    let mut letter_count_index44 = 0;\n    let mut letter_count_index45\
    \ = 0;\n    let mut letter_count_index46 = 0;\n    let mut letter_count_index47\
    \ = 0;\n    let mut letter_count_index48 = 0;\n    let mut letter_count_index49\
    \ = 0;\n    let mut letter_count_index50 = 0;\n    let mut letter_count_index51\
    \ = 0;\n    let mut letter_count_index52 = 0;\n    let mut letter_count_index53\
    \ = 0;\n    let mut letter_count_index54\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpyd4e3113.rs:69:33\n   |\n\
    69 |     let mut letter_count_index54\n   |                                 ^\
    \ help: add `;` here\n70 | }\n   | - unexpected token\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyd4e3113.rs:74:17\n   |\n74 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyd4e3113.rs:74:25\n\
    \   |\n74 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpyd4e3113.rs:75:17\n   |\n75 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpyd4e3113.rs:75:25\n   |\n75 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpyd4e3113.rs:76:17\n   |\n76 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpyd4e3113.rs:76:25\n   |\n76 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpyd4e3113.rs:77:17\n  \
    \ |\n77 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpyd4e3113.rs:77:25\n   |\n77 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpyd4e3113.rs:78:17\n   |\n78 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpyd4e3113.rs:78:25\n\
    \   |\n78 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0308]"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letter_map = HashMap::new();\n\
    \    for letter in message.chars() {\n        if let Some(index) = vowels.iter().position(|&vowel|\
    \ vowel == letter) {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \        } else {\n            result.push_str(&letter);\n        }\n    }\n \
    \   for vowel in vowels.iter() {\n        letter_map.insert(vowel, result.chars().next().unwrap());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5oct31tk.rs:14:26\n   |\n14 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5oct31tk.rs:30:17\n  \
    \ |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5oct31tk.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp5oct31tk.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp5oct31tk.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp5oct31tk.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp5oct31tk.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp5oct31tk.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp5oct31tk.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp5oct31tk.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp5oct31tk.rs:34:25\n   |\n34 |  "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut letters = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut vowels_counter =\
    \ 0;\n    let mut letters_counter = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            if letter == vowels[vowels_counter] {\n                result.push_str(&vowels[vowels_counter]);\n\
    \                vowels_counter += 1;\n            } else {\n                result.push_str(&letters[letters_counter]);\n\
    \                letters_counter += 1;\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpofcu0l1c.rs:35:17\n\
    \   |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpofcu0l1c.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpofcu0l1c.rs:36:17\n   |\n36 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpofcu0l1c.rs:36:25\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpofcu0l1c.rs:37:17\n   |\n37 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpofcu0l1c.rs:37:25\n   |\n37 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpofcu0l1c.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpofcu0l1c.rs:38:25\n   |\n38 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpofcu0l1c.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpofcu0l1c.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpofcu0l1c.rs:22:33\n   |\n22 |                 result.push_str(&vowels[vowels_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut vowels_index = -1;\n    let mut letter_count = 1;\n    let mut\
    \ letter_index = 0;\n    for letter in message.chars() {\n        if letter ==\
    \ ' ' {\n            result.push_str(&format!(\"{}\", letter));\n        } else\
    \ {\n            if letter_count > 2 {\n                result.push_str(&format!(\"\
    {}{}\", vowels[vowels_index], letter));\n            } else {\n              \
    \  result.push_str(&format!(\"{}{}\", letter, vowels[vowels_index]));\n      \
    \      }\n            vowels_index += 1;\n            letter_count += 1;\n   \
    \     }\n        letter_index += 1;\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4nfohalw.rs:36:17\n\
    \   |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4nfohalw.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4nfohalw.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4nfohalw.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4nfohalw.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4nfohalw.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4nfohalw.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4nfohalw.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4nfohalw.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4nfohalw.rs:40:25\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `str` cannot be indexed by `{integer}`\n  --> /tmp/tmp4nfohalw.rs:22:50\n  \
    \ |\n22 |                 result.push_str(&format!(\"{}{}\", vowels[vowels_index],\
    \ letter));\n   |                   "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut alphabet = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message {\n        if letter in vowels {\n         \
    \   vowel_counter += 1;\n            if vowel_counter == 2 && letter_counter <\
    \ alphabet.len() {\n                result += alphabet[letter_counter];\n    \
    \        }\n            letter_counter += 1;\n        } else {\n            result\
    \ += letter;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmp3xna7dsw.rs:18:19\n\
    \   |\n18 |         if letter in vowels {\n   |         --        ^^ expected\
    \ `{`\n   |         |\n   |         this `if` expression has a condition, but\
    \ no block\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp3xna7dsw.rs:33:17\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xna7dsw.rs:33:25\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp3xna7dsw.rs:34:17\n   |\n34 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp3xna7dsw.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp3xna7dsw.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp3xna7dsw.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp3xna7dsw.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp3xna7dsw.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp3xna7dsw.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp3xna7dsw.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ no"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_map = vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"\
    , \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\"\
    , \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut\
    \ letter_map_index = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\
    \ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut\
    \ letter_map_reverse = vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"\
    H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"\
    S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_map_reverse_index\
    \ = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\
    \ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse2\
    \ = vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"\
    , \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\"\
    , \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_map_reverse2_index =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse3\
    \ = vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"\
    , \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\"\
    , \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_map_reverse3_index =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31];\n    let mut letter_map_reverse4\
    \ = vec![\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\"\
    , \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\"\
    , \"V\", \"W\", \"X\", \"Y\", \"Z\"];\n    let mut letter_map_reverse4_index =\
    \ vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, \n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpcy2qs1ot.rs:25:1\n   |\n25 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpcy2qs1ot.rs:24:45\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |                                      - closing delimiter possibly meant\
    \ for this\n...\n24 |     let mut letter_map_reverse4_index = vec![0, 1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, \n   |           \
    \                                  ^ unclosed delimiter\n25 | }\n   | ^ mismatched\
    \ closing delimiter\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpcy2qs1ot.rs:29:17\n   |\n29 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpcy2qs1ot.rs:29:25\n   |\n29 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpcy2qs1ot.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpcy2qs1ot.rs:30:25\n   |\n30 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpcy2qs1ot.rs:31:17\n  \
    \ |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpcy2qs1ot.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpcy2qs1ot.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpcy2qs1ot.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |        "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut consonants = vec!['b',\
    \ 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'];\n    let mut vowel_counter = 0;\n    let mut consonant_counter\
    \ = 0;\n    let mut current_letter = String::new();\n    let mut current_consonant\
    \ = String::new();\n    let mut current_vowel = String::new();\n    let mut current_consonant_counter\
    \ = 0;\n    let mut current_vowel_counter = 0;\n    let mut current_consonant_vowel\
    \ = String::new();\n    let mut current_vowel_consonant = String::new();\n   \
    \ let mut current_consonant_vowel_counter = 0;\n    let mut current_vowel_consonant_counter\
    \ = 0;\n    let mut current_consonant_vowel_consonant = String::new();\n    let\
    \ mut current_vowel_consonant_vowel = String::new();\n    let mut current_vowel_consonant_vowel_counter\
    \ = 0;\n    let mut current_vowel_consonant_vowel_consonant = String::new();\n\
    \    let mut current_vowel_consonant_vowel_consonant_counter = 0;\n    let mut\
    \ current_vowel_consonant_vowel_consonant_vowel = String::new();\n    let mut\
    \ current_vowel_consonant_vowel_consonant_vowel_counter = 0;\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = String::new();\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant_counter\
    \ = 0;\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant_vowel\
    \ = String::new();\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant_vowel_counter\
    \ = 0;\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant\
    \ = String::new();\n    let mut current_vowel_consonant_vowel_consonant_vowel_consonant_vowel_consonant_counter\
    \ = 0;\n    let mut current_vowel_consonant_\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmp9xm9xl6p.rs:39:37\n   |\n\
    39 |     let mut current_vowel_consonant_\n   |                              \
    \       ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:44:17\n  \
    \ |\n44 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9xm9xl6p.rs:44:25\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:45:17\n   |\n45 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:45:25\n\
    \   |\n45 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp9xm9xl6p.rs:46:17\n   |\n46 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:46:25\n   |\n46 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp9xm9xl6p.rs:47:17\n   |\n47 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:47:25\n   |\n47 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp9xm9xl6p.rs:48:17\n  \
    \ |\n48 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp9xm9xl6p.rs:48:25\n   |\n48 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerro"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message.chars() {\n\
    \        if vowels.contains(&letter) {\n            if vowel_counter < 2 {\n \
    \               result.push((&letters[letter_counter]).to_string());\n       \
    \         letter_counter += 1;\n            } else {\n                result.push((&letters[letter_counter]).to_string());\n\
    \                letter_counter += 2;\n                vowel_counter += 1;\n \
    \           }\n        } else {\n            result.push((&letters[letter_counter]).to_string());\n\
    \            letter_counter += 1;\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8xwdb1d8.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8xwdb1d8.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8xwdb1d8.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8xwdb1d8.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8xwdb1d8.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8xwdb1d8.rs:18:28\n   |\n18 |         if vowels.contains(&letter)\
    \ {\n   |                            ^^^^^^^ expected `&str`, found `char`\n \
    \  |\n   = note: expected re"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_map = HashMap::new();\n    for vowel\
    \ in vowels {\n        vowels_map.insert(vowel.to_string(), vowel);\n    }\n \
    \   for letter in message.chars() {\n        if let Some(vowel) = vowels_map.get(&letter)\
    \ {\n            result.push((vowel + letter).to_string());\n        } else {\n\
    \            result.push(letter);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4bu2cpqo.rs:14:26\n   |\n14 |     let mut vowels_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:30:17\n  \
    \ |\n30 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4bu2cpqo.rs:30:25\n   |\n30 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:31:17\n   |\n31 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:31:25\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4bu2cpqo.rs:32:17\n   |\n32 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:32:25\n   |\n32 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4bu2cpqo.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:33:25\n   |\n33 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4bu2cpqo.rs:34:17\n  \
    \ |\n34 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4bu2cpqo.rs:34:25\n   |\n34 |  "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut index = 0;\n    let mut letter = message.chars().nth(index).unwrap();\n\
    \    while letter != ' ' {\n        if vowels.contains(&letter) {\n          \
    \  result.push((&vowels[(index + 1) % vowels.len()]).to_string());\n         \
    \   vowels.remove(&letter);\n        } else {\n            result.push((&letter).to_string());\n\
    \        }\n        index += 1; \n        letter = message.chars().nth(index).unwrap();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4zy_ebva.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4zy_ebva.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4zy_ebva.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4zy_ebva.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4zy_ebva.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4zy_ebva.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4zy_ebva.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4zy_ebva.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4zy_ebva.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4zy_ebva.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp4zy_ebva.rs:17:28\n   |\n\
    17 |         if vowels.contains(&letter) {\n   |                            ^^^^^^^\
    \ expected an `Fn<(char,)>` c"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    let mut letters = \"abcdefghijklmnopqrstuvwxyz\";\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    let mut i = 0;\n    while i < message.len()\
    \ {\n        if message[i] == letters[letters_index] {\n            result +=\
    \ message[i];\n            letters_index += 1;\n        } else {\n           \
    \ result += letters[letters_index];\n            letters_index = 0;\n        }\n\
    \        if letters_index == letters.len() {\n            letters_index = 0;\n\
    \            vowels_index += 1;\n        }\n        if vowels_index == vowels.len()\
    \ {\n            vowels_index = 0;\n            letters_index += 1;\n        }\n\
    \        i += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpy374xtfb.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy374xtfb.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpy374xtfb.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpy374xtfb.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpy374xtfb.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpy374xtfb.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpy374xtfb.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpy374xtfb.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpy374xtfb.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpy374xtfb.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpy374xtfb.rs:19:12\n   |\n\
    19 |         if message[i] == letters[letters_index] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed b"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    for letter in message.chars() {\n\
    \        if letter.is_uppercase() {\n            letters.insert(letter);\n   \
    \     } else {\n            vowels.insert(letter);\n        }\n    }\n    for\
    \ vowel in vowels.iter() {\n        let mut index = vowels.iter().position(|&x|\
    \ x == vowel).unwrap();\n        result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \    }\n    for letter in letters.iter() {\n        result.push_str(&letter);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpye2_xw6s.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmpye2_xw6s.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmpye2_xw6s.rs:34:17\n   |\n34 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpye2_xw6s.rs:34:25\n\
    \   |\n34 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpye2_xw6s.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpye2_xw6s.rs:35:25\n   |\n35 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpye2_xw6s.rs:36:17\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpye2_xw6s.rs:36:25\n   |\n36 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpye2_xw6s.rs:37:17\n  \
    \ |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpye2_xw6s.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec!['A',\
    \ 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',\
    \ 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    for\
    \ c in message.chars() {\n        if index == 0 {\n            encoded.push(c);\n\
    \        } else {\n            if vowels.contains(&c) {\n                encoded.push(vowels[(index\
    \ - 2) as usize]);\n            } else {\n                encoded.push(c);\n \
    \           }\n        }\n        index += 1;\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp6k1j_zop.rs:32:17\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6k1j_zop.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp6k1j_zop.rs:33:17\n   |\n33 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp6k1j_zop.rs:33:25\n\
    \   |\n33 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp6k1j_zop.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp6k1j_zop.rs:34:25\n   |\n34 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp6k1j_zop.rs:35:17\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp6k1j_zop.rs:35:25\n   |\n35 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp6k1j_zop.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp6k1j_zop.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 10 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut index = 0;\n\
    \    let mut index2 = 0;\n    let mut index3 = 0;\n    let mut index4 = 0;\n \
    \   let mut index5 = 0;\n    let mut index6 = 0;\n    let mut index7 = 0;\n  \
    \  let mut index8 = 0;\n    let mut index9 = 0;\n    let mut index10 = 0;\n  \
    \  let mut index11 = 0;\n    let mut index12 = 0;\n    let mut index13 = 0;\n\
    \    let mut index14 = 0;\n    let mut index15 = 0;\n    let mut index16 = 0;\n\
    \    let mut index17 = 0;\n    let mut index18 = 0;\n    let mut index19 = 0;\n\
    \    let mut index20 = 0;\n    let mut index21 = 0;\n    let mut index22 = 0;\n\
    \    let mut index23 = 0;\n    let mut index24 = 0;\n    let mut index25 = 0;\n\
    \    let mut index26 = 0;\n    let mut index27 = 0;\n    let mut index28 = 0;\n\
    \    let mut index29 = 0;\n    let mut index30 = 0;\n    let mut index31 = 0;\n\
    \    let mut index32 = 0;\n    let mut index33 = 0;\n    let mut index34 = 0;\n\
    \    let mut index35 = 0;\n    let mut index36 = 0;\n    let mut index37 = 0;\n\
    \    let mut index38 = 0;\n    let mut index39 = 0;\n    let mut index40 = 0;\n\
    \    let mut index41 = 0;\n    let mut index42 = 0;\n    let mut index43 = 0;\n\
    \    let mut index44 = 0;\n    let mut index45 = 0;\n    let mut index46 = 0;\n\
    \    let mut index47 = 0;\n    let mut index48 = 0;\n    let mut index49 = 0;\n\
    \    let mut index50 = 0;\n    let mut index51 = 0;\n    let mut index52 = 0;\n\
    \    let mut index53 = 0;\n    let mut index54 = 0;\n    let mut index55 = 0;\n\
    \    let mut index56 = 0;\n    let mut index57 = 0;\n    let mut index58 = 0;\n\
    \    let mut index59 = 0;\n    let mut index60 = 0;\n    let mut index61 = 0;\n\
    \    let mut index62 = 0;\n    let mut index63 = 0;\n    let mut index64\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n \
    \   assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpkl3z9pcv.rs:78:20\n   |\n\
    78 |     let mut index64\n   |                    ^ help: add `;` here\n79 | }\n\
    \   | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkl3z9pcv.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpkl3z9pcv.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpkl3z9pcv.rs:85:25\n   |\n85 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:86:17\n   |\n86 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:86:25\n\
    \   |\n86 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpkl3z9pcv.rs:87:17\n   |\n87 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpkl3z9pcv.rs:87:25\n   |\n87 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut vowel_counter = 0;\n    let mut letter_counter\
    \ = 0;\n    for letter in message.chars() {\n        if letter == ' ' {\n    \
    \        result.push_str(\" \");\n        } else {\n            if letter == vowels[vowel_counter]\
    \ {\n                result.push_str(vowels[vowel_counter]);\n               \
    \ vowel_counter = vowel_counter + 1;\n            } else {\n                let\
    \ mut new_letter = letters[letter_counter];\n                letter_counter =\
    \ letter_counter + 1;\n                while vowel_counter < vowels.len() && letter\
    \ == vowels[vowel_counter] {\n                    new_letter = letters[letter_counter];\n\
    \                    letter_counter = letter_counter + 1;\n                  \
    \  vowel_counter = vowel_counter + 1;\n                }\n                result.push_str(new_letter);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:41:17\n\
    \   |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxo6hv7mn.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpxo6hv7mn.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpxo6hv7mn.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpxo6hv7mn.rs:45:17\n  \
    \ |\n45 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpxo6hv7mn.rs:45:25\n   |\n45 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxo6hv7mn.rs:22:33\n   |\n22 |                 result.push_str(vowels[vowel_counter]);\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^^^^ expected `&str`, fou"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowels_index\
    \ = 0;\n    let mut letters_index = 0;\n    for letter in message.chars() {\n\
    \        if letter == ' ' {\n            result.push_str(\" \");\n        } else\
    \ {\n            result.push_str(&letters[letters_index]);\n            if letter\
    \ == vowels[vowels_index] {\n                vowels_index += 1;\n            }\
    \ else {\n                letters_index += 1;\n            }\n        }\n    }\n\
    \    if vowels_index != 0 {\n        result.push_str(&vowels[vowels_index]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpelxgh94l.rs:37:17\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpelxgh94l.rs:37:25\n   |\n37 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpelxgh94l.rs:38:17\n   |\n38 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpelxgh94l.rs:38:25\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpelxgh94l.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpelxgh94l.rs:39:25\n   |\n39 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpelxgh94l.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpelxgh94l.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpelxgh94l.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpelxgh94l.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpelxgh94l.rs:22:26\n   |\n22 |             if letter ==\
    \ vowels[vowels_index] {\n   |                          ^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found `&str`\n\nerror"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index2 = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_count_index3 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index4\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index5 = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_count_index6 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index7\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index8 = vec![0, 1, 2, 3, 4];\n\
    \    let mut letter_count_index9 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index10\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index11 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index12 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index13\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index14 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index15 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index16\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index17 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index18 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index19\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index20 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index21 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index22\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index23 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index24 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index25\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index26 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index27 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index28\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index29 = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count_index30 = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index31\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letter_count_index32 = \n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmprh9jxj7l.rs:48:1\n\
    \   |\n48 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmprh9jxj7l.rs:52:17\n   |\n52 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmprh9jxj7l.rs:52:25\n \
    \  |\n52 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmprh9jxj7l.rs:53:17\n   |\n53 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmprh9jxj7l.rs:53:25\n   |\n53 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmprh9jxj7l.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmprh9jxj7l.rs:54:25\n   |\n54 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmprh9jxj7l.rs:55:17\n  \
    \ |\n55 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmprh9jxj7l.rs:55:25\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmprh9jxj7l.rs:56:17\n   |\n56 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmprh9jxj7l.rs:56:25\n\
    \   |\n56 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut letters = vec![\"a\", \"e\", \"\
    i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letters_index = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next = vec![0,\
    \ 1, 2, 3, 4];\n    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n    let\
    \ mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n\
    \    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n    let mut letters_index_next\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut letters_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n\
    \    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n    let mut letters_index_next\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n\
    \    let mut letters_index_prev = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n\
    \    let mut vowels_index_prev = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_next = vec![0, 1, 2, 3, 4];\n\
    \    let mut letters_index_next = vec![0, 1, 2, 3, 4];\n    let mut vowels_index_prev\
    \ = vec![0, 1, 2, 3, 4];\n    let mut letters_index_prev = \n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpz0cu0uaj.rs:49:1\n\
    \   |\n49 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpz0cu0uaj.rs:53:17\n   |\n53 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:53:25\n \
    \  |\n53 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpz0cu0uaj.rs:54:17\n   |\n54 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:54:25\n   |\n54 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpz0cu0uaj.rs:55:17\n   |\n55 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:55:25\n   |\n55 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:56:17\n  \
    \ |\n56 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpz0cu0uaj.rs:56:25\n   |\n56 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:57:17\n   |\n57 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpz0cu0uaj.rs:57:25\n\
    \   |\n57 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowels_idx = 0;\n    let mut letter_counts = HashMap::new();\n  \
    \  for letter in message.chars() {\n        if let Some(idx) = vowels.iter().position(|&x|\
    \ x == letter) {\n            result.push_str(&message[vowels_idx + idx]);\n \
    \       } else {\n            result.push_str(&letter);\n        }\n        if\
    \ let Some(idx) = letter_counts.iter().position(|&(_, count)| count == 2) {\n\
    \            vowels_idx += idx;\n            letter_counts.remove(&(letter, 2));\n\
    \        } else {\n            vowels.insert(letter);\n            letter_counts.insert(letter,\
    \ 1);\n        }\n    }\n    if let Some(idx) = letter_counts.iter().position(|&(_,\
    \ count)| count == 2) {\n        vowels_idx += idx;\n    }\n    result.push_str(&message[vowels_idx..]);\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpsi01j905.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpsi01j905.rs:15:29\n\
    \   |\n15 |     let mut letter_counts = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpsi01j905.rs:39:17\n  \
    \ |\n39 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpsi01j905.rs:39:25\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpsi01j905.rs:40:17\n   |\n40 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpsi01j905.rs:40:25\n\
    \   |\n40 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpsi01j905.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpsi01j905.rs:41:25\n   |\n41 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpsi01j905.rs:42:17\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpsi01j905.rs:42:25\n   |\n42 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    ;\n    let mut index = 0;\n    for c in message.chars() {\n        if let Some(vowel)\
    \ = vowels.find(&c) {\n            result.push_str(&vowels[(index + 1) % vowels.len()]);\n\
    \            index = vowels.len() - 1;\n        } else {\n            result.push_str(&c);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp4pkirqsm.rs:28:17\n\
    \   |\n28 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4pkirqsm.rs:28:25\n   |\n28 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4pkirqsm.rs:29:17\n   |\n29 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4pkirqsm.rs:29:25\n\
    \   |\n29 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4pkirqsm.rs:30:17\n   |\n30 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4pkirqsm.rs:30:25\n   |\n30 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4pkirqsm.rs:31:17\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4pkirqsm.rs:31:25\n   |\n31 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4pkirqsm.rs:32:17\n  \
    \ |\n32 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4pkirqsm.rs:32:25\n   |\n32 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n  --> /tmp/tmp4pkirqsm.rs:16:42\n   |\n\
    16 |         if let Some(vowel) = vowels.find(&c) {\n   |                    \
    \                      ^^ expected "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4];\n    let\
    \ mut letter_map = HashMap::new();\n    for letter in message.chars() {\n    \
    \    letter_map.insert(letter, letter);\n    }\n    for letter in vowels.iter()\
    \ {\n        letter_map.insert(letter, letter);\n    }\n    for letter in message.chars()\
    \ {\n        if let Some(index) = vowels_index.iter().position(|&i| {\n      \
    \      i == letter_map.get(letter)\n        }) {\n            result.push((letter_map.get(letter)\
    \ + index) % 26);\n        } else {\n            result.push(letter_map.get(letter));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp4fht3y81.rs:15:26\n   |\n15 |     let mut letter_map = HashMap::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4fht3y81.rs:36:17\n  \
    \ |\n36 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4fht3y81.rs:36:25\n   |\n36 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp4fht3y81.rs:37:17\n   |\n37 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp4fht3y81.rs:37:25\n\
    \   |\n37 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp4fht3y81.rs:38:17\n   |\n38 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp4fht3y81.rs:38:25\n   |\n38 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp4fht3y81.rs:39:17\n   |\n39 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp4fht3y81.rs:39:25\n   |\n39 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp4fht3y81.rs:40:17\n  \
    \ |\n40 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp4fht3y81.rs:40:25\n   |\n40 |  "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut letters = HashSet::new();\n    let mut vowel_pos = 0;\n    let mut\
    \ letter_pos = 0;\n    for c in message.chars() {\n        if c.is_uppercase()\
    \ {\n            letters.insert(c.to_lowercase());\n        } else {\n       \
    \     letters.insert(c.to_uppercase());\n        }\n        if letters.contains(&c.to_lowercase())\
    \ {\n            vowels.insert(c.to_lowercase());\n        }\n        if letters.contains(&c.to_uppercase())\
    \ {\n            vowels.insert(c.to_uppercase());\n        }\n    }\n    for c\
    \ in message.chars() {\n        if letters.contains(&c.to_lowercase()) {\n   \
    \         result.push(c);\n            letter_pos += 1;\n        }\n        if\
    \ letters.contains(&c.to_uppercase()) {\n            result.push(c);\n       \
    \     letter_pos += 1;\n        }\n        if vowels.contains(&c.to_lowercase())\
    \ {\n            result.push(c);\n            vowel_pos += 1;\n        }\n   \
    \     if vowels.contains(&c.to_uppercase()) {\n            result.push(c);\n \
    \           vowel_pos += 1;\n        }\n    }\n    if vowel_pos == 0 {\n     \
    \   result.push(*vowels.iter().next().unwrap());\n    }\n    if letter_pos ==\
    \ 0 {\n        result.push(*letters.iter().next().unwrap());\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp8kq3g73a.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashSet`\n  --> /tmp/tmp8kq3g73a.rs:14:23\n\
    \   |\n14 |     let mut letters = HashSet::new();\n   |                      \
    \ ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]: cannot find\
    \ value `left` in this scope\n  --> /tmp/tmp8kq3g73a.rs:59:17\n   |\n59 |    \
    \ assert_eq!({left}, {right});\n   |                 ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp8kq3g73a.rs:59:25\n\
    \   |\n59 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp8kq3g73a.rs:60:17\n   |\n60 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp8kq3g73a.rs:60:25\n   |\n60 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp8kq3g73a.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp8kq3g73a.rs:61:25\n   |\n61 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp8kq3g73a.rs:62:17\n  \
    \ |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp8kq3g73a.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in th"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = \"aeiouAEIOU\"\
    .to_string();\n    let mut index = 0;\n    let mut index2 = 0;\n    let mut index3\
    \ = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut index6 =\
    \ 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9 = 0;\n\
    \    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12 = 0;\n\
    \    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15 = 0;\n\
    \    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18 = 0;\n\
    \    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21 = 0;\n\
    \    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24 = 0;\n\
    \    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27 = 0;\n\
    \    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30 = 0;\n\
    \    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33 = 0;\n\
    \    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36 = 0;\n\
    \    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39 = 0;\n\
    \    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42 = 0;\n\
    \    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45 = 0;\n\
    \    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48 = 0;\n\
    \    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51 = 0;\n\
    \    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54 = 0;\n\
    \    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57 = 0;\n\
    \    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60 = 0;\n\
    \    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63 = 0;\n\
    \    let mut index64 = 0;\n    let mut index65 = 0;\n    let mut index66 = 0;\n\
    \    let mut index67 = 0;\n    let mut index68 = 0;\n    let mut index69 = 0;\n\
    \    let mut index70 = 0;\n    let mut index\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpaoftn30m.rs:84:18\n   |\n\
    84 |     let mut index\n   |                  ^ help: add `;` here\n85 | }\n \
    \  | - unexpected token\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaoftn30m.rs:89:17\n   |\n89 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaoftn30m.rs:89:25\n   |\n89 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpaoftn30m.rs:90:17\n   |\n90 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpaoftn30m.rs:90:25\n   |\n90 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpaoftn30m.rs:91:17\n  \
    \ |\n91 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpaoftn30m.rs:91:25\n   |\n91 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpaoftn30m.rs:92:17\n   |\n92 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpaoftn30m.rs:92:25\n\
    \   |\n92 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpaoftn30m.rs:93:17\n   |\n93 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpaoftn30m.rs:93:25\n   |\n93 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowels = HashSet::new();\n\
    \    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n    let mut\
    \ letter_counter2 = 0;\n    let mut letter_counter3 = 0;\n    let mut letter_counter4\
    \ = 0;\n    let mut letter_counter5 = 0;\n    let mut letter_counter6 = 0;\n \
    \   let mut letter_counter7 = 0;\n    let mut letter_counter8 = 0;\n    let mut\
    \ letter_counter9 = 0;\n    let mut letter_counter10 = 0;\n    let mut letter_counter11\
    \ = 0;\n    let mut letter_counter12 = 0;\n    let mut letter_counter13 = 0;\n\
    \    let mut letter_counter14 = 0;\n    let mut letter_counter15 = 0;\n    let\
    \ mut letter_counter16 = 0;\n    let mut letter_counter17 = 0;\n    let mut letter_counter18\
    \ = 0;\n    let mut letter_counter19 = 0;\n    let mut letter_counter20 = 0;\n\
    \    let mut letter_counter21 = 0;\n    let mut letter_counter22 = 0;\n    let\
    \ mut letter_counter23 = 0;\n    let mut letter_counter24 = 0;\n    let mut letter_counter25\
    \ = 0;\n    let mut letter_counter26 = 0;\n    let mut letter_counter27 = 0;\n\
    \    let mut letter_counter28 = 0;\n    let mut letter_counter29 = 0;\n    let\
    \ mut letter_counter30 = 0;\n    let mut letter_counter31 = 0;\n    let mut letter_counter32\
    \ = 0;\n    let mut letter_counter33 = 0;\n    let mut letter_counter34 = 0;\n\
    \    let mut letter_counter35 = 0;\n    let mut letter_counter36 = 0;\n    let\
    \ mut letter_counter37 = 0;\n    let mut letter_counter38 = 0;\n    let mut letter_counter39\
    \ = 0;\n    let mut letter_counter40 = 0;\n    let mut letter_counter41 = 0;\n\
    \    let mut letter_counter42 = 0;\n    let mut letter_counter43 = 0;\n    let\
    \ mut letter_counter44 = 0;\n    let mut letter_counter45 = 0;\n    let mut letter_counter46\
    \ = 0;\n    let mut letter_counter47 = 0;\n    let mut letter_counter48 = 0;\n\
    \    let mut letter_counter49 = 0;\n    let mut letter_counter50 = 0;\n    let\
    \ mut letter_counter51 = 0;\n    let mut letter_counter52 = 0;\n    let mut letter_counter53\
    \ = 0;\n    let mut letter_counter54 = 0;\n    let mut letter_counter55 = 0;\n\
    \    let mut letter_counter56 = 0;\n    let mut letter_counter57 = 0;\n    let\
    \ mut letter_counter58 = 0;\n    let mut letter_counter59 = 0;\n    let mut letter_counter60\
    \ = 0;\n    let mut letter_counter61 = 0;\n\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpv8tovy9n.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv8tovy9n.rs:81:17\n  \
    \ |\n81 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv8tovy9n.rs:81:25\n   |\n81 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpv8tovy9n.rs:82:17\n   |\n82 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpv8tovy9n.rs:82:25\n\
    \   |\n82 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpv8tovy9n.rs:83:17\n   |\n83 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpv8tovy9n.rs:83:25\n   |\n83 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpv8tovy9n.rs:84:17\n   |\n84 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpv8tovy9n.rs:84:25\n   |\n84 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpv8tovy9n.rs:85:17\n  \
    \ |\n85 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpv8tovy9n.rs:85:25\n   |\n85 |     asser"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut letters = vec![\"b\", \"c\", \"\
    d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"\
    r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n    let mut vowel_counter\
    \ = 0;\n    let mut letter_counter = 0;\n    for letter in message {\n       \
    \ if letter == letters[letter_counter] {\n            letter_counter += 1;\n \
    \       } else {\n            letter_counter = 0;\n        }\n        if vowels[vowel_counter]\
    \ == letters[letter_counter] {\n            vowel_counter += 1;\n        } else\
    \ {\n            vowel_counter = 0;\n        }\n        result.push(letters[letter_counter]);\n\
    \    }\n    if vowel_counter > 0 {\n        result.push(vowels[vowel_counter]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:38:17\n\
    \   |\n38 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd8ge7v8a.rs:38:25\n   |\n38 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:39:17\n   |\n39 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:39:25\n\
    \   |\n39 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpd8ge7v8a.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:40:25\n   |\n40 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpd8ge7v8a.rs:41:17\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:41:25\n   |\n41 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpd8ge7v8a.rs:42:17\n  \
    \ |\n42 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpd8ge7v8a.rs:42:25\n   |\n42 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpd8ge7v8a.rs:17:19\n    |\n17  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_counts = vec![0];\n    let mut letter_counts_index =\
    \ vec![0];\n    let mut letter = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut vowel = String::new();\n    let mut vowel_index = String::new();\n\
    \    let mut letter_count = String::new();\n    let mut letter_index = String::new();\n\
    \    let mut vowel_count = String::new();\n    let mut vowel_index = String::new();\n\
    \    let mut letter_count_index = String::new();\n    let mut vowel_index_index\
    \ = String::new();\n    let mut vowel_count_index = String::new();\n    let mut\
    \ letter_count_index = String::new();\n    let mut vowel_index_index = String::new();\n\
    \    let mut vowel_count_index = String::new();\n    let mut letter_count_index\
    \ = String::new();\n    let mut vowel_index_index = String::new();\n    let mut\
    \ vowel_count_index = String::new();\n    let mut letter_count_index = String::new();\n\
    \    let mut vowel_index_index = String::new();\n    let mut vowel_count_index\
    \ = String::new();\n    let mut letter_count_index = String::new();\n    let mut\
    \ vowel_index_index = String::new();\n    let mut vowel_count_index = String::new();\n\
    \    let mut letter_count_index = String::new();\n    let mut vowel_index_index\
    \ = String::new();\n    let mut vowel_count_index = String::new();\n    let mut\
    \ letter_count_index = String::new();\n    let mut vowel_index_index = String::new();\n\
    \    let mut vowel_count_index = String::new();\n    let mut letter_count_index\
    \ = String::new();\n    let mut vowel_index_index = String::new();\n    let mut\
    \ vowel_count_index = String::new();\n    let mut letter_count_index = String::new();\n\
    \    let mut vowel_index_index = String::new();\n    let mut vowel_count_index\
    \ = String::new();\n    let mut letter_count_index = String::new();\n    let mut\
    \ vowel_index_index = String::new();\n    let mut vowel_count_index = String::new();\n\
    \    let mut letter_count_index = String::new();\n    let mut vowel_index_index\
    \ = String::new();\n    let mut vowel_count_index = String\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `}`\n  --> /tmp/tmpx2s7y62y.rs:57:39\n   |\n\
    57 |     let mut vowel_count_index = String\n   |                            \
    \           ^ help: add `;` here\n58 | }\n   | - unexpected token\n\nerror[E0423]:\
    \ expected value, found struct `String`\n   --> /tmp/tmpx2s7y62y.rs:57:33\n  \
    \  |\n57  |       let mut vowel_count_index = String\n    |                  \
    \                 ^^^^^^ help: use struct literal syntax instead: `String { vec:\
    \ val }`\n\nerror[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpx2s7y62y.rs:62:17\n\
    \   |\n62 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpx2s7y62y.rs:62:25\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpx2s7y62y.rs:63:17\n   |\n63 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpx2s7y62y.rs:63:25\n\
    \   |\n63 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpx2s7y62y.rs:64:17\n   |\n64 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpx2s7y62y.rs:64:25\n   |\n64 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpx2s7y62y.rs:65:17\n   |\n65 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpx2s7y62y.rs:65:25\n   |\n65 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpx2s7y62y.rs:66:17\n  \
    \ |\n66 |     assert_eq!({left}, {"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut index = 0;\n    let mut index2 = 0;\n    let\
    \ mut index3 = 0;\n    let mut index4 = 0;\n    let mut index5 = 0;\n    let mut\
    \ index6 = 0;\n    let mut index7 = 0;\n    let mut index8 = 0;\n    let mut index9\
    \ = 0;\n    let mut index10 = 0;\n    let mut index11 = 0;\n    let mut index12\
    \ = 0;\n    let mut index13 = 0;\n    let mut index14 = 0;\n    let mut index15\
    \ = 0;\n    let mut index16 = 0;\n    let mut index17 = 0;\n    let mut index18\
    \ = 0;\n    let mut index19 = 0;\n    let mut index20 = 0;\n    let mut index21\
    \ = 0;\n    let mut index22 = 0;\n    let mut index23 = 0;\n    let mut index24\
    \ = 0;\n    let mut index25 = 0;\n    let mut index26 = 0;\n    let mut index27\
    \ = 0;\n    let mut index28 = 0;\n    let mut index29 = 0;\n    let mut index30\
    \ = 0;\n    let mut index31 = 0;\n    let mut index32 = 0;\n    let mut index33\
    \ = 0;\n    let mut index34 = 0;\n    let mut index35 = 0;\n    let mut index36\
    \ = 0;\n    let mut index37 = 0;\n    let mut index38 = 0;\n    let mut index39\
    \ = 0;\n    let mut index40 = 0;\n    let mut index41 = 0;\n    let mut index42\
    \ = 0;\n    let mut index43 = 0;\n    let mut index44 = 0;\n    let mut index45\
    \ = 0;\n    let mut index46 = 0;\n    let mut index47 = 0;\n    let mut index48\
    \ = 0;\n    let mut index49 = 0;\n    let mut index50 = 0;\n    let mut index51\
    \ = 0;\n    let mut index52 = 0;\n    let mut index53 = 0;\n    let mut index54\
    \ = 0;\n    let mut index55 = 0;\n    let mut index56 = 0;\n    let mut index57\
    \ = 0;\n    let mut index58 = 0;\n    let mut index59 = 0;\n    let mut index60\
    \ = 0;\n    let mut index61 = 0;\n    let mut index62 = 0;\n    let mut index63\
    \ = 0;\n\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmpck19tyli.rs:83:17\n\
    \   |\n83 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpck19tyli.rs:83:25\n   |\n83 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpck19tyli.rs:84:17\n   |\n84 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpck19tyli.rs:84:25\n\
    \   |\n84 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpck19tyli.rs:85:17\n   |\n85 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpck19tyli.rs:85:25\n   |\n85 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpck19tyli.rs:86:17\n   |\n86 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpck19tyli.rs:86:25\n   |\n86 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpck19tyli.rs:87:17\n  \
    \ |\n87 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpck19tyli.rs:87:25\n   |\n87 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpck19tyli.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |   "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    A\", \"E\", \"I\", \"O\", \"U\"];\n    let mut alphabet = vec![\"a\", \"b\", \"\
    c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"\
    n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"\
    y\", \"z\"];\n    let mut vowel_counter = 0;\n    let mut letter_counter = 0;\n\
    \    for letter in message {\n        if vowels.contains(&letter) {\n        \
    \    result.push((alphabet.len() - vowel_counter + letter_counter + alphabet.index(&letter))\
    \ as char);\n            vowel_counter = vowel_counter + 1;\n        } else {\n\
    \            result.push((alphabet.len() - letter_counter + alphabet.index(&letter))\
    \ as char);\n            letter_counter = letter_counter + 1;\n        }\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmppldcua5y.rs:31:17\n\
    \   |\n31 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppldcua5y.rs:31:25\n   |\n31 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmppldcua5y.rs:32:17\n   |\n32 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmppldcua5y.rs:32:25\n\
    \   |\n32 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmppldcua5y.rs:33:17\n   |\n33 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmppldcua5y.rs:33:25\n   |\n33 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmppldcua5y.rs:34:17\n   |\n34 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmppldcua5y.rs:34:25\n   |\n34 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmppldcua5y.rs:35:17\n  \
    \ |\n35 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmppldcua5y.rs:35:25\n   |\n35 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmppldcua5y.rs:17:19\n    |\n17  |     for letter\
    \ in message {\n    |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.byte"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    let mut letters = vec!['a', 'b', 'c', 'd', 'e', 'f',\
    \ 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\
    \ 'w', 'x', 'y', 'z'];\n    let mut vowels_index = vec![0, 1, 2, 3, 4, 5, 6, 7,\
    \ 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\
    \ 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\
    \ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,\
    \ 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\
    \ 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,\
    \ 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\
    \ 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135,\
    \ 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,\
    \ 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\
    \ 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,\
    \ 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199,\
    \ 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215,\
    \ 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,\
    \ 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,\
    \ 248, 249, 250, 251, 252, 253, 254, 255];\n    let mut letters_index = vec!\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `}`\n  --> /tmp/tmp7hs_30bm.rs:17:1\n\
    \   |\n16 |     let mut letters_index = vec!\n   |                           \
    \      - expected one of `(`, `[`, or `{`\n17 | }\n   | ^ unexpected token\n\n\
    error[E0425]: cannot find value `left` in this scope\n  --> /tmp/tmp7hs_30bm.rs:21:17\n\
    \   |\n21 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7hs_30bm.rs:21:25\n   |\n21 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmp7hs_30bm.rs:22:17\n   |\n22 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmp7hs_30bm.rs:22:25\n\
    \   |\n22 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmp7hs_30bm.rs:23:17\n   |\n23 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmp7hs_30bm.rs:23:25\n   |\n23 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmp7hs_30bm.rs:24:17\n   |\n24 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmp7hs_30bm.rs:24:25\n   |\n24 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmp7hs_30bm.rs:25:17\n  \
    \ |\n25 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmp7hs_30bm.rs:25:25\n   |\n25 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not "
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec![\"\
    a\", \"e\", \"i\", \"o\", \"u\"];\n    let mut vowels_index = vec![0, 1, 2, 3,\
    \ 4];\n    let mut letter_count = vec![0];\n    let mut letter_count_index = vec![0];\n\
    \    let mut letter_count_index2 = vec![0];\n    let mut letter_count_index3 =\
    \ vec![0];\n    let mut letter_count_index4 = vec![0];\n    let mut letter_count_index5\
    \ = vec![0];\n    let mut letter_count_index6 = vec![0];\n    let mut letter_count_index7\
    \ = vec![0];\n    let mut letter_count_index8 = vec![0];\n    let mut letter_count_index9\
    \ = vec![0];\n    let mut letter_count_index10 = vec![0];\n    let mut letter_count_index11\
    \ = vec![0];\n    let mut letter_count_index12 = vec![0];\n    let mut letter_count_index13\
    \ = vec![0];\n    let mut letter_count_index14 = vec![0];\n    let mut letter_count_index15\
    \ = vec![0];\n    let mut letter_count_index16 = vec![0];\n    let mut letter_count_index17\
    \ = vec![0];\n    let mut letter_count_index18 = vec![0];\n    let mut letter_count_index19\
    \ = vec![0];\n    let mut letter_count_index20 = vec![0];\n    let mut letter_count_index21\
    \ = vec![0];\n    let mut letter_count_index22 = vec![0];\n    let mut letter_count_index23\
    \ = vec![0];\n    let mut letter_count_index24 = vec![0];\n    let mut letter_count_index25\
    \ = vec![0];\n    let mut letter_count_index26 = vec![0];\n    let mut letter_count_index27\
    \ = vec![0];\n    let mut letter_count_index28 = vec![0];\n    let mut letter_count_index29\
    \ = vec![0];\n    let mut letter_count_index30 = vec![0];\n    let mut letter_count_index31\
    \ = vec![0];\n    let mut letter_count_index32 = vec![0];\n    let mut letter_count_index33\
    \ = vec![0];\n    let mut letter_count_index34 = vec![0];\n    let mut letter_count_index35\
    \ = vec![0];\n    let mut letter_count_index36 = vec![0];\n    let mut letter_count_index37\
    \ = vec![0];\n    let mut letter_count_index38 = vec![0];\n    let mut letter_count_index39\
    \ = vec![0];\n    let mut letter_count_index40 = \n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `}`\n  --> /tmp/tmpmc4d7qw6.rs:56:1\n\
    \   |\n56 | }\n   | ^ expected expression\n\nerror[E0425]: cannot find value `left`\
    \ in this scope\n  --> /tmp/tmpmc4d7qw6.rs:60:17\n   |\n60 |     assert_eq!({left},\
    \ {right});\n   |                 ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `right` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:60:25\n \
    \  |\n60 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpmc4d7qw6.rs:61:17\n   |\n61 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:61:25\n   |\n61 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpmc4d7qw6.rs:62:17\n   |\n62 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:62:25\n   |\n62 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:63:17\n  \
    \ |\n63 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpmc4d7qw6.rs:63:25\n   |\n63 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:64:17\n   |\n64 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpmc4d7qw6.rs:64:25\n\
    \   |\n64 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror: aborting due to 11 previous errors\n\nFor\
    \ more information about this error, try `rustc --expl"
  stdout: ''
  timestamp: 1659821834
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowels = vec!['A',\
    \ 'E', 'I', 'O', 'U'];\n    let mut letters = vec!['A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z'];\n    let mut i = 0;\n    while i < message.len() {\n  \
    \      if let Some(letter) = message.chars().nth(i + 1) {\n            if letter\
    \ in vowels {\n                result.push(*letter);\n                i += 1;\n\
    \                continue;\n            }\n            let mut j = 0;\n      \
    \      while j < letters.len() {\n                if letter == letters[j] {\n\
    \                    result.push(*letters[(j + 2) % letters.len()]);\n       \
    \             i += 1;\n                    break;\n                }\n       \
    \         j += 1;\n            }\n        }\n        i += 1;\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!({left}, {right});\n\
    \    assert_eq!({left}, {right});\n    assert_eq!({left}, {right});\n    assert_eq!({left},\
    \ {right});\n    assert_eq!({left}, {right});\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpt5ltmxgt.rs:18:23\n\
    \   |\n18 |             if letter in vowels {\n   |             --        ^^ expected\
    \ `{`\n   |             |\n   |             this `if` expression has a condition,\
    \ but no block\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt5ltmxgt.rs:40:17\n   |\n40 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:40:25\n   |\n40 |     assert_eq!({left},\
    \ {right});\n   |                         ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `left` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:41:17\n  \
    \ |\n41 |     assert_eq!({left}, {right});\n   |                 ^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `right` in this scope\n  -->\
    \ /tmp/tmpt5ltmxgt.rs:41:25\n   |\n41 |     assert_eq!({left}, {right});\n   |\
    \                         ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `left` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:42:17\n   |\n42 |\
    \     assert_eq!({left}, {right});\n   |                 ^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `right` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:42:25\n\
    \   |\n42 |     assert_eq!({left}, {right});\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n\
    \  --> /tmp/tmpt5ltmxgt.rs:43:17\n   |\n43 |     assert_eq!({left}, {right});\n\
    \   |                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `right` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:43:25\n   |\n43 |   \
    \  assert_eq!({left}, {right});\n   |                         ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `left` in this scope\n  -->\
    \ /tmp/tmpt5ltmxgt.rs:44:17\n   |\n44 |     assert_eq!({left}, {right});\n   |\
    \                 ^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `right` in this scope\n  --> /tmp/tmpt5ltmxgt.rs:44:25\n   |\n44 |     assert_eq!({left},\
    \ {right});\n   |                 "
  stdout: ''
  timestamp: 1659821834
